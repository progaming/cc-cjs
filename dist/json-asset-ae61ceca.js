'use strict';

const WECHAT = false;
const ALIPAY = false;
const BAIDU = false;
const XIAOMI = false;
const BYTEDANCE = false;
const OPPO = false;
const VIVO = false;
const HUAWEI = false;
const COCOSPLAY = false;
const EDITOR = false;
const PREVIEW = false;
const BUILD = true;
const TEST = false;
const DEV = false;
const DEBUG = false;
const RUNTIME_BASED = false;
const MINIGAME = false;
const JSB = false;
const SUPPORT_JIT = true;

var _global = typeof window === 'undefined' ? global : window;

var legacyCC = {
  _global: _global
};
legacyCC.internal = {};

{
  _global.CC_BUILD = BUILD;
  _global.CC_TEST = TEST;
  _global.CC_EDITOR = EDITOR;
  _global.CC_PREVIEW = PREVIEW;
  _global.CC_DEV = DEV;
  _global.CC_DEBUG = DEBUG;
  _global.CC_JSB = JSB;
  _global.CC_BYTEDANCE = BYTEDANCE;
  _global.CC_WECHAT = WECHAT;
  _global.CC_ALIPAY = ALIPAY;
  _global.CC_XIAOMI = XIAOMI;
  _global.CC_BAIDU = BAIDU;
  _global.CC_COCOSPLAY = COCOSPLAY;
  _global.CC_HUAWEI = HUAWEI;
  _global.CC_OPPO = OPPO;
  _global.CC_VIVO = VIVO;
  _global.CC_MINIGAME = MINIGAME;
  _global.CC_RUNTIME_BASED = RUNTIME_BASED;
  _global.CC_SUPPORT_JIT = SUPPORT_JIT;
}

var engineVersion = '3.3.0';
_global.CocosEngine = legacyCC.ENGINE_VERSION = engineVersion;
_global.cc = legacyCC;

var ERROR_MAP_URL = 'https://github.com/cocos-creator/engine/blob/3d/EngineErrorMap.md';
var logList = null;
var ccLog = console.log.bind(console);
var ccWarn = ccLog;
var ccError = ccLog;

var ccAssert = function ccAssert(condition, message) {
  if (!condition) {
    for (var _len = arguments.length, optionalParams = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      optionalParams[_key - 2] = arguments[_key];
    }

    console.log("ASSERT: " + formatString.apply(void 0, [message].concat(optionalParams)));
  }
};

var ccDebug = ccLog;

function formatString(message) {
  for (var _len2 = arguments.length, optionalParams = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    optionalParams[_key2 - 1] = arguments[_key2];
  }

  return legacyCC.js.formatStr.apply(null, [message].concat(optionalParams));
}

function log(message) {
  for (var _len3 = arguments.length, optionalParams = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
    optionalParams[_key3 - 1] = arguments[_key3];
  }

  return ccLog.apply(void 0, [message].concat(optionalParams));
}
function warn(message) {
  for (var _len4 = arguments.length, optionalParams = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
    optionalParams[_key4 - 1] = arguments[_key4];
  }

  return ccWarn.apply(void 0, [message].concat(optionalParams));
}
function error(message) {
  for (var _len5 = arguments.length, optionalParams = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
    optionalParams[_key5 - 1] = arguments[_key5];
  }

  return ccError.apply(void 0, [message].concat(optionalParams));
}
function assert(value, message) {
  for (var _len6 = arguments.length, optionalParams = new Array(_len6 > 2 ? _len6 - 2 : 0), _key6 = 2; _key6 < _len6; _key6++) {
    optionalParams[_key6 - 2] = arguments[_key6];
  }

  return ccAssert.apply(void 0, [value, message].concat(optionalParams));
}
function debug() {
  return ccDebug.apply(void 0, arguments);
}
function _resetDebugSetting(mode) {
  ccLog = ccWarn = ccError = ccAssert = ccDebug = function ccDebug() {};

  if (mode === exports.DebugMode.NONE) {
    return;
  }

  if (mode > exports.DebugMode.ERROR) {
    var logToWebPage = function logToWebPage(msg) {
      if (!legacyCC.game.canvas) {
        return;
      }

      if (!logList) {
        var logDiv = document.createElement('Div');
        logDiv.setAttribute('id', 'logInfoDiv');
        logDiv.setAttribute('width', '200');
        logDiv.setAttribute('height', legacyCC.game.canvas.height);
        var logDivStyle = logDiv.style;
        logDivStyle.zIndex = '99999';
        logDivStyle.position = 'absolute';
        logDivStyle.top = logDivStyle.left = '0';
        logList = document.createElement('textarea');
        logList.setAttribute('rows', '20');
        logList.setAttribute('cols', '30');
        logList.setAttribute('disabled', 'true');
        var logListStyle = logList.style;
        logListStyle.backgroundColor = 'transparent';
        logListStyle.borderBottom = '1px solid #cccccc';
        logListStyle.borderTopWidth = logListStyle.borderLeftWidth = logListStyle.borderRightWidth = '0px';
        logListStyle.borderTopStyle = logListStyle.borderLeftStyle = logListStyle.borderRightStyle = 'none';
        logListStyle.padding = '0px';
        logListStyle.margin = '0px';
        logDiv.appendChild(logList);
        legacyCC.game.canvas.parentNode.appendChild(logDiv);
      }

      logList.value = logList.value + msg + "\r\n";
      logList.scrollTop = logList.scrollHeight;
    };

    ccError = function ccError(message) {
      for (var _len7 = arguments.length, optionalParams = new Array(_len7 > 1 ? _len7 - 1 : 0), _key7 = 1; _key7 < _len7; _key7++) {
        optionalParams[_key7 - 1] = arguments[_key7];
      }

      logToWebPage("ERROR :  " + formatString.apply(void 0, [message].concat(optionalParams)));
    };

    ccAssert = function ccAssert(condition, message) {
      if (!condition) {
        for (var _len8 = arguments.length, optionalParams = new Array(_len8 > 2 ? _len8 - 2 : 0), _key8 = 2; _key8 < _len8; _key8++) {
          optionalParams[_key8 - 2] = arguments[_key8];
        }

        logToWebPage("ASSERT: " + formatString.apply(void 0, [message].concat(optionalParams)));
      }
    };

    if (mode !== exports.DebugMode.ERROR_FOR_WEB_PAGE) {
      ccWarn = function ccWarn(message) {
        for (var _len9 = arguments.length, optionalParams = new Array(_len9 > 1 ? _len9 - 1 : 0), _key9 = 1; _key9 < _len9; _key9++) {
          optionalParams[_key9 - 1] = arguments[_key9];
        }

        logToWebPage("WARN :  " + formatString.apply(void 0, [message].concat(optionalParams)));
      };
    }

    if (mode === exports.DebugMode.INFO_FOR_WEB_PAGE) {
      ccLog = function ccLog(message) {
        for (var _len10 = arguments.length, optionalParams = new Array(_len10 > 1 ? _len10 - 1 : 0), _key10 = 1; _key10 < _len10; _key10++) {
          optionalParams[_key10 - 1] = arguments[_key10];
        }

        logToWebPage(formatString.apply(void 0, [message].concat(optionalParams)));
      };
    }
  } else if (console) {
    if (!console.error) {
      console.error = console.log;
    }

    if (!console.warn) {
      console.warn = console.log;
    }

    if ( console.error.bind) {
      ccError = console.error.bind(console);
    } else {
      ccError =  function (message) {
        for (var _len11 = arguments.length, optionalParams = new Array(_len11 > 1 ? _len11 - 1 : 0), _key11 = 1; _key11 < _len11; _key11++) {
          optionalParams[_key11 - 1] = arguments[_key11];
        }

        return console.error.apply(console, [message].concat(optionalParams));
      };
    }

    ccAssert = function ccAssert(condition, message) {
      if (!condition) {
        for (var _len12 = arguments.length, optionalParams = new Array(_len12 > 2 ? _len12 - 2 : 0), _key12 = 2; _key12 < _len12; _key12++) {
          optionalParams[_key12 - 2] = arguments[_key12];
        }

        var errorText = formatString.apply(void 0, [message].concat(optionalParams));

        {
          throw new Error(errorText);
        }
      }
    };
  }

  if (mode !== exports.DebugMode.ERROR) {
    if (console.warn.bind) {
      ccWarn = console.warn.bind(console);
    } else {
      ccWarn =  function (message) {
        for (var _len13 = arguments.length, optionalParams = new Array(_len13 > 1 ? _len13 - 1 : 0), _key13 = 1; _key13 < _len13; _key13++) {
          optionalParams[_key13 - 1] = arguments[_key13];
        }

        return console.warn.apply(console, [message].concat(optionalParams));
      };
    }
  }

  if (mode === exports.DebugMode.INFO) {
    if (console.log.bind) {
      ccLog = console.log.bind(console);
    } else {
      ccLog = function ccLog(message) {
        for (var _len15 = arguments.length, optionalParams = new Array(_len15 > 1 ? _len15 - 1 : 0), _key15 = 1; _key15 < _len15; _key15++) {
          optionalParams[_key15 - 1] = arguments[_key15];
        }

        return console.log.apply(console, [message].concat(optionalParams));
      };
    }
  }

  if (mode <= exports.DebugMode.VERBOSE) {
    if (typeof console.debug === 'function') {
      var vendorDebug = console.debug.bind(console);

      ccDebug = function ccDebug() {
        return vendorDebug.apply(void 0, arguments);
      };
    }
  }
}
function _throw(error_) {
  {
    var stack = error_.stack;

    if (stack) {
      error( stack);
    } else {
      error(error_);
    }

    return undefined;
  }
}

function getTypedFormatter(type) {
  return function (id) {
    var msg =  type + " " + id + ", please go to " + ERROR_MAP_URL + "#" + id + " to see details.";

    for (var _len16 = arguments.length, args = new Array(_len16 > 1 ? _len16 - 1 : 0), _key16 = 1; _key16 < _len16; _key16++) {
      args[_key16 - 1] = arguments[_key16];
    }

    if (args.length === 0) {
      return msg;
    }

    return  msg + " Arguments: " + args.join(', ');
  };
}

var logFormatter = getTypedFormatter('Log');
function logID(id) {
  for (var _len17 = arguments.length, optionalParams = new Array(_len17 > 1 ? _len17 - 1 : 0), _key17 = 1; _key17 < _len17; _key17++) {
    optionalParams[_key17 - 1] = arguments[_key17];
  }

  log(logFormatter.apply(void 0, [id].concat(optionalParams)));
}
var warnFormatter = getTypedFormatter('Warning');
function warnID(id) {
  for (var _len18 = arguments.length, optionalParams = new Array(_len18 > 1 ? _len18 - 1 : 0), _key18 = 1; _key18 < _len18; _key18++) {
    optionalParams[_key18 - 1] = arguments[_key18];
  }

  warn(warnFormatter.apply(void 0, [id].concat(optionalParams)));
}
var errorFormatter = getTypedFormatter('Error');
function errorID(id) {
  for (var _len19 = arguments.length, optionalParams = new Array(_len19 > 1 ? _len19 - 1 : 0), _key19 = 1; _key19 < _len19; _key19++) {
    optionalParams[_key19 - 1] = arguments[_key19];
  }

  error(errorFormatter.apply(void 0, [id].concat(optionalParams)));
}
var assertFormatter = getTypedFormatter('Assert');
function assertID(condition, id) {
  if (condition) {
    return;
  }

  for (var _len20 = arguments.length, optionalParams = new Array(_len20 > 2 ? _len20 - 2 : 0), _key20 = 2; _key20 < _len20; _key20++) {
    optionalParams[_key20 - 2] = arguments[_key20];
  }

  assert(false, assertFormatter.apply(void 0, [id].concat(optionalParams)));
}

(function (DebugMode) {
  DebugMode[DebugMode["NONE"] = 0] = "NONE";
  DebugMode[DebugMode["VERBOSE"] = 1] = "VERBOSE";
  DebugMode[DebugMode["INFO"] = 2] = "INFO";
  DebugMode[DebugMode["WARN"] = 3] = "WARN";
  DebugMode[DebugMode["ERROR"] = 4] = "ERROR";
  DebugMode[DebugMode["INFO_FOR_WEB_PAGE"] = 5] = "INFO_FOR_WEB_PAGE";
  DebugMode[DebugMode["WARN_FOR_WEB_PAGE"] = 6] = "WARN_FOR_WEB_PAGE";
  DebugMode[DebugMode["ERROR_FOR_WEB_PAGE"] = 7] = "ERROR_FOR_WEB_PAGE";
})(exports.DebugMode || (exports.DebugMode = {}));

function getError(errorId) {
  for (var _len21 = arguments.length, param = new Array(_len21 > 1 ? _len21 - 1 : 0), _key21 = 1; _key21 < _len21; _key21++) {
    param[_key21 - 1] = arguments[_key21];
  }

  return errorFormatter.apply(void 0, [errorId].concat(param));
}
function isDisplayStats() {
  return legacyCC.profiler ? legacyCC.profiler.isShowingStats() : false;
}
function setDisplayStats(displayStats) {
  if (legacyCC.profiler) {
    displayStats ? legacyCC.profiler.showStats() : legacyCC.profiler.hideStats();
    legacyCC.game.config.showFPS = !!displayStats;
  }
}

var debug$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    log: log,
    warn: warn,
    error: error,
    assert: assert,
    debug: debug,
    _resetDebugSetting: _resetDebugSetting,
    _throw: _throw,
    logID: logID,
    warnID: warnID,
    errorID: errorID,
    assertID: assertID,
    get DebugMode () { return exports.DebugMode; },
    getError: getError,
    isDisplayStats: isDisplayStats,
    setDisplayStats: setDisplayStats
});

(function (BrowserType) {
  BrowserType["UNKNOWN"] = "unknown";
  BrowserType["WECHAT"] = "wechat";
  BrowserType["ANDROID"] = "androidbrowser";
  BrowserType["IE"] = "ie";
  BrowserType["EDGE"] = "edge";
  BrowserType["QQ"] = "qqbrowser";
  BrowserType["MOBILE_QQ"] = "mqqbrowser";
  BrowserType["UC"] = "ucbrowser";
  BrowserType["UCBS"] = "ucbs";
  BrowserType["BROWSER_360"] = "360browser";
  BrowserType["BAIDU_APP"] = "baiduboxapp";
  BrowserType["BAIDU"] = "baidubrowser";
  BrowserType["MAXTHON"] = "maxthon";
  BrowserType["OPERA"] = "opera";
  BrowserType["OUPENG"] = "oupeng";
  BrowserType["MIUI"] = "miuibrowser";
  BrowserType["FIREFOX"] = "firefox";
  BrowserType["SAFARI"] = "safari";
  BrowserType["CHROME"] = "chrome";
  BrowserType["LIEBAO"] = "liebao";
  BrowserType["QZONE"] = "qzone";
  BrowserType["SOUGOU"] = "sogou";
  BrowserType["HUAWEI"] = "huawei";
})(exports.BrowserType || (exports.BrowserType = {}));

var Language;

(function (Language) {
  Language["UNKNOWN"] = "unknown";
  Language["ENGLISH"] = "en";
  Language["CHINESE"] = "zh";
  Language["FRENCH"] = "fr";
  Language["ITALIAN"] = "it";
  Language["GERMAN"] = "de";
  Language["SPANISH"] = "es";
  Language["DUTCH"] = "du";
  Language["RUSSIAN"] = "ru";
  Language["KOREAN"] = "ko";
  Language["JAPANESE"] = "ja";
  Language["HUNGARIAN"] = "hu";
  Language["PORTUGUESE"] = "pt";
  Language["ARABIC"] = "ar";
  Language["NORWEGIAN"] = "no";
  Language["POLISH"] = "pl";
  Language["TURKISH"] = "tr";
  Language["UKRAINIAN"] = "uk";
  Language["ROMANIAN"] = "ro";
  Language["BULGARIAN"] = "bg";
})(Language || (Language = {}));

var NetworkType;

(function (NetworkType) {
  NetworkType[NetworkType["NONE"] = 0] = "NONE";
  NetworkType[NetworkType["LAN"] = 1] = "LAN";
  NetworkType[NetworkType["WWAN"] = 2] = "WWAN";
})(NetworkType || (NetworkType = {}));

(function (OS) {
  OS["UNKNOWN"] = "Unknown";
  OS["IOS"] = "iOS";
  OS["ANDROID"] = "Android";
  OS["WINDOWS"] = "Windows";
  OS["LINUX"] = "Linux";
  OS["OSX"] = "OS X";
  OS["OHOS"] = "OHOS";
})(exports.OS || (exports.OS = {}));

var Platform;

(function (Platform) {
  Platform["UNKNOWN"] = "UNKNOWN";
  Platform["EDITOR_PAGE"] = "EDITOR_PAGE";
  Platform["EDITOR_CORE"] = "EDITOR_CORE";
  Platform["MOBILE_BROWSER"] = "MOBILE_BROWSER";
  Platform["DESKTOP_BROWSER"] = "DESKTOP_BROWSER";
  Platform["WIN32"] = "WIN32";
  Platform["ANDROID"] = "ANDROID";
  Platform["IOS"] = "IOS";
  Platform["MACOS"] = "MACOS";
  Platform["OHOS"] = "OHOS";
  Platform["WECHAT_GAME"] = "WECHAT_GAME";
  Platform["BAIDU_MINI_GAME"] = "BAIDU_MINI_GAME";
  Platform["XIAOMI_QUICK_GAME"] = "XIAOMI_QUICK_GAME";
  Platform["ALIPAY_MINI_GAME"] = "ALIPAY_MINI_GAME";
  Platform["BYTEDANCE_MINI_GAME"] = "BYTEDANCE_MINI_GAME";
  Platform["OPPO_MINI_GAME"] = "OPPO_MINI_GAME";
  Platform["VIVO_MINI_GAME"] = "VIVO_MINI_GAME";
  Platform["HUAWEI_QUICK_GAME"] = "HUAWEI_QUICK_GAME";
  Platform["COCOSPLAY"] = "COCOSPLAY";
  Platform["LINKSURE_MINI_GAME"] = "LINKSURE_MINI_GAME";
  Platform["QTT_MINI_GAME"] = "QTT_MINI_GAME";
})(Platform || (Platform = {}));

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;

  _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !_isNativeFunction(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return _construct(Class, arguments, _getPrototypeOf(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class);
  };

  return _wrapNativeSuper(Class);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it;

  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;
      return function () {
        if (i >= o.length) return {
          done: true
        };
        return {
          done: false,
          value: o[i++]
        };
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  it = o[Symbol.iterator]();
  return it.next.bind(it);
}

function _initializerDefineProperty(target, property, descriptor, context) {
  if (!descriptor) return;
  Object.defineProperty(target, property, {
    enumerable: descriptor.enumerable,
    configurable: descriptor.configurable,
    writable: descriptor.writable,
    value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
  });
}

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
  var desc = {};
  Object.keys(descriptor).forEach(function (key) {
    desc[key] = descriptor[key];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;

  if ('value' in desc || desc.initializer) {
    desc.writable = true;
  }

  desc = decorators.slice().reverse().reduce(function (desc, decorator) {
    return decorator(target, property, desc) || desc;
  }, desc);

  if (context && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
    desc.initializer = undefined;
  }

  if (desc.initializer === void 0) {
    Object.defineProperty(target, property, desc);
    desc = null;
  }

  return desc;
}

var Pool = function () {
  function Pool(ctor, elementsPerBatch) {
    this._ctor = void 0;
    this._elementsPerBatch = void 0;
    this._nextAvail = void 0;
    this._freepool = [];
    this._ctor = ctor;
    this._elementsPerBatch = Math.max(elementsPerBatch, 1);
    this._nextAvail = this._elementsPerBatch - 1;

    for (var i = 0; i < this._elementsPerBatch; ++i) {
      this._freepool.push(ctor());
    }
  }

  var _proto = Pool.prototype;

  _proto.alloc = function alloc() {
    if (this._nextAvail < 0) {
      var elementsPerBatch = this._elementsPerBatch;

      for (var i = 0; i < elementsPerBatch; i++) {
        this._freepool.push(this._ctor());
      }

      this._nextAvail = elementsPerBatch - 1;
    }

    var ret = this._freepool[this._nextAvail--];
    this._freepool.length--;
    return ret;
  };

  _proto.free = function free(obj) {
    this._freepool.push(obj);

    this._nextAvail++;
  };

  _proto.freeArray = function freeArray(objs) {
    Array.prototype.push.apply(this._freepool, objs);
    this._nextAvail += objs.length;
  };

  _proto.destroy = function destroy(dtor) {
    if (dtor) {
      for (var i = 0; i <= this._nextAvail; i++) {
        dtor(this._freepool[i]);
      }
    }

    this._freepool.length = 0;
    this._nextAvail = -1;
  };

  return Pool;
}();

var RecyclePool = function () {
  function RecyclePool(fn, size) {
    this._fn = void 0;
    this._count = 0;
    this._data = void 0;
    this._fn = fn;
    this._data = new Array(size);

    for (var i = 0; i < size; ++i) {
      this._data[i] = fn();
    }
  }

  var _proto = RecyclePool.prototype;

  _proto.reset = function reset() {
    this._count = 0;
  };

  _proto.resize = function resize(size) {
    if (size > this._data.length) {
      for (var i = this._data.length; i < size; ++i) {
        this._data[i] = this._fn();
      }
    }
  };

  _proto.add = function add() {
    if (this._count >= this._data.length) {
      this.resize(this._data.length * 2);
    }

    return this._data[this._count++];
  };

  _proto.removeAt = function removeAt(idx) {
    if (idx >= this._count) {
      return;
    }

    var last = this._count - 1;
    var tmp = this._data[idx];
    this._data[idx] = this._data[last];
    this._data[last] = tmp;
    this._count -= 1;
  };

  _createClass(RecyclePool, [{
    key: "length",
    get: function get() {
      return this._count;
    }
  }, {
    key: "data",
    get: function get() {
      return this._data;
    }
  }]);

  return RecyclePool;
}();

var CachedArray = function () {
  function CachedArray(length, compareFn) {
    this.array = void 0;
    this.length = 0;
    this._compareFn = void 0;
    this.array = new Array(length);
    this.length = 0;

    if (compareFn !== undefined) {
      this._compareFn = compareFn;
    } else {
      this._compareFn = function (a, b) {
        return a - b;
      };
    }
  }

  var _proto = CachedArray.prototype;

  _proto.push = function push(item) {
    this.array[this.length++] = item;
  };

  _proto.pop = function pop() {
    return this.array[--this.length];
  };

  _proto.get = function get(idx) {
    return this.array[idx];
  };

  _proto.clear = function clear() {
    this.length = 0;
  };

  _proto.destroy = function destroy() {
    this.length = 0;
    this.array.length = 0;
  };

  _proto.sort = function sort() {
    this.array.length = this.length;
    this.array.sort(this._compareFn);
  };

  _proto.concat = function concat(array) {
    for (var i = 0; i < array.length; ++i) {
      this.array[this.length++] = array[i];
    }
  };

  _proto.fastRemove = function fastRemove(idx) {
    if (idx >= this.length || idx < 0) {
      return;
    }

    var last = --this.length;
    this.array[idx] = this.array[last];
  };

  _proto.indexOf = function indexOf(val) {
    return this.array.indexOf(val);
  };

  return CachedArray;
}();

var MutableForwardIterator = function () {
  function MutableForwardIterator(array) {
    this.i = 0;
    this.array = array;
  }

  var _proto = MutableForwardIterator.prototype;

  _proto.remove = function remove(value) {
    var index = this.array.indexOf(value);

    if (index >= 0) {
      this.removeAt(index);
    }
  };

  _proto.removeAt = function removeAt(i) {
    this.array.splice(i, 1);

    if (i <= this.i) {
      --this.i;
    }
  };

  _proto.fastRemove = function fastRemove(value) {
    var index = this.array.indexOf(value);

    if (index >= 0) {
      this.fastRemoveAt(index);
    }
  };

  _proto.fastRemoveAt = function fastRemoveAt(i) {
    var array = this.array;
    array[i] = array[array.length - 1];
    --array.length;

    if (i <= this.i) {
      --this.i;
    }
  };

  _proto.push = function push(item) {
    this.array.push(item);
  };

  _createClass(MutableForwardIterator, [{
    key: "length",
    get: function get() {
      return this.array.length;
    },
    set: function set(value) {
      this.array.length = value;

      if (this.i >= value) {
        this.i = value - 1;
      }
    }
  }]);

  return MutableForwardIterator;
}();

function removeAt(array, index) {
  array.splice(index, 1);
}
function fastRemoveAt(array, index) {
  var length = array.length;

  if (index < 0 || index >= length) {
    return;
  }

  array[index] = array[length - 1];
  array.length = length - 1;
}
function remove(array, value) {
  var index = array.indexOf(value);

  if (index >= 0) {
    removeAt(array, index);
    return true;
  } else {
    return false;
  }
}
function fastRemove(array, value) {
  var index = array.indexOf(value);

  if (index >= 0) {
    array[index] = array[array.length - 1];
    --array.length;
  }
}
function removeIf(array, predicate) {
  var index = array.findIndex(predicate);

  if (index >= 0) {
    var _value = array[index];
    removeAt(array, index);
    return _value;
  }
}
function verifyType(array, type) {
  if (array && array.length > 0) {
    for (var _iterator = _createForOfIteratorHelperLoose(array), _step; !(_step = _iterator()).done;) {
      var item = _step.value;

      if (!(item instanceof type)) {
        logID(1300);
        return false;
      }
    }
  }

  return true;
}
function removeArray(array, removals) {
  for (var i = 0, l = removals.length; i < l; i++) {
    remove(array, removals[i]);
  }
}
function appendObjectsAt(array, objects, index) {
  array.splice.apply(array, [index, 0].concat(objects));
  return array;
}
function contains(array, value) {
  return array.indexOf(value) >= 0;
}
function copy(array) {
  var len = array.length;
  var cloned = new Array(len);

  for (var i = 0; i < len; i += 1) {
    cloned[i] = array[i];
  }

  return cloned;
}

var jsarray = /*#__PURE__*/Object.freeze({
    __proto__: null,
    removeAt: removeAt,
    fastRemoveAt: fastRemoveAt,
    remove: remove,
    fastRemove: fastRemove,
    removeIf: removeIf,
    verifyType: verifyType,
    removeArray: removeArray,
    appendObjectsAt: appendObjectsAt,
    contains: contains,
    copy: copy,
    MutableForwardIterator: MutableForwardIterator
});

var NonUuidMark = '.';

var IDGenerator = function () {
  function IDGenerator(category) {
    this.id = void 0;
    this.prefix = void 0;
    this.id = 0 | Math.random() * 998;
    this.prefix = category ? category + NonUuidMark : '';
  }

  var _proto = IDGenerator.prototype;

  _proto.getNewId = function getNewId() {

    return this.prefix + ++this.id;
  };

  return IDGenerator;
}();

IDGenerator.global = new IDGenerator('global');

var tempCIDGenerator = new IDGenerator('TmpCId.');
var aliasesTag = typeof Symbol === 'undefined' ? '__aliases__' : Symbol('[[Aliases]]');
var classNameTag = '__classname__';
var classIdTag = '__cid__';
function isNumber(object) {
  return typeof object === 'number' || object instanceof Number;
}
function isString(object) {
  return typeof object === 'string' || object instanceof String;
}
function isEmptyObject(obj) {
  for (var key in obj) {
    return false;
  }

  return true;
}
var value = function () {
  var descriptor = {
    value: undefined,
    enumerable: false,
    writable: false,
    configurable: true
  };
  return function (object, propertyName, value_, writable, enumerable) {
    descriptor.value = value_;
    descriptor.writable = writable;
    descriptor.enumerable = enumerable;
    Object.defineProperty(object, propertyName, descriptor);
    descriptor.value = undefined;
  };
}();
var getset = function () {
  var descriptor = {
    get: undefined,
    set: undefined,
    enumerable: false
  };
  return function (object, propertyName, getter, setter, enumerable, configurable) {
    if (enumerable === void 0) {
      enumerable = false;
    }

    if (configurable === void 0) {
      configurable = false;
    }

    if (typeof setter === 'boolean') {
      enumerable = setter;
      setter = undefined;
    }

    descriptor.get = getter;
    descriptor.set = setter;
    descriptor.enumerable = enumerable;
    descriptor.configurable = configurable;
    Object.defineProperty(object, propertyName, descriptor);
    descriptor.get = undefined;
    descriptor.set = undefined;
  };
}();
var get = function () {
  var descriptor = {
    get: undefined,
    enumerable: false,
    configurable: false
  };
  return function (object, propertyName, getter, enumerable, configurable) {
    descriptor.get = getter;
    descriptor.enumerable = enumerable;
    descriptor.configurable = configurable;
    Object.defineProperty(object, propertyName, descriptor);
    descriptor.get = undefined;
  };
}();
var set = function () {
  var descriptor = {
    set: undefined,
    enumerable: false,
    configurable: false
  };
  return function (object, propertyName, setter, enumerable, configurable) {
    descriptor.set = setter;
    descriptor.enumerable = enumerable;
    descriptor.configurable = configurable;
    Object.defineProperty(object, propertyName, descriptor);
    descriptor.set = undefined;
  };
}();
function createMap(forceDictMode) {
  var map = Object.create(null);

  if (forceDictMode) {
    var INVALID_IDENTIFIER_1 = '.';
    var INVALID_IDENTIFIER_2 = '/';
    map[INVALID_IDENTIFIER_1] = 1;
    map[INVALID_IDENTIFIER_2] = 1;
    delete map[INVALID_IDENTIFIER_1];
    delete map[INVALID_IDENTIFIER_2];
  }

  return map;
}
function getClassName(objOrCtor) {
  if (typeof objOrCtor === 'function') {
    var prototype = objOrCtor.prototype;

    if (prototype && prototype.hasOwnProperty(classNameTag) && prototype[classNameTag]) {
      return prototype[classNameTag];
    }

    var retval = '';

    if (objOrCtor.name) {
      retval = objOrCtor.name;
    }

    if (objOrCtor.toString) {
      var arr;
      var str = objOrCtor.toString();

      if (str.charAt(0) === '[') {
        arr = str.match(/\[\w+\s*(\w+)\]/);
      } else {
        arr = str.match(/function\s*(\w+)/);
      }

      if (arr && arr.length === 2) {
        retval = arr[1];
      }
    }

    return retval !== 'Object' ? retval : '';
  } else if (objOrCtor && objOrCtor.constructor) {
    return getClassName(objOrCtor.constructor);
  }

  return '';
}
function obsolete(object, obsoleted, newExpr, writable) {
  var extractPropName = /([^.]+)$/;
  var oldProp = extractPropName.exec(obsoleted)[0];
  var newProp = extractPropName.exec(newExpr)[0];

  function getter() {

    return this[newProp];
  }

  function setter(value_) {

    this[newProp] = value_;
  }

  if (writable) {
    getset(object, oldProp, getter, setter);
  } else {
    get(object, oldProp, getter);
  }
}
function obsoletes(obj, objName, props, writable) {
  for (var obsoleted in props) {
    var newName = props[obsoleted];
    obsolete(obj, objName + "." + obsoleted, newName, writable);
  }
}
var REGEXP_NUM_OR_STR = /(%d)|(%s)/;
var REGEXP_STR = /%s/;
function formatStr(msg) {
  for (var _len = arguments.length, subst = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    subst[_key - 1] = arguments[_key];
  }

  if (arguments.length === 0) {
    return '';
  }

  if (subst.length === 0) {
    return "" + msg;
  }

  var hasSubstitution = typeof msg === 'string' && REGEXP_NUM_OR_STR.test(msg);

  if (hasSubstitution) {
    for (var _iterator = _createForOfIteratorHelperLoose(subst), _step; !(_step = _iterator()).done;) {
      var arg = _step.value;
      var regExpToTest = typeof arg === 'number' ? REGEXP_NUM_OR_STR : REGEXP_STR;

      if (regExpToTest.test(msg)) {
        var notReplaceFunction = "" + arg;
        msg = msg.replace(regExpToTest, notReplaceFunction);
      } else {
        msg += " " + arg;
      }
    }
  } else {
    for (var _iterator2 = _createForOfIteratorHelperLoose(subst), _step2; !(_step2 = _iterator2()).done;) {
      var _arg = _step2.value;
      msg += " " + _arg;
    }
  }

  return msg;
}
function shiftArguments() {
  var len = arguments.length - 1;
  var args = new Array(len);

  for (var i = 0; i < len; ++i) {
    args[i] = arguments[i + 1];
  }

  return args;
}
function getPropertyDescriptor(object, propertyName) {
  while (object) {
    var pd = Object.getOwnPropertyDescriptor(object, propertyName);

    if (pd) {
      return pd;
    }

    object = Object.getPrototypeOf(object);
  }

  return null;
}

function _copyprop(name, source, target) {
  var pd = getPropertyDescriptor(source, name);

  if (pd) {
    Object.defineProperty(target, name, pd);
  }
}

function addon(object) {
  object = object || {};

  for (var _len2 = arguments.length, sources = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    sources[_key2 - 1] = arguments[_key2];
  }

  for (var _i = 0, _sources = sources; _i < _sources.length; _i++) {
    var source = _sources[_i];

    if (source) {
      if (typeof source !== 'object') {
        errorID(5402, source);
        continue;
      }

      for (var name in source) {
        if (!(name in object)) {
          _copyprop(name, source, object);
        }
      }
    }
  }

  return object;
}
function mixin(object) {
  object = object || {};

  for (var _len3 = arguments.length, sources = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
    sources[_key3 - 1] = arguments[_key3];
  }

  for (var _i2 = 0, _sources2 = sources; _i2 < _sources2.length; _i2++) {
    var source = _sources2[_i2];

    if (source) {
      if (typeof source !== 'object') {
        errorID(5403, source);
        continue;
      }

      for (var name in source) {
        _copyprop(name, source, object);
      }
    }
  }

  return object;
}
function extend(cls, base) {

  for (var p in base) {
    if (base.hasOwnProperty(p)) {
      cls[p] = base[p];
    }
  }

  cls.prototype = Object.create(base.prototype, {
    constructor: {
      value: cls,
      writable: true,
      configurable: true
    }
  });
  return cls;
}
function getSuper(constructor) {
  var proto = constructor.prototype;
  var dunderProto = proto && Object.getPrototypeOf(proto);
  return dunderProto && dunderProto.constructor;
}
function isChildClassOf(subclass, superclass) {
  if (subclass && superclass) {
    if (typeof subclass !== 'function') {
      return false;
    }

    if (typeof superclass !== 'function') {

      return false;
    }

    if (subclass === superclass) {
      return true;
    }

    for (;;) {
      subclass = getSuper(subclass);

      if (!subclass) {
        return false;
      }

      if (subclass === superclass) {
        return true;
      }
    }
  }

  return false;
}
function clear(object) {
  for (var _i3 = 0, _Object$keys = Object.keys(object); _i3 < _Object$keys.length; _i3++) {
    var key = _Object$keys[_i3];
    delete object[key];
  }
}

function isTempClassId(id) {
  return typeof id !== 'string' || id.startsWith(tempCIDGenerator.prefix);
}

var _idToClass = createMap(true);
var _nameToClass = createMap(true);

function setup(tag, table) {
  return function (id, constructor) {
    if (constructor.prototype.hasOwnProperty(tag)) {
      delete table[constructor.prototype[tag]];
    }

    value(constructor.prototype, tag, id);

    if (id) {
      var registered = table[id];

      if (registered && registered !== constructor) {
        var err = "A Class already exists with the same " + tag + " : \"" + id + "\".";

        error(err);
      } else {
        table[id] = constructor;
      }
    }
  };
}

var _setClassId = setup('__cid__', _idToClass);
var doSetClassName = setup('__classname__', _nameToClass);
function setClassName(className, constructor) {
  doSetClassName(className, constructor);

  if (!constructor.prototype.hasOwnProperty(classIdTag)) {
    var id = className || tempCIDGenerator.getNewId();

    if (id) {
      _setClassId(id, constructor);
    }
  }
}
function setClassAlias(target, alias) {
  var nameRegistry = _nameToClass[alias];
  var idRegistry = _idToClass[alias];
  var ok = true;

  if (nameRegistry && nameRegistry !== target) {
    error("\"" + alias + "\" has already been set as name or alias of another class.");
    ok = false;
  }

  if (idRegistry && idRegistry !== target) {
    error("\"" + alias + "\" has already been set as id or alias of another class.");
    ok = false;
  }

  if (ok) {
    var classAliases = target[aliasesTag];

    if (!classAliases) {
      classAliases = [];
      target[aliasesTag] = classAliases;
    }

    classAliases.push(alias);
    _nameToClass[alias] = target;
    _idToClass[alias] = target;
  }
}
function unregisterClass() {
  for (var _len4 = arguments.length, constructors = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
    constructors[_key4] = arguments[_key4];
  }

  for (var _i4 = 0, _constructors = constructors; _i4 < _constructors.length; _i4++) {
    var _constructor = _constructors[_i4];
    var p = _constructor.prototype;
    var classId = p[classIdTag];

    if (classId) {
      delete _idToClass[classId];
    }

    var classname = p[classNameTag];

    if (classname) {
      delete _nameToClass[classname];
    }

    var aliases = p[aliasesTag];

    if (aliases) {
      for (var iAlias = 0; iAlias < aliases.length; ++iAlias) {
        var alias = aliases[iAlias];
        delete _nameToClass[alias];
        delete _idToClass[alias];
      }
    }
  }
}
function _getClassById(classId) {
  return _idToClass[classId];
}
function getClassByName(classname) {
  return _nameToClass[classname];
}
function _getClassId(obj, allowTempId) {
  allowTempId = typeof allowTempId !== 'undefined' ? allowTempId : true;
  var res;

  if (typeof obj === 'function' && obj.prototype.hasOwnProperty(classIdTag)) {
    res = obj.prototype[classIdTag];

    if (!allowTempId && ( EDITOR) && isTempClassId(res)) {
      return '';
    }

    return res;
  }

  if (obj && obj.constructor) {
    var prototype = obj.constructor.prototype;

    if (prototype && prototype.hasOwnProperty(classIdTag)) {
      res = obj[classIdTag];

      if (!allowTempId && ( EDITOR) && isTempClassId(res)) {
        return '';
      }

      return res;
    }
  }

  return '';
}

var Pool$1 = function () {
  var _proto = Pool.prototype;

  _proto.get = function get() {
    return this._get();
  };

  function Pool(_0, _1) {
    this.count = void 0;
    this._pool = void 0;
    this._cleanup = void 0;
    var size = _1 === undefined ? _0 : _1;
    var cleanupFunc = _1 === undefined ? null : _0;
    this.count = 0;
    this._pool = new Array(size);
    this._cleanup = cleanupFunc;
  }

  _proto._get = function _get() {
    if (this.count > 0) {
      --this.count;
      var cache = this._pool[this.count];
      this._pool[this.count] = null;
      return cache;
    }

    return null;
  };

  _proto.put = function put(obj) {
    var pool = this._pool;

    if (this.count < pool.length) {
      if (this._cleanup && this._cleanup(obj) === false) {
        return;
      }

      pool[this.count] = obj;
      ++this.count;
    }
  };

  _proto.resize = function resize(length) {
    if (length >= 0) {
      this._pool.length = length;

      if (this.count > length) {
        this.count = length;
      }
    }
  };

  return Pool;
}();

var array = jsarray;
var js = {
  IDGenerator: IDGenerator,
  Pool: Pool$1,
  array: jsarray,
  isNumber: isNumber,
  isString: isString,
  isEmptyObject: isEmptyObject,
  getPropertyDescriptor: getPropertyDescriptor,
  addon: addon,
  mixin: mixin,
  extend: extend,
  getSuper: getSuper,
  isChildClassOf: isChildClassOf,
  clear: clear,
  value: value,
  getset: getset,
  get: get,
  set: set,
  unregisterClass: unregisterClass,
  getClassName: getClassName,
  setClassName: setClassName,
  setClassAlias: setClassAlias,
  getClassByName: getClassByName,

  get _registeredClassNames() {
    return _extends({}, _nameToClass);
  },

  set _registeredClassNames(value) {
    clear(_nameToClass);
    Object.assign(_nameToClass, value);
  },

  get _registeredClassIds() {
    return _extends({}, _idToClass);
  },

  set _registeredClassIds(value) {
    clear(_idToClass);
    Object.assign(_idToClass, value);
  },

  _getClassId: _getClassId,
  _setClassId: _setClassId,
  _getClassById: _getClassById,
  obsolete: obsolete,
  obsoletes: obsoletes,
  formatStr: formatStr,
  shiftArguments: shiftArguments,
  createMap: createMap
};
legacyCC.js = js;

var js$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    array: array,
    js: js,
    IDGenerator: IDGenerator,
    Pool: Pool$1,
    isNumber: isNumber,
    isString: isString,
    isEmptyObject: isEmptyObject,
    value: value,
    getset: getset,
    get: get,
    set: set,
    createMap: createMap,
    getClassName: getClassName,
    obsolete: obsolete,
    obsoletes: obsoletes,
    formatStr: formatStr,
    shiftArguments: shiftArguments,
    getPropertyDescriptor: getPropertyDescriptor,
    addon: addon,
    mixin: mixin,
    extend: extend,
    getSuper: getSuper,
    isChildClassOf: isChildClassOf,
    clear: clear,
    _idToClass: _idToClass,
    _nameToClass: _nameToClass,
    _setClassId: _setClassId,
    setClassName: setClassName,
    setClassAlias: setClassAlias,
    unregisterClass: unregisterClass,
    _getClassById: _getClassById,
    getClassByName: getClassByName,
    _getClassId: _getClassId
});

function BitMask(obj) {
  if ('__bitmask__' in obj) {
    return obj;
  }

  value(obj, '__bitmask__', null, true);
  var lastIndex = -1;
  var keys = Object.keys(obj);

  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    var val = obj[key];

    if (val === -1) {
      val = ++lastIndex;
      obj[key] = val;
    } else if (typeof val === 'number') {
      lastIndex = val;
    } else if (typeof val === 'string' && Number.isInteger(parseFloat(key))) {
      continue;
    }

    var reverseKey = "" + val;

    if (key !== reverseKey) {

      value(obj, reverseKey, key);
    }
  }

  return obj;
}

BitMask.isBitMask = function (BitMaskType) {
  return BitMaskType && BitMaskType.hasOwnProperty('__bitmask__');
};

BitMask.getList = function (BitMaskDef) {
  if (BitMaskDef.__bitmask__) {
    return BitMaskDef.__bitmask__;
  }

  var bitlist = BitMaskDef.__bitmask__ = [];

  for (var name in BitMaskDef) {
    var v = BitMaskDef[name];

    if (Number.isInteger(v)) {
      bitlist.push({
        name: name,
        value: v
      });
    }
  }

  bitlist.sort(function (a, b) {
    return a.value - b.value;
  });
  return bitlist;
};
legacyCC.BitMask = BitMask;

function assertIsNonNullable(expr, message) {
}
function assertIsTrue(expr, message) {
}

function Enum(obj) {
  if ('__enums__' in obj) {
    return obj;
  }

  value(obj, '__enums__', null, true);
  return Enum.update(obj);
}

Enum.update = function (obj) {
  var lastIndex = -1;
  var keys = Object.keys(obj);

  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    var val = obj[key];

    if (val === -1) {
      val = ++lastIndex;
      obj[key] = val;
    } else if (typeof val === 'number') {
      lastIndex = val;
    } else if (typeof val === 'string' && Number.isInteger(parseFloat(key))) {
      continue;
    }

    var reverseKey = "" + val;

    if (key !== reverseKey) {

      value(obj, reverseKey, key);
    }
  }

  if (Array.isArray(obj.__enums__)) {
    updateList(obj);
  }

  return obj;
};

(function (_Enum) {})(Enum || (Enum = {}));

Enum.isEnum = function (enumType) {
  return enumType && enumType.hasOwnProperty('__enums__');
};

function assertIsEnum(enumType) {
  assertIsTrue(enumType.hasOwnProperty('__enums__'));
}

Enum.getList = function (enumType) {
  assertIsEnum(enumType);

  if (enumType.__enums__) {
    return enumType.__enums__;
  }

  return updateList(enumType);
};

function updateList(enumType) {
  assertIsEnum(enumType);
  var enums = enumType.__enums__ || [];
  enums.length = 0;

  for (var name in enumType) {
    var v = enumType[name];

    if (Number.isInteger(v)) {
      enums.push({
        name: name,
        value: v
      });
    }
  }

  enums.sort(function (a, b) {
    return a.value - b.value;
  });
  enumType.__enums__ = enums;
  return enums;
}

function ccenum(enumType) {
  if (!('__enums__' in enumType)) {
    value(enumType, '__enums__', null, true);
  }
}
legacyCC.Enum = Enum;

var ValueType = function () {
  function ValueType() {}

  var _proto = ValueType.prototype;

  _proto.clone = function clone() {
    errorID(100, getClassName(this) + ".clone");
    return this;
  };

  _proto.equals = function equals(other) {
    return false;
  };

  _proto.set = function set(other) {
    errorID(100, getClassName(this) + ".set");
  };

  _proto.toString = function toString() {
    return "" + {};
  };

  return ValueType;
}();
setClassName('cc.ValueType', ValueType);
legacyCC.ValueType = ValueType;

var SUPPORT_TEXTURE_FORMATS = ['.astc', '.pkm', '.pvr', '.webp', '.jpg', '.jpeg', '.bmp', '.png'];
var KEY = {
  none: 0,
  back: 6,
  menu: 18,
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  ctrl: 17,
  alt: 18,
  pause: 19,
  capslock: 20,
  escape: 27,
  space: 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  left: 37,
  up: 38,
  right: 39,
  down: 40,
  select: 41,
  insert: 45,
  Delete: 46,
  0: 48,
  1: 49,
  2: 50,
  3: 51,
  4: 52,
  5: 53,
  6: 54,
  7: 55,
  8: 56,
  9: 57,
  a: 65,
  b: 66,
  c: 67,
  d: 68,
  e: 69,
  f: 70,
  g: 71,
  h: 72,
  i: 73,
  j: 74,
  k: 75,
  l: 76,
  m: 77,
  n: 78,
  o: 79,
  p: 80,
  q: 81,
  r: 82,
  s: 83,
  t: 84,
  u: 85,
  v: 86,
  w: 87,
  x: 88,
  y: 89,
  z: 90,
  num0: 96,
  num1: 97,
  num2: 98,
  num3: 99,
  num4: 100,
  num5: 101,
  num6: 102,
  num7: 103,
  num8: 104,
  num9: 105,
  '*': 106,
  '+': 107,
  '-': 109,
  numdel: 110,
  '/': 111,
  f1: 112,
  f2: 113,
  f3: 114,
  f4: 115,
  f5: 116,
  f6: 117,
  f7: 118,
  f8: 119,
  f9: 120,
  f10: 121,
  f11: 122,
  f12: 123,
  numlock: 144,
  scrolllock: 145,
  ';': 186,
  semicolon: 186,
  equal: 187,
  '=': 187,
  ',': 188,
  comma: 188,
  dash: 189,
  '.': 190,
  period: 190,
  forwardslash: 191,
  grave: 192,
  '[': 219,
  openbracket: 219,
  backslash: 220,
  ']': 221,
  closebracket: 221,
  quote: 222,
  dpadLeft: 1000,
  dpadRight: 1001,
  dpadUp: 1003,
  dpadDown: 1004,
  dpadCenter: 1005
};
var macro = {
  SUPPORT_TEXTURE_FORMATS: SUPPORT_TEXTURE_FORMATS,
  KEY: KEY,
  RAD: Math.PI / 180,
  DEG: 180 / Math.PI,
  REPEAT_FOREVER: Number.MAX_VALUE - 1,
  FLT_EPSILON: 0.0000001192092896,
  ORIENTATION_PORTRAIT: 1,
  ORIENTATION_LANDSCAPE: 2,
  ORIENTATION_AUTO: 3,
  ENABLE_TILEDMAP_CULLING: true,
  TOUCH_TIMEOUT: 5000,
  ENABLE_TRANSPARENT_CANVAS: false,
  ENABLE_WEBGL_ANTIALIAS: true,
  CLEANUP_IMAGE_CACHE: false,
  ENABLE_MULTI_TOUCH: true,
  MAX_LABEL_CANVAS_POOL_SIZE: 20
};
legacyCC.macro = macro;

var BUILTIN_CLASSID_RE = /^(?:cc|dragonBones|sp|ccsg)\..+/;
var BASE64_KEYS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
var values = new Array(123);

for (var i = 0; i < 123; ++i) {
  values[i] = 64;
}

for (var _i = 0; _i < 64; ++_i) {
  values[BASE64_KEYS.charCodeAt(_i)] = _i;
}

var BASE64_VALUES = values;
function propertyDefine(ctor, sameNameGetSets, diffNameGetSets) {
  function define(np, propName, getter, setter) {
    var pd = Object.getOwnPropertyDescriptor(np, propName);

    if (pd) {
      if (pd.get) {
        np[getter] = pd.get;
      }

      if (pd.set && setter) {
        np[setter] = pd.set;
      }
    } else {
      var getterFunc = np[getter];

      {
        getset(np, propName, getterFunc, np[setter]);
      }
    }
  }

  var propName;
  var np = ctor.prototype;

  for (var _i2 = 0; _i2 < sameNameGetSets.length; _i2++) {
    propName = sameNameGetSets[_i2];
    var suffix = propName[0].toUpperCase() + propName.slice(1);
    define(np, propName, "get" + suffix, "set" + suffix);
  }

  for (propName in diffNameGetSets) {
    var gs = diffNameGetSets[propName];
    define(np, propName, gs[0], gs[1]);
  }
}
function pushToMap(map, key, value, pushFront) {
  var exists = map[key];

  if (exists) {
    if (Array.isArray(exists)) {
      if (pushFront) {
        exists.push(exists[0]);
        exists[0] = value;
      } else {
        exists.push(value);
      }
    } else {
      map[key] = pushFront ? [value, exists] : [exists, value];
    }
  } else {
    map[key] = value;
  }
}
function contains$1(refNode, otherNode) {
  if (typeof refNode.contains === 'function') {
    return refNode.contains(otherNode);
  } else if (typeof refNode.compareDocumentPosition === 'function') {
    return !!(refNode.compareDocumentPosition(otherNode) & 16);
  } else {
    var node = otherNode.parentNode;

    if (node) {
      do {
        if (node === refNode) {
          return true;
        } else {
          node = node.parentNode;
        }
      } while (node !== null);
    }

    return false;
  }
}
function isDomNode(obj) {
  if (typeof window === 'object' && typeof Node === 'function') {
    return obj instanceof Node;
  } else {
    return obj && typeof obj === 'object' && typeof obj.nodeType === 'number' && typeof obj.nodeName === 'string';
  }
}
function callInNextTick(callback, p1, p2) {
  if (callback) {
    setTimeout(function () {
      callback(p1, p2);
    }, 0);
  }
}
function tryCatchFunctor_EDITOR(funcName) {
  return Function('target', "" + ('try {\n' + '  target.') + funcName + "();\n" + "}\n" + "catch (e) {\n" + "  cc._throw(e);\n" + "}");
}
function isPlainEmptyObj_DEV(obj) {
  if (!obj || obj.constructor !== Object) {
    return false;
  }

  return isEmptyObject(obj);
}
function clampf(value, min_inclusive, max_inclusive) {
  if (min_inclusive > max_inclusive) {
    var temp = min_inclusive;
    min_inclusive = max_inclusive;
    max_inclusive = temp;
  }

  return value < min_inclusive ? min_inclusive : value < max_inclusive ? value : max_inclusive;
}
function degreesToRadians(angle) {
  return angle * macro.RAD;
}
function radiansToDegrees(angle) {
  return angle * macro.DEG;
}
legacyCC.misc = {
  BUILTIN_CLASSID_RE: BUILTIN_CLASSID_RE,
  BASE64_VALUES: BASE64_VALUES,
  propertyDefine: propertyDefine,
  pushToMap: pushToMap,
  contains: contains$1,
  isDomNode: isDomNode,
  callInNextTick: callInNextTick,
  isPlainEmptyObj_DEV: isPlainEmptyObj_DEV,
  clampf: clampf,
  degreesToRadians: degreesToRadians,
  radiansToDegrees: radiansToDegrees
};

var misc = /*#__PURE__*/Object.freeze({
    __proto__: null,
    BUILTIN_CLASSID_RE: BUILTIN_CLASSID_RE,
    BASE64_VALUES: BASE64_VALUES,
    propertyDefine: propertyDefine,
    pushToMap: pushToMap,
    contains: contains$1,
    isDomNode: isDomNode,
    callInNextTick: callInNextTick,
    tryCatchFunctor_EDITOR: tryCatchFunctor_EDITOR,
    isPlainEmptyObj_DEV: isPlainEmptyObj_DEV,
    clampf: clampf,
    degreesToRadians: degreesToRadians,
    radiansToDegrees: radiansToDegrees
});

var DELIMETER = '$_$';
function createAttrsSingle(owner, superAttrs) {
  var attrs = superAttrs ? Object.create(superAttrs) : {};
  value(owner, '__attrs__', attrs);
  return attrs;
}
function createAttrs(subclass) {
  if (typeof subclass !== 'function') {
    var instance = subclass;
    return createAttrsSingle(instance, getClassAttrs(instance.constructor));
  }

  var superClass;
  var chains = legacyCC.Class.getInheritanceChain(subclass);

  for (var i = chains.length - 1; i >= 0; i--) {
    var cls = chains[i];

    var attrs = cls.hasOwnProperty('__attrs__') && cls.__attrs__;

    if (!attrs) {
      superClass = chains[i + 1];
      createAttrsSingle(cls, superClass && superClass.__attrs__);
    }
  }

  superClass = chains[0];
  createAttrsSingle(subclass, superClass && superClass.__attrs__);
  return subclass.__attrs__;
}
function attr(constructor, propertyName) {
  var attrs = getClassAttrs(constructor);
  var prefix = propertyName + DELIMETER;
  var ret = {};

  for (var key in attrs) {
    if (key.startsWith(prefix)) {
      ret[key.slice(prefix.length)] = attrs[key];
    }
  }

  return ret;
}
function getClassAttrs(constructor) {
  return constructor.hasOwnProperty('__attrs__') && constructor.__attrs__ || createAttrs(constructor);
}
function setClassAttr(ctor, propName, key, value) {
  getClassAttrs(ctor)[propName + DELIMETER + key] = value;
}
var PrimitiveType = function () {
  function PrimitiveType(name, defaultValue) {
    this.name = void 0;
    this["default"] = void 0;
    this.name = name;
    this["default"] = defaultValue;
  }

  var _proto = PrimitiveType.prototype;

  _proto.toString = function toString() {
    return this.name;
  };

  return PrimitiveType;
}();
var CCInteger = new PrimitiveType('Integer', 0);
legacyCC.Integer = CCInteger;
legacyCC.CCInteger = CCInteger;
var CCFloat = new PrimitiveType('Float', 0.0);
legacyCC.Float = CCFloat;
legacyCC.CCFloat = CCFloat;

var CCBoolean = new PrimitiveType('Boolean', false);
legacyCC.Boolean = CCBoolean;
legacyCC.CCBoolean = CCBoolean;
var CCString = new PrimitiveType('String', '');
legacyCC.String = CCString;
legacyCC.CCString = CCString;
function getTypeChecker_ET(type, attributeName) {
  return function (constructor, mainPropertyName) {
    var propInfo = "\"" + getClassName(constructor) + "." + mainPropertyName + "\"";
    var mainPropAttrs = attr(constructor, mainPropertyName);
    var mainPropAttrsType = mainPropAttrs.type;

    if (mainPropAttrsType === CCInteger || mainPropAttrsType === CCFloat) {
      mainPropAttrsType = 'Number';
    } else if (mainPropAttrsType === CCString || mainPropAttrsType === CCBoolean) {
      mainPropAttrsType = "" + mainPropAttrsType;
    }

    if (mainPropAttrsType !== type) {
      warnID(3604, propInfo);
      return;
    }

    if (!mainPropAttrs.hasOwnProperty('default')) {
      return;
    }

    var defaultVal = mainPropAttrs["default"];

    if (typeof defaultVal === 'undefined') {
      return;
    }

    var isContainer = Array.isArray(defaultVal) || isPlainEmptyObj_DEV(defaultVal);

    if (isContainer) {
      return;
    }

    var defaultType = typeof defaultVal;
    var type_lowerCase = type.toLowerCase();

    if (defaultType === type_lowerCase) {
      if (type_lowerCase === 'object') {
        if (defaultVal && !(defaultVal instanceof mainPropAttrs.ctor)) {
          warnID(3605, propInfo, getClassName(mainPropAttrs.ctor));
        } else {
          return;
        }
      } else if (type !== 'Number') {
        warnID(3606, attributeName, propInfo, type);
      }
    } else if (defaultType !== 'function') {
      if (type === CCString["default"] && defaultVal == null) {
        warnID(3607, propInfo);
      } else {
        warnID(3611, attributeName, propInfo, defaultType);
      }
    } else {
      return;
    }

    delete mainPropAttrs.type;
  };
}
function getObjTypeChecker_ET(typeCtor) {
  return function (classCtor, mainPropName) {
    getTypeChecker_ET('Object', 'type')(classCtor, mainPropName);
    var defaultDef = getClassAttrs(classCtor)[mainPropName + DELIMETER + "default"];
    var defaultVal = legacyCC.Class.getDefault(defaultDef);

    if (!Array.isArray(defaultVal) && isChildClassOf(typeCtor, legacyCC.ValueType)) {
      var typename = getClassName(typeCtor);
      var info = formatStr('No need to specify the "type" of "%s.%s" because %s is a child class of ValueType.', getClassName(classCtor), mainPropName, typename);

      if (defaultDef) {
        log(info);
      } else {
        warnID(3612, info, typename, getClassName(classCtor), mainPropName, typename);
      }
    }
  };
}

var attributeUtils = /*#__PURE__*/Object.freeze({
    __proto__: null,
    DELIMETER: DELIMETER,
    createAttrsSingle: createAttrsSingle,
    createAttrs: createAttrs,
    attr: attr,
    getClassAttrs: getClassAttrs,
    setClassAttr: setClassAttr,
    PrimitiveType: PrimitiveType,
    CCInteger: CCInteger,
    CCFloat: CCFloat,
    CCBoolean: CCBoolean,
    CCString: CCString,
    getTypeChecker_ET: getTypeChecker_ET,
    getObjTypeChecker_ET: getObjTypeChecker_ET
});

var SerializableAttrs = {
  "default": {},
  serializable: {},
  editorOnly: {},
  formerlySerializedAs: {}
};

function parseNotify(val, propName, notify, properties) {
  if (val.get || val.set) {

    return;
  }

  if (val.hasOwnProperty('default')) {
    var newKey = "_N$" + propName;

    val.get = function () {
      return this[newKey];
    };

    val.set = function (value) {
      var oldValue = this[newKey];
      this[newKey] = value;
      notify.call(this, oldValue);
    };

    var newValue = {};
    properties[newKey] = newValue;

    for (var attr in SerializableAttrs) {
      var v = SerializableAttrs[attr];

      if (val.hasOwnProperty(attr)) {
        newValue[attr] = val[attr];

        if (!v.canUsedInGet) {
          delete val[attr];
        }
      }
    }
  }
}

function parseType(val, type, className, propName) {

  if (Array.isArray(type)) {

    if (type.length > 0) {
      val.type = type = type[0];
    } else {
      return errorID(5508, className, propName);
    }
  }

  if (typeof type === 'function') {
    if (type === String) {
      val.type = legacyCC.String;
    } else if (type === Boolean) {
      val.type = legacyCC.Boolean;
    } else if (type === Number) {
      val.type = legacyCC.Float;
    }
  }
}

function _wrapOptions(isGetset, _default, type) {
  var res = isGetset ? {
    _short: true
  } : {
    _short: true,
    "default": _default
  };

  if (type) {
    res.type = type;
  }

  return res;
}

function getFullFormOfProperty(options, isGetset) {
  var isLiteral = options && options.constructor === Object;

  if (!isLiteral) {
    if (Array.isArray(options) && options.length > 0) {
      return _wrapOptions(isGetset, [], options);
    } else if (typeof options === 'function') {
      var type = options;
      return _wrapOptions(isGetset, isChildClassOf(type, legacyCC.ValueType) ? new type() : null, type);
    } else if (options instanceof PrimitiveType) {
      return _wrapOptions(isGetset, options["default"]);
    } else {
      return _wrapOptions(isGetset, options);
    }
  }

  return null;
}
function preprocessAttrs(properties, className, cls) {
  for (var propName in properties) {
    var val = properties[propName];
    var fullForm = getFullFormOfProperty(val, false);

    if (fullForm) {
      val = properties[propName] = fullForm;
    }

    if (val) {

      var notify = val.notify;

      if (notify) {
        {
          parseNotify(val, propName, notify, properties);
        }
      }

      if ('type' in val) {
        parseType(val, val.type, className, propName);
      }
    }
  }
}

var requiringFrames = [];
function push(module, uuid, script, importMeta) {
  if (script === undefined) {
    script = uuid;
    uuid = '';
  }

  requiringFrames.push({
    uuid: uuid,
    script: script,
    module: module,
    exports: module.exports,
    beh: null,
    importMeta: importMeta
  });
}
function pop() {
  var frameInfo = requiringFrames.pop();
  var module = frameInfo.module;
  var exports = module.exports;

  if (exports === frameInfo.exports) {
    for (var anykey in exports) {
      return;
    }

    module.exports = exports = frameInfo.cls;
  }
}
function peek() {
  return requiringFrames[requiringFrames.length - 1];
}
legacyCC._RF = {
  push: push,
  pop: pop,
  peek: peek
};

var DELIMETER$1 = DELIMETER;

function pushUnique(array, item) {
  if (array.indexOf(item) < 0) {
    array.push(item);
  }
}

var deferredInitializer = {
  datas: null,
  push: function push(data) {
    if (this.datas) {
      this.datas.push(data);
    } else {
      this.datas = [data];
      var self = this;
      setTimeout(function () {
        self.init();
      }, 0);
    }
  },
  init: function init() {
    var datas = this.datas;

    if (datas) {
      for (var i = 0; i < datas.length; ++i) {
        var data = datas[i];
        var cls = data.cls;
        var properties = data.props;

        if (typeof properties === 'function') {
          properties = properties();
        }

        var name = getClassName(cls);

        if (properties) {
          declareProperties(cls, name, properties, cls.$super, data.mixins);
        } else {
          errorID(3633, name);
        }
      }

      this.datas = null;
    }
  }
};

function appendProp(cls, name) {

  pushUnique(cls.__props__, name);
}

function defineProp(cls, className, propName, val) {

  appendProp(cls, propName);
  parseAttributes(cls, val, className, propName);
}

function defineGetSet(cls, name, propName, val) {
  var getter = val.get;
  var setter = val.set;

  if (getter) {
    parseAttributes(cls, val, name, propName);

    setClassAttr(cls, propName, 'serializable', false);
  }
}

function getDefault(defaultVal) {
  if (typeof defaultVal === 'function') {
    {
      return defaultVal();
    }
  }

  return defaultVal;
}

function mixinWithInherited(dest, src, filter) {
  for (var prop in src) {
    if (!dest.hasOwnProperty(prop) && (!filter || filter(prop))) {
      Object.defineProperty(dest, prop, getPropertyDescriptor(src, prop));
    }
  }
}

function doDefine(className, baseClass, mixins, options) {
  var ctor = options.ctor;

  var ctors = [ctor];
  var fireClass = ctor;
  value(fireClass, '__ctors__', ctors.length > 0 ? ctors : null, true);
  var prototype = fireClass.prototype;

  if (baseClass) {
    fireClass.$super = baseClass;
  }

  if (mixins) {
    for (var m = mixins.length - 1; m >= 0; m--) {
      var mixin = mixins[m];
      mixinWithInherited(prototype, mixin.prototype);

      if (CCClass._isCCClass(mixin)) {
        mixinWithInherited(getClassAttrs(fireClass), getClassAttrs(mixin));
      }
    }

    prototype.constructor = fireClass;
  }

  setClassName(className, fireClass);
  return fireClass;
}

function define(className, baseClass, mixins, options) {
  var Component = legacyCC.Component;
  var frame = peek();

  if (frame && isChildClassOf(baseClass, Component)) {
    if (isChildClassOf(frame.cls, Component)) {
      errorID(3615);
      return null;
    }

    className = className || frame.script;
  }

  var cls = doDefine(className, baseClass, mixins, options);

  if (frame) {
    if (isChildClassOf(baseClass, Component)) {
      var uuid = frame.uuid;

      if (uuid) {
        _setClassId(uuid, cls);
      }

      frame.cls = cls;
    } else if (!isChildClassOf(frame.cls, Component)) {
      frame.cls = cls;
    }
  }

  return cls;
}

function getNewValueTypeCodeJit(value) {
  var clsName = getClassName(value);
  var type = value.constructor;
  var res = "new " + clsName + "(";

  for (var i = 0; i < type.__props__.length; i++) {
    var prop = type.__props__[i];
    var propVal = value[prop];

    res += propVal;

    if (i < type.__props__.length - 1) {
      res += ',';
    }
  }

  return res + ")";
}

function escapeForJS(s) {
  return JSON.stringify(s).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
}

var IDENTIFIER_RE = /^[A-Za-z_$][0-9A-Za-z_$]*$/;

function declareProperties(cls, className, properties, baseClass, mixins) {
  cls.__props__ = [];

  if (baseClass && baseClass.__props__) {
    cls.__props__ = baseClass.__props__.slice();
  }

  if (mixins) {
    for (var m = 0; m < mixins.length; ++m) {
      var mixin = mixins[m];

      if (mixin.__props__) {
        cls.__props__ = cls.__props__.concat(mixin.__props__.filter(function (x) {
          return cls.__props__.indexOf(x) < 0;
        }));
      }
    }
  }

  if (properties) {
    preprocessAttrs(properties, className);

    for (var propName in properties) {
      var val = properties[propName];

      if (!val.get && !val.set) {
        defineProp(cls, className, propName, val);
      } else {
        defineGetSet(cls, className, propName, val);
      }
    }
  }

  var attrs = getClassAttrs(cls);
  cls.__values__ = cls.__props__.filter(function (prop) {
    return attrs[prop + DELIMETER$1 + "serializable"] !== false;
  });
}

function CCClass(options) {
  var name = options.name;
  var base = options["extends"];
  var mixins = options.mixins;
  var cls = define(name, base, mixins, options);

  if (!name) {
    name = legacyCC.js.getClassName(cls);
  }

  cls._sealed = true;

  if (base) {
    base._sealed = false;
  }

  var properties = options.properties;

  if (typeof properties === 'function' || base && base.__props__ === null || mixins && mixins.some(function (x) {
    return x.__props__ === null;
  })) {
    {
      deferredInitializer.push({
        cls: cls,
        props: properties,
        mixins: mixins
      });
      cls.__props__ = cls.__values__ = null;
    }
  } else {
    declareProperties(cls, name, properties, base, options.mixins);
  }

  var editor = options.editor;

  if (editor) {
    if (isChildClassOf(base, legacyCC.Component)) {
      legacyCC.Component._registerEditorProps(cls, editor);
    }
  }

  return cls;
}

CCClass._isCCClass = function isCCClass(constructor) {
  var _constructor$hasOwnPr;

  return constructor === null || constructor === void 0 ? void 0 : (_constructor$hasOwnPr = constructor.hasOwnProperty) === null || _constructor$hasOwnPr === void 0 ? void 0 : _constructor$hasOwnPr.call(constructor, '__ctors__');
};

CCClass.fastDefine = function (className, constructor, serializableFields) {
  setClassName(className, constructor);
  var props = constructor.__props__ = constructor.__values__ = Object.keys(serializableFields);
  var attrs = getClassAttrs(constructor);

  for (var i = 0; i < props.length; i++) {
    var key = props[i];
    attrs[key + DELIMETER$1 + "visible"] = false;
    attrs[key + DELIMETER$1 + "default"] = serializableFields[key];
  }
};

CCClass.Attr = attributeUtils;
CCClass.attr = attr;

function getInheritanceChain(constructor) {
  var chain = [];

  for (;;) {
    constructor = getSuper(constructor);

    if (!constructor) {
      break;
    }

    if (constructor !== Object) {
      chain.push(constructor);
    }
  }

  return chain;
}

CCClass.getInheritanceChain = getInheritanceChain;
var PrimitiveTypes = {
  Integer: 'Number',
  Float: 'Number',
  Boolean: 'Boolean',
  String: 'String'
};

function parseAttributes(constructor, attributes, className, propertyName, usedInGetter) {
  var attrs = null;
  var propertyNamePrefix = '';

  function initAttrs() {
    propertyNamePrefix = propertyName + DELIMETER$1;
    return attrs = getClassAttrs(constructor);
  }

  if ('type' in attributes && typeof attributes.type === 'undefined') {
    warnID(3660, propertyName, className);
  }
  var type = attributes.type;

  if (type) {
    var primitiveType = PrimitiveTypes[type];

    if (primitiveType) {
      (attrs || initAttrs())[propertyNamePrefix + "type"] = type;
    } else if (type === 'Object') ; else if (typeof type === 'object') {
        if (Enum.isEnum(type)) {
          (attrs || initAttrs())[propertyNamePrefix + "type"] = 'Enum';
          attrs[propertyNamePrefix + "enumList"] = Enum.getList(type);
        } else if (BitMask.isBitMask(type)) {
          (attrs || initAttrs())[propertyNamePrefix + "type"] = 'BitMask';
          attrs[propertyNamePrefix + "bitmaskList"] = BitMask.getList(type);
        } else ;
      } else if (typeof type === 'function') {
        (attrs || initAttrs())[propertyNamePrefix + "type"] = 'Object';
        attrs[propertyNamePrefix + "ctor"] = type;
      } else ;
  }

  if ('default' in attributes) {
    (attrs || initAttrs())[propertyNamePrefix + "default"] = attributes["default"];
  }

  var parseSimpleAttribute = function parseSimpleAttribute(attributeName, expectType) {
    if (attributeName in attributes) {
      var val = attributes[attributeName];

      if (typeof val === expectType) {
        (attrs || initAttrs())[propertyNamePrefix + attributeName] = val;
      }
    }
  };

  if (attributes.editorOnly) {
    {
      (attrs || initAttrs())[propertyNamePrefix + "editorOnly"] = true;
    }
  }

  if (attributes.__noImplicit) {
    var _attributes$serializa;

    (attrs || initAttrs())[propertyNamePrefix + "serializable"] = (_attributes$serializa = attributes.serializable) !== null && _attributes$serializa !== void 0 ? _attributes$serializa : false;
  } else if (attributes.serializable === false) {
    {
      (attrs || initAttrs())[propertyNamePrefix + "serializable"] = false;
    }
  }

  parseSimpleAttribute('formerlySerializedAs', 'string');

  var range = attributes.range;

  if (range) {
    if (Array.isArray(range)) {
      if (range.length >= 2) {
        (attrs || initAttrs())[propertyNamePrefix + "min"] = range[0];
        attrs[propertyNamePrefix + "max"] = range[1];

        if (range.length > 2) {
          attrs[propertyNamePrefix + "step"] = range[2];
        }
      }
    }
  }

  parseSimpleAttribute('min', 'number');
  parseSimpleAttribute('max', 'number');
  parseSimpleAttribute('step', 'number');
}

CCClass.isArray = function (defaultVal) {
  defaultVal = getDefault(defaultVal);
  return Array.isArray(defaultVal);
};

CCClass.getDefault = getDefault;
CCClass.escapeForJS = escapeForJS;
CCClass.IDENTIFIER_RE = IDENTIFIER_RE;
CCClass.getNewValueTypeCode =  getNewValueTypeCodeJit;
legacyCC.Class = CCClass;

var editorExtrasTag = '__editorExtras__';

var _CCClass$fastDefine;
var Destroyed = 1 << 0;
var ToDestroy = 1 << 2;
var DontSave = 1 << 3;
var EditorOnly = 1 << 4;
var Dirty = 1 << 5;
var DontDestroy = 1 << 6;
var Destroying = 1 << 7;
var Deactivating = 1 << 8;
var LockedInEditor = 1 << 9;
var HideInHierarchy = 1 << 10;
var IsOnEnableCalled = 1 << 11;
var IsEditorOnEnableCalled = 1 << 12;
var IsPreloadStarted = 1 << 13;
var IsOnLoadCalled = 1 << 14;
var IsOnLoadStarted = 1 << 15;
var IsStartCalled = 1 << 16;
var IsRotationLocked = 1 << 17;
var IsScaleLocked = 1 << 18;
var IsAnchorLocked = 1 << 19;
var IsSizeLocked = 1 << 20;
var IsPositionLocked = 1 << 21;
var IsReplicated = 1 << 22;
var PersistentMask = ~(ToDestroy | Dirty | Destroying | DontDestroy | Deactivating | IsPreloadStarted | IsOnLoadStarted | IsOnLoadCalled | IsStartCalled | IsOnEnableCalled | IsEditorOnEnableCalled | IsRotationLocked | IsScaleLocked | IsAnchorLocked | IsSizeLocked | IsPositionLocked);
var AllHideMasks = DontSave | EditorOnly | LockedInEditor | HideInHierarchy;
var objectsToDestroy = [];

function compileDestruct(obj, ctor) {
  var shouldSkipId = obj instanceof legacyCC._BaseNode || obj instanceof legacyCC.Component;
  var idToSkip = shouldSkipId ? '_id' : null;
  var key;
  var propsToReset = {};

  for (key in obj) {
    if (obj.hasOwnProperty(key)) {
      if (key === idToSkip) {
        continue;
      }

      switch (typeof obj[key]) {
        case 'string':
          propsToReset[key] = '';
          break;

        case 'object':
        case 'function':
          propsToReset[key] = null;
          break;
      }
    }
  }

  if (CCClass._isCCClass(ctor)) {
    var attrs = legacyCC.Class.Attr.getClassAttrs(ctor);
    var propList = ctor.__props__;

    for (var i = 0; i < propList.length; i++) {
      key = propList[i];
      var attrKey = key + legacyCC.Class.Attr.DELIMETER + "default";

      if (attrKey in attrs) {
        if (shouldSkipId && key === '_id') {
          continue;
        }

        switch (typeof attrs[attrKey]) {
          case 'string':
            propsToReset[key] = '';
            break;

          case 'object':
          case 'function':
            propsToReset[key] = null;
            break;

          case 'undefined':
            propsToReset[key] = undefined;
            break;
        }
      }
    }
  }

  {
    var func = '';

    for (key in propsToReset) {
      var statement = void 0;

      if (CCClass.IDENTIFIER_RE.test(key)) {
        statement = "o." + key + "=";
      } else {
        statement = "o[" + CCClass.escapeForJS(key) + "]=";
      }

      var val = propsToReset[key];

      if (val === '') {
        val = '""';
      }

      func += statement + val + ";\n";
    }

    return Function('o', func);
  }
}

var CCObject = function () {
  CCObject._deferredDestroy = function _deferredDestroy() {
    var deleteCount = objectsToDestroy.length;

    for (var i = 0; i < deleteCount; ++i) {
      var obj = objectsToDestroy[i];

      if (!(obj._objFlags & Destroyed)) {
        obj._destroyImmediate();
      }
    }

    if (deleteCount === objectsToDestroy.length) {
      objectsToDestroy.length = 0;
    } else {
      objectsToDestroy.splice(0, deleteCount);
    }
  };

  function CCObject(name) {
    if (name === void 0) {
      name = '';
    }

    this._objFlags = void 0;
    this._name = void 0;
    this._name = name;
    this._objFlags = 0;
  }

  var _proto = CCObject.prototype;

  _proto.destroy = function destroy() {
    if (this._objFlags & Destroyed) {
      warnID(5000);
      return false;
    }

    if (this._objFlags & ToDestroy) {
      return false;
    }

    this._objFlags |= ToDestroy;
    objectsToDestroy.push(this);

    return true;
  };

  _proto._destruct = function _destruct() {
    var ctor = this.constructor;
    var destruct = ctor.__destruct__;

    if (!destruct) {
      destruct = compileDestruct(this, ctor);
      value(ctor, '__destruct__', destruct, true);
    }

    destruct(this);
  };

  _proto._destroyImmediate = function _destroyImmediate() {
    if (this._objFlags & Destroyed) {
      errorID(5000);
      return;
    }

    if (this._onPreDestroy) {
      this._onPreDestroy();
    }

    {
      this._destruct();
    }

    this._objFlags |= Destroyed;
  };

  _createClass(CCObject, [{
    key: "name",
    get: function get() {
      return this._name;
    },
    set: function set(value) {
      this._name = value;
    }
  }, {
    key: "hideFlags",
    set: function set(hideFlags) {
      var flags = hideFlags & CCObject.Flags.AllHideMasks;
      this._objFlags = this._objFlags & ~CCObject.Flags.AllHideMasks | flags;
    },
    get: function get() {
      return this._objFlags & CCObject.Flags.AllHideMasks;
    }
  }, {
    key: "replicated",
    set: function set(value) {
      if (value) {
        this._objFlags |= IsReplicated;
      } else {
        this._objFlags &= ~IsReplicated;
      }
    },
    get: function get() {
      return !!(this._objFlags & IsReplicated);
    }
  }, {
    key: "isValid",
    get: function get() {
      return !(this._objFlags & Destroyed);
    }
  }]);

  return CCObject;
}();

var prototype = CCObject.prototype;

prototype._deserialize = null;
prototype._onPreDestroy = null;
CCClass.fastDefine('cc.Object', CCObject, (_CCClass$fastDefine = {
  _name: '',
  _objFlags: 0
}, _CCClass$fastDefine[editorExtrasTag] = {}, _CCClass$fastDefine));
CCClass.Attr.setClassAttr(CCObject, editorExtrasTag, 'editorOnly', true);
value(CCObject, 'Flags', {
  Destroyed: Destroyed,
  DontSave: DontSave,
  EditorOnly: EditorOnly,
  Dirty: Dirty,
  DontDestroy: DontDestroy,
  PersistentMask: PersistentMask,
  Destroying: Destroying,
  Deactivating: Deactivating,
  LockedInEditor: LockedInEditor,
  HideInHierarchy: HideInHierarchy,
  AllHideMasks: AllHideMasks,
  IsPreloadStarted: IsPreloadStarted,
  IsOnLoadStarted: IsOnLoadStarted,
  IsOnLoadCalled: IsOnLoadCalled,
  IsOnEnableCalled: IsOnEnableCalled,
  IsStartCalled: IsStartCalled,
  IsEditorOnEnableCalled: IsEditorOnEnableCalled,
  IsPositionLocked: IsPositionLocked,
  IsRotationLocked: IsRotationLocked,
  IsScaleLocked: IsScaleLocked,
  IsAnchorLocked: IsAnchorLocked,
  IsSizeLocked: IsSizeLocked
});
function isValid(value, strictMode) {
  if (typeof value === 'object') {
    return !!value && !(value._objFlags & (strictMode ? Destroyed | ToDestroy : Destroyed));
  } else {
    return typeof value !== 'undefined';
  }
}
legacyCC.isValid = isValid;

legacyCC.Object = CCObject;

var fastRemoveAt$1 = array.fastRemoveAt;

function empty() {}

var CallbackInfo = function () {
  function CallbackInfo() {
    this.callback = empty;
    this.target = undefined;
    this.once = false;
  }

  var _proto = CallbackInfo.prototype;

  _proto.set = function set(callback, target, once) {
    this.callback = callback || empty;
    this.target = target;
    this.once = !!once;
  };

  _proto.reset = function reset() {
    this.target = undefined;
    this.callback = empty;
    this.once = false;
  };

  _proto.check = function check() {
    if (this.target instanceof CCObject && !isValid(this.target, true)) {
      return false;
    } else {
      return true;
    }
  };

  return CallbackInfo;
}();

var callbackInfoPool = new Pool(function () {
  return new CallbackInfo();
}, 32);
var CallbackList = function () {
  function CallbackList() {
    this.callbackInfos = [];
    this.isInvoking = false;
    this.containCanceled = false;
  }

  var _proto2 = CallbackList.prototype;

  _proto2.removeByCallback = function removeByCallback(cb) {
    for (var i = 0; i < this.callbackInfos.length; ++i) {
      var info = this.callbackInfos[i];

      if (info && info.callback === cb) {
        info.reset();
        callbackInfoPool.free(info);
        fastRemoveAt$1(this.callbackInfos, i);
        --i;
      }
    }
  };

  _proto2.removeByTarget = function removeByTarget(target) {
    for (var i = 0; i < this.callbackInfos.length; ++i) {
      var info = this.callbackInfos[i];

      if (info && info.target === target) {
        info.reset();
        callbackInfoPool.free(info);
        fastRemoveAt$1(this.callbackInfos, i);
        --i;
      }
    }
  };

  _proto2.cancel = function cancel(index) {
    var info = this.callbackInfos[index];

    if (info) {
      info.reset();

      if (this.isInvoking) {
        this.callbackInfos[index] = null;
      } else {
        fastRemoveAt$1(this.callbackInfos, index);
      }

      callbackInfoPool.free(info);
    }

    this.containCanceled = true;
  };

  _proto2.cancelAll = function cancelAll() {
    for (var i = 0; i < this.callbackInfos.length; i++) {
      var info = this.callbackInfos[i];

      if (info) {
        info.reset();
        callbackInfoPool.free(info);
        this.callbackInfos[i] = null;
      }
    }

    this.containCanceled = true;
  };

  _proto2.purgeCanceled = function purgeCanceled() {
    for (var i = this.callbackInfos.length - 1; i >= 0; --i) {
      var info = this.callbackInfos[i];

      if (!info) {
        fastRemoveAt$1(this.callbackInfos, i);
      }
    }

    this.containCanceled = false;
  };

  _proto2.clear = function clear() {
    this.cancelAll();
    this.callbackInfos.length = 0;
    this.isInvoking = false;
    this.containCanceled = false;
  };

  return CallbackList;
}();
var MAX_SIZE = 16;
var callbackListPool = new Pool(function () {
  return new CallbackList();
}, MAX_SIZE);
var CallbacksInvoker = function () {
  function CallbacksInvoker() {
    this._callbackTable = createMap(true);
  }

  var _proto3 = CallbacksInvoker.prototype;

  _proto3.on = function on(key, callback, target, once) {
    if (!this.hasEventListener(key, callback, target)) {
      var list = this._callbackTable[key];

      if (!list) {
        list = this._callbackTable[key] = callbackListPool.alloc();
      }

      var info = callbackInfoPool.alloc();
      info.set(callback, target, once);
      list.callbackInfos.push(info);
    }

    return callback;
  };

  _proto3.hasEventListener = function hasEventListener(key, callback, target) {
    var list = this._callbackTable && this._callbackTable[key];

    if (!list) {
      return false;
    }

    var infos = list.callbackInfos;

    if (!callback) {
      if (list.isInvoking) {
        for (var i = 0; i < infos.length; ++i) {
          if (infos[i]) {
            return true;
          }
        }

        return false;
      } else {
        return infos.length > 0;
      }
    }

    for (var _i = 0; _i < infos.length; ++_i) {
      var info = infos[_i];

      if (info && info.check() && info.callback === callback && info.target === target) {
        return true;
      }
    }

    return false;
  };

  _proto3.removeAll = function removeAll(keyOrTarget) {
    var type = typeof keyOrTarget;

    if (type === 'string' || type === 'number') {
      var list = this._callbackTable && this._callbackTable[keyOrTarget];

      if (list) {
        if (list.isInvoking) {
          list.cancelAll();
        } else {
          list.clear();
          callbackListPool.free(list);
          delete this._callbackTable[keyOrTarget];
        }
      }
    } else if (keyOrTarget) {
      for (var key in this._callbackTable) {
        var _list = this._callbackTable[key];

        if (_list.isInvoking) {
          var infos = _list.callbackInfos;

          for (var i = 0; i < infos.length; ++i) {
            var info = infos[i];

            if (info && info.target === keyOrTarget) {
              _list.cancel(i);
            }
          }
        } else {
          _list.removeByTarget(keyOrTarget);
        }
      }
    }
  };

  _proto3.off = function off(key, callback, target) {
    var list = this._callbackTable && this._callbackTable[key];

    if (list) {
      var infos = list.callbackInfos;

      if (callback) {
        for (var i = 0; i < infos.length; ++i) {
          var info = infos[i];

          if (info && info.callback === callback && info.target === target) {
            list.cancel(i);
            break;
          }
        }
      } else {
        this.removeAll(key);
      }
    }
  };

  _proto3.emit = function emit(key, arg0, arg1, arg2, arg3, arg4) {
    var list = this._callbackTable && this._callbackTable[key];

    if (list) {
      var rootInvoker = !list.isInvoking;
      list.isInvoking = true;
      var infos = list.callbackInfos;

      for (var i = 0, len = infos.length; i < len; ++i) {
        var info = infos[i];

        if (info) {
          var callback = info.callback;
          var target = info.target;

          if (info.once) {
            this.off(key, callback, target);
          }

          if (!info.check()) {
            this.off(key, callback, target);
          } else if (target) {
            callback.call(target, arg0, arg1, arg2, arg3, arg4);
          } else {
            callback(arg0, arg1, arg2, arg3, arg4);
          }
        }
      }

      if (rootInvoker) {
        list.isInvoking = false;

        if (list.containCanceled) {
          list.purgeCanceled();
        }
      }
    }
  };

  _proto3.clear = function clear() {
    for (var key in this._callbackTable) {
      var list = this._callbackTable[key];

      if (list) {
        list.clear();
        callbackListPool.free(list);
        delete this._callbackTable[key];
      }
    }
  };

  return CallbacksInvoker;
}();

function Eventify(base) {
  var Eventified = function (_ref) {
    _inheritsLoose(Eventified, _ref);

    function Eventified() {
      var _this;

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _ref.call.apply(_ref, [this].concat(args)) || this;
      _this._callbackTable = createMap(true);
      return _this;
    }

    var _proto = Eventified.prototype;

    _proto.once = function once(type, callback, target) {
      return this.on(type, callback, target, true);
    };

    _proto.targetOff = function targetOff(typeOrTarget) {
      this.removeAll(typeOrTarget);
    };

    return Eventified;
  }(base);

  var callbacksInvokerPrototype = CallbacksInvoker.prototype;
  var propertyKeys = Object.getOwnPropertyNames(callbacksInvokerPrototype).concat(Object.getOwnPropertySymbols(callbacksInvokerPrototype));

  for (var iPropertyKey = 0; iPropertyKey < propertyKeys.length; ++iPropertyKey) {
    var propertyKey = propertyKeys[iPropertyKey];

    if (!(propertyKey in Eventified.prototype)) {
      var propertyDescriptor = Object.getOwnPropertyDescriptor(callbacksInvokerPrototype, propertyKey);

      if (propertyDescriptor) {
        Object.defineProperty(Eventified.prototype, propertyKey, propertyDescriptor);
      }
    }
  }

  return Eventified;
}

var Empty = function Empty() {};

var EventTarget = Eventify(Empty);
legacyCC.EventTarget = EventTarget;

var SystemInfo = function (_EventTarget) {
  _inheritsLoose(SystemInfo, _EventTarget);

  function SystemInfo() {
    var _nav$getBattery;

    var _this;

    _this = _EventTarget.call(this) || this;
    _this.networkType = void 0;
    _this.isNative = void 0;
    _this.isBrowser = void 0;
    _this.isMobile = void 0;
    _this.isLittleEndian = void 0;
    _this.platform = void 0;
    _this.language = void 0;
    _this.nativeLanguage = void 0;
    _this.os = void 0;
    _this.osVersion = void 0;
    _this.osMainVersion = void 0;
    _this.browserType = void 0;
    _this.browserVersion = void 0;
    _this.pixelRatio = void 0;
    _this.supportCapability = void 0;
    _this._battery = void 0;
    var nav = window.navigator;
    var ua = nav.userAgent.toLowerCase();
    (_nav$getBattery = nav.getBattery) === null || _nav$getBattery === void 0 ? void 0 : _nav$getBattery.call(nav).then(function (battery) {
      _this._battery = battery;
    });
    _this.networkType = NetworkType.LAN;
    _this.isNative = false;
    _this.isBrowser = true;

    {
      _this.isMobile = /mobile|android|iphone|ipad/.test(ua);
      _this.platform = _this.isMobile ? Platform.MOBILE_BROWSER : Platform.DESKTOP_BROWSER;
    }

    _this.isLittleEndian = function () {
      var buffer = new ArrayBuffer(2);
      new DataView(buffer).setInt16(0, 256, true);
      return new Int16Array(buffer)[0] === 256;
    }();

    var currLanguage = nav.language;
    _this.nativeLanguage = currLanguage.toLowerCase();
    currLanguage = currLanguage || nav.browserLanguage;
    currLanguage = currLanguage ? currLanguage.split('-')[0] : Language.ENGLISH;
    _this.language = currLanguage;
    var isAndroid = false;
    var iOS = false;
    var osVersion = '';
    var osMajorVersion = 0;
    var uaResult = /android\s*(\d+(?:\.\d+)*)/i.exec(ua) || /android\s*(\d+(?:\.\d+)*)/i.exec(nav.platform);

    if (uaResult) {
      isAndroid = true;
      osVersion = uaResult[1] || '';
      osMajorVersion = parseInt(osVersion) || 0;
    }

    uaResult = /(iPad|iPhone|iPod).*OS ((\d+_?){2,3})/i.exec(ua);

    if (uaResult) {
      iOS = true;
      osVersion = uaResult[2] || '';
      osMajorVersion = parseInt(osVersion) || 0;
    } else if (/(iPhone|iPad|iPod)/.exec(nav.platform) || nav.platform === 'MacIntel' && nav.maxTouchPoints && nav.maxTouchPoints > 1) {
      iOS = true;
      osVersion = '';
      osMajorVersion = 0;
    }

    var osName = exports.OS.UNKNOWN;

    if (nav.appVersion.indexOf('Win') !== -1) {
      osName = exports.OS.WINDOWS;
    } else if (iOS) {
      osName = exports.OS.IOS;
    } else if (nav.appVersion.indexOf('Mac') !== -1) {
      osName = exports.OS.OSX;
    } else if (nav.appVersion.indexOf('X11') !== -1 && nav.appVersion.indexOf('Linux') === -1) {
      osName = exports.OS.LINUX;
    } else if (isAndroid) {
      osName = exports.OS.ANDROID;
    } else if (nav.appVersion.indexOf('Linux') !== -1 || ua.indexOf('ubuntu') !== -1) {
      osName = exports.OS.LINUX;
    }

    _this.os = osName;
    _this.osVersion = osVersion;
    _this.osMainVersion = osMajorVersion;
    _this.browserType = exports.BrowserType.UNKNOWN;
    var typeReg0 = /wechat|weixin|micromessenger/i;
    var typeReg1 = /mqqbrowser|micromessenger|qqbrowser|sogou|qzone|liebao|maxthon|ucbs|360 aphone|360browser|baiduboxapp|baidubrowser|maxthon|mxbrowser|miuibrowser/i;
    var typeReg2 = /qq|qqbrowser|ucbrowser|ubrowser|edge|HuaweiBrowser/i;
    var typeReg3 = /chrome|safari|firefox|trident|opera|opr\/|oupeng/i;
    var browserTypes = typeReg0.exec(ua) || typeReg1.exec(ua) || typeReg2.exec(ua) || typeReg3.exec(ua);
    var browserType = browserTypes ? browserTypes[0].toLowerCase() : exports.OS.UNKNOWN;

    if (browserType === 'safari' && isAndroid) {
      browserType = exports.BrowserType.ANDROID;
    } else if (browserType === 'qq' && /android.*applewebkit/i.test(ua)) {
      browserType = exports.BrowserType.ANDROID;
    }

    var typeMap = {
      micromessenger: exports.BrowserType.WECHAT,
      wechat: exports.BrowserType.WECHAT,
      weixin: exports.BrowserType.WECHAT,
      trident: exports.BrowserType.IE,
      edge: exports.BrowserType.EDGE,
      '360 aphone': exports.BrowserType.BROWSER_360,
      mxbrowser: exports.BrowserType.MAXTHON,
      'opr/': exports.BrowserType.OPERA,
      ubrowser: exports.BrowserType.UC,
      huaweibrowser: exports.BrowserType.HUAWEI
    };
    _this.browserType = typeMap[browserType] || browserType;
    _this.browserVersion = '';
    var versionReg1 = /(mqqbrowser|micromessenger|qqbrowser|sogou|qzone|liebao|maxthon|uc|ucbs|360 aphone|360|baiduboxapp|baidu|maxthon|mxbrowser|miui(?:.hybrid)?)(mobile)?(browser)?\/?([\d.]+)/i;
    var versionReg2 = /(qq|chrome|safari|firefox|trident|opera|opr\/|oupeng)(mobile)?(browser)?\/?([\d.]+)/i;
    var tmp = versionReg1.exec(ua);

    if (!tmp) {
      tmp = versionReg2.exec(ua);
    }

    _this.browserVersion = tmp ? tmp[4] : '';
    _this.pixelRatio = window.devicePixelRatio || 1;

    var _tmpCanvas1 = document.createElement('canvas');

    var supportCanvas =  !!_tmpCanvas1.getContext('2d');
    var supportWebGL = false;

    if (window.WebGLRenderingContext) {
      supportWebGL = true;
    }

    var supportWebp;

    try {
      supportWebp = TEST ? false : _tmpCanvas1.toDataURL('image/webp').startsWith('data:image/webp');
    } catch (e) {
      supportWebp = false;
    }

    var supportImageBitmap = false;

    if ( typeof createImageBitmap !== 'undefined' && typeof Blob !== 'undefined') {
      _tmpCanvas1.width = _tmpCanvas1.height = 2;
      createImageBitmap(_tmpCanvas1, {}).then(function (imageBitmap) {
        supportImageBitmap = true;
        imageBitmap === null || imageBitmap === void 0 ? void 0 : imageBitmap.close();
      })["catch"](function (err) {});
    }

    _this.supportCapability = {
      webp: supportWebp,
      gl: supportWebGL,
      canvas: supportCanvas,
      imageBitmap: supportImageBitmap
    };

    _this._registerEvent();

    return _this;
  }

  var _proto = SystemInfo.prototype;

  _proto._registerEvent = function _registerEvent() {
    var _this2 = this;

    var hiddenPropName;

    if (typeof document.hidden !== 'undefined') {
      hiddenPropName = 'hidden';
    } else if (typeof document.mozHidden !== 'undefined') {
      hiddenPropName = 'mozHidden';
    } else if (typeof document.msHidden !== 'undefined') {
      hiddenPropName = 'msHidden';
    } else if (typeof document.webkitHidden !== 'undefined') {
      hiddenPropName = 'webkitHidden';
    } else {
      hiddenPropName = 'hidden';
    }

    var hidden = false;

    var onHidden = function onHidden() {
      if (!hidden) {
        hidden = true;

        _this2.emit('hide');
      }
    };

    var onShown = function onShown(arg0, arg1, arg2, arg3, arg4) {
      if (hidden) {
        hidden = false;

        _this2.emit('show', arg0, arg1, arg2, arg3, arg4);
      }
    };

    if (hiddenPropName) {
      var changeList = ['visibilitychange', 'mozvisibilitychange', 'msvisibilitychange', 'webkitvisibilitychange', 'qbrowserVisibilityChange'];

      for (var i = 0; i < changeList.length; i++) {
        document.addEventListener(changeList[i], function (event) {
          var visible = document[hiddenPropName];
          visible = visible || event.hidden;

          if (visible) {
            onHidden();
          } else {
            onShown();
          }
        });
      }
    } else {
      window.addEventListener('blur', onHidden);
      window.addEventListener('focus', onShown);
    }

    if (window.navigator.userAgent.indexOf('MicroMessenger') > -1) {
      window.onfocus = onShown;
    }

    if ('onpageshow' in window && 'onpagehide' in window) {
      window.addEventListener('pagehide', onHidden);
      window.addEventListener('pageshow', onShown);
      document.addEventListener('pagehide', onHidden);
      document.addEventListener('pageshow', onShown);
    }
  };

  _proto.getBatteryLevel = function getBatteryLevel() {
    if (this._battery) {
      return this._battery.level;
    } else {

      return 1;
    }
  };

  _proto.triggerGC = function triggerGC() {
  };

  _proto.openURL = function openURL(url) {
    window.open(url);
  };

  _proto.now = function now() {
    if (Date.now) {
      return Date.now();
    }

    return +new Date();
  };

  _proto.restartJSVM = function restartJSVM() {
  };

  _proto.close = function close() {
    this.emit('close');
    window.close();
  };

  return SystemInfo;
}(EventTarget);

var systemInfo = new SystemInfo();

var INT_BITS = 32;
var INT_MAX = 0x7fffffff;
var INT_MIN = -1 << INT_BITS - 1;
function sign(v) {
  return (v > 0) - (v < 0);
}
function abs(v) {
  var mask = v >> INT_BITS - 1;
  return (v ^ mask) - mask;
}
function min(x, y) {
  return y ^ (x ^ y) & -(x < y);
}
function max(x, y) {
  return x ^ (x ^ y) & -(x < y);
}
function isPow2(v) {
  return !(v & v - 1) && !!v;
}
function log2(v) {
  var r;
  var shift;
  r = (v > 0xFFFF) << 4;
  v >>>= r;
  shift = (v > 0xFF) << 3;
  v >>>= shift;
  r |= shift;
  shift = (v > 0xF) << 2;
  v >>>= shift;
  r |= shift;
  shift = (v > 0x3) << 1;
  v >>>= shift;
  r |= shift;
  return r | v >> 1;
}
function log10(v) {
  return v >= 1000000000 ? 9 : v >= 100000000 ? 8 : v >= 10000000 ? 7 : v >= 1000000 ? 6 : v >= 100000 ? 5 : v >= 10000 ? 4 : v >= 1000 ? 3 : v >= 100 ? 2 : v >= 10 ? 1 : 0;
}
function popCount(v) {
  v -= v >>> 1 & 0x55555555;
  v = (v & 0x33333333) + (v >>> 2 & 0x33333333);
  return (v + (v >>> 4) & 0xF0F0F0F) * 0x1010101 >>> 24;
}
function countTrailingZeros(v) {
  var c = 32;
  v &= -v;

  if (v) {
    c--;
  }

  if (v & 0x0000FFFF) {
    c -= 16;
  }

  if (v & 0x00FF00FF) {
    c -= 8;
  }

  if (v & 0x0F0F0F0F) {
    c -= 4;
  }

  if (v & 0x33333333) {
    c -= 2;
  }

  if (v & 0x55555555) {
    c -= 1;
  }

  return c;
}
function nextPow2(v) {
  v += v === 0;
  --v;
  v |= v >>> 1;
  v |= v >>> 2;
  v |= v >>> 4;
  v |= v >>> 8;
  v |= v >>> 16;
  return v + 1;
}
function prevPow2(v) {
  v |= v >>> 1;
  v |= v >>> 2;
  v |= v >>> 4;
  v |= v >>> 8;
  v |= v >>> 16;
  return v - (v >>> 1);
}
function parity(v) {
  v ^= v >>> 16;
  v ^= v >>> 8;
  v ^= v >>> 4;
  v &= 0xf;
  return 0x6996 >>> v & 1;
}
var REVERSE_TABLE = new Array(256);

(function (tab) {
  for (var i = 0; i < 256; ++i) {
    var v = i;
    var r = i;
    var s = 7;

    for (v >>>= 1; v; v >>>= 1) {
      r <<= 1;
      r |= v & 1;
      --s;
    }

    tab[i] = r << s & 0xff;
  }
})(REVERSE_TABLE);

function reverse(v) {
  return REVERSE_TABLE[v & 0xff] << 24 | REVERSE_TABLE[v >>> 8 & 0xff] << 16 | REVERSE_TABLE[v >>> 16 & 0xff] << 8 | REVERSE_TABLE[v >>> 24 & 0xff];
}
function interleave2(x, y) {
  x &= 0xFFFF;
  x = (x | x << 8) & 0x00FF00FF;
  x = (x | x << 4) & 0x0F0F0F0F;
  x = (x | x << 2) & 0x33333333;
  x = (x | x << 1) & 0x55555555;
  y &= 0xFFFF;
  y = (y | y << 8) & 0x00FF00FF;
  y = (y | y << 4) & 0x0F0F0F0F;
  y = (y | y << 2) & 0x33333333;
  y = (y | y << 1) & 0x55555555;
  return x | y << 1;
}
function deinterleave2(v, n) {
  v = v >>> n & 0x55555555;
  v = (v | v >>> 1) & 0x33333333;
  v = (v | v >>> 2) & 0x0F0F0F0F;
  v = (v | v >>> 4) & 0x00FF00FF;
  v = (v | v >>> 16) & 0x000FFFF;
  return v << 16 >> 16;
}
function interleave3(x, y, z) {
  x &= 0x3FF;
  x = (x | x << 16) & 4278190335;
  x = (x | x << 8) & 251719695;
  x = (x | x << 4) & 3272356035;
  x = (x | x << 2) & 1227133513;
  y &= 0x3FF;
  y = (y | y << 16) & 4278190335;
  y = (y | y << 8) & 251719695;
  y = (y | y << 4) & 3272356035;
  y = (y | y << 2) & 1227133513;
  x |= y << 1;
  z &= 0x3FF;
  z = (z | z << 16) & 4278190335;
  z = (z | z << 8) & 251719695;
  z = (z | z << 4) & 3272356035;
  z = (z | z << 2) & 1227133513;
  return x | z << 2;
}
function deinterleave3(v, n) {
  v = v >>> n & 1227133513;
  v = (v | v >>> 2) & 3272356035;
  v = (v | v >>> 4) & 251719695;
  v = (v | v >>> 8) & 4278190335;
  v = (v | v >>> 16) & 0x3FF;
  return v << 22 >> 22;
}
function nextCombination(v) {
  var t = v | v - 1;
  return t + 1 | (~t & -~t) - 1 >>> countTrailingZeros(v) + 1;
}

var bits = /*#__PURE__*/Object.freeze({
    __proto__: null,
    INT_BITS: INT_BITS,
    INT_MAX: INT_MAX,
    INT_MIN: INT_MIN,
    sign: sign,
    abs: abs,
    min: min,
    max: max,
    isPow2: isPow2,
    log2: log2,
    log10: log10,
    popCount: popCount,
    countTrailingZeros: countTrailingZeros,
    nextPow2: nextPow2,
    prevPow2: prevPow2,
    parity: parity,
    reverse: reverse,
    interleave2: interleave2,
    deinterleave2: deinterleave2,
    interleave3: interleave3,
    deinterleave3: deinterleave3,
    nextCombination: nextCombination
});

var defaultLogTimes = 10;
function setDefaultLogTimes(times) {
  if (times > 0) {
    defaultLogTimes = times;
  }
}
var replacePropertyLog;
var markAsWarningLog;
var removePropertyLog;
var messageID = 0;
var messageMap = new Map();

replacePropertyLog = function replacePropertyLog(n, dp, n2, newp, f, id, s) {
  var item = messageMap.get(id);

  if (item && item.logTimes > item.count) {
    f("'%s' is deprecated, please use '%s' instead. " + s, n + "." + dp, n2 + "." + newp);
    item.count++;
  }
};

exports.replaceProperty = function replaceProperty(owner, ownerName, properties) {
  if (owner == null) return;
  properties.forEach(function (item) {
    var id = messageID++;
    messageMap.set(id, {
      id: id,
      count: 0,
      logTimes: item.logTimes !== undefined ? item.logTimes : defaultLogTimes
    });
    var target = item.target != null ? item.target : owner;
    var newName = item.newName != null ? item.newName : item.name;
    var targetName = item.targetName != null ? item.targetName : ownerName;
    var sameTarget = target === owner;
    var suggest = item.suggest ? "(" + item.suggest + ")" : '';

    if (item.customFunction != null) {
      owner[item.name] = function () {
        var _ref;

        replacePropertyLog(ownerName, item.name, targetName, newName, warn, id, suggest);
        return (_ref = item.customFunction).call.apply(_ref, [this].concat(Array.prototype.slice.call(arguments)));
      };
    } else if (item.customSetter != null || item.customGetter != null) {
      var hasSetter = item.customSetter != null;
      var hasGetter = item.customGetter != null;

      if (hasSetter && hasGetter) {
        Object.defineProperty(owner, item.name, {
          get: function get() {
            replacePropertyLog(ownerName, item.name, targetName, newName, warn, id, suggest);
            return item.customGetter.call(this);
          },
          set: function set(v) {
            replacePropertyLog(ownerName, item.name, targetName, newName, warn, id, suggest);
            item.customSetter.call(this, v);
          },
          enumerable: false
        });
      } else if (hasSetter) {
        Object.defineProperty(owner, item.name, {
          set: function set(v) {
            replacePropertyLog(ownerName, item.name, targetName, newName, warn, id, suggest);
            item.customSetter.call(this, v);
          },
          enumerable: false
        });
      } else if (hasGetter) {
        Object.defineProperty(owner, item.name, {
          get: function get() {
            replacePropertyLog(ownerName, item.name, targetName, newName, warn, id, suggest);
            return item.customGetter.call(this);
          },
          enumerable: false
        });
      }
    } else {
      Object.defineProperty(owner, item.name, {
        get: function get() {
          replacePropertyLog(ownerName, item.name, targetName, newName, warn, id, suggest);
          return sameTarget ? this[newName] : target[newName];
        },
        set: function set(v) {
          replacePropertyLog(ownerName, item.name, targetName, newName, warn, id, suggest);

          if (sameTarget) {
            this[newName] = v;
          } else {
            target[newName] = v;
          }
        },
        enumerable: false
      });
    }
  });
};

removePropertyLog = function removePropertyLog(n, dp, f, id, s) {
  var item = messageMap.get(id);

  if (item && item.logTimes > item.count) {
    f("'%s' has been removed. " + s, n + "." + dp);
    item.count++;
  }
};

exports.removeProperty = function removeProperty(owner, ownerName, properties) {
  if (owner == null) return;
  properties.forEach(function (item) {
    var id = messageID++;
    messageMap.set(id, {
      id: id,
      count: 0,
      logTimes: item.logTimes !== undefined ? item.logTimes : defaultLogTimes
    });
    var suggest = item.suggest ? "(" + item.suggest + ")" : '';
    Object.defineProperty(owner, item.name, {
      get: function get() {
        return removePropertyLog(ownerName, item.name, error, id, suggest);
      },
      set: function set() {
        removePropertyLog(ownerName, item.name, error, id, suggest);
      },
      enumerable: false
    });
  });
};

markAsWarningLog = function markAsWarningLog(n, dp, f, id, s) {
  var item = messageMap.get(id);

  if (item && item.logTimes > item.count) {
    f("'%s' is deprecated. " + s, n + "." + dp);
    item.count++;
  }
};

exports.markAsWarning = function markAsWarning(owner, ownerName, properties) {
  if (owner == null) return;

  var _defaultGetSet = function _defaultGetSet(d, n, dp, f, id, s) {
    if (d.get) {
      var oldGet = d.get;

      d.get = function () {
        markAsWarningLog(n, dp, f, id, s);
        return oldGet.call(this);
      };
    }

    if (d.set) {
      var oldSet = d.set;

      d.set = function (v) {
        markAsWarningLog(n, dp, f, id, s);
        oldSet.call(this, v);
      };
    }

    Object.defineProperty(owner, dp, d);
  };

  properties.forEach(function (item) {
    var deprecatedProp = item.name;
    var descriptor = Object.getOwnPropertyDescriptor(owner, deprecatedProp);

    if (!descriptor || !descriptor.configurable) {
      return;
    }

    var id = messageID++;
    messageMap.set(id, {
      id: id,
      count: 0,
      logTimes: item.logTimes !== undefined ? item.logTimes : defaultLogTimes
    });
    var suggest = item.suggest ? "(" + item.suggest + ")" : '';

    if (typeof descriptor.value !== 'undefined') {
      if (typeof descriptor.value === 'function') {
        var oldValue = descriptor.value;

        owner[deprecatedProp] = function () {
          markAsWarningLog(ownerName, deprecatedProp, warn, id, suggest);
          return oldValue.call.apply(oldValue, [this].concat(Array.prototype.slice.call(arguments)));
        };
      } else {
        var _oldValue = descriptor.value;
        Object.defineProperty(owner, deprecatedProp, {
          configurable: true,
          get: function get() {
            markAsWarningLog(ownerName, deprecatedProp, warn, id, suggest);
            return _oldValue;
          }
        });

        if (descriptor.writable) {
          Object.defineProperty(owner, deprecatedProp, {
            set: function set(value) {
              markAsWarningLog(ownerName, deprecatedProp, warn, id, suggest);
              _oldValue = value;
            }
          });
        }
      }
    } else {
      _defaultGetSet(descriptor, ownerName, deprecatedProp, warn, id, suggest);
    }

    Object.defineProperty(owner, deprecatedProp, {
      enumerable: false
    });
  });
};

var _d2r = Math.PI / 180.0;

var _r2d = 180.0 / Math.PI;

var EPSILON = 0.000001;
function equals(a, b) {
  return Math.abs(a - b) <= EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));
}
function approx(a, b, maxDiff) {
  maxDiff = maxDiff || EPSILON;
  return Math.abs(a - b) <= maxDiff;
}
function clamp(val, min, max) {
  if (min > max) {
    var temp = min;
    min = max;
    max = temp;
  }

  return val < min ? min : val > max ? max : val;
}
function clamp01(val) {
  return val < 0 ? 0 : val > 1 ? 1 : val;
}
function lerp(from, to, ratio) {
  return from + (to - from) * ratio;
}
function toRadian(a) {
  return a * _d2r;
}
function toDegree(a) {
  return a * _r2d;
}
var random = Math.random;
function randomRange(min, max) {
  return Math.random() * (max - min) + min;
}
function randomRangeInt(min, max) {
  return Math.floor(randomRange(min, max));
}
function pseudoRandom(seed) {
  seed = (seed * 9301 + 49297) % 233280;
  return seed / 233280.0;
}
function pseudoRandomRange(seed, min, max) {
  return pseudoRandom(seed) * (max - min) + min;
}
function pseudoRandomRangeInt(seed, min, max) {
  return Math.floor(pseudoRandomRange(seed, min, max));
}
function nextPow2$1(val) {
  --val;
  val |= val >> 1;
  val |= val >> 2;
  val |= val >> 4;
  val |= val >> 8;
  val |= val >> 16;
  ++val;
  return val;
}
function repeat(t, length) {
  return t - Math.floor(t / length) * length;
}
function pingPong(t, length) {
  t = repeat(t, length * 2);
  t = length - Math.abs(t - length);
  return t;
}
function inverseLerp(from, to, value) {
  return (value - from) / (to - from);
}
function absMaxComponent(v) {
  if (Math.abs(v.x) > Math.abs(v.y)) {
    if (Math.abs(v.x) > Math.abs(v.z)) {
      return v.x;
    } else {
      return v.z;
    }
  } else if (Math.abs(v.y) > Math.abs(v.z)) {
    return v.y;
  } else {
    return v.z;
  }
}
function absMax(a, b) {
  if (Math.abs(a) > Math.abs(b)) {
    return a;
  } else {
    return b;
  }
}
function enumerableProps(prototype, attrs) {
  attrs.forEach(function (key) {
    Object.defineProperty(prototype, key, {
      enumerable: true
    });
  });
}

var toFloat = 1 / 255;
var Color = function (_ValueType) {
  _inheritsLoose(Color, _ValueType);

  Color.clone = function clone(a) {
    var out = new Color();

    if (a._val) {
      out._val = a._val;
    } else {
      out._val = (a.a << 24 >>> 0) + (a.b << 16) + (a.g << 8) + a.r;
    }

    return out;
  };

  Color.copy = function copy(out, a) {
    out.r = a.r;
    out.g = a.g;
    out.b = a.b;
    out.a = a.a;
    return out;
  };

  Color.set = function set(out, r, g, b, a) {
    out.r = r;
    out.g = g;
    out.b = b;
    out.a = a;
    return out;
  };

  Color.fromHEX = function fromHEX(out, hexString) {
    hexString = hexString.indexOf('#') === 0 ? hexString.substring(1) : hexString;
    out.r = parseInt(hexString.substr(0, 2), 16) || 0;
    out.g = parseInt(hexString.substr(2, 2), 16) || 0;
    out.b = parseInt(hexString.substr(4, 2), 16) || 0;
    out.a = parseInt(hexString.substr(6, 2), 16) || 255;
    out._val = (out.a << 24 >>> 0) + (out.b << 16) + (out.g << 8) + out.r;
    return out;
  };

  Color.add = function add(out, a, b) {
    out.r = a.r + b.r;
    out.g = a.g + b.g;
    out.b = a.b + b.b;
    out.a = a.a + b.a;
    return out;
  };

  Color.subtract = function subtract(out, a, b) {
    out.r = a.r - b.r;
    out.g = a.g - b.g;
    out.b = a.b - b.b;
    out.a = a.a - b.a;
    return out;
  };

  Color.multiply = function multiply(out, a, b) {
    out.r = a.r * b.r;
    out.g = a.g * b.g;
    out.b = a.b * b.b;
    out.a = a.a * b.a;
    return out;
  };

  Color.divide = function divide(out, a, b) {
    out.r = a.r / b.r;
    out.g = a.g / b.g;
    out.b = a.b / b.b;
    out.a = a.a / b.a;
    return out;
  };

  Color.scale = function scale(out, a, b) {
    out.r = a.r * b;
    out.g = a.g * b;
    out.b = a.b * b;
    out.a = a.a * b;
    return out;
  };

  Color.lerp = function lerp(out, from, to, ratio) {
    var r = from.r;
    var g = from.g;
    var b = from.b;
    var a = from.a;
    r += (to.r - r) * ratio;
    g += (to.g - g) * ratio;
    b += (to.b - b) * ratio;
    a += (to.a - a) * ratio;
    out._val = Math.floor((a << 24 >>> 0) + (b << 16) + (g << 8) + r);
    return out;
  };

  Color.toArray = function toArray(out, a, ofs) {
    if (ofs === void 0) {
      ofs = 0;
    }

    var scale = a instanceof Color || a.a > 1 ? 1 / 255 : 1;
    out[ofs + 0] = a.r * scale;
    out[ofs + 1] = a.g * scale;
    out[ofs + 2] = a.b * scale;
    out[ofs + 3] = a.a * scale;
    return out;
  };

  Color.fromArray = function fromArray(arr, out, ofs) {
    if (ofs === void 0) {
      ofs = 0;
    }

    out.r = arr[ofs + 0] * 255;
    out.g = arr[ofs + 1] * 255;
    out.b = arr[ofs + 2] * 255;
    out.a = arr[ofs + 3] * 255;
    return out;
  };

  Color.strictEquals = function strictEquals(a, b) {
    return a.r === b.r && a.g === b.g && a.b === b.b && a.a === b.a;
  };

  Color.equals = function equals(a, b, epsilon) {
    if (epsilon === void 0) {
      epsilon = EPSILON;
    }

    return Math.abs(a.r - b.r) <= epsilon * Math.max(1.0, Math.abs(a.r), Math.abs(b.r)) && Math.abs(a.g - b.g) <= epsilon * Math.max(1.0, Math.abs(a.g), Math.abs(b.g)) && Math.abs(a.b - b.b) <= epsilon * Math.max(1.0, Math.abs(a.b), Math.abs(b.b)) && Math.abs(a.a - b.a) <= epsilon * Math.max(1.0, Math.abs(a.a), Math.abs(b.a));
  };

  Color.hex = function hex(a) {
    return (a.r * 255 << 24 | a.g * 255 << 16 | a.b * 255 << 8 | a.a * 255) >>> 0;
  };

  _createClass(Color, [{
    key: "r",
    get: function get() {
      return this._val & 0x000000ff;
    },
    set: function set(red) {
      red = ~~clamp(red, 0, 255);
      this._val = (this._val & 0xffffff00 | red) >>> 0;
    }
  }, {
    key: "g",
    get: function get() {
      return (this._val & 0x0000ff00) >> 8;
    },
    set: function set(green) {
      green = ~~clamp(green, 0, 255);
      this._val = (this._val & 0xffff00ff | green << 8) >>> 0;
    }
  }, {
    key: "b",
    get: function get() {
      return (this._val & 0x00ff0000) >> 16;
    },
    set: function set(blue) {
      blue = ~~clamp(blue, 0, 255);
      this._val = (this._val & 0xff00ffff | blue << 16) >>> 0;
    }
  }, {
    key: "a",
    get: function get() {
      return (this._val & 0xff000000) >>> 24;
    },
    set: function set(alpha) {
      alpha = ~~clamp(alpha, 0, 255);
      this._val = (this._val & 0x00ffffff | alpha << 24) >>> 0;
    }
  }, {
    key: "x",
    get: function get() {
      return this.r * toFloat;
    },
    set: function set(value) {
      this.r = value * 255;
    }
  }, {
    key: "y",
    get: function get() {
      return this.g * toFloat;
    },
    set: function set(value) {
      this.g = value * 255;
    }
  }, {
    key: "z",
    get: function get() {
      return this.b * toFloat;
    },
    set: function set(value) {
      this.b = value * 255;
    }
  }, {
    key: "w",
    get: function get() {
      return this.a * toFloat;
    },
    set: function set(value) {
      this.a = value * 255;
    }
  }]);

  function Color(r, g, b, a) {
    var _this;

    _this = _ValueType.call(this) || this;
    _this._val = 0;

    if (typeof r === 'string') {
      _this.fromHEX(r);
    } else if (g !== undefined) {
      _this.set(r, g, b, a);
    } else {
      _this.set(r);
    }

    return _this;
  }

  var _proto = Color.prototype;

  _proto.clone = function clone() {
    var ret = new Color();
    ret._val = this._val;
    return ret;
  };

  _proto.equals = function equals(other) {
    return other && this._val === other._val;
  };

  _proto.lerp = function lerp(to, ratio) {
    var r = this.r;
    var g = this.g;
    var b = this.b;
    var a = this.a;
    r += (to.r - r) * ratio;
    g += (to.g - g) * ratio;
    b += (to.b - b) * ratio;
    a += (to.a - a) * ratio;
    this._val = Math.floor((a << 24 >>> 0) + (b << 16) + (g << 8) + r);
    return this;
  };

  _proto.toString = function toString() {
    return "rgba(" + this.r.toFixed() + ", " + this.g.toFixed() + ", " + this.b.toFixed() + ", " + this.a.toFixed() + ")";
  };

  _proto.toCSS = function toCSS(opt) {
    if (opt === void 0) {
      opt = 'rgba';
    }

    if (opt === 'rgba') {
      return "rgba(" + this.r + "," + this.g + "," + this.b + "," + (this.a * toFloat).toFixed(2) + ")";
    } else if (opt === 'rgb') {
      return "rgb(" + this.r + "," + this.g + "," + this.b + ")";
    } else {
      return "#" + this.toHEX(opt);
    }
  };

  _proto.fromHEX = function fromHEX(hexString) {
    hexString = hexString.indexOf('#') === 0 ? hexString.substring(1) : hexString;
    var r = parseInt(hexString.substr(0, 2), 16) || 0;
    var g = parseInt(hexString.substr(2, 2), 16) || 0;
    var b = parseInt(hexString.substr(4, 2), 16) || 0;
    var a = parseInt(hexString.substr(6, 2), 16) || 255;
    this._val = (a << 24 >>> 0) + (b << 16) + (g << 8) + (r | 0);
    return this;
  };

  _proto.toHEX = function toHEX(fmt) {
    if (fmt === void 0) {
      fmt = '#rrggbb';
    }

    var prefix = '0';
    var hex = [(this.r < 16 ? prefix : '') + this.r.toString(16), (this.g < 16 ? prefix : '') + this.g.toString(16), (this.b < 16 ? prefix : '') + this.b.toString(16)];

    if (fmt === '#rgb') {
      hex[0] = hex[0][0];
      hex[1] = hex[1][0];
      hex[2] = hex[2][0];
    } else if (fmt === '#rrggbbaa') {
      hex.push((this.a < 16 ? prefix : '') + this.a.toString(16));
    }

    return hex.join('');
  };

  _proto.toRGBValue = function toRGBValue() {
    return this._val & 0x00ffffff;
  };

  _proto.fromHSV = function fromHSV(h, s, v) {
    var r = 0;
    var g = 0;
    var b = 0;

    if (s === 0) {
      r = g = b = v;
    } else if (v === 0) {
      r = g = b = 0;
    } else {
      if (h === 1) {
        h = 0;
      }

      h *= 6;
      var i = Math.floor(h);
      var f = h - i;
      var p = v * (1 - s);
      var q = v * (1 - s * f);
      var t = v * (1 - s * (1 - f));

      switch (i) {
        case 0:
          r = v;
          g = t;
          b = p;
          break;

        case 1:
          r = q;
          g = v;
          b = p;
          break;

        case 2:
          r = p;
          g = v;
          b = t;
          break;

        case 3:
          r = p;
          g = q;
          b = v;
          break;

        case 4:
          r = t;
          g = p;
          b = v;
          break;

        case 5:
          r = v;
          g = p;
          b = q;
          break;
      }
    }

    r *= 255;
    g *= 255;
    b *= 255;
    this._val = (this.a << 24 >>> 0) + (b << 16) + (g << 8) + (r | 0);
    return this;
  };

  _proto.toHSV = function toHSV() {
    var r = this.r * toFloat;
    var g = this.g * toFloat;
    var b = this.b * toFloat;
    var hsv = {
      h: 0,
      s: 0,
      v: 0
    };
    var max = Math.max(r, g, b);
    var min = Math.min(r, g, b);
    var delta = 0;
    hsv.v = max;
    hsv.s = max ? (max - min) / max : 0;

    if (!hsv.s) {
      hsv.h = 0;
    } else {
      delta = max - min;

      if (r === max) {
        hsv.h = (g - b) / delta;
      } else if (g === max) {
        hsv.h = 2 + (b - r) / delta;
      } else {
        hsv.h = 4 + (r - g) / delta;
      }

      hsv.h /= 6;

      if (hsv.h < 0) {
        hsv.h += 1.0;
      }
    }

    return hsv;
  };

  _proto.set = function set(r, g, b, a) {
    if (typeof r === 'object') {
      if (r._val != null) {
        this._val = r._val;
      } else {
        g = r.g || 0;
        b = r.b || 0;
        a = typeof r.a === 'number' ? r.a : 255;
        r = r.r || 0;
        this._val = (a << 24 >>> 0) + (b << 16) + (g << 8) + (r | 0);
      }
    } else {
      r = r || 0;
      g = g || 0;
      b = b || 0;
      a = typeof a === 'number' ? a : 255;
      this._val = (a << 24 >>> 0) + (b << 16) + (g << 8) + (r | 0);
    }

    return this;
  };

  _proto.multiply = function multiply(other) {
    var r = (this._val & 0x000000ff) * other.r >> 8;
    var g = (this._val & 0x0000ff00) * other.g >> 8;
    var b = (this._val & 0x00ff0000) * other.b >> 8;
    var a = ((this._val & 0xff000000) >>> 8) * other.a;
    this._val = a & 0xff000000 | b & 0x00ff0000 | g & 0x0000ff00 | r & 0x000000ff;
    return this;
  };

  _proto._set_r_unsafe = function _set_r_unsafe(red) {
    this._val = (this._val & 0xffffff00 | red) >>> 0;
    return this;
  };

  _proto._set_g_unsafe = function _set_g_unsafe(green) {
    this._val = (this._val & 0xffff00ff | green << 8) >>> 0;
    return this;
  };

  _proto._set_b_unsafe = function _set_b_unsafe(blue) {
    this._val = (this._val & 0xff00ffff | blue << 16) >>> 0;
    return this;
  };

  _proto._set_a_unsafe = function _set_a_unsafe(alpha) {
    this._val = (this._val & 0x00ffffff | alpha << 24) >>> 0;
    return this;
  };

  return Color;
}(ValueType);
Color.WHITE = Object.freeze(new Color(255, 255, 255, 255));
Color.GRAY = Object.freeze(new Color(127, 127, 127, 255));
Color.BLACK = Object.freeze(new Color(0, 0, 0, 255));
Color.TRANSPARENT = Object.freeze(new Color(0, 0, 0, 0));
Color.RED = Object.freeze(new Color(255, 0, 0, 255));
Color.GREEN = Object.freeze(new Color(0, 255, 0, 255));
Color.BLUE = Object.freeze(new Color(0, 0, 255, 255));
Color.CYAN = Object.freeze(new Color(0, 255, 255, 255));
Color.MAGENTA = Object.freeze(new Color(255, 0, 255, 255));
Color.YELLOW = Object.freeze(new Color(255, 255, 0, 255));
enumerableProps(Color.prototype, ['r', 'g', 'b', 'a', 'x', 'y', 'z', 'w']);
CCClass.fastDefine('cc.Color', Color, {
  r: 0,
  g: 0,
  b: 0,
  a: 255
});
legacyCC.Color = Color;
function color(r, g, b, a) {
  return new Color(r, g, b, a);
}
legacyCC.color = color;

var MATH_FLOAT_ARRAY =  Float64Array;
var MathBase = function (_ValueType) {
  _inheritsLoose(MathBase, _ValueType);

  function MathBase() {
    return _ValueType.apply(this, arguments) || this;
  }

  MathBase.createFloatArray = function createFloatArray(size) {
    return new MATH_FLOAT_ARRAY(size);
  };

  _createClass(MathBase, [{
    key: "array",
    get: function get() {
      return this._array;
    }
  }]);

  return MathBase;
}(ValueType);

var Vec3 = function (_MathBase) {
  _inheritsLoose(Vec3, _MathBase);

  Vec3.zero = function zero(out) {
    out.x = 0;
    out.y = 0;
    out.z = 0;
    return out;
  };

  Vec3.clone = function clone(a) {
    return new Vec3(a.x, a.y, a.z);
  };

  Vec3.copy = function copy(out, a) {
    out.x = a.x;
    out.y = a.y;
    out.z = a.z;
    return out;
  };

  Vec3.set = function set(out, x, y, z) {
    out.x = x;
    out.y = y;
    out.z = z;
    return out;
  };

  Vec3.add = function add(out, a, b) {
    out.x = a.x + b.x;
    out.y = a.y + b.y;
    out.z = a.z + b.z;
    return out;
  };

  Vec3.subtract = function subtract(out, a, b) {
    out.x = a.x - b.x;
    out.y = a.y - b.y;
    out.z = a.z - b.z;
    return out;
  };

  Vec3.multiply = function multiply(out, a, b) {
    out.x = a.x * b.x;
    out.y = a.y * b.y;
    out.z = a.z * b.z;
    return out;
  };

  Vec3.divide = function divide(out, a, b) {
    out.x = a.x / b.x;
    out.y = a.y / b.y;
    out.z = a.z / b.z;
    return out;
  };

  Vec3.ceil = function ceil(out, a) {
    out.x = Math.ceil(a.x);
    out.y = Math.ceil(a.y);
    out.z = Math.ceil(a.z);
    return out;
  };

  Vec3.floor = function floor(out, a) {
    out.x = Math.floor(a.x);
    out.y = Math.floor(a.y);
    out.z = Math.floor(a.z);
    return out;
  };

  Vec3.min = function min(out, a, b) {
    out.x = Math.min(a.x, b.x);
    out.y = Math.min(a.y, b.y);
    out.z = Math.min(a.z, b.z);
    return out;
  };

  Vec3.max = function max(out, a, b) {
    out.x = Math.max(a.x, b.x);
    out.y = Math.max(a.y, b.y);
    out.z = Math.max(a.z, b.z);
    return out;
  };

  Vec3.round = function round(out, a) {
    out.x = Math.round(a.x);
    out.y = Math.round(a.y);
    out.z = Math.round(a.z);
    return out;
  };

  Vec3.multiplyScalar = function multiplyScalar(out, a, b) {
    out.x = a.x * b;
    out.y = a.y * b;
    out.z = a.z * b;
    return out;
  };

  Vec3.scaleAndAdd = function scaleAndAdd(out, a, b, scale) {
    out.x = a.x + b.x * scale;
    out.y = a.y + b.y * scale;
    out.z = a.z + b.z * scale;
    return out;
  };

  Vec3.distance = function distance(a, b) {
    var x = b.x - a.x;
    var y = b.y - a.y;
    var z = b.z - a.z;
    return Math.sqrt(x * x + y * y + z * z);
  };

  Vec3.squaredDistance = function squaredDistance(a, b) {
    var x = b.x - a.x;
    var y = b.y - a.y;
    var z = b.z - a.z;
    return x * x + y * y + z * z;
  };

  Vec3.len = function len(a) {
    var x = a.x;
    var y = a.y;
    var z = a.z;
    return Math.sqrt(x * x + y * y + z * z);
  };

  Vec3.lengthSqr = function lengthSqr(a) {
    var x = a.x;
    var y = a.y;
    var z = a.z;
    return x * x + y * y + z * z;
  };

  Vec3.negate = function negate(out, a) {
    out.x = -a.x;
    out.y = -a.y;
    out.z = -a.z;
    return out;
  };

  Vec3.invert = function invert(out, a) {
    out.x = 1.0 / a.x;
    out.y = 1.0 / a.y;
    out.z = 1.0 / a.z;
    return out;
  };

  Vec3.invertSafe = function invertSafe(out, a) {
    var x = a.x;
    var y = a.y;
    var z = a.z;

    if (Math.abs(x) < EPSILON) {
      out.x = 0;
    } else {
      out.x = 1.0 / x;
    }

    if (Math.abs(y) < EPSILON) {
      out.y = 0;
    } else {
      out.y = 1.0 / y;
    }

    if (Math.abs(z) < EPSILON) {
      out.z = 0;
    } else {
      out.z = 1.0 / z;
    }

    return out;
  };

  Vec3.normalize = function normalize(out, a) {
    var x = a.x;
    var y = a.y;
    var z = a.z;
    var len = x * x + y * y + z * z;

    if (len > 0) {
      len = 1 / Math.sqrt(len);
      out.x = x * len;
      out.y = y * len;
      out.z = z * len;
    }

    return out;
  };

  Vec3.dot = function dot(a, b) {
    return a.x * b.x + a.y * b.y + a.z * b.z;
  };

  Vec3.cross = function cross(out, a, b) {
    var ax = a.x,
        ay = a.y,
        az = a.z;
    var bx = b.x,
        by = b.y,
        bz = b.z;
    out.x = ay * bz - az * by;
    out.y = az * bx - ax * bz;
    out.z = ax * by - ay * bx;
    return out;
  };

  Vec3.lerp = function lerp(out, a, b, t) {
    out.x = a.x + t * (b.x - a.x);
    out.y = a.y + t * (b.y - a.y);
    out.z = a.z + t * (b.z - a.z);
    return out;
  };

  Vec3.random = function random$1(out, scale) {
    scale = scale || 1.0;
    var phi = random() * 2.0 * Math.PI;
    var cosTheta = random() * 2 - 1;
    var sinTheta = Math.sqrt(1 - cosTheta * cosTheta);
    out.x = sinTheta * Math.cos(phi) * scale;
    out.y = sinTheta * Math.sin(phi) * scale;
    out.z = cosTheta * scale;
    return out;
  };

  Vec3.transformMat4 = function transformMat4(out, a, m) {
    var x = a.x;
    var y = a.y;
    var z = a.z;
    var rhw = m.m03 * x + m.m07 * y + m.m11 * z + m.m15;
    rhw = rhw ? Math.abs(1 / rhw) : 1;
    out.x = (m.m00 * x + m.m04 * y + m.m08 * z + m.m12) * rhw;
    out.y = (m.m01 * x + m.m05 * y + m.m09 * z + m.m13) * rhw;
    out.z = (m.m02 * x + m.m06 * y + m.m10 * z + m.m14) * rhw;
    return out;
  };

  Vec3.transformMat4Normal = function transformMat4Normal(out, a, m) {
    var x = a.x;
    var y = a.y;
    var z = a.z;
    var rhw = m.m03 * x + m.m07 * y + m.m11 * z;
    rhw = rhw ? Math.abs(1 / rhw) : 1;
    out.x = (m.m00 * x + m.m04 * y + m.m08 * z) * rhw;
    out.y = (m.m01 * x + m.m05 * y + m.m09 * z) * rhw;
    out.z = (m.m02 * x + m.m06 * y + m.m10 * z) * rhw;
    return out;
  };

  Vec3.transformMat3 = function transformMat3(out, a, m) {
    var x = a.x;
    var y = a.y;
    var z = a.z;
    out.x = x * m.m00 + y * m.m03 + z * m.m06;
    out.y = x * m.m01 + y * m.m04 + z * m.m07;
    out.z = x * m.m02 + y * m.m05 + z * m.m08;
    return out;
  };

  Vec3.transformAffine = function transformAffine(out, v, m) {
    var x = v.x;
    var y = v.y;
    var z = v.z;
    out.x = m.m00 * x + m.m04 * y + m.m08 * z + m.m12;
    out.y = m.m01 * x + m.m05 * y + m.m09 * z + m.m13;
    out.x = m.m02 * x + m.m06 * y + m.m10 * z + m.m14;
    return out;
  };

  Vec3.transformQuat = function transformQuat(out, a, q) {
    var ix = q.w * a.x + q.y * a.z - q.z * a.y;
    var iy = q.w * a.y + q.z * a.x - q.x * a.z;
    var iz = q.w * a.z + q.x * a.y - q.y * a.x;
    var iw = -q.x * a.x - q.y * a.y - q.z * a.z;
    out.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;
    out.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;
    out.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;
    return out;
  };

  Vec3.transformRTS = function transformRTS(out, a, r, t, s) {
    var x = a.x * s.x;
    var y = a.y * s.y;
    var z = a.z * s.z;
    var ix = r.w * x + r.y * z - r.z * y;
    var iy = r.w * y + r.z * x - r.x * z;
    var iz = r.w * z + r.x * y - r.y * x;
    var iw = -r.x * x - r.y * y - r.z * z;
    out.x = ix * r.w + iw * -r.x + iy * -r.z - iz * -r.y + t.x;
    out.y = iy * r.w + iw * -r.y + iz * -r.x - ix * -r.z + t.y;
    out.z = iz * r.w + iw * -r.z + ix * -r.y - iy * -r.x + t.z;
    return out;
  };

  Vec3.transformInverseRTS = function transformInverseRTS(out, a, r, t, s) {
    var x = a.x - t.x;
    var y = a.y - t.y;
    var z = a.z - t.z;
    var ix = r.w * x - r.y * z + r.z * y;
    var iy = r.w * y - r.z * x + r.x * z;
    var iz = r.w * z - r.x * y + r.y * x;
    var iw = r.x * x + r.y * y + r.z * z;
    out.x = (ix * r.w + iw * r.x + iy * r.z - iz * r.y) / s.x;
    out.y = (iy * r.w + iw * r.y + iz * r.x - ix * r.z) / s.y;
    out.z = (iz * r.w + iw * r.z + ix * r.y - iy * r.x) / s.z;
    return out;
  };

  Vec3.rotateX = function rotateX(out, v, o, a) {
    var x = v.x - o.x;
    var y = v.y - o.y;
    var z = v.z - o.z;
    var cos = Math.cos(a);
    var sin = Math.sin(a);
    var rx = x;
    var ry = y * cos - z * sin;
    var rz = y * sin + z * cos;
    out.x = rx + o.x;
    out.y = ry + o.y;
    out.z = rz + o.z;
    return out;
  };

  Vec3.rotateY = function rotateY(out, v, o, a) {
    var x = v.x - o.x;
    var y = v.y - o.y;
    var z = v.z - o.z;
    var cos = Math.cos(a);
    var sin = Math.sin(a);
    var rx = z * sin + x * cos;
    var ry = y;
    var rz = z * cos - x * sin;
    out.x = rx + o.x;
    out.y = ry + o.y;
    out.z = rz + o.z;
    return out;
  };

  Vec3.rotateZ = function rotateZ(out, v, o, a) {
    var x = v.x - o.x;
    var y = v.y - o.y;
    var z = v.z - o.z;
    var cos = Math.cos(a);
    var sin = Math.sin(a);
    var rx = x * cos - y * sin;
    var ry = x * sin + y * cos;
    var rz = z;
    out.x = rx + o.x;
    out.y = ry + o.y;
    out.z = rz + o.z;
    return out;
  };

  Vec3.toArray = function toArray(out, v, ofs) {
    if (ofs === void 0) {
      ofs = 0;
    }

    out[ofs + 0] = v.x;
    out[ofs + 1] = v.y;
    out[ofs + 2] = v.z;
    return out;
  };

  Vec3.fromArray = function fromArray(out, arr, ofs) {
    if (ofs === void 0) {
      ofs = 0;
    }

    out.x = arr[ofs + 0];
    out.y = arr[ofs + 1];
    out.z = arr[ofs + 2];
    return out;
  };

  Vec3.strictEquals = function strictEquals(a, b) {
    return a.x === b.x && a.y === b.y && a.z === b.z;
  };

  Vec3.equals = function equals(a, b, epsilon) {
    if (epsilon === void 0) {
      epsilon = EPSILON;
    }

    var a0 = a.x,
        a1 = a.y,
        a2 = a.z;
    var b0 = b.x,
        b1 = b.y,
        b2 = b.z;
    return Math.abs(a0 - b0) <= epsilon * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= epsilon * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= epsilon * Math.max(1.0, Math.abs(a2), Math.abs(b2));
  };

  Vec3.angle = function angle(a, b) {
    Vec3.normalize(v3_1, a);
    Vec3.normalize(v3_2, b);
    var cosine = Vec3.dot(v3_1, v3_2);

    if (cosine > 1.0) {
      return 0;
    }

    if (cosine < -1.0) {
      return Math.PI;
    }

    return Math.acos(cosine);
  };

  Vec3.projectOnPlane = function projectOnPlane(out, a, n) {
    return Vec3.subtract(out, a, Vec3.project(out, a, n));
  };

  Vec3.project = function project(out, a, b) {
    var sqrLen = Vec3.lengthSqr(b);

    if (sqrLen < 0.000001) {
      return Vec3.set(out, 0, 0, 0);
    } else {
      return Vec3.multiplyScalar(out, b, Vec3.dot(a, b) / sqrLen);
    }
  };

  _createClass(Vec3, [{
    key: "x",
    get: function get() {
      return this._array[0];
    },
    set: function set(x) {
      this._array[0] = x;
    }
  }, {
    key: "y",
    get: function get() {
      return this._array[1];
    },
    set: function set(y) {
      this._array[1] = y;
    }
  }, {
    key: "z",
    get: function get() {
      return this._array[2];
    },
    set: function set(z) {
      this._array[2] = z;
    }
  }]);

  function Vec3(x, y, z) {
    var _this;

    _this = _MathBase.call(this) || this;

    if (x && typeof x === 'object') {
      if (ArrayBuffer.isView(x)) {
        _this._array = x;

        _this._array.fill(0);
      } else {
        var v = x.array;
        _this._array = MathBase.createFloatArray(3);
        _this._array[0] = v[0];
        _this._array[1] = v[1];
        _this._array[2] = v[2];
      }
    } else {
      _this._array = MathBase.createFloatArray(3);
      _this._array[0] = x || 0;
      _this._array[1] = y || 0;
      _this._array[2] = z || 0;
    }

    return _this;
  }

  var _proto = Vec3.prototype;

  _proto.clone = function clone() {
    return new Vec3(this._array[0], this._array[1], this._array[2]);
  };

  _proto.set = function set(x, y, z) {
    if (x && typeof x === 'object') {
      this._array[0] = x.x;
      this._array[1] = x.y;
      this._array[2] = x.z;
    } else {
      this._array[0] = x || 0;
      this._array[1] = y || 0;
      this._array[2] = z || 0;
    }

    return this;
  };

  _proto.equals = function equals(other, epsilon) {
    if (epsilon === void 0) {
      epsilon = EPSILON;
    }

    var v = other.array;
    return Math.abs(this._array[0] - v[0]) <= epsilon * Math.max(1.0, Math.abs(this._array[0]), Math.abs(v[0])) && Math.abs(this._array[1] - v[1]) <= epsilon * Math.max(1.0, Math.abs(this._array[1]), Math.abs(v[1])) && Math.abs(this._array[2] - v[2]) <= epsilon * Math.max(1.0, Math.abs(this._array[2]), Math.abs(v[2]));
  };

  _proto.equals3f = function equals3f(x, y, z, epsilon) {
    if (epsilon === void 0) {
      epsilon = EPSILON;
    }

    return Math.abs(this._array[0] - x) <= epsilon * Math.max(1.0, Math.abs(this._array[0]), Math.abs(x)) && Math.abs(this._array[1] - y) <= epsilon * Math.max(1.0, Math.abs(this._array[1]), Math.abs(y)) && Math.abs(this._array[2] - z) <= epsilon * Math.max(1.0, Math.abs(this._array[2]), Math.abs(z));
  };

  _proto.strictEquals = function strictEquals(other) {
    var v = other.array;
    return this._array[0] === v[0] && this._array[1] === v[1] && this._array[2] === v[2];
  };

  _proto.strictEquals3f = function strictEquals3f(x, y, z) {
    return this._array[0] === x && this._array[1] === y && this._array[2] === z;
  };

  _proto.toString = function toString() {
    return "(" + this._array[0].toFixed(2) + ", " + this._array[1].toFixed(2) + ", " + this._array[2].toFixed(2) + ")";
  };

  _proto.lerp = function lerp(to, ratio) {
    this._array[0] += ratio * (to.x - this._array[0]);
    this._array[1] += ratio * (to.y - this._array[1]);
    this._array[2] += ratio * (to.z - this._array[2]);
    return this;
  };

  _proto.add = function add(other) {
    var v = other.array;
    this._array[0] += v[0];
    this._array[1] += v[1];
    this._array[2] += v[2];
    return this;
  };

  _proto.add3f = function add3f(x, y, z) {
    this._array[0] += x;
    this._array[1] += y;
    this._array[2] += z;
    return this;
  };

  _proto.subtract = function subtract(other) {
    var v = other.array;
    this._array[0] -= v[0];
    this._array[1] -= v[1];
    this._array[2] -= v[2];
    return this;
  };

  _proto.subtract3f = function subtract3f(x, y, z) {
    this._array[0] -= x;
    this._array[1] -= y;
    this._array[2] -= z;
    return this;
  };

  _proto.multiplyScalar = function multiplyScalar(scalar) {
    if (typeof scalar === 'object') {
      console.warn('should use Vec3.multiply for vector * vector operation');
    }

    this._array[0] *= scalar;
    this._array[1] *= scalar;
    this._array[2] *= scalar;
    return this;
  };

  _proto.multiply = function multiply(other) {
    if (typeof other !== 'object') {
      console.warn('should use Vec3.scale for vector * scalar operation');
    }

    var v = other.array;
    this._array[0] *= v[0];
    this._array[1] *= v[1];
    this._array[2] *= v[2];
    return this;
  };

  _proto.multiply3f = function multiply3f(x, y, z) {
    this._array[0] *= x;
    this._array[1] *= y;
    this._array[2] *= z;
    return this;
  };

  _proto.divide = function divide(other) {
    var v = other.array;
    this._array[0] /= v[0];
    this._array[1] /= v[1];
    this._array[2] /= v[2];
    return this;
  };

  _proto.divide3f = function divide3f(x, y, z) {
    this._array[0] /= x;
    this._array[1] /= y;
    this._array[2] /= z;
    return this;
  };

  _proto.negative = function negative() {
    this._array[0] = -this._array[0];
    this._array[1] = -this._array[1];
    this._array[2] = -this._array[2];
    return this;
  };

  _proto.clampf = function clampf(minInclusive, maxInclusive) {
    var min = minInclusive.array;
    var max = maxInclusive.array;
    this._array[0] = clamp(this._array[0], min[0], max[0]);
    this._array[1] = clamp(this._array[1], min[1], max[1]);
    this._array[2] = clamp(this._array[2], min[2], max[2]);
    return this;
  };

  _proto.dot = function dot(other) {
    var v = other.array;
    return this._array[0] * v[0] + this._array[1] * v[1] + this._array[2] * v[2];
  };

  _proto.cross = function cross(other) {
    var ax = this._array[0];
    var ay = this._array[1];
    var az = this._array[2];
    var bx = other.array[0];
    var by = other.array[1];
    var bz = other.array[2];
    this._array[0] = ay * bz - az * by;
    this._array[1] = az * bx - ax * bz;
    this._array[2] = ax * by - ay * bx;
    return this;
  };

  _proto.length = function length() {
    return Math.sqrt(this._array[0] * this._array[0] + this._array[1] * this._array[1] + this._array[2] * this._array[2]);
  };

  _proto.lengthSqr = function lengthSqr() {
    return this._array[0] * this._array[0] + this._array[1] * this._array[1] + this._array[2] * this._array[2];
  };

  _proto.normalize = function normalize() {
    var x = this._array[0];
    var y = this._array[1];
    var z = this._array[2];
    var len = x * x + y * y + z * z;

    if (len > 0) {
      len = 1 / Math.sqrt(len);
      this._array[0] = x * len;
      this._array[1] = y * len;
      this._array[2] = z * len;
    }

    return this;
  };

  _proto.transformMat4 = function transformMat4(matrix) {
    var x = this._array[0];
    var y = this._array[1];
    var z = this._array[2];
    var v = matrix.array;
    var rhw = v[3] * x + v[7] * y + v[11] * z + v[15];
    rhw = rhw ? 1 / rhw : 1;
    this._array[0] = (v[0] * x + v[4] * y + v[8] * z + v[12]) * rhw;
    this._array[1] = (v[1] * x + v[5] * y + v[9] * z + v[13]) * rhw;
    this._array[2] = (v[2] * x + v[6] * y + v[10] * z + v[14]) * rhw;
    return this;
  };

  return Vec3;
}(MathBase);
Vec3.UNIT_X = Object.freeze(new Vec3(1, 0, 0));
Vec3.UNIT_Y = Object.freeze(new Vec3(0, 1, 0));
Vec3.UNIT_Z = Object.freeze(new Vec3(0, 0, 1));
Vec3.RIGHT = Object.freeze(new Vec3(1, 0, 0));
Vec3.UP = Object.freeze(new Vec3(0, 1, 0));
Vec3.FORWARD = Object.freeze(new Vec3(0, 0, -1));
Vec3.ZERO = Object.freeze(new Vec3(0, 0, 0));
Vec3.ONE = Object.freeze(new Vec3(1, 1, 1));
Vec3.NEG_ONE = Object.freeze(new Vec3(-1, -1, -1));
var v3_1 = new Vec3();
var v3_2 = new Vec3();
enumerableProps(Vec3.prototype, ['x', 'y', 'z']);
CCClass.fastDefine('cc.Vec3', Vec3, {
  x: 0,
  y: 0,
  z: 0
});
legacyCC.Vec3 = Vec3;
function v3(x, y, z) {
  return new Vec3(x, y, z);
}
legacyCC.v3 = v3;

var Mat3 = function (_MathBase) {
  _inheritsLoose(Mat3, _MathBase);

  Mat3.clone = function clone(a) {
    return new Mat3(a.m00, a.m01, a.m02, a.m03, a.m04, a.m05, a.m06, a.m07, a.m08);
  };

  Mat3.copy = function copy(out, a) {
    out.m00 = a.m00;
    out.m01 = a.m01;
    out.m02 = a.m02;
    out.m03 = a.m03;
    out.m04 = a.m04;
    out.m05 = a.m05;
    out.m06 = a.m06;
    out.m07 = a.m07;
    out.m08 = a.m08;
    return out;
  };

  Mat3.set = function set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
    out.m00 = m00;
    out.m01 = m01;
    out.m02 = m02;
    out.m03 = m10;
    out.m04 = m11;
    out.m05 = m12;
    out.m06 = m20;
    out.m07 = m21;
    out.m08 = m22;
    return out;
  };

  Mat3.identity = function identity(out) {
    out.m00 = 1;
    out.m01 = 0;
    out.m02 = 0;
    out.m03 = 0;
    out.m04 = 1;
    out.m05 = 0;
    out.m06 = 0;
    out.m07 = 0;
    out.m08 = 1;
    return out;
  };

  Mat3.transpose = function transpose(out, a) {
    if (out === a) {
      var a01 = a.m01;
      var a02 = a.m02;
      var a12 = a.m05;
      out.m01 = a.m03;
      out.m02 = a.m06;
      out.m03 = a01;
      out.m05 = a.m07;
      out.m06 = a02;
      out.m07 = a12;
    } else {
      out.m00 = a.m00;
      out.m01 = a.m03;
      out.m02 = a.m06;
      out.m03 = a.m01;
      out.m04 = a.m04;
      out.m05 = a.m07;
      out.m06 = a.m02;
      out.m07 = a.m05;
      out.m08 = a.m08;
    }

    return out;
  };

  Mat3.invert = function invert(out, a) {
    var a00 = a.m00;
    var a01 = a.m01;
    var a02 = a.m02;
    var a10 = a.m03;
    var a11 = a.m04;
    var a12 = a.m05;
    var a20 = a.m06;
    var a21 = a.m07;
    var a22 = a.m08;
    var b01 = a22 * a11 - a12 * a21;
    var b11 = -a22 * a10 + a12 * a20;
    var b21 = a21 * a10 - a11 * a20;
    var det = a00 * b01 + a01 * b11 + a02 * b21;

    if (det === 0) {
      out.m00 = 0;
      out.m01 = 0;
      out.m02 = 0;
      out.m03 = 0;
      out.m04 = 0;
      out.m05 = 0;
      out.m06 = 0;
      out.m07 = 0;
      out.m08 = 0;
      return out;
    }

    det = 1.0 / det;
    out.m00 = b01 * det;
    out.m01 = (-a22 * a01 + a02 * a21) * det;
    out.m02 = (a12 * a01 - a02 * a11) * det;
    out.m03 = b11 * det;
    out.m04 = (a22 * a00 - a02 * a20) * det;
    out.m05 = (-a12 * a00 + a02 * a10) * det;
    out.m06 = b21 * det;
    out.m07 = (-a21 * a00 + a01 * a20) * det;
    out.m08 = (a11 * a00 - a01 * a10) * det;
    return out;
  };

  Mat3.determinant = function determinant(a) {
    var a00 = a.m00;
    var a01 = a.m01;
    var a02 = a.m02;
    var a10 = a.m03;
    var a11 = a.m04;
    var a12 = a.m05;
    var a20 = a.m06;
    var a21 = a.m07;
    var a22 = a.m08;
    return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
  };

  Mat3.multiply = function multiply(out, a, b) {
    var a00 = a.m00;
    var a01 = a.m01;
    var a02 = a.m02;
    var a10 = a.m03;
    var a11 = a.m04;
    var a12 = a.m05;
    var a20 = a.m06;
    var a21 = a.m07;
    var a22 = a.m08;
    var b00 = b.m00;
    var b01 = b.m01;
    var b02 = b.m02;
    var b10 = b.m03;
    var b11 = b.m04;
    var b12 = b.m05;
    var b20 = b.m06;
    var b21 = b.m07;
    var b22 = b.m08;
    out.m00 = b00 * a00 + b01 * a10 + b02 * a20;
    out.m01 = b00 * a01 + b01 * a11 + b02 * a21;
    out.m02 = b00 * a02 + b01 * a12 + b02 * a22;
    out.m03 = b10 * a00 + b11 * a10 + b12 * a20;
    out.m04 = b10 * a01 + b11 * a11 + b12 * a21;
    out.m05 = b10 * a02 + b11 * a12 + b12 * a22;
    out.m06 = b20 * a00 + b21 * a10 + b22 * a20;
    out.m07 = b20 * a01 + b21 * a11 + b22 * a21;
    out.m08 = b20 * a02 + b21 * a12 + b22 * a22;
    return out;
  };

  Mat3.multiplyMat4 = function multiplyMat4(out, a, b) {
    var a00 = a.m00;
    var a01 = a.m01;
    var a02 = a.m02;
    var a10 = a.m03;
    var a11 = a.m04;
    var a12 = a.m05;
    var a20 = a.m06;
    var a21 = a.m07;
    var a22 = a.m08;
    var b00 = b.m00;
    var b01 = b.m01;
    var b02 = b.m02;
    var b10 = b.m04;
    var b11 = b.m05;
    var b12 = b.m06;
    var b20 = b.m08;
    var b21 = b.m09;
    var b22 = b.m10;
    out.m00 = b00 * a00 + b01 * a10 + b02 * a20;
    out.m01 = b00 * a01 + b01 * a11 + b02 * a21;
    out.m02 = b00 * a02 + b01 * a12 + b02 * a22;
    out.m03 = b10 * a00 + b11 * a10 + b12 * a20;
    out.m04 = b10 * a01 + b11 * a11 + b12 * a21;
    out.m05 = b10 * a02 + b11 * a12 + b12 * a22;
    out.m06 = b20 * a00 + b21 * a10 + b22 * a20;
    out.m07 = b20 * a01 + b21 * a11 + b22 * a21;
    out.m08 = b20 * a02 + b21 * a12 + b22 * a22;
    return out;
  };

  Mat3.transform = function transform(out, a, v) {
    var a00 = a.m00;
    var a01 = a.m01;
    var a02 = a.m02;
    var a10 = a.m03;
    var a11 = a.m04;
    var a12 = a.m05;
    var a20 = a.m06;
    var a21 = a.m07;
    var a22 = a.m08;
    var x = v.x;
    var y = v.y;
    out.m00 = a00;
    out.m01 = a01;
    out.m02 = a02;
    out.m03 = a10;
    out.m04 = a11;
    out.m05 = a12;
    out.m06 = x * a00 + y * a10 + a20;
    out.m07 = x * a01 + y * a11 + a21;
    out.m08 = x * a02 + y * a12 + a22;
    return out;
  };

  Mat3.scale = function scale(out, a, v) {
    var x = v.x;
    var y = v.y;
    out.m00 = x * a.m00;
    out.m01 = x * a.m01;
    out.m02 = x * a.m02;
    out.m03 = y * a.m03;
    out.m04 = y * a.m04;
    out.m05 = y * a.m05;
    out.m06 = a.m06;
    out.m07 = a.m07;
    out.m08 = a.m08;
    return out;
  };

  Mat3.rotate = function rotate(out, a, rad) {
    var a00 = a.m00;
    var a01 = a.m01;
    var a02 = a.m02;
    var a10 = a.m03;
    var a11 = a.m04;
    var a12 = a.m05;
    var a20 = a.m06;
    var a21 = a.m07;
    var a22 = a.m08;
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    out.m00 = c * a00 + s * a10;
    out.m01 = c * a01 + s * a11;
    out.m02 = c * a02 + s * a12;
    out.m03 = c * a10 - s * a00;
    out.m04 = c * a11 - s * a01;
    out.m05 = c * a12 - s * a02;
    out.m06 = a20;
    out.m07 = a21;
    out.m08 = a22;
    return out;
  };

  Mat3.fromMat4 = function fromMat4(out, a) {
    out.m00 = a.m00;
    out.m01 = a.m01;
    out.m02 = a.m02;
    out.m03 = a.m04;
    out.m04 = a.m05;
    out.m05 = a.m06;
    out.m06 = a.m08;
    out.m07 = a.m09;
    out.m08 = a.m10;
    return out;
  };

  Mat3.fromViewUp = function fromViewUp(out, view, up) {
    if (Vec3.lengthSqr(view) < EPSILON * EPSILON) {
      Mat3.identity(out);
      return out;
    }

    Vec3.normalize(v3_1$1, Vec3.cross(v3_1$1, up || Vec3.UNIT_Y, view));

    if (Vec3.lengthSqr(v3_1$1) < EPSILON * EPSILON) {
      Mat3.identity(out);
      return out;
    }

    Vec3.cross(v3_2$1, view, v3_1$1);
    Mat3.set(out, v3_1$1.x, v3_1$1.y, v3_1$1.z, v3_2$1.x, v3_2$1.y, v3_2$1.z, view.x, view.y, view.z);
    return out;
  };

  Mat3.fromTranslation = function fromTranslation(out, v) {
    out.m00 = 1;
    out.m01 = 0;
    out.m02 = 0;
    out.m03 = 0;
    out.m04 = 1;
    out.m05 = 0;
    out.m06 = v.x;
    out.m07 = v.y;
    out.m08 = 1;
    return out;
  };

  Mat3.fromScaling = function fromScaling(out, v) {
    out.m00 = v.x;
    out.m01 = 0;
    out.m02 = 0;
    out.m03 = 0;
    out.m04 = v.y;
    out.m05 = 0;
    out.m06 = 0;
    out.m07 = 0;
    out.m08 = 1;
    return out;
  };

  Mat3.fromRotation = function fromRotation(out, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    out.m00 = c;
    out.m01 = s;
    out.m02 = 0;
    out.m03 = -s;
    out.m04 = c;
    out.m05 = 0;
    out.m06 = 0;
    out.m07 = 0;
    out.m08 = 1;
    return out;
  };

  Mat3.fromQuat = function fromQuat(out, q) {
    var x = q.x;
    var y = q.y;
    var z = q.z;
    var w = q.w;
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var yx = y * x2;
    var yy = y * y2;
    var zx = z * x2;
    var zy = z * y2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    out.m00 = 1 - yy - zz;
    out.m03 = yx - wz;
    out.m06 = zx + wy;
    out.m01 = yx + wz;
    out.m04 = 1 - xx - zz;
    out.m07 = zy - wx;
    out.m02 = zx - wy;
    out.m05 = zy + wx;
    out.m08 = 1 - xx - yy;
    return out;
  };

  Mat3.inverseTransposeMat4 = function inverseTransposeMat4(out, a) {
    var a00 = a.m00;
    var a01 = a.m01;
    var a02 = a.m02;
    var a03 = a.m03;
    var a10 = a.m04;
    var a11 = a.m05;
    var a12 = a.m06;
    var a13 = a.m07;
    var a20 = a.m08;
    var a21 = a.m09;
    var a22 = a.m10;
    var a23 = a.m11;
    var a30 = a.m12;
    var a31 = a.m13;
    var a32 = a.m14;
    var a33 = a.m15;
    var b00 = a00 * a11 - a01 * a10;
    var b01 = a00 * a12 - a02 * a10;
    var b02 = a00 * a13 - a03 * a10;
    var b03 = a01 * a12 - a02 * a11;
    var b04 = a01 * a13 - a03 * a11;
    var b05 = a02 * a13 - a03 * a12;
    var b06 = a20 * a31 - a21 * a30;
    var b07 = a20 * a32 - a22 * a30;
    var b08 = a20 * a33 - a23 * a30;
    var b09 = a21 * a32 - a22 * a31;
    var b10 = a21 * a33 - a23 * a31;
    var b11 = a22 * a33 - a23 * a32;
    var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (!det) {
      return null;
    }

    det = 1.0 / det;
    out.m00 = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out.m01 = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out.m02 = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out.m03 = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out.m04 = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out.m05 = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out.m06 = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out.m07 = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out.m08 = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    return out;
  };

  Mat3.toArray = function toArray(out, m, ofs) {
    if (ofs === void 0) {
      ofs = 0;
    }

    out[ofs + 0] = m.m00;
    out[ofs + 1] = m.m01;
    out[ofs + 2] = m.m02;
    out[ofs + 3] = m.m03;
    out[ofs + 4] = m.m04;
    out[ofs + 5] = m.m05;
    out[ofs + 6] = m.m06;
    out[ofs + 7] = m.m07;
    out[ofs + 8] = m.m08;
    return out;
  };

  Mat3.fromArray = function fromArray(out, arr, ofs) {
    if (ofs === void 0) {
      ofs = 0;
    }

    out.m00 = arr[ofs + 0];
    out.m01 = arr[ofs + 1];
    out.m02 = arr[ofs + 2];
    out.m03 = arr[ofs + 3];
    out.m04 = arr[ofs + 4];
    out.m05 = arr[ofs + 5];
    out.m06 = arr[ofs + 6];
    out.m07 = arr[ofs + 7];
    out.m08 = arr[ofs + 8];
    return out;
  };

  Mat3.add = function add(out, a, b) {
    out.m00 = a.m00 + b.m00;
    out.m01 = a.m01 + b.m01;
    out.m02 = a.m02 + b.m02;
    out.m03 = a.m03 + b.m03;
    out.m04 = a.m04 + b.m04;
    out.m05 = a.m05 + b.m05;
    out.m06 = a.m06 + b.m06;
    out.m07 = a.m07 + b.m07;
    out.m08 = a.m08 + b.m08;
    return out;
  };

  Mat3.subtract = function subtract(out, a, b) {
    out.m00 = a.m00 - b.m00;
    out.m01 = a.m01 - b.m01;
    out.m02 = a.m02 - b.m02;
    out.m03 = a.m03 - b.m03;
    out.m04 = a.m04 - b.m04;
    out.m05 = a.m05 - b.m05;
    out.m06 = a.m06 - b.m06;
    out.m07 = a.m07 - b.m07;
    out.m08 = a.m08 - b.m08;
    return out;
  };

  Mat3.multiplyScalar = function multiplyScalar(out, a, b) {
    out.m00 = a.m00 * b;
    out.m01 = a.m01 * b;
    out.m02 = a.m02 * b;
    out.m03 = a.m03 * b;
    out.m04 = a.m04 * b;
    out.m05 = a.m05 * b;
    out.m06 = a.m06 * b;
    out.m07 = a.m07 * b;
    out.m08 = a.m08 * b;
    return out;
  };

  Mat3.multiplyScalarAndAdd = function multiplyScalarAndAdd(out, a, b, scale) {
    out.m00 = b.m00 * scale + a.m00;
    out.m01 = b.m01 * scale + a.m01;
    out.m02 = b.m02 * scale + a.m02;
    out.m03 = b.m03 * scale + a.m03;
    out.m04 = b.m04 * scale + a.m04;
    out.m05 = b.m05 * scale + a.m05;
    out.m06 = b.m06 * scale + a.m06;
    out.m07 = b.m07 * scale + a.m07;
    out.m08 = b.m08 * scale + a.m08;
    return out;
  };

  Mat3.strictEquals = function strictEquals(a, b) {
    return a.m00 === b.m00 && a.m01 === b.m01 && a.m02 === b.m02 && a.m03 === b.m03 && a.m04 === b.m04 && a.m05 === b.m05 && a.m06 === b.m06 && a.m07 === b.m07 && a.m08 === b.m08;
  };

  Mat3.equals = function equals(a, b, epsilon) {
    if (epsilon === void 0) {
      epsilon = EPSILON;
    }

    return Math.abs(a.m00 - b.m00) <= epsilon * Math.max(1.0, Math.abs(a.m00), Math.abs(b.m00)) && Math.abs(a.m01 - b.m01) <= epsilon * Math.max(1.0, Math.abs(a.m01), Math.abs(b.m01)) && Math.abs(a.m02 - b.m02) <= epsilon * Math.max(1.0, Math.abs(a.m02), Math.abs(b.m02)) && Math.abs(a.m03 - b.m03) <= epsilon * Math.max(1.0, Math.abs(a.m03), Math.abs(b.m03)) && Math.abs(a.m04 - b.m04) <= epsilon * Math.max(1.0, Math.abs(a.m04), Math.abs(b.m04)) && Math.abs(a.m05 - b.m05) <= epsilon * Math.max(1.0, Math.abs(a.m05), Math.abs(b.m05)) && Math.abs(a.m06 - b.m06) <= epsilon * Math.max(1.0, Math.abs(a.m06), Math.abs(b.m06)) && Math.abs(a.m07 - b.m07) <= epsilon * Math.max(1.0, Math.abs(a.m07), Math.abs(b.m07)) && Math.abs(a.m08 - b.m08) <= epsilon * Math.max(1.0, Math.abs(a.m08), Math.abs(b.m08));
  };

  _createClass(Mat3, [{
    key: "m00",
    get: function get() {
      return this._array[0];
    },
    set: function set(m) {
      this._array[0] = m;
    }
  }, {
    key: "m01",
    get: function get() {
      return this._array[1];
    },
    set: function set(m) {
      this._array[1] = m;
    }
  }, {
    key: "m02",
    get: function get() {
      return this._array[2];
    },
    set: function set(m) {
      this._array[2] = m;
    }
  }, {
    key: "m03",
    get: function get() {
      return this._array[3];
    },
    set: function set(m) {
      this._array[3] = m;
    }
  }, {
    key: "m04",
    get: function get() {
      return this._array[4];
    },
    set: function set(m) {
      this._array[4] = m;
    }
  }, {
    key: "m05",
    get: function get() {
      return this._array[5];
    },
    set: function set(m) {
      this._array[5] = m;
    }
  }, {
    key: "m06",
    get: function get() {
      return this._array[6];
    },
    set: function set(m) {
      this._array[6] = m;
    }
  }, {
    key: "m07",
    get: function get() {
      return this._array[7];
    },
    set: function set(m) {
      this._array[7] = m;
    }
  }, {
    key: "m08",
    get: function get() {
      return this._array[8];
    },
    set: function set(m) {
      this._array[8] = m;
    }
  }]);

  function Mat3(m00, m01, m02, m03, m04, m05, m06, m07, m08) {
    var _this;

    if (m00 === void 0) {
      m00 = 1;
    }

    if (m01 === void 0) {
      m01 = 0;
    }

    if (m02 === void 0) {
      m02 = 0;
    }

    if (m03 === void 0) {
      m03 = 0;
    }

    if (m04 === void 0) {
      m04 = 1;
    }

    if (m05 === void 0) {
      m05 = 0;
    }

    if (m06 === void 0) {
      m06 = 0;
    }

    if (m07 === void 0) {
      m07 = 0;
    }

    if (m08 === void 0) {
      m08 = 1;
    }

    _this = _MathBase.call(this) || this;

    if (m00 && typeof m00 === 'object') {
      if (ArrayBuffer.isView(m00)) {
        _this._array = m00;

        _this._array.set([1, 0, 0, 0, 1, 0, 0, 0, 1]);
      } else {
        var v = m00.array;
        _this._array = MathBase.createFloatArray(9);
        _this._array[0] = v[0];
        _this._array[1] = v[1];
        _this._array[2] = v[2];
        _this._array[3] = v[3];
        _this._array[4] = v[4];
        _this._array[5] = v[5];
        _this._array[6] = v[6];
        _this._array[7] = v[7];
        _this._array[8] = v[8];
      }
    } else {
      _this._array = MathBase.createFloatArray(9);
      _this._array[0] = m00;
      _this._array[1] = m01;
      _this._array[2] = m02;
      _this._array[3] = m03;
      _this._array[4] = m04;
      _this._array[5] = m05;
      _this._array[6] = m06;
      _this._array[7] = m07;
      _this._array[8] = m08;
    }

    return _this;
  }

  var _proto = Mat3.prototype;

  _proto.clone = function clone() {
    var m = this._array;
    return new Mat3(m[0], m[1], m[2], m[3], m[4], m[5], m[6], m[7], m[8]);
  };

  _proto.set = function set(m00, m01, m02, m03, m04, m05, m06, m07, m08) {
    if (m00 === void 0) {
      m00 = 1;
    }

    if (m01 === void 0) {
      m01 = 0;
    }

    if (m02 === void 0) {
      m02 = 0;
    }

    if (m03 === void 0) {
      m03 = 0;
    }

    if (m04 === void 0) {
      m04 = 1;
    }

    if (m05 === void 0) {
      m05 = 0;
    }

    if (m06 === void 0) {
      m06 = 0;
    }

    if (m07 === void 0) {
      m07 = 0;
    }

    if (m08 === void 0) {
      m08 = 1;
    }

    if (m00 && typeof m00 === 'object') {
      var v = m00.array;
      this._array[0] = v[0];
      this._array[1] = v[1];
      this._array[2] = v[2];
      this._array[3] = v[3];
      this._array[4] = v[4];
      this._array[5] = v[5];
      this._array[6] = v[6];
      this._array[7] = v[7];
      this._array[8] = v[8];
    } else {
      this._array[0] = m00;
      this._array[1] = m01;
      this._array[2] = m02;
      this._array[3] = m03;
      this._array[4] = m04;
      this._array[5] = m05;
      this._array[6] = m06;
      this._array[7] = m07;
      this._array[8] = m08;
    }

    return this;
  };

  _proto.equals = function equals(other, epsilon) {
    if (epsilon === void 0) {
      epsilon = EPSILON;
    }

    var v = other.array;
    return Math.abs(this._array[0] - v[0]) <= epsilon * Math.max(1.0, Math.abs(this._array[0]), Math.abs(v[0])) && Math.abs(this._array[1] - v[1]) <= epsilon * Math.max(1.0, Math.abs(this._array[1]), Math.abs(v[1])) && Math.abs(this._array[2] - v[2]) <= epsilon * Math.max(1.0, Math.abs(this._array[2]), Math.abs(v[2])) && Math.abs(this._array[3] - v[3]) <= epsilon * Math.max(1.0, Math.abs(this._array[3]), Math.abs(v[3])) && Math.abs(this._array[4] - v[4]) <= epsilon * Math.max(1.0, Math.abs(this._array[4]), Math.abs(v[4])) && Math.abs(this._array[5] - v[5]) <= epsilon * Math.max(1.0, Math.abs(this._array[5]), Math.abs(v[5])) && Math.abs(this._array[6] - v[6]) <= epsilon * Math.max(1.0, Math.abs(this._array[6]), Math.abs(v[6])) && Math.abs(this._array[7] - v[7]) <= epsilon * Math.max(1.0, Math.abs(this._array[7]), Math.abs(v[7])) && Math.abs(this._array[8] - v[8]) <= epsilon * Math.max(1.0, Math.abs(this._array[8]), Math.abs(v[8]));
  };

  _proto.strictEquals = function strictEquals(other) {
    var v = other.array;
    return this._array[0] === v[0] && this._array[1] === v[1] && this._array[2] === v[2] && this._array[3] === v[3] && this._array[4] === v[4] && this._array[5] === v[5] && this._array[6] === v[6] && this._array[7] === v[7] && this._array[8] === v[8];
  };

  _proto.toString = function toString() {
    return "[\n" + this._array[0] + ", " + this._array[1] + ", " + this._array[2] + ",\n" + this._array[3] + ",\n" + this._array[4] + ", " + this._array[5] + ",\n" + this._array[6] + ", " + this._array[7] + ",\n" + this._array[8] + "\n" + "]";
  };

  _proto.identity = function identity() {
    this._array[0] = 1;
    this._array[1] = 0;
    this._array[2] = 0;
    this._array[3] = 0;
    this._array[4] = 1;
    this._array[5] = 0;
    this._array[6] = 0;
    this._array[7] = 0;
    this._array[8] = 1;
    return this;
  };

  _proto.transpose = function transpose() {
    var a01 = this._array[1];
    var a02 = this._array[2];
    var a12 = this._array[5];
    this._array[1] = this._array[3];
    this._array[2] = this._array[6];
    this._array[3] = a01;
    this._array[5] = this._array[7];
    this._array[6] = a02;
    this._array[7] = a12;
    return this;
  };

  _proto.invert = function invert() {
    var a00 = this._array[0];
    var a01 = this._array[1];
    var a02 = this._array[2];
    var a10 = this._array[3];
    var a11 = this._array[4];
    var a12 = this._array[5];
    var a20 = this._array[6];
    var a21 = this._array[7];
    var a22 = this._array[8];
    var b01 = a22 * a11 - a12 * a21;
    var b11 = -a22 * a10 + a12 * a20;
    var b21 = a21 * a10 - a11 * a20;
    var det = a00 * b01 + a01 * b11 + a02 * b21;

    if (det === 0) {
      this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
      return this;
    }

    det = 1.0 / det;
    this._array[0] = b01 * det;
    this._array[1] = (-a22 * a01 + a02 * a21) * det;
    this._array[2] = (a12 * a01 - a02 * a11) * det;
    this._array[3] = b11 * det;
    this._array[4] = (a22 * a00 - a02 * a20) * det;
    this._array[5] = (-a12 * a00 + a02 * a10) * det;
    this._array[6] = b21 * det;
    this._array[7] = (-a21 * a00 + a01 * a20) * det;
    this._array[8] = (a11 * a00 - a01 * a10) * det;
    return this;
  };

  _proto.determinant = function determinant() {
    var a00 = this._array[0];
    var a01 = this._array[1];
    var a02 = this._array[2];
    var a10 = this._array[3];
    var a11 = this._array[4];
    var a12 = this._array[5];
    var a20 = this._array[6];
    var a21 = this._array[7];
    var a22 = this._array[8];
    return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
  };

  _proto.add = function add(mat) {
    var v = mat.array;
    this._array[0] += v[0];
    this._array[1] += v[1];
    this._array[2] += v[2];
    this._array[3] += v[3];
    this._array[4] += v[4];
    this._array[5] += v[5];
    this._array[6] += v[6];
    this._array[7] += v[7];
    this._array[8] += v[8];
    return this;
  };

  _proto.subtract = function subtract(mat) {
    var v = mat.array;
    this._array[0] -= v[0];
    this._array[1] -= v[1];
    this._array[2] -= v[2];
    this._array[3] -= v[3];
    this._array[4] -= v[4];
    this._array[5] -= v[5];
    this._array[6] -= v[6];
    this._array[7] -= v[7];
    this._array[8] -= v[8];
    return this;
  };

  _proto.multiply = function multiply(mat) {
    var a00 = this._array[0];
    var a01 = this._array[1];
    var a02 = this._array[2];
    var a10 = this._array[3];
    var a11 = this._array[4];
    var a12 = this._array[5];
    var a20 = this._array[6];
    var a21 = this._array[7];
    var a22 = this._array[8];
    var v = mat.array;
    var b00 = v[0];
    var b01 = v[1];
    var b02 = v[2];
    var b10 = v[3];
    var b11 = v[4];
    var b12 = v[5];
    var b20 = v[6];
    var b21 = v[7];
    var b22 = v[8];
    this._array[0] = b00 * a00 + b01 * a10 + b02 * a20;
    this._array[1] = b00 * a01 + b01 * a11 + b02 * a21;
    this._array[2] = b00 * a02 + b01 * a12 + b02 * a22;
    this._array[3] = b10 * a00 + b11 * a10 + b12 * a20;
    this._array[4] = b10 * a01 + b11 * a11 + b12 * a21;
    this._array[5] = b10 * a02 + b11 * a12 + b12 * a22;
    this._array[6] = b20 * a00 + b21 * a10 + b22 * a20;
    this._array[7] = b20 * a01 + b21 * a11 + b22 * a21;
    this._array[8] = b20 * a02 + b21 * a12 + b22 * a22;
    return this;
  };

  _proto.multiplyScalar = function multiplyScalar(scalar) {
    this._array[0] *= scalar;
    this._array[1] *= scalar;
    this._array[2] *= scalar;
    this._array[3] *= scalar;
    this._array[4] *= scalar;
    this._array[5] *= scalar;
    this._array[6] *= scalar;
    this._array[7] *= scalar;
    this._array[8] *= scalar;
    return this;
  };

  _proto.scale = function scale(vec) {
    var x = vec.array[0];
    var y = vec.array[1];
    this._array[0] *= x;
    this._array[1] *= x;
    this._array[2] *= x;
    this._array[3] *= y;
    this._array[4] *= y;
    this._array[5] *= y;
    return this;
  };

  _proto.rotate = function rotate(rad) {
    var a00 = this._array[0];
    var a01 = this._array[1];
    var a02 = this._array[2];
    var a10 = this._array[3];
    var a11 = this._array[4];
    var a12 = this._array[5];
    var a20 = this._array[6];
    var a21 = this._array[7];
    var a22 = this._array[8];
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    this._array[0] = c * a00 + s * a10;
    this._array[1] = c * a01 + s * a11;
    this._array[2] = c * a02 + s * a12;
    this._array[3] = c * a10 - s * a00;
    this._array[4] = c * a11 - s * a01;
    this._array[5] = c * a12 - s * a02;
    this._array[6] = a20;
    this._array[7] = a21;
    this._array[8] = a22;
    return this;
  };

  _proto.fromQuat = function fromQuat(q) {
    var x = q.x;
    var y = q.y;
    var z = q.z;
    var w = q.w;
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var yx = y * x2;
    var yy = y * y2;
    var zx = z * x2;
    var zy = z * y2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    this._array[0] = 1 - yy - zz;
    this._array[3] = yx - wz;
    this._array[6] = zx + wy;
    this._array[1] = yx + wz;
    this._array[4] = 1 - xx - zz;
    this._array[7] = zy - wx;
    this._array[2] = zx - wy;
    this._array[5] = zy + wx;
    this._array[8] = 1 - xx - yy;
    return this;
  };

  return Mat3;
}(MathBase);
Mat3.IDENTITY = Object.freeze(new Mat3());
var v3_1$1 = new Vec3();
var v3_2$1 = new Vec3();
enumerableProps(Mat3.prototype, ['m00', 'm01', 'm02', 'm03', 'm04', 'm05', 'm06', 'm07', 'm08']);
CCClass.fastDefine('cc.Mat3', Mat3, {
  m00: 1,
  m01: 0,
  m02: 0,
  m03: 0,
  m04: 1,
  m05: 0,
  m06: 0,
  m07: 0,
  m08: 1
});
legacyCC.Mat3 = Mat3;

var Quat = function (_MathBase) {
  _inheritsLoose(Quat, _MathBase);

  Quat.clone = function clone(a) {
    return new Quat(a.x, a.y, a.z, a.w);
  };

  Quat.copy = function copy(out, a) {
    out.x = a.x;
    out.y = a.y;
    out.z = a.z;
    out.w = a.w;
    return out;
  };

  Quat.set = function set(out, x, y, z, w) {
    out.x = x;
    out.y = y;
    out.z = z;
    out.w = w;
    return out;
  };

  Quat.identity = function identity(out) {
    out.x = 0;
    out.y = 0;
    out.z = 0;
    out.w = 1;
    return out;
  };

  Quat.rotationTo = function rotationTo(out, a, b) {
    var dot = Vec3.dot(a, b);

    if (dot < -0.999999) {
      Vec3.cross(v3_1$2, Vec3.UNIT_X, a);

      if (v3_1$2.length() < 0.000001) {
        Vec3.cross(v3_1$2, Vec3.UNIT_Y, a);
      }

      Vec3.normalize(v3_1$2, v3_1$2);
      Quat.fromAxisAngle(out, v3_1$2, Math.PI);
      return out;
    } else if (dot > 0.999999) {
      out.x = 0;
      out.y = 0;
      out.z = 0;
      out.w = 1;
      return out;
    } else {
      Vec3.cross(v3_1$2, a, b);
      out.x = v3_1$2.x;
      out.y = v3_1$2.y;
      out.z = v3_1$2.z;
      out.w = 1 + dot;
      return Quat.normalize(out, out);
    }
  };

  Quat.getAxisAngle = function getAxisAngle(outAxis, q) {
    var rad = Math.acos(q.w) * 2.0;
    var s = Math.sin(rad / 2.0);

    if (s !== 0.0) {
      outAxis.x = q.x / s;
      outAxis.y = q.y / s;
      outAxis.z = q.z / s;
    } else {
      outAxis.x = 1;
      outAxis.y = 0;
      outAxis.z = 0;
    }

    return rad;
  };

  Quat.multiply = function multiply(out, a, b) {
    var x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;
    var y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;
    var z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;
    var w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;
    out.x = x;
    out.y = y;
    out.z = z;
    out.w = w;
    return out;
  };

  Quat.multiplyScalar = function multiplyScalar(out, a, b) {
    out.x = a.x * b;
    out.y = a.y * b;
    out.z = a.z * b;
    out.w = a.w * b;
    return out;
  };

  Quat.scaleAndAdd = function scaleAndAdd(out, a, b, scale) {
    out.x = a.x + b.x * scale;
    out.y = a.y + b.y * scale;
    out.z = a.z + b.z * scale;
    out.w = a.w + b.w * scale;
    return out;
  };

  Quat.rotateX = function rotateX(out, a, rad) {
    rad *= 0.5;
    var bx = Math.sin(rad);
    var bw = Math.cos(rad);
    var x = a.x,
        y = a.y,
        z = a.z,
        w = a.w;
    out.x = x * bw + w * bx;
    out.y = y * bw + z * bx;
    out.z = z * bw - y * bx;
    out.w = w * bw - x * bx;
    return out;
  };

  Quat.rotateY = function rotateY(out, a, rad) {
    rad *= 0.5;
    var by = Math.sin(rad);
    var bw = Math.cos(rad);
    var x = a.x,
        y = a.y,
        z = a.z,
        w = a.w;
    out.x = x * bw - z * by;
    out.y = y * bw + w * by;
    out.z = z * bw + x * by;
    out.w = w * bw - y * by;
    return out;
  };

  Quat.rotateZ = function rotateZ(out, a, rad) {
    rad *= 0.5;
    var bz = Math.sin(rad);
    var bw = Math.cos(rad);
    var x = a.x,
        y = a.y,
        z = a.z,
        w = a.w;
    out.x = x * bw + y * bz;
    out.y = y * bw - x * bz;
    out.z = z * bw + w * bz;
    out.w = w * bw - z * bz;
    return out;
  };

  Quat.rotateAround = function rotateAround(out, rot, axis, rad) {
    Quat.invert(qt_1, rot);
    Vec3.transformQuat(v3_1$2, axis, qt_1);
    Quat.fromAxisAngle(qt_1, v3_1$2, rad);
    Quat.multiply(out, rot, qt_1);
    return out;
  };

  Quat.rotateAroundLocal = function rotateAroundLocal(out, rot, axis, rad) {
    Quat.fromAxisAngle(qt_1, axis, rad);
    Quat.multiply(out, rot, qt_1);
    return out;
  };

  Quat.calculateW = function calculateW(out, a) {
    out.x = a.x;
    out.y = a.y;
    out.z = a.z;
    out.w = Math.sqrt(Math.abs(1.0 - a.x * a.x - a.y * a.y - a.z * a.z));
    return out;
  };

  Quat.dot = function dot(a, b) {
    return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w;
  };

  Quat.lerp = function lerp(out, a, b, t) {
    out.x = a.x + t * (b.x - a.x);
    out.y = a.y + t * (b.y - a.y);
    out.z = a.z + t * (b.z - a.z);
    out.w = a.w + t * (b.w - a.w);
    return out;
  };

  Quat.slerp = function slerp(out, a, b, t) {
    var scale0 = 0;
    var scale1 = 0;
    var bx = b.x;
    var by = b.y;
    var bz = b.z;
    var bw = b.w;
    var cosom = a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w;

    if (cosom < 0.0) {
      cosom = -cosom;
      bx = -bx;
      by = -by;
      bz = -bz;
      bw = -bw;
    }

    if (1.0 - cosom > 0.000001) {
      var omega = Math.acos(cosom);
      var sinom = Math.sin(omega);
      scale0 = Math.sin((1.0 - t) * omega) / sinom;
      scale1 = Math.sin(t * omega) / sinom;
    } else {
      scale0 = 1.0 - t;
      scale1 = t;
    }

    out.x = scale0 * a.x + scale1 * bx;
    out.y = scale0 * a.y + scale1 * by;
    out.z = scale0 * a.z + scale1 * bz;
    out.w = scale0 * a.w + scale1 * bw;
    return out;
  };

  Quat.sqlerp = function sqlerp(out, a, b, c, d, t) {
    Quat.slerp(qt_1, a, d, t);
    Quat.slerp(qt_2, b, c, t);
    Quat.slerp(out, qt_1, qt_2, 2 * t * (1 - t));
    return out;
  };

  Quat.invert = function invert(out, a) {
    var dot = a.x * a.x + a.y * a.y + a.z * a.z + a.w * a.w;
    var invDot = dot ? 1.0 / dot : 0;
    out.x = -a.x * invDot;
    out.y = -a.y * invDot;
    out.z = -a.z * invDot;
    out.w = a.w * invDot;
    return out;
  };

  Quat.conjugate = function conjugate(out, a) {
    out.x = -a.x;
    out.y = -a.y;
    out.z = -a.z;
    out.w = a.w;
    return out;
  };

  Quat.len = function len(a) {
    return Math.sqrt(a.x * a.x + a.y * a.y + a.z * a.z + a.w * a.w);
  };

  Quat.lengthSqr = function lengthSqr(a) {
    return a.x * a.x + a.y * a.y + a.z * a.z + a.w * a.w;
  };

  Quat.normalize = function normalize(out, a) {
    var len = a.x * a.x + a.y * a.y + a.z * a.z + a.w * a.w;

    if (len > 0) {
      len = 1 / Math.sqrt(len);
      out.x = a.x * len;
      out.y = a.y * len;
      out.z = a.z * len;
      out.w = a.w * len;
    }

    return out;
  };

  Quat.fromAxes = function fromAxes(out, xAxis, yAxis, zAxis) {
    Mat3.set(m3_1, xAxis.x, xAxis.y, xAxis.z, yAxis.x, yAxis.y, yAxis.z, zAxis.x, zAxis.y, zAxis.z);
    return Quat.normalize(out, Quat.fromMat3(out, m3_1));
  };

  Quat.fromViewUp = function fromViewUp(out, view, up) {
    Mat3.fromViewUp(m3_1, view, up);
    return Quat.normalize(out, Quat.fromMat3(out, m3_1));
  };

  Quat.fromAxisAngle = function fromAxisAngle(out, axis, rad) {
    rad *= 0.5;
    var s = Math.sin(rad);
    out.x = s * axis.x;
    out.y = s * axis.y;
    out.z = s * axis.z;
    out.w = Math.cos(rad);
    return out;
  };

  Quat.fromMat3 = function fromMat3(out, m) {
    var m00 = m.m00,
        m01 = m.m03,
        m02 = m.m06,
        m10 = m.m01,
        m11 = m.m04,
        m12 = m.m07,
        m20 = m.m02,
        m21 = m.m05,
        m22 = m.m08;
    var trace = m00 + m11 + m22;

    if (trace > 0) {
      var s = 0.5 / Math.sqrt(trace + 1.0);
      out.w = 0.25 / s;
      out.x = (m21 - m12) * s;
      out.y = (m02 - m20) * s;
      out.z = (m10 - m01) * s;
    } else if (m00 > m11 && m00 > m22) {
      var _s = 2.0 * Math.sqrt(1.0 + m00 - m11 - m22);

      out.w = (m21 - m12) / _s;
      out.x = 0.25 * _s;
      out.y = (m01 + m10) / _s;
      out.z = (m02 + m20) / _s;
    } else if (m11 > m22) {
      var _s2 = 2.0 * Math.sqrt(1.0 + m11 - m00 - m22);

      out.w = (m02 - m20) / _s2;
      out.x = (m01 + m10) / _s2;
      out.y = 0.25 * _s2;
      out.z = (m12 + m21) / _s2;
    } else {
      var _s3 = 2.0 * Math.sqrt(1.0 + m22 - m00 - m11);

      out.w = (m10 - m01) / _s3;
      out.x = (m02 + m20) / _s3;
      out.y = (m12 + m21) / _s3;
      out.z = 0.25 * _s3;
    }

    return out;
  };

  Quat.fromEuler = function fromEuler(out, x, y, z) {
    x *= halfToRad;
    y *= halfToRad;
    z *= halfToRad;
    var sx = Math.sin(x);
    var cx = Math.cos(x);
    var sy = Math.sin(y);
    var cy = Math.cos(y);
    var sz = Math.sin(z);
    var cz = Math.cos(z);
    out.x = sx * cy * cz + cx * sy * sz;
    out.y = cx * sy * cz + sx * cy * sz;
    out.z = cx * cy * sz - sx * sy * cz;
    out.w = cx * cy * cz - sx * sy * sz;
    return out;
  };

  Quat.fromAngleZ = function fromAngleZ(out, z) {
    z *= halfToRad;
    out.x = out.y = 0;
    out.z = Math.sin(z);
    out.w = Math.cos(z);
    return out;
  };

  Quat.toAxisX = function toAxisX(out, q) {
    var fy = 2.0 * q.y;
    var fz = 2.0 * q.z;
    out.x = 1.0 - fy * q.y - fz * q.z;
    out.y = fy * q.x + fz * q.w;
    out.z = fz * q.x + fy * q.w;
    return out;
  };

  Quat.toAxisY = function toAxisY(out, q) {
    var fx = 2.0 * q.x;
    var fy = 2.0 * q.y;
    var fz = 2.0 * q.z;
    out.x = fy * q.x - fz * q.w;
    out.y = 1.0 - fx * q.x - fz * q.z;
    out.z = fz * q.y + fx * q.w;
    return out;
  };

  Quat.toAxisZ = function toAxisZ(out, q) {
    var fx = 2.0 * q.x;
    var fy = 2.0 * q.y;
    var fz = 2.0 * q.z;
    out.x = fz * q.x - fy * q.w;
    out.y = fz * q.y - fx * q.w;
    out.z = 1.0 - fx * q.x - fy * q.y;
    return out;
  };

  Quat.toEuler = function toEuler(out, q, outerZ) {
    var x = q.x,
        y = q.y,
        z = q.z,
        w = q.w;
    var bank = 0;
    var heading = 0;
    var attitude = 0;
    var test = x * y + z * w;

    if (test > 0.499999) {
      bank = 0;
      heading = toDegree(2 * Math.atan2(x, w));
      attitude = 90;
    } else if (test < -0.499999) {
      bank = 0;
      heading = -toDegree(2 * Math.atan2(x, w));
      attitude = -90;
    } else {
      var sqx = x * x;
      var sqy = y * y;
      var sqz = z * z;
      bank = toDegree(Math.atan2(2 * x * w - 2 * y * z, 1 - 2 * sqx - 2 * sqz));
      heading = toDegree(Math.atan2(2 * y * w - 2 * x * z, 1 - 2 * sqy - 2 * sqz));
      attitude = toDegree(Math.asin(2 * test));

      if (outerZ) {
        bank = -180 * Math.sign(bank + 1e-6) + bank;
        heading = -180 * Math.sign(heading + 1e-6) + heading;
        attitude = 180 * Math.sign(attitude + 1e-6) - attitude;
      }
    }

    out.x = bank;
    out.y = heading;
    out.z = attitude;
    return out;
  };

  Quat.toArray = function toArray(out, q, ofs) {
    if (ofs === void 0) {
      ofs = 0;
    }

    out[ofs + 0] = q.x;
    out[ofs + 1] = q.y;
    out[ofs + 2] = q.z;
    out[ofs + 3] = q.w;
    return out;
  };

  Quat.fromArray = function fromArray(out, arr, ofs) {
    if (ofs === void 0) {
      ofs = 0;
    }

    out.x = arr[ofs + 0];
    out.y = arr[ofs + 1];
    out.z = arr[ofs + 2];
    out.w = arr[ofs + 3];
    return out;
  };

  Quat.strictEquals = function strictEquals(a, b) {
    return a.x === b.x && a.y === b.y && a.z === b.z && a.w === b.w;
  };

  Quat.equals = function equals(a, b, epsilon) {
    if (epsilon === void 0) {
      epsilon = EPSILON;
    }

    return Math.abs(a.x - b.x) <= epsilon * Math.max(1.0, Math.abs(a.x), Math.abs(b.x)) && Math.abs(a.y - b.y) <= epsilon * Math.max(1.0, Math.abs(a.y), Math.abs(b.y)) && Math.abs(a.z - b.z) <= epsilon * Math.max(1.0, Math.abs(a.z), Math.abs(b.z)) && Math.abs(a.w - b.w) <= epsilon * Math.max(1.0, Math.abs(a.w), Math.abs(b.w));
  };

  _createClass(Quat, [{
    key: "x",
    get: function get() {
      return this._array[0];
    },
    set: function set(x) {
      this._array[0] = x;
    }
  }, {
    key: "y",
    get: function get() {
      return this._array[1];
    },
    set: function set(y) {
      this._array[1] = y;
    }
  }, {
    key: "z",
    get: function get() {
      return this._array[2];
    },
    set: function set(z) {
      this._array[2] = z;
    }
  }, {
    key: "w",
    get: function get() {
      return this._array[3];
    },
    set: function set(w) {
      this._array[3] = w;
    }
  }]);

  function Quat(x, y, z, w) {
    var _this;

    _this = _MathBase.call(this) || this;

    if (x && typeof x === 'object') {
      if (ArrayBuffer.isView(x)) {
        _this._array = x;

        _this._array.fill(0);

        _this._array[3] = 1;
      } else {
        var v = x.array;
        _this._array = MathBase.createFloatArray(4);
        _this._array[0] = v[0];
        _this._array[1] = v[1];
        _this._array[2] = v[2];
        _this._array[3] = v[3];
      }
    } else {
      _this._array = MathBase.createFloatArray(4);
      _this._array[0] = x || 0;
      _this._array[1] = y || 0;
      _this._array[2] = z || 0;
      _this._array[3] = w !== null && w !== void 0 ? w : 1;
    }

    return _this;
  }

  var _proto = Quat.prototype;

  _proto.clone = function clone() {
    return new Quat(this._array[0], this._array[1], this._array[2], this._array[3]);
  };

  _proto.set = function set(x, y, z, w) {
    if (x && typeof x === 'object') {
      var v = x.array;
      this._array[0] = v[0];
      this._array[1] = v[1];
      this._array[2] = v[2];
      this._array[3] = v[3];
    } else {
      this._array[0] = x || 0;
      this._array[1] = y || 0;
      this._array[2] = z || 0;
      this._array[3] = w !== null && w !== void 0 ? w : 1;
    }

    return this;
  };

  _proto.equals = function equals(other, epsilon) {
    if (epsilon === void 0) {
      epsilon = EPSILON;
    }

    var v = other.array;
    return Math.abs(this._array[0] - v[0]) <= epsilon * Math.max(1.0, Math.abs(this._array[0]), Math.abs(v[0])) && Math.abs(this._array[1] - v[1]) <= epsilon * Math.max(1.0, Math.abs(this._array[1]), Math.abs(v[1])) && Math.abs(this._array[2] - v[2]) <= epsilon * Math.max(1.0, Math.abs(this._array[2]), Math.abs(v[2])) && Math.abs(this._array[3] - v[3]) <= epsilon * Math.max(1.0, Math.abs(this._array[3]), Math.abs(v[3]));
  };

  _proto.strictEquals = function strictEquals(other) {
    var v = other.array;
    return other && this._array[0] === v[0] && this._array[1] === v[1] && this._array[2] === v[2] && this._array[3] === v[3];
  };

  _proto.getEulerAngles = function getEulerAngles(out) {
    return Quat.toEuler(out, this);
  };

  _proto.lerp = function lerp(to, ratio) {
    var tq = to.array;
    this._array[0] += ratio * (tq[0] - this._array[0]);
    this._array[1] += ratio * (tq[1] - this._array[1]);
    this._array[2] += ratio * (tq[2] - this._array[2]);
    this._array[3] += ratio * (tq[3] - this._array[3]);
    return this;
  };

  _proto.slerp = function slerp(to, ratio) {
    return Quat.slerp(this, this, to, ratio);
  };

  _proto.length = function length() {
    var v = this._array;
    return Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2] + v[3] * v[3]);
  };

  _proto.lengthSqr = function lengthSqr() {
    var v = this._array;
    return v[0] * v[0] + v[1] * v[1] + v[2] * v[2] + v[3] * v[3];
  };

  return Quat;
}(MathBase);
Quat.IDENTITY = Object.freeze(new Quat());
enumerableProps(Quat.prototype, ['x', 'y', 'z', 'w']);
var qt_1 = new Quat();
var qt_2 = new Quat();
var v3_1$2 = new Vec3();
var m3_1 = new Mat3();
var halfToRad = 0.5 * Math.PI / 180.0;
CCClass.fastDefine('cc.Quat', Quat, {
  x: 0,
  y: 0,
  z: 0,
  w: 1
});
legacyCC.Quat = Quat;
function quat(x, y, z, w) {
  if (x === void 0) {
    x = 0;
  }

  if (y === void 0) {
    y = 0;
  }

  if (z === void 0) {
    z = 0;
  }

  if (w === void 0) {
    w = 1;
  }

  return new Quat(x, y, z, w);
}
legacyCC.quat = quat;

var preTransforms = Object.freeze([Object.freeze([1, 0, 0, 1]), Object.freeze([0, 1, -1, 0]), Object.freeze([-1, 0, 0, -1]), Object.freeze([0, -1, 1, 0])]);
var Mat4 = function (_MathBase) {
  _inheritsLoose(Mat4, _MathBase);

  Mat4.clone = function clone(a) {
    return new Mat4(a.m00, a.m01, a.m02, a.m03, a.m04, a.m05, a.m06, a.m07, a.m08, a.m09, a.m10, a.m11, a.m12, a.m13, a.m14, a.m15);
  };

  Mat4.copy = function copy(out, a) {
    out.m00 = a.m00;
    out.m01 = a.m01;
    out.m02 = a.m02;
    out.m03 = a.m03;
    out.m04 = a.m04;
    out.m05 = a.m05;
    out.m06 = a.m06;
    out.m07 = a.m07;
    out.m08 = a.m08;
    out.m09 = a.m09;
    out.m10 = a.m10;
    out.m11 = a.m11;
    out.m12 = a.m12;
    out.m13 = a.m13;
    out.m14 = a.m14;
    out.m15 = a.m15;
    return out;
  };

  Mat4.set = function set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
    out.m00 = m00;
    out.m01 = m01;
    out.m02 = m02;
    out.m03 = m03;
    out.m04 = m10;
    out.m05 = m11;
    out.m06 = m12;
    out.m07 = m13;
    out.m08 = m20;
    out.m09 = m21;
    out.m10 = m22;
    out.m11 = m23;
    out.m12 = m30;
    out.m13 = m31;
    out.m14 = m32;
    out.m15 = m33;
    return out;
  };

  Mat4.identity = function identity(out) {
    out.m00 = 1;
    out.m01 = 0;
    out.m02 = 0;
    out.m03 = 0;
    out.m04 = 0;
    out.m05 = 1;
    out.m06 = 0;
    out.m07 = 0;
    out.m08 = 0;
    out.m09 = 0;
    out.m10 = 1;
    out.m11 = 0;
    out.m12 = 0;
    out.m13 = 0;
    out.m14 = 0;
    out.m15 = 1;
    return out;
  };

  Mat4.transpose = function transpose(out, a) {
    if (out === a) {
      var a01 = a.m01;
      var a02 = a.m02;
      var a03 = a.m03;
      var a12 = a.m06;
      var a13 = a.m07;
      var a23 = a.m11;
      out.m01 = a.m04;
      out.m02 = a.m08;
      out.m03 = a.m12;
      out.m04 = a01;
      out.m06 = a.m09;
      out.m07 = a.m13;
      out.m08 = a02;
      out.m09 = a12;
      out.m11 = a.m14;
      out.m12 = a03;
      out.m13 = a13;
      out.m14 = a23;
    } else {
      out.m00 = a.m00;
      out.m01 = a.m04;
      out.m02 = a.m08;
      out.m03 = a.m12;
      out.m04 = a.m01;
      out.m05 = a.m05;
      out.m06 = a.m09;
      out.m07 = a.m13;
      out.m08 = a.m02;
      out.m09 = a.m06;
      out.m10 = a.m10;
      out.m11 = a.m14;
      out.m12 = a.m03;
      out.m13 = a.m07;
      out.m14 = a.m11;
      out.m15 = a.m15;
    }

    return out;
  };

  Mat4.invert = function invert(out, a) {
    var a00 = a.m00;
    var a01 = a.m01;
    var a02 = a.m02;
    var a03 = a.m03;
    var a10 = a.m04;
    var a11 = a.m05;
    var a12 = a.m06;
    var a13 = a.m07;
    var a20 = a.m08;
    var a21 = a.m09;
    var a22 = a.m10;
    var a23 = a.m11;
    var a30 = a.m12;
    var a31 = a.m13;
    var a32 = a.m14;
    var a33 = a.m15;
    var b00 = a00 * a11 - a01 * a10;
    var b01 = a00 * a12 - a02 * a10;
    var b02 = a00 * a13 - a03 * a10;
    var b03 = a01 * a12 - a02 * a11;
    var b04 = a01 * a13 - a03 * a11;
    var b05 = a02 * a13 - a03 * a12;
    var b06 = a20 * a31 - a21 * a30;
    var b07 = a20 * a32 - a22 * a30;
    var b08 = a20 * a33 - a23 * a30;
    var b09 = a21 * a32 - a22 * a31;
    var b10 = a21 * a33 - a23 * a31;
    var b11 = a22 * a33 - a23 * a32;
    var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (det === 0) {
      out.m00 = 0;
      out.m01 = 0;
      out.m02 = 0;
      out.m03 = 0;
      out.m04 = 0;
      out.m05 = 0;
      out.m06 = 0;
      out.m07 = 0;
      out.m08 = 0;
      out.m09 = 0;
      out.m10 = 0;
      out.m11 = 0;
      out.m12 = 0;
      out.m13 = 0;
      out.m14 = 0;
      out.m15 = 0;
      return out;
    }

    det = 1.0 / det;
    out.m00 = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out.m01 = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out.m02 = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out.m03 = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out.m04 = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out.m05 = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out.m06 = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out.m07 = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out.m08 = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out.m09 = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out.m10 = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out.m11 = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out.m12 = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out.m13 = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out.m14 = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out.m15 = (a20 * b03 - a21 * b01 + a22 * b00) * det;
    return out;
  };

  Mat4.determinant = function determinant(a) {
    var a00 = a.m00;
    var a01 = a.m01;
    var a02 = a.m02;
    var a03 = a.m03;
    var a10 = a.m04;
    var a11 = a.m05;
    var a12 = a.m06;
    var a13 = a.m07;
    var a20 = a.m08;
    var a21 = a.m09;
    var a22 = a.m10;
    var a23 = a.m11;
    var a30 = a.m12;
    var a31 = a.m13;
    var a32 = a.m14;
    var a33 = a.m15;
    var b00 = a00 * a11 - a01 * a10;
    var b01 = a00 * a12 - a02 * a10;
    var b02 = a00 * a13 - a03 * a10;
    var b03 = a01 * a12 - a02 * a11;
    var b04 = a01 * a13 - a03 * a11;
    var b05 = a02 * a13 - a03 * a12;
    var b06 = a20 * a31 - a21 * a30;
    var b07 = a20 * a32 - a22 * a30;
    var b08 = a20 * a33 - a23 * a30;
    var b09 = a21 * a32 - a22 * a31;
    var b10 = a21 * a33 - a23 * a31;
    var b11 = a22 * a33 - a23 * a32;
    return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
  };

  Mat4.multiply = function multiply(out, a, b) {
    var a00 = a.m00;
    var a01 = a.m01;
    var a02 = a.m02;
    var a03 = a.m03;
    var a10 = a.m04;
    var a11 = a.m05;
    var a12 = a.m06;
    var a13 = a.m07;
    var a20 = a.m08;
    var a21 = a.m09;
    var a22 = a.m10;
    var a23 = a.m11;
    var a30 = a.m12;
    var a31 = a.m13;
    var a32 = a.m14;
    var a33 = a.m15;
    var b0 = b.m00;
    var b1 = b.m01;
    var b2 = b.m02;
    var b3 = b.m03;
    out.m00 = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out.m01 = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out.m02 = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out.m03 = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b.m04;
    b1 = b.m05;
    b2 = b.m06;
    b3 = b.m07;
    out.m04 = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out.m05 = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out.m06 = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out.m07 = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b.m08;
    b1 = b.m09;
    b2 = b.m10;
    b3 = b.m11;
    out.m08 = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out.m09 = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out.m10 = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out.m11 = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b.m12;
    b1 = b.m13;
    b2 = b.m14;
    b3 = b.m15;
    out.m12 = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out.m13 = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out.m14 = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out.m15 = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    return out;
  };

  Mat4.transform = function transform(out, a, v) {
    var x = v.x;
    var y = v.y;
    var z = v.z;

    if (a === out) {
      out.m12 = a.m00 * x + a.m04 * y + a.m08 * z + a.m12;
      out.m13 = a.m01 * x + a.m05 * y + a.m09 * z + a.m13;
      out.m14 = a.m02 * x + a.m06 * y + a.m10 * z + a.m14;
      out.m15 = a.m03 * x + a.m07 * y + a.m11 * z + a.m15;
    } else {
      var a00 = a.m00;
      var a01 = a.m01;
      var a02 = a.m02;
      var a03 = a.m03;
      var a10 = a.m04;
      var a11 = a.m05;
      var a12 = a.m06;
      var a13 = a.m07;
      var a20 = a.m08;
      var a21 = a.m09;
      var a22 = a.m10;
      var a23 = a.m11;
      var a30 = a.m12;
      var a31 = a.m13;
      var a32 = a.m14;
      var a33 = a.m15;
      out.m00 = a00;
      out.m01 = a01;
      out.m02 = a02;
      out.m03 = a03;
      out.m04 = a10;
      out.m05 = a11;
      out.m06 = a12;
      out.m07 = a13;
      out.m08 = a20;
      out.m09 = a21;
      out.m10 = a22;
      out.m11 = a23;
      out.m12 = a00 * x + a10 * y + a20 * z + a.m12;
      out.m13 = a01 * x + a11 * y + a21 * z + a.m13;
      out.m14 = a02 * x + a12 * y + a22 * z + a.m14;
      out.m15 = a03 * x + a13 * y + a23 * z + a.m15;
    }

    return out;
  };

  Mat4.translate = function translate(out, a, v) {
    console.warn('function changed');

    if (a === out) {
      out.m12 += v.x;
      out.m13 += v.y;
      out.m14 += v.z;
    } else {
      out.m00 = a.m00;
      out.m01 = a.m01;
      out.m02 = a.m02;
      out.m03 = a.m03;
      out.m04 = a.m04;
      out.m05 = a.m05;
      out.m06 = a.m06;
      out.m07 = a.m07;
      out.m08 = a.m08;
      out.m09 = a.m09;
      out.m10 = a.m10;
      out.m11 = a.m11;
      out.m12 += v.x;
      out.m13 += v.y;
      out.m14 += v.z;
      out.m15 = a.m15;
    }

    return out;
  };

  Mat4.scale = function scale(out, a, v) {
    var x = v.x;
    var y = v.y;
    var z = v.z;
    out.m00 = a.m00 * x;
    out.m01 = a.m01 * x;
    out.m02 = a.m02 * x;
    out.m03 = a.m03 * x;
    out.m04 = a.m04 * y;
    out.m05 = a.m05 * y;
    out.m06 = a.m06 * y;
    out.m07 = a.m07 * y;
    out.m08 = a.m08 * z;
    out.m09 = a.m09 * z;
    out.m10 = a.m10 * z;
    out.m11 = a.m11 * z;
    out.m12 = a.m12;
    out.m13 = a.m13;
    out.m14 = a.m14;
    out.m15 = a.m15;
    return out;
  };

  Mat4.rotate = function rotate(out, a, rad, axis) {
    var x = axis.x;
    var y = axis.y;
    var z = axis.z;
    var len = Math.sqrt(x * x + y * y + z * z);

    if (Math.abs(len) < EPSILON) {
      return null;
    }

    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    var t = 1 - c;
    var a00 = a.m00;
    var a01 = a.m01;
    var a02 = a.m02;
    var a03 = a.m03;
    var a10 = a.m04;
    var a11 = a.m05;
    var a12 = a.m06;
    var a13 = a.m07;
    var a20 = a.m08;
    var a21 = a.m09;
    var a22 = a.m10;
    var a23 = a.m11;
    var b00 = x * x * t + c;
    var b01 = y * x * t + z * s;
    var b02 = z * x * t - y * s;
    var b10 = x * y * t - z * s;
    var b11 = y * y * t + c;
    var b12 = z * y * t + x * s;
    var b20 = x * z * t + y * s;
    var b21 = y * z * t - x * s;
    var b22 = z * z * t + c;
    out.m00 = a00 * b00 + a10 * b01 + a20 * b02;
    out.m01 = a01 * b00 + a11 * b01 + a21 * b02;
    out.m02 = a02 * b00 + a12 * b01 + a22 * b02;
    out.m03 = a03 * b00 + a13 * b01 + a23 * b02;
    out.m04 = a00 * b10 + a10 * b11 + a20 * b12;
    out.m05 = a01 * b10 + a11 * b11 + a21 * b12;
    out.m06 = a02 * b10 + a12 * b11 + a22 * b12;
    out.m07 = a03 * b10 + a13 * b11 + a23 * b12;
    out.m08 = a00 * b20 + a10 * b21 + a20 * b22;
    out.m09 = a01 * b20 + a11 * b21 + a21 * b22;
    out.m10 = a02 * b20 + a12 * b21 + a22 * b22;
    out.m11 = a03 * b20 + a13 * b21 + a23 * b22;

    if (a !== out) {
      out.m12 = a.m12;
      out.m13 = a.m13;
      out.m14 = a.m14;
      out.m15 = a.m15;
    }

    return out;
  };

  Mat4.rotateX = function rotateX(out, a, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    var a10 = a.m04;
    var a11 = a.m05;
    var a12 = a.m06;
    var a13 = a.m07;
    var a20 = a.m08;
    var a21 = a.m09;
    var a22 = a.m10;
    var a23 = a.m11;

    if (a !== out) {
      out.m00 = a.m00;
      out.m01 = a.m01;
      out.m02 = a.m02;
      out.m03 = a.m03;
      out.m12 = a.m12;
      out.m13 = a.m13;
      out.m14 = a.m14;
      out.m15 = a.m15;
    }

    out.m04 = a10 * c + a20 * s;
    out.m05 = a11 * c + a21 * s;
    out.m06 = a12 * c + a22 * s;
    out.m07 = a13 * c + a23 * s;
    out.m08 = a20 * c - a10 * s;
    out.m09 = a21 * c - a11 * s;
    out.m10 = a22 * c - a12 * s;
    out.m11 = a23 * c - a13 * s;
    return out;
  };

  Mat4.rotateY = function rotateY(out, a, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    var a00 = a.m00;
    var a01 = a.m01;
    var a02 = a.m02;
    var a03 = a.m03;
    var a20 = a.m08;
    var a21 = a.m09;
    var a22 = a.m10;
    var a23 = a.m11;

    if (a !== out) {
      out.m04 = a.m04;
      out.m05 = a.m05;
      out.m06 = a.m06;
      out.m07 = a.m07;
      out.m12 = a.m12;
      out.m13 = a.m13;
      out.m14 = a.m14;
      out.m15 = a.m15;
    }

    out.m00 = a00 * c - a20 * s;
    out.m01 = a01 * c - a21 * s;
    out.m02 = a02 * c - a22 * s;
    out.m03 = a03 * c - a23 * s;
    out.m08 = a00 * s + a20 * c;
    out.m09 = a01 * s + a21 * c;
    out.m10 = a02 * s + a22 * c;
    out.m11 = a03 * s + a23 * c;
    return out;
  };

  Mat4.rotateZ = function rotateZ(out, a, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    var a00 = a.m00;
    var a01 = a.m01;
    var a02 = a.m02;
    var a03 = a.m03;
    var a10 = a.m04;
    var a11 = a.m05;
    var a12 = a.m06;
    var a13 = a.m07;

    if (a !== out) {
      out.m08 = a.m08;
      out.m09 = a.m09;
      out.m10 = a.m10;
      out.m11 = a.m11;
      out.m12 = a.m12;
      out.m13 = a.m13;
      out.m14 = a.m14;
      out.m15 = a.m15;
    }

    out.m00 = a00 * c + a10 * s;
    out.m01 = a01 * c + a11 * s;
    out.m02 = a02 * c + a12 * s;
    out.m03 = a03 * c + a13 * s;
    out.m04 = a10 * c - a00 * s;
    out.m05 = a11 * c - a01 * s;
    out.m06 = a12 * c - a02 * s;
    out.m07 = a13 * c - a03 * s;
    return out;
  };

  Mat4.fromTranslation = function fromTranslation(out, v) {
    out.m00 = 1;
    out.m01 = 0;
    out.m02 = 0;
    out.m03 = 0;
    out.m04 = 0;
    out.m05 = 1;
    out.m06 = 0;
    out.m07 = 0;
    out.m08 = 0;
    out.m09 = 0;
    out.m10 = 1;
    out.m11 = 0;
    out.m12 = v.x;
    out.m13 = v.y;
    out.m14 = v.z;
    out.m15 = 1;
    return out;
  };

  Mat4.fromScaling = function fromScaling(out, v) {
    out.m00 = v.x;
    out.m01 = 0;
    out.m02 = 0;
    out.m03 = 0;
    out.m04 = 0;
    out.m05 = v.y;
    out.m06 = 0;
    out.m07 = 0;
    out.m08 = 0;
    out.m09 = 0;
    out.m10 = v.z;
    out.m11 = 0;
    out.m12 = 0;
    out.m13 = 0;
    out.m14 = 0;
    out.m15 = 1;
    return out;
  };

  Mat4.fromRotation = function fromRotation(out, rad, axis) {
    var x = axis.x;
    var y = axis.y;
    var z = axis.z;
    var len = Math.sqrt(x * x + y * y + z * z);

    if (Math.abs(len) < EPSILON) {
      return null;
    }

    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    var t = 1 - c;
    out.m00 = x * x * t + c;
    out.m01 = y * x * t + z * s;
    out.m02 = z * x * t - y * s;
    out.m03 = 0;
    out.m04 = x * y * t - z * s;
    out.m05 = y * y * t + c;
    out.m06 = z * y * t + x * s;
    out.m07 = 0;
    out.m08 = x * z * t + y * s;
    out.m09 = y * z * t - x * s;
    out.m10 = z * z * t + c;
    out.m11 = 0;
    out.m12 = 0;
    out.m13 = 0;
    out.m14 = 0;
    out.m15 = 1;
    return out;
  };

  Mat4.fromXRotation = function fromXRotation(out, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    out.m00 = 1;
    out.m01 = 0;
    out.m02 = 0;
    out.m03 = 0;
    out.m04 = 0;
    out.m05 = c;
    out.m06 = s;
    out.m07 = 0;
    out.m08 = 0;
    out.m09 = -s;
    out.m10 = c;
    out.m11 = 0;
    out.m12 = 0;
    out.m13 = 0;
    out.m14 = 0;
    out.m15 = 1;
    return out;
  };

  Mat4.fromYRotation = function fromYRotation(out, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    out.m00 = c;
    out.m01 = 0;
    out.m02 = -s;
    out.m03 = 0;
    out.m04 = 0;
    out.m05 = 1;
    out.m06 = 0;
    out.m07 = 0;
    out.m08 = s;
    out.m09 = 0;
    out.m10 = c;
    out.m11 = 0;
    out.m12 = 0;
    out.m13 = 0;
    out.m14 = 0;
    out.m15 = 1;
    return out;
  };

  Mat4.fromZRotation = function fromZRotation(out, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    out.m00 = c;
    out.m01 = s;
    out.m02 = 0;
    out.m03 = 0;
    out.m04 = -s;
    out.m05 = c;
    out.m06 = 0;
    out.m07 = 0;
    out.m08 = 0;
    out.m09 = 0;
    out.m10 = 1;
    out.m11 = 0;
    out.m12 = 0;
    out.m13 = 0;
    out.m14 = 0;
    out.m15 = 1;
    return out;
  };

  Mat4.fromRT = function fromRT(out, q, v) {
    var x = q.x;
    var y = q.y;
    var z = q.z;
    var w = q.w;
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var xy = x * y2;
    var xz = x * z2;
    var yy = y * y2;
    var yz = y * z2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    out.m00 = 1 - (yy + zz);
    out.m01 = xy + wz;
    out.m02 = xz - wy;
    out.m03 = 0;
    out.m04 = xy - wz;
    out.m05 = 1 - (xx + zz);
    out.m06 = yz + wx;
    out.m07 = 0;
    out.m08 = xz + wy;
    out.m09 = yz - wx;
    out.m10 = 1 - (xx + yy);
    out.m11 = 0;
    out.m12 = v.x;
    out.m13 = v.y;
    out.m14 = v.z;
    out.m15 = 1;
    return out;
  };

  Mat4.getTranslation = function getTranslation(out, mat) {
    out.x = mat.m12;
    out.y = mat.m13;
    out.z = mat.m14;
    return out;
  };

  Mat4.getScaling = function getScaling(out, mat) {
    var m00 = m3_1$1.m00 = mat.m00;
    var m01 = m3_1$1.m01 = mat.m01;
    var m02 = m3_1$1.m02 = mat.m02;
    var m04 = m3_1$1.m03 = mat.m04;
    var m05 = m3_1$1.m04 = mat.m05;
    var m06 = m3_1$1.m05 = mat.m06;
    var m08 = m3_1$1.m06 = mat.m08;
    var m09 = m3_1$1.m07 = mat.m09;
    var m10 = m3_1$1.m08 = mat.m10;
    out.x = Math.sqrt(m00 * m00 + m01 * m01 + m02 * m02);
    out.y = Math.sqrt(m04 * m04 + m05 * m05 + m06 * m06);
    out.z = Math.sqrt(m08 * m08 + m09 * m09 + m10 * m10);

    if (Mat3.determinant(m3_1$1) < 0) {
      out.x *= -1;
    }

    return out;
  };

  Mat4.getRotation = function getRotation(out, mat) {
    var trace = mat.m00 + mat.m05 + mat.m10;
    var S = 0;

    if (trace > 0) {
      S = Math.sqrt(trace + 1.0) * 2;
      out.w = 0.25 * S;
      out.x = (mat.m06 - mat.m09) / S;
      out.y = (mat.m08 - mat.m02) / S;
      out.z = (mat.m01 - mat.m04) / S;
    } else if (mat.m00 > mat.m05 && mat.m00 > mat.m10) {
      S = Math.sqrt(1.0 + mat.m00 - mat.m05 - mat.m10) * 2;
      out.w = (mat.m06 - mat.m09) / S;
      out.x = 0.25 * S;
      out.y = (mat.m01 + mat.m04) / S;
      out.z = (mat.m08 + mat.m02) / S;
    } else if (mat.m05 > mat.m10) {
      S = Math.sqrt(1.0 + mat.m05 - mat.m00 - mat.m10) * 2;
      out.w = (mat.m08 - mat.m02) / S;
      out.x = (mat.m01 + mat.m04) / S;
      out.y = 0.25 * S;
      out.z = (mat.m06 + mat.m09) / S;
    } else {
      S = Math.sqrt(1.0 + mat.m10 - mat.m00 - mat.m05) * 2;
      out.w = (mat.m01 - mat.m04) / S;
      out.x = (mat.m08 + mat.m02) / S;
      out.y = (mat.m06 + mat.m09) / S;
      out.z = 0.25 * S;
    }

    return out;
  };

  Mat4.toRTS = function toRTS(m, q, v, s) {
    s.x = Vec3.set(v3_1$3, m.m00, m.m01, m.m02).length();
    m3_1$1.m00 = m.m00 / s.x;
    m3_1$1.m01 = m.m01 / s.x;
    m3_1$1.m02 = m.m02 / s.x;
    s.y = Vec3.set(v3_1$3, m.m04, m.m05, m.m06).length();
    m3_1$1.m03 = m.m04 / s.y;
    m3_1$1.m04 = m.m05 / s.y;
    m3_1$1.m05 = m.m06 / s.y;
    s.z = Vec3.set(v3_1$3, m.m08, m.m09, m.m10).length();
    m3_1$1.m06 = m.m08 / s.z;
    m3_1$1.m07 = m.m09 / s.z;
    m3_1$1.m08 = m.m10 / s.z;
    var det = Mat3.determinant(m3_1$1);

    if (det < 0) {
      s.x *= -1;
      m3_1$1.m00 *= -1;
      m3_1$1.m01 *= -1;
      m3_1$1.m02 *= -1;
    }

    Quat.fromMat3(q, m3_1$1);
    Vec3.set(v, m.m12, m.m13, m.m14);
  };

  Mat4.fromRTS = function fromRTS(out, q, v, s) {
    var x = q.x;
    var y = q.y;
    var z = q.z;
    var w = q.w;
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var xy = x * y2;
    var xz = x * z2;
    var yy = y * y2;
    var yz = y * z2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    var sx = s.x;
    var sy = s.y;
    var sz = s.z;
    out.m00 = (1 - (yy + zz)) * sx;
    out.m01 = (xy + wz) * sx;
    out.m02 = (xz - wy) * sx;
    out.m03 = 0;
    out.m04 = (xy - wz) * sy;
    out.m05 = (1 - (xx + zz)) * sy;
    out.m06 = (yz + wx) * sy;
    out.m07 = 0;
    out.m08 = (xz + wy) * sz;
    out.m09 = (yz - wx) * sz;
    out.m10 = (1 - (xx + yy)) * sz;
    out.m11 = 0;
    out.m12 = v.x;
    out.m13 = v.y;
    out.m14 = v.z;
    out.m15 = 1;
    return out;
  };

  Mat4.fromRTSOrigin = function fromRTSOrigin(out, q, v, s, o) {
    var x = q.x;
    var y = q.y;
    var z = q.z;
    var w = q.w;
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var xy = x * y2;
    var xz = x * z2;
    var yy = y * y2;
    var yz = y * z2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    var sx = s.x;
    var sy = s.y;
    var sz = s.z;
    var ox = o.x;
    var oy = o.y;
    var oz = o.z;
    out.m00 = (1 - (yy + zz)) * sx;
    out.m01 = (xy + wz) * sx;
    out.m02 = (xz - wy) * sx;
    out.m03 = 0;
    out.m04 = (xy - wz) * sy;
    out.m05 = (1 - (xx + zz)) * sy;
    out.m06 = (yz + wx) * sy;
    out.m07 = 0;
    out.m08 = (xz + wy) * sz;
    out.m09 = (yz - wx) * sz;
    out.m10 = (1 - (xx + yy)) * sz;
    out.m11 = 0;
    out.m12 = v.x + ox - (out.m00 * ox + out.m04 * oy + out.m08 * oz);
    out.m13 = v.y + oy - (out.m01 * ox + out.m05 * oy + out.m09 * oz);
    out.m14 = v.z + oz - (out.m02 * ox + out.m06 * oy + out.m10 * oz);
    out.m15 = 1;
    return out;
  };

  Mat4.fromQuat = function fromQuat(out, q) {
    var x = q.x;
    var y = q.y;
    var z = q.z;
    var w = q.w;
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var yx = y * x2;
    var yy = y * y2;
    var zx = z * x2;
    var zy = z * y2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    out.m00 = 1 - yy - zz;
    out.m01 = yx + wz;
    out.m02 = zx - wy;
    out.m03 = 0;
    out.m04 = yx - wz;
    out.m05 = 1 - xx - zz;
    out.m06 = zy + wx;
    out.m07 = 0;
    out.m08 = zx + wy;
    out.m09 = zy - wx;
    out.m10 = 1 - xx - yy;
    out.m11 = 0;
    out.m12 = 0;
    out.m13 = 0;
    out.m14 = 0;
    out.m15 = 1;
    return out;
  };

  Mat4.frustum = function frustum(out, left, right, bottom, top, near, far) {
    var rl = 1 / (right - left);
    var tb = 1 / (top - bottom);
    var nf = 1 / (near - far);
    out.m00 = near * 2 * rl;
    out.m01 = 0;
    out.m02 = 0;
    out.m03 = 0;
    out.m04 = 0;
    out.m05 = near * 2 * tb;
    out.m06 = 0;
    out.m07 = 0;
    out.m08 = (right + left) * rl;
    out.m09 = (top + bottom) * tb;
    out.m10 = (far + near) * nf;
    out.m11 = -1;
    out.m12 = 0;
    out.m13 = 0;
    out.m14 = far * near * 2 * nf;
    out.m15 = 0;
    return out;
  };

  Mat4.perspective = function perspective(out, fov, aspect, near, far, isFOVY, minClipZ, projectionSignY, orientation) {
    if (isFOVY === void 0) {
      isFOVY = true;
    }

    if (minClipZ === void 0) {
      minClipZ = -1;
    }

    if (projectionSignY === void 0) {
      projectionSignY = 1;
    }

    if (orientation === void 0) {
      orientation = 0;
    }

    var f = 1.0 / Math.tan(fov / 2);
    var nf = 1 / (near - far);
    var x = isFOVY ? f / aspect : f;
    var y = (isFOVY ? f : f * aspect) * projectionSignY;
    var preTransform = preTransforms[orientation];
    out.m00 = x * preTransform[0];
    out.m01 = x * preTransform[1];
    out.m02 = 0;
    out.m03 = 0;
    out.m04 = y * preTransform[2];
    out.m05 = y * preTransform[3];
    out.m06 = 0;
    out.m07 = 0;
    out.m08 = 0;
    out.m09 = 0;
    out.m10 = (far - minClipZ * near) * nf;
    out.m11 = -1;
    out.m12 = 0;
    out.m13 = 0;
    out.m14 = far * near * nf * (1 - minClipZ);
    out.m15 = 0;
    return out;
  };

  Mat4.ortho = function ortho(out, left, right, bottom, top, near, far, minClipZ, projectionSignY, orientation) {
    if (minClipZ === void 0) {
      minClipZ = -1;
    }

    if (projectionSignY === void 0) {
      projectionSignY = 1;
    }

    if (orientation === void 0) {
      orientation = 0;
    }

    var lr = 1 / (left - right);
    var bt = 1 / (bottom - top) * projectionSignY;
    var nf = 1 / (near - far);
    var x = -2 * lr;
    var y = -2 * bt;
    var dx = (left + right) * lr;
    var dy = (top + bottom) * bt;
    var preTransform = preTransforms[orientation];
    out.m00 = x * preTransform[0];
    out.m01 = x * preTransform[1];
    out.m02 = 0;
    out.m03 = 0;
    out.m04 = y * preTransform[2];
    out.m05 = y * preTransform[3];
    out.m06 = 0;
    out.m07 = 0;
    out.m08 = 0;
    out.m09 = 0;
    out.m10 = nf * (1 - minClipZ);
    out.m11 = 0;
    out.m12 = dx * preTransform[0] + dy * preTransform[2];
    out.m13 = dx * preTransform[1] + dy * preTransform[3];
    out.m14 = (near - minClipZ * far) * nf;
    out.m15 = 1;
    return out;
  };

  Mat4.lookAt = function lookAt(out, eye, center, up) {
    var eyex = eye.x;
    var eyey = eye.y;
    var eyez = eye.z;
    var upx = up.x;
    var upy = up.y;
    var upz = up.z;
    var centerx = center.x;
    var centery = center.y;
    var centerz = center.z;
    var z0 = eyex - centerx;
    var z1 = eyey - centery;
    var z2 = eyez - centerz;
    var len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
    z0 *= len;
    z1 *= len;
    z2 *= len;
    var x0 = upy * z2 - upz * z1;
    var x1 = upz * z0 - upx * z2;
    var x2 = upx * z1 - upy * z0;
    len = 1 / Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
    x0 *= len;
    x1 *= len;
    x2 *= len;
    var y0 = z1 * x2 - z2 * x1;
    var y1 = z2 * x0 - z0 * x2;
    var y2 = z0 * x1 - z1 * x0;
    out.m00 = x0;
    out.m01 = y0;
    out.m02 = z0;
    out.m03 = 0;
    out.m04 = x1;
    out.m05 = y1;
    out.m06 = z1;
    out.m07 = 0;
    out.m08 = x2;
    out.m09 = y2;
    out.m10 = z2;
    out.m11 = 0;
    out.m12 = -(x0 * eyex + x1 * eyey + x2 * eyez);
    out.m13 = -(y0 * eyex + y1 * eyey + y2 * eyez);
    out.m14 = -(z0 * eyex + z1 * eyey + z2 * eyez);
    out.m15 = 1;
    return out;
  };

  Mat4.inverseTranspose = function inverseTranspose(out, a) {
    var a00 = a.m00;
    var a01 = a.m01;
    var a02 = a.m02;
    var a03 = a.m03;
    var a10 = a.m04;
    var a11 = a.m05;
    var a12 = a.m06;
    var a13 = a.m07;
    var a20 = a.m08;
    var a21 = a.m09;
    var a22 = a.m10;
    var a23 = a.m11;
    var a30 = a.m12;
    var a31 = a.m13;
    var a32 = a.m14;
    var a33 = a.m15;
    var b00 = a00 * a11 - a01 * a10;
    var b01 = a00 * a12 - a02 * a10;
    var b02 = a00 * a13 - a03 * a10;
    var b03 = a01 * a12 - a02 * a11;
    var b04 = a01 * a13 - a03 * a11;
    var b05 = a02 * a13 - a03 * a12;
    var b06 = a20 * a31 - a21 * a30;
    var b07 = a20 * a32 - a22 * a30;
    var b08 = a20 * a33 - a23 * a30;
    var b09 = a21 * a32 - a22 * a31;
    var b10 = a21 * a33 - a23 * a31;
    var b11 = a22 * a33 - a23 * a32;
    var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (!det) {
      return null;
    }

    det = 1.0 / det;
    out.m00 = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out.m01 = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out.m02 = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out.m03 = 0;
    out.m04 = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out.m05 = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out.m06 = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out.m07 = 0;
    out.m08 = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out.m09 = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out.m10 = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out.m11 = 0;
    out.m12 = 0;
    out.m13 = 0;
    out.m14 = 0;
    out.m15 = 1;
    return out;
  };

  Mat4.toArray = function toArray(out, m, ofs) {
    if (ofs === void 0) {
      ofs = 0;
    }

    out[ofs + 0] = m.m00;
    out[ofs + 1] = m.m01;
    out[ofs + 2] = m.m02;
    out[ofs + 3] = m.m03;
    out[ofs + 4] = m.m04;
    out[ofs + 5] = m.m05;
    out[ofs + 6] = m.m06;
    out[ofs + 7] = m.m07;
    out[ofs + 8] = m.m08;
    out[ofs + 9] = m.m09;
    out[ofs + 10] = m.m10;
    out[ofs + 11] = m.m11;
    out[ofs + 12] = m.m12;
    out[ofs + 13] = m.m13;
    out[ofs + 14] = m.m14;
    out[ofs + 15] = m.m15;
    return out;
  };

  Mat4.fromArray = function fromArray(out, arr, ofs) {
    if (ofs === void 0) {
      ofs = 0;
    }

    out.m00 = arr[ofs + 0];
    out.m01 = arr[ofs + 1];
    out.m02 = arr[ofs + 2];
    out.m03 = arr[ofs + 3];
    out.m04 = arr[ofs + 4];
    out.m05 = arr[ofs + 5];
    out.m06 = arr[ofs + 6];
    out.m07 = arr[ofs + 7];
    out.m08 = arr[ofs + 8];
    out.m09 = arr[ofs + 9];
    out.m10 = arr[ofs + 10];
    out.m11 = arr[ofs + 11];
    out.m12 = arr[ofs + 12];
    out.m13 = arr[ofs + 13];
    out.m14 = arr[ofs + 14];
    out.m15 = arr[ofs + 15];
    return out;
  };

  Mat4.add = function add(out, a, b) {
    out.m00 = a.m00 + b.m00;
    out.m01 = a.m01 + b.m01;
    out.m02 = a.m02 + b.m02;
    out.m03 = a.m03 + b.m03;
    out.m04 = a.m04 + b.m04;
    out.m05 = a.m05 + b.m05;
    out.m06 = a.m06 + b.m06;
    out.m07 = a.m07 + b.m07;
    out.m08 = a.m08 + b.m08;
    out.m09 = a.m09 + b.m09;
    out.m10 = a.m10 + b.m10;
    out.m11 = a.m11 + b.m11;
    out.m12 = a.m12 + b.m12;
    out.m13 = a.m13 + b.m13;
    out.m14 = a.m14 + b.m14;
    out.m15 = a.m15 + b.m15;
    return out;
  };

  Mat4.subtract = function subtract(out, a, b) {
    out.m00 = a.m00 - b.m00;
    out.m01 = a.m01 - b.m01;
    out.m02 = a.m02 - b.m02;
    out.m03 = a.m03 - b.m03;
    out.m04 = a.m04 - b.m04;
    out.m05 = a.m05 - b.m05;
    out.m06 = a.m06 - b.m06;
    out.m07 = a.m07 - b.m07;
    out.m08 = a.m08 - b.m08;
    out.m09 = a.m09 - b.m09;
    out.m10 = a.m10 - b.m10;
    out.m11 = a.m11 - b.m11;
    out.m12 = a.m12 - b.m12;
    out.m13 = a.m13 - b.m13;
    out.m14 = a.m14 - b.m14;
    out.m15 = a.m15 - b.m15;
    return out;
  };

  Mat4.multiplyScalar = function multiplyScalar(out, a, b) {
    out.m00 = a.m00 * b;
    out.m01 = a.m01 * b;
    out.m02 = a.m02 * b;
    out.m03 = a.m03 * b;
    out.m04 = a.m04 * b;
    out.m05 = a.m05 * b;
    out.m06 = a.m06 * b;
    out.m07 = a.m07 * b;
    out.m08 = a.m08 * b;
    out.m09 = a.m09 * b;
    out.m10 = a.m10 * b;
    out.m11 = a.m11 * b;
    out.m12 = a.m12 * b;
    out.m13 = a.m13 * b;
    out.m14 = a.m14 * b;
    out.m15 = a.m15 * b;
    return out;
  };

  Mat4.multiplyScalarAndAdd = function multiplyScalarAndAdd(out, a, b, scale) {
    out.m00 = a.m00 + b.m00 * scale;
    out.m01 = a.m01 + b.m01 * scale;
    out.m02 = a.m02 + b.m02 * scale;
    out.m03 = a.m03 + b.m03 * scale;
    out.m04 = a.m04 + b.m04 * scale;
    out.m05 = a.m05 + b.m05 * scale;
    out.m06 = a.m06 + b.m06 * scale;
    out.m07 = a.m07 + b.m07 * scale;
    out.m08 = a.m08 + b.m08 * scale;
    out.m09 = a.m09 + b.m09 * scale;
    out.m10 = a.m10 + b.m10 * scale;
    out.m11 = a.m11 + b.m11 * scale;
    out.m12 = a.m12 + b.m12 * scale;
    out.m13 = a.m13 + b.m13 * scale;
    out.m14 = a.m14 + b.m14 * scale;
    out.m15 = a.m15 + b.m15 * scale;
    return out;
  };

  Mat4.strictEquals = function strictEquals(a, b) {
    return a.m00 === b.m00 && a.m01 === b.m01 && a.m02 === b.m02 && a.m03 === b.m03 && a.m04 === b.m04 && a.m05 === b.m05 && a.m06 === b.m06 && a.m07 === b.m07 && a.m08 === b.m08 && a.m09 === b.m09 && a.m10 === b.m10 && a.m11 === b.m11 && a.m12 === b.m12 && a.m13 === b.m13 && a.m14 === b.m14 && a.m15 === b.m15;
  };

  Mat4.equals = function equals(a, b, epsilon) {
    if (epsilon === void 0) {
      epsilon = EPSILON;
    }

    return Math.abs(a.m00 - b.m00) <= epsilon * Math.max(1.0, Math.abs(a.m00), Math.abs(b.m00)) && Math.abs(a.m01 - b.m01) <= epsilon * Math.max(1.0, Math.abs(a.m01), Math.abs(b.m01)) && Math.abs(a.m02 - b.m02) <= epsilon * Math.max(1.0, Math.abs(a.m02), Math.abs(b.m02)) && Math.abs(a.m03 - b.m03) <= epsilon * Math.max(1.0, Math.abs(a.m03), Math.abs(b.m03)) && Math.abs(a.m04 - b.m04) <= epsilon * Math.max(1.0, Math.abs(a.m04), Math.abs(b.m04)) && Math.abs(a.m05 - b.m05) <= epsilon * Math.max(1.0, Math.abs(a.m05), Math.abs(b.m05)) && Math.abs(a.m06 - b.m06) <= epsilon * Math.max(1.0, Math.abs(a.m06), Math.abs(b.m06)) && Math.abs(a.m07 - b.m07) <= epsilon * Math.max(1.0, Math.abs(a.m07), Math.abs(b.m07)) && Math.abs(a.m08 - b.m08) <= epsilon * Math.max(1.0, Math.abs(a.m08), Math.abs(b.m08)) && Math.abs(a.m09 - b.m09) <= epsilon * Math.max(1.0, Math.abs(a.m09), Math.abs(b.m09)) && Math.abs(a.m10 - b.m10) <= epsilon * Math.max(1.0, Math.abs(a.m10), Math.abs(b.m10)) && Math.abs(a.m11 - b.m11) <= epsilon * Math.max(1.0, Math.abs(a.m11), Math.abs(b.m11)) && Math.abs(a.m12 - b.m12) <= epsilon * Math.max(1.0, Math.abs(a.m12), Math.abs(b.m12)) && Math.abs(a.m13 - b.m13) <= epsilon * Math.max(1.0, Math.abs(a.m13), Math.abs(b.m13)) && Math.abs(a.m14 - b.m14) <= epsilon * Math.max(1.0, Math.abs(a.m14), Math.abs(b.m14)) && Math.abs(a.m15 - b.m15) <= epsilon * Math.max(1.0, Math.abs(a.m15), Math.abs(b.m15));
  };

  _createClass(Mat4, [{
    key: "m00",
    get: function get() {
      return this._array[0];
    },
    set: function set(m) {
      this._array[0] = m;
    }
  }, {
    key: "m01",
    get: function get() {
      return this._array[1];
    },
    set: function set(m) {
      this._array[1] = m;
    }
  }, {
    key: "m02",
    get: function get() {
      return this._array[2];
    },
    set: function set(m) {
      this._array[2] = m;
    }
  }, {
    key: "m03",
    get: function get() {
      return this._array[3];
    },
    set: function set(m) {
      this._array[3] = m;
    }
  }, {
    key: "m04",
    get: function get() {
      return this._array[4];
    },
    set: function set(m) {
      this._array[4] = m;
    }
  }, {
    key: "m05",
    get: function get() {
      return this._array[5];
    },
    set: function set(m) {
      this._array[5] = m;
    }
  }, {
    key: "m06",
    get: function get() {
      return this._array[6];
    },
    set: function set(m) {
      this._array[6] = m;
    }
  }, {
    key: "m07",
    get: function get() {
      return this._array[7];
    },
    set: function set(m) {
      this._array[7] = m;
    }
  }, {
    key: "m08",
    get: function get() {
      return this._array[8];
    },
    set: function set(m) {
      this._array[8] = m;
    }
  }, {
    key: "m09",
    get: function get() {
      return this._array[9];
    },
    set: function set(m) {
      this._array[9] = m;
    }
  }, {
    key: "m10",
    get: function get() {
      return this._array[10];
    },
    set: function set(m) {
      this._array[10] = m;
    }
  }, {
    key: "m11",
    get: function get() {
      return this._array[11];
    },
    set: function set(m) {
      this._array[11] = m;
    }
  }, {
    key: "m12",
    get: function get() {
      return this._array[12];
    },
    set: function set(m) {
      this._array[12] = m;
    }
  }, {
    key: "m13",
    get: function get() {
      return this._array[13];
    },
    set: function set(m) {
      this._array[13] = m;
    }
  }, {
    key: "m14",
    get: function get() {
      return this._array[14];
    },
    set: function set(m) {
      this._array[14] = m;
    }
  }, {
    key: "m15",
    get: function get() {
      return this._array[15];
    },
    set: function set(m) {
      this._array[15] = m;
    }
  }]);

  function Mat4(m00, m01, m02, m03, m04, m05, m06, m07, m08, m09, m10, m11, m12, m13, m14, m15) {
    var _this;

    if (m00 === void 0) {
      m00 = 1;
    }

    if (m01 === void 0) {
      m01 = 0;
    }

    if (m02 === void 0) {
      m02 = 0;
    }

    if (m03 === void 0) {
      m03 = 0;
    }

    if (m04 === void 0) {
      m04 = 0;
    }

    if (m05 === void 0) {
      m05 = 1;
    }

    if (m06 === void 0) {
      m06 = 0;
    }

    if (m07 === void 0) {
      m07 = 0;
    }

    if (m08 === void 0) {
      m08 = 0;
    }

    if (m09 === void 0) {
      m09 = 0;
    }

    if (m10 === void 0) {
      m10 = 1;
    }

    if (m11 === void 0) {
      m11 = 0;
    }

    if (m12 === void 0) {
      m12 = 0;
    }

    if (m13 === void 0) {
      m13 = 0;
    }

    if (m14 === void 0) {
      m14 = 0;
    }

    if (m15 === void 0) {
      m15 = 1;
    }

    _this = _MathBase.call(this) || this;

    if (m00 && typeof m00 === 'object') {
      if (ArrayBuffer.isView(m00)) {
        _this._array = m00;

        _this._array.set([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
      } else {
        var v = m00.array;
        _this._array = MathBase.createFloatArray(16);
        _this._array[0] = v[0];
        _this._array[1] = v[1];
        _this._array[2] = v[2];
        _this._array[3] = v[3];
        _this._array[4] = v[4];
        _this._array[5] = v[5];
        _this._array[6] = v[6];
        _this._array[7] = v[7];
        _this._array[8] = v[8];
        _this._array[9] = v[9];
        _this._array[10] = v[10];
        _this._array[11] = v[11];
        _this._array[12] = v[12];
        _this._array[13] = v[13];
        _this._array[14] = v[14];
        _this._array[15] = v[15];
      }
    } else {
      _this._array = MathBase.createFloatArray(16);
      _this._array[0] = m00;
      _this._array[1] = m01;
      _this._array[2] = m02;
      _this._array[3] = m03;
      _this._array[4] = m04;
      _this._array[5] = m05;
      _this._array[6] = m06;
      _this._array[7] = m07;
      _this._array[8] = m08;
      _this._array[9] = m09;
      _this._array[10] = m10;
      _this._array[11] = m11;
      _this._array[12] = m12;
      _this._array[13] = m13;
      _this._array[14] = m14;
      _this._array[15] = m15;
    }

    return _this;
  }

  var _proto = Mat4.prototype;

  _proto.clone = function clone() {
    var v = this._array;
    return new Mat4(v[0], v[1], v[2], v[3], v[4], v[5], v[6], v[7], v[8], v[9], v[10], v[11], v[12], v[13], v[14], v[15]);
  };

  _proto.set = function set(m00, m01, m02, m03, m04, m05, m06, m07, m08, m09, m10, m11, m12, m13, m14, m15) {
    if (m00 === void 0) {
      m00 = 1;
    }

    if (m01 === void 0) {
      m01 = 0;
    }

    if (m02 === void 0) {
      m02 = 0;
    }

    if (m03 === void 0) {
      m03 = 0;
    }

    if (m04 === void 0) {
      m04 = 0;
    }

    if (m05 === void 0) {
      m05 = 1;
    }

    if (m06 === void 0) {
      m06 = 0;
    }

    if (m07 === void 0) {
      m07 = 0;
    }

    if (m08 === void 0) {
      m08 = 0;
    }

    if (m09 === void 0) {
      m09 = 0;
    }

    if (m10 === void 0) {
      m10 = 1;
    }

    if (m11 === void 0) {
      m11 = 0;
    }

    if (m12 === void 0) {
      m12 = 0;
    }

    if (m13 === void 0) {
      m13 = 0;
    }

    if (m14 === void 0) {
      m14 = 0;
    }

    if (m15 === void 0) {
      m15 = 1;
    }

    if (m00 && typeof m00 === 'object') {
      var v = m00.array;
      this._array[1] = v[1];
      this._array[2] = v[2];
      this._array[3] = v[3];
      this._array[4] = v[4];
      this._array[5] = v[5];
      this._array[6] = v[6];
      this._array[7] = v[7];
      this._array[8] = v[8];
      this._array[9] = v[9];
      this._array[10] = v[10];
      this._array[11] = v[11];
      this._array[12] = v[12];
      this._array[13] = v[13];
      this._array[14] = v[14];
      this._array[15] = v[15];
      this._array[0] = v[0];
    } else {
      this._array[1] = m01;
      this._array[2] = m02;
      this._array[3] = m03;
      this._array[4] = m04;
      this._array[5] = m05;
      this._array[6] = m06;
      this._array[7] = m07;
      this._array[8] = m08;
      this._array[9] = m09;
      this._array[10] = m10;
      this._array[11] = m11;
      this._array[12] = m12;
      this._array[13] = m13;
      this._array[14] = m14;
      this._array[15] = m15;
      this._array[0] = m00;
    }

    return this;
  };

  _proto.equals = function equals(other, epsilon) {
    if (epsilon === void 0) {
      epsilon = EPSILON;
    }

    var v = other.array;
    return Math.abs(this._array[0] - v[0]) <= epsilon * Math.max(1.0, Math.abs(this._array[0]), Math.abs(v[0])) && Math.abs(this._array[1] - v[1]) <= epsilon * Math.max(1.0, Math.abs(this._array[1]), Math.abs(v[1])) && Math.abs(this._array[2] - v[2]) <= epsilon * Math.max(1.0, Math.abs(this._array[2]), Math.abs(v[2])) && Math.abs(this._array[3] - v[3]) <= epsilon * Math.max(1.0, Math.abs(this._array[3]), Math.abs(v[3])) && Math.abs(this._array[4] - v[4]) <= epsilon * Math.max(1.0, Math.abs(this._array[4]), Math.abs(v[4])) && Math.abs(this._array[5] - v[5]) <= epsilon * Math.max(1.0, Math.abs(this._array[5]), Math.abs(v[5])) && Math.abs(this._array[6] - v[6]) <= epsilon * Math.max(1.0, Math.abs(this._array[6]), Math.abs(v[6])) && Math.abs(this._array[7] - v[7]) <= epsilon * Math.max(1.0, Math.abs(this._array[7]), Math.abs(v[7])) && Math.abs(this._array[8] - v[8]) <= epsilon * Math.max(1.0, Math.abs(this._array[8]), Math.abs(v[8])) && Math.abs(this._array[9] - v[9]) <= epsilon * Math.max(1.0, Math.abs(this._array[9]), Math.abs(v[9])) && Math.abs(this._array[10] - v[10]) <= epsilon * Math.max(1.0, Math.abs(this._array[10]), Math.abs(v[10])) && Math.abs(this._array[11] - v[11]) <= epsilon * Math.max(1.0, Math.abs(this._array[11]), Math.abs(v[11])) && Math.abs(this._array[12] - v[12]) <= epsilon * Math.max(1.0, Math.abs(this._array[12]), Math.abs(v[12])) && Math.abs(this._array[13] - v[13]) <= epsilon * Math.max(1.0, Math.abs(this._array[13]), Math.abs(v[13])) && Math.abs(this._array[14] - v[14]) <= epsilon * Math.max(1.0, Math.abs(this._array[14]), Math.abs(v[14])) && Math.abs(this._array[15] - v[15]) <= epsilon * Math.max(1.0, Math.abs(this._array[15]), Math.abs(v[15]));
  };

  _proto.strictEquals = function strictEquals(other) {
    var v = other.array;
    return this._array[0] === other.m00 && this._array[1] === v[1] && this._array[2] === v[2] && this._array[3] === v[3] && this._array[4] === v[4] && this._array[5] === v[5] && this._array[6] === v[6] && this._array[7] === v[7] && this._array[8] === v[8] && this._array[9] === v[9] && this._array[10] === v[10] && this._array[11] === v[11] && this._array[12] === v[12] && this._array[13] === v[13] && this._array[14] === v[14] && this._array[15] === v[15];
  };

  _proto.toString = function toString() {
    return "[\n" + this._array[0] + ", " + this._array[1] + ", " + this._array[2] + ", " + this._array[3] + ",\n" + this._array[4] + ", " + this._array[5] + ", " + this._array[6] + ", " + this._array[7] + ",\n" + this._array[8] + ", " + this._array[9] + ", " + this._array[10] + ", " + this._array[11] + ",\n" + this._array[12] + ", " + this._array[13] + ", " + this._array[14] + ", " + this._array[15] + "\n" + "]";
  };

  _proto.identity = function identity() {
    this._array[0] = 1;
    this._array[1] = 0;
    this._array[2] = 0;
    this._array[3] = 0;
    this._array[4] = 0;
    this._array[5] = 1;
    this._array[6] = 0;
    this._array[7] = 0;
    this._array[8] = 0;
    this._array[9] = 0;
    this._array[10] = 1;
    this._array[11] = 0;
    this._array[12] = 0;
    this._array[13] = 0;
    this._array[14] = 0;
    this._array[15] = 1;
    return this;
  };

  _proto.zero = function zero() {
    this.m00 = 0;
    this.m01 = 0;
    this.m02 = 0;
    this.m03 = 0;
    this.m04 = 0;
    this.m05 = 0;
    this.m06 = 0;
    this.m07 = 0;
    this.m08 = 0;
    this.m09 = 0;
    this.m10 = 0;
    this.m11 = 0;
    this.m12 = 0;
    this.m13 = 0;
    this.m14 = 0;
    this.m15 = 0;
    return this;
  };

  _proto.transpose = function transpose() {
    var a01 = this._array[1];
    var a02 = this._array[2];
    var a03 = this._array[3];
    var a12 = this._array[6];
    var a13 = this._array[7];
    var a23 = this._array[11];
    this._array[1] = this._array[4];
    this._array[2] = this._array[8];
    this._array[3] = this._array[12];
    this._array[4] = a01;
    this._array[6] = this._array[9];
    this._array[7] = this._array[13];
    this._array[8] = a02;
    this._array[9] = a12;
    this._array[11] = this._array[14];
    this._array[12] = a03;
    this._array[13] = a13;
    this._array[14] = a23;
    return this;
  };

  _proto.invert = function invert() {
    var a00 = this._array[0];
    var a01 = this._array[1];
    var a02 = this._array[2];
    var a03 = this._array[3];
    var a10 = this._array[4];
    var a11 = this._array[5];
    var a12 = this._array[6];
    var a13 = this._array[7];
    var a20 = this._array[8];
    var a21 = this._array[9];
    var a22 = this._array[10];
    var a23 = this._array[11];
    var a30 = this._array[12];
    var a31 = this._array[13];
    var a32 = this._array[14];
    var a33 = this._array[15];
    var b00 = a00 * a11 - a01 * a10;
    var b01 = a00 * a12 - a02 * a10;
    var b02 = a00 * a13 - a03 * a10;
    var b03 = a01 * a12 - a02 * a11;
    var b04 = a01 * a13 - a03 * a11;
    var b05 = a02 * a13 - a03 * a12;
    var b06 = a20 * a31 - a21 * a30;
    var b07 = a20 * a32 - a22 * a30;
    var b08 = a20 * a33 - a23 * a30;
    var b09 = a21 * a32 - a22 * a31;
    var b10 = a21 * a33 - a23 * a31;
    var b11 = a22 * a33 - a23 * a32;
    var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (det === 0) {
      this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
      return this;
    }

    det = 1.0 / det;
    this._array[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    this._array[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    this._array[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    this._array[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    this._array[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    this._array[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    this._array[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    this._array[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    this._array[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    this._array[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    this._array[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    this._array[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    this._array[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    this._array[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    this._array[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    this._array[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
    return this;
  };

  _proto.determinant = function determinant() {
    var a00 = this._array[0];
    var a01 = this._array[1];
    var a02 = this._array[2];
    var a03 = this._array[3];
    var a10 = this._array[4];
    var a11 = this._array[5];
    var a12 = this._array[6];
    var a13 = this._array[7];
    var a20 = this._array[8];
    var a21 = this._array[9];
    var a22 = this._array[10];
    var a23 = this._array[11];
    var a30 = this._array[12];
    var a31 = this._array[13];
    var a32 = this._array[14];
    var a33 = this._array[15];
    var b00 = a00 * a11 - a01 * a10;
    var b01 = a00 * a12 - a02 * a10;
    var b02 = a00 * a13 - a03 * a10;
    var b03 = a01 * a12 - a02 * a11;
    var b04 = a01 * a13 - a03 * a11;
    var b05 = a02 * a13 - a03 * a12;
    var b06 = a20 * a31 - a21 * a30;
    var b07 = a20 * a32 - a22 * a30;
    var b08 = a20 * a33 - a23 * a30;
    var b09 = a21 * a32 - a22 * a31;
    var b10 = a21 * a33 - a23 * a31;
    var b11 = a22 * a33 - a23 * a32;
    return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
  };

  _proto.add = function add(mat) {
    var v = mat.array;
    this._array[0] += v[0];
    this._array[1] += v[1];
    this._array[2] += v[2];
    this._array[3] += v[3];
    this._array[4] += v[4];
    this._array[5] += v[5];
    this._array[6] += v[6];
    this._array[7] += v[7];
    this._array[8] += v[8];
    this._array[9] += v[9];
    this._array[10] += v[10];
    this._array[11] += v[11];
    this._array[12] += v[12];
    this._array[13] += v[13];
    this._array[14] += v[14];
    this._array[15] += v[15];
    return this;
  };

  _proto.subtract = function subtract(mat) {
    var v = mat.array;
    this._array[0] -= v[0];
    this._array[1] -= v[1];
    this._array[2] -= v[2];
    this._array[3] -= v[3];
    this._array[4] -= v[4];
    this._array[5] -= v[5];
    this._array[6] -= v[6];
    this._array[7] -= v[7];
    this._array[8] -= v[8];
    this._array[9] -= v[9];
    this._array[10] -= v[10];
    this._array[11] -= v[11];
    this._array[12] -= v[12];
    this._array[13] -= v[13];
    this._array[14] -= v[14];
    this._array[15] -= v[15];
    return this;
  };

  _proto.multiply = function multiply(mat) {
    var a00 = this._array[0];
    var a01 = this._array[1];
    var a02 = this._array[2];
    var a03 = this._array[3];
    var a10 = this._array[4];
    var a11 = this._array[5];
    var a12 = this._array[6];
    var a13 = this._array[7];
    var a20 = this._array[8];
    var a21 = this._array[9];
    var a22 = this._array[10];
    var a23 = this._array[11];
    var a30 = this._array[12];
    var a31 = this._array[13];
    var a32 = this._array[14];
    var a33 = this._array[15];
    var v = mat.array;
    var b0 = v[0];
    var b1 = v[1];
    var b2 = v[2];
    var b3 = v[3];
    this._array[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    this._array[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    this._array[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    this._array[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = v[4];
    b1 = v[5];
    b2 = v[6];
    b3 = v[7];
    this._array[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    this._array[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    this._array[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    this._array[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = v[8];
    b1 = v[9];
    b2 = v[10];
    b3 = v[11];
    this._array[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    this._array[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    this._array[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    this._array[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = v[12];
    b1 = v[13];
    b2 = v[14];
    b3 = v[15];
    this._array[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    this._array[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    this._array[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    this._array[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    return this;
  };

  _proto.multiplyScalar = function multiplyScalar(scalar) {
    this._array[0] *= scalar;
    this._array[1] *= scalar;
    this._array[2] *= scalar;
    this._array[3] *= scalar;
    this._array[4] *= scalar;
    this._array[5] *= scalar;
    this._array[6] *= scalar;
    this._array[7] *= scalar;
    this._array[8] *= scalar;
    this._array[9] *= scalar;
    this._array[10] *= scalar;
    this._array[11] *= scalar;
    this._array[12] *= scalar;
    this._array[13] *= scalar;
    this._array[14] *= scalar;
    this._array[15] *= scalar;
    return this;
  };

  _proto.translate = function translate(vec) {
    console.warn('function changed');
    var v = vec.array;
    this._array[12] += v[0];
    this._array[13] += v[1];
    this._array[14] += v[2];
    return this;
  };

  _proto.scale = function scale(vec) {
    var v = vec.array;
    var x = v[0];
    var y = v[1];
    var z = v[2];
    this._array[0] *= x;
    this._array[1] *= x;
    this._array[2] *= x;
    this._array[3] *= x;
    this._array[4] *= y;
    this._array[5] *= y;
    this._array[6] *= y;
    this._array[7] *= y;
    this._array[8] *= z;
    this._array[9] *= z;
    this._array[10] *= z;
    this._array[11] *= z;
    return this;
  };

  _proto.rotate = function rotate(rad, axis) {
    var x = axis.x;
    var y = axis.y;
    var z = axis.z;
    var len = Math.sqrt(x * x + y * y + z * z);

    if (Math.abs(len) < EPSILON) {
      return null;
    }

    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    var t = 1 - c;
    var a00 = this._array[0];
    var a01 = this._array[1];
    var a02 = this._array[2];
    var a03 = this._array[3];
    var a10 = this._array[4];
    var a11 = this._array[5];
    var a12 = this._array[6];
    var a13 = this._array[7];
    var a20 = this._array[8];
    var a21 = this._array[9];
    var a22 = this._array[10];
    var a23 = this._array[11];
    var b00 = x * x * t + c;
    var b01 = y * x * t + z * s;
    var b02 = z * x * t - y * s;
    var b10 = x * y * t - z * s;
    var b11 = y * y * t + c;
    var b12 = z * y * t + x * s;
    var b20 = x * z * t + y * s;
    var b21 = y * z * t - x * s;
    var b22 = z * z * t + c;
    this._array[0] = a00 * b00 + a10 * b01 + a20 * b02;
    this._array[1] = a01 * b00 + a11 * b01 + a21 * b02;
    this._array[2] = a02 * b00 + a12 * b01 + a22 * b02;
    this._array[3] = a03 * b00 + a13 * b01 + a23 * b02;
    this._array[4] = a00 * b10 + a10 * b11 + a20 * b12;
    this._array[5] = a01 * b10 + a11 * b11 + a21 * b12;
    this._array[6] = a02 * b10 + a12 * b11 + a22 * b12;
    this._array[7] = a03 * b10 + a13 * b11 + a23 * b12;
    this._array[8] = a00 * b20 + a10 * b21 + a20 * b22;
    this._array[9] = a01 * b20 + a11 * b21 + a21 * b22;
    this._array[10] = a02 * b20 + a12 * b21 + a22 * b22;
    this._array[11] = a03 * b20 + a13 * b21 + a23 * b22;
    return this;
  };

  _proto.getTranslation = function getTranslation(out) {
    out.x = this._array[12];
    out.y = this._array[13];
    out.z = this._array[14];
    return out;
  };

  _proto.getScale = function getScale(out) {
    var o = out.array;
    var t = m3_1$1.array;
    var m00 = t[0] = this._array[0];
    var m01 = t[1] = this._array[1];
    var m02 = t[2] = this._array[2];
    var m04 = t[3] = this._array[4];
    var m05 = t[4] = this._array[5];
    var m06 = t[5] = this._array[6];
    var m08 = t[6] = this._array[8];
    var m09 = t[7] = this._array[9];
    var m10 = t[8] = this._array[10];
    o[0] = Math.sqrt(m00 * m00 + m01 * m01 + m02 * m02);
    o[1] = Math.sqrt(m04 * m04 + m05 * m05 + m06 * m06);
    o[2] = Math.sqrt(m08 * m08 + m09 * m09 + m10 * m10);

    if (Mat3.determinant(m3_1$1) < 0) {
      out.x *= -1;
    }

    return out;
  };

  _proto.getRotation = function getRotation(out) {
    var trace = this._array[0] + this._array[5] + this._array[10];
    var S = 0;

    if (trace > 0) {
      S = Math.sqrt(trace + 1.0) * 2;
      out.w = 0.25 * S;
      out.x = (this._array[6] - this._array[9]) / S;
      out.y = (this._array[8] - this._array[2]) / S;
      out.z = (this._array[1] - this._array[4]) / S;
    } else if (this._array[0] > this._array[5] && this._array[0] > this._array[10]) {
      S = Math.sqrt(1.0 + this._array[0] - this._array[5] - this._array[10]) * 2;
      out.w = (this._array[6] - this._array[9]) / S;
      out.x = 0.25 * S;
      out.y = (this._array[1] + this._array[4]) / S;
      out.z = (this._array[8] + this._array[2]) / S;
    } else if (this._array[5] > this._array[10]) {
      S = Math.sqrt(1.0 + this._array[5] - this._array[0] - this._array[10]) * 2;
      out.w = (this._array[8] - this._array[2]) / S;
      out.x = (this._array[1] + this._array[4]) / S;
      out.y = 0.25 * S;
      out.z = (this._array[6] + this._array[9]) / S;
    } else {
      S = Math.sqrt(1.0 + this._array[10] - this._array[0] - this._array[5]) * 2;
      out.w = (this._array[1] - this._array[4]) / S;
      out.x = (this._array[8] + this._array[2]) / S;
      out.y = (this._array[6] + this._array[9]) / S;
      out.z = 0.25 * S;
    }

    return out;
  };

  _proto.fromRTS = function fromRTS(q, v, s) {
    var x = q.x;
    var y = q.y;
    var z = q.z;
    var w = q.w;
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var xy = x * y2;
    var xz = x * z2;
    var yy = y * y2;
    var yz = y * z2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    var sx = s.x;
    var sy = s.y;
    var sz = s.z;
    this._array[0] = (1 - (yy + zz)) * sx;
    this._array[1] = (xy + wz) * sx;
    this._array[2] = (xz - wy) * sx;
    this._array[3] = 0;
    this._array[4] = (xy - wz) * sy;
    this._array[5] = (1 - (xx + zz)) * sy;
    this._array[6] = (yz + wx) * sy;
    this._array[7] = 0;
    this._array[8] = (xz + wy) * sz;
    this._array[9] = (yz - wx) * sz;
    this._array[10] = (1 - (xx + yy)) * sz;
    this._array[11] = 0;
    this._array[12] = v.x;
    this._array[13] = v.y;
    this._array[14] = v.z;
    this._array[15] = 1;
    return this;
  };

  _proto.fromQuat = function fromQuat(q) {
    var x = q.x;
    var y = q.y;
    var z = q.z;
    var w = q.w;
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var yx = y * x2;
    var yy = y * y2;
    var zx = z * x2;
    var zy = z * y2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    this._array[0] = 1 - yy - zz;
    this._array[1] = yx + wz;
    this._array[2] = zx - wy;
    this._array[3] = 0;
    this._array[4] = yx - wz;
    this._array[5] = 1 - xx - zz;
    this._array[6] = zy + wx;
    this._array[7] = 0;
    this._array[8] = zx + wy;
    this._array[9] = zy - wx;
    this._array[10] = 1 - xx - yy;
    this._array[11] = 0;
    this._array[12] = 0;
    this._array[13] = 0;
    this._array[14] = 0;
    this._array[15] = 1;
    return this;
  };

  return Mat4;
}(MathBase);
Mat4.IDENTITY = Object.freeze(new Mat4());
var v3_1$3 = new Vec3();
var m3_1$1 = new Mat3();
enumerableProps(Mat4.prototype, ['m00', 'm01', 'm02', 'm03', 'm04', 'm05', 'm06', 'm07', 'm08', 'm09', 'm10', 'm11', 'm12', 'm13', 'm14', 'm15']);
CCClass.fastDefine('cc.Mat4', Mat4, {
  m00: 1,
  m01: 0,
  m02: 0,
  m03: 0,
  m04: 0,
  m05: 1,
  m06: 0,
  m07: 0,
  m08: 0,
  m09: 0,
  m10: 1,
  m11: 0,
  m12: 0,
  m13: 0,
  m14: 0,
  m15: 1
});
legacyCC.Mat4 = Mat4;
function mat4(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  return new Mat4(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33);
}
legacyCC.mat4 = mat4;

var Vec2 = function (_MathBase) {
  _inheritsLoose(Vec2, _MathBase);

  Vec2.clone = function clone(a) {
    return new Vec2(a.x, a.y);
  };

  Vec2.copy = function copy(out, a) {
    out.x = a.x;
    out.y = a.y;
    return out;
  };

  Vec2.set = function set(out, x, y) {
    out.x = x;
    out.y = y;
    return out;
  };

  Vec2.add = function add(out, a, b) {
    out.x = a.x + b.x;
    out.y = a.y + b.y;
    return out;
  };

  Vec2.subtract = function subtract(out, a, b) {
    out.x = a.x - b.x;
    out.y = a.y - b.y;
    return out;
  };

  Vec2.multiply = function multiply(out, a, b) {
    out.x = a.x * b.x;
    out.y = a.y * b.y;
    return out;
  };

  Vec2.divide = function divide(out, a, b) {
    out.x = a.x / b.x;
    out.y = a.y / b.y;
    return out;
  };

  Vec2.ceil = function ceil(out, a) {
    out.x = Math.ceil(a.x);
    out.y = Math.ceil(a.y);
    return out;
  };

  Vec2.floor = function floor(out, a) {
    out.x = Math.floor(a.x);
    out.y = Math.floor(a.y);
    return out;
  };

  Vec2.min = function min(out, a, b) {
    out.x = Math.min(a.x, b.x);
    out.y = Math.min(a.y, b.y);
    return out;
  };

  Vec2.max = function max(out, a, b) {
    out.x = Math.max(a.x, b.x);
    out.y = Math.max(a.y, b.y);
    return out;
  };

  Vec2.round = function round(out, a) {
    out.x = Math.round(a.x);
    out.y = Math.round(a.y);
    return out;
  };

  Vec2.multiplyScalar = function multiplyScalar(out, a, b) {
    out.x = a.x * b;
    out.y = a.y * b;
    return out;
  };

  Vec2.scaleAndAdd = function scaleAndAdd(out, a, b, scale) {
    out.x = a.x + b.x * scale;
    out.y = a.y + b.y * scale;
    return out;
  };

  Vec2.distance = function distance(a, b) {
    var x = b.x - a.x;
    var y = b.y - a.y;
    return Math.sqrt(x * x + y * y);
  };

  Vec2.squaredDistance = function squaredDistance(a, b) {
    var x = b.x - a.x;
    var y = b.y - a.y;
    return x * x + y * y;
  };

  Vec2.len = function len(a) {
    var x = a.x;
    var y = a.y;
    return Math.sqrt(x * x + y * y);
  };

  Vec2.lengthSqr = function lengthSqr(a) {
    var x = a.x;
    var y = a.y;
    return x * x + y * y;
  };

  Vec2.negate = function negate(out, a) {
    out.x = -a.x;
    out.y = -a.y;
    return out;
  };

  Vec2.inverse = function inverse(out, a) {
    out.x = 1.0 / a.x;
    out.y = 1.0 / a.y;
    return out;
  };

  Vec2.inverseSafe = function inverseSafe(out, a) {
    var x = a.x;
    var y = a.y;

    if (Math.abs(x) < EPSILON) {
      out.x = 0;
    } else {
      out.x = 1.0 / x;
    }

    if (Math.abs(y) < EPSILON) {
      out.y = 0;
    } else {
      out.y = 1.0 / y;
    }

    return out;
  };

  Vec2.normalize = function normalize(out, a) {
    var x = a.x;
    var y = a.y;
    var len = x * x + y * y;

    if (len > 0) {
      len = 1 / Math.sqrt(len);
      out.x = x * len;
      out.y = y * len;
    }

    return out;
  };

  Vec2.dot = function dot(a, b) {
    return a.x * b.x + a.y * b.y;
  };

  Vec2.cross = function cross(out, a, b) {
    out.x = out.y = 0;
    out.z = a.x * b.y - a.y * b.x;
    return out;
  };

  Vec2.lerp = function lerp(out, a, b, t) {
    var x = a.x;
    var y = a.y;
    out.x = x + t * (b.x - x);
    out.y = y + t * (b.y - y);
    return out;
  };

  Vec2.random = function random$1(out, scale) {
    scale = scale || 1.0;
    var r = random() * 2.0 * Math.PI;
    out.x = Math.cos(r) * scale;
    out.y = Math.sin(r) * scale;
    return out;
  };

  Vec2.transformMat3 = function transformMat3(out, a, m) {
    var x = a.x;
    var y = a.y;
    out.x = m.m00 * x + m.m03 * y + m.m06;
    out.y = m.m01 * x + m.m04 * y + m.m07;
    return out;
  };

  Vec2.transformMat4 = function transformMat4(out, a, m) {
    var x = a.x;
    var y = a.y;
    out.x = m.m00 * x + m.m04 * y + m.m12;
    out.y = m.m01 * x + m.m05 * y + m.m13;
    return out;
  };

  Vec2.str = function str(a) {
    return "Vec2(" + a.x + ", " + a.y + ")";
  };

  Vec2.toArray = function toArray(out, v, ofs) {
    if (ofs === void 0) {
      ofs = 0;
    }

    out[ofs + 0] = v.x;
    out[ofs + 1] = v.y;
    return out;
  };

  Vec2.fromArray = function fromArray(out, arr, ofs) {
    if (ofs === void 0) {
      ofs = 0;
    }

    out.x = arr[ofs + 0];
    out.y = arr[ofs + 1];
    return out;
  };

  Vec2.strictEquals = function strictEquals(a, b) {
    return a.x === b.x && a.y === b.y;
  };

  Vec2.equals = function equals(a, b, epsilon) {
    if (epsilon === void 0) {
      epsilon = EPSILON;
    }

    return Math.abs(a.x - b.x) <= epsilon * Math.max(1.0, Math.abs(a.x), Math.abs(b.x)) && Math.abs(a.y - b.y) <= epsilon * Math.max(1.0, Math.abs(a.y), Math.abs(b.y));
  };

  Vec2.angle = function angle(a, b) {
    Vec2.normalize(v2_1, a);
    Vec2.normalize(v2_2, b);
    var cosine = Vec2.dot(v2_1, v2_2);

    if (cosine > 1.0) {
      return 0;
    }

    if (cosine < -1.0) {
      return Math.PI;
    }

    return Math.acos(cosine);
  };

  _createClass(Vec2, [{
    key: "x",
    get: function get() {
      return this._array[0];
    },
    set: function set(x) {
      this._array[0] = x;
    }
  }, {
    key: "y",
    get: function get() {
      return this._array[1];
    },
    set: function set(y) {
      this._array[1] = y;
    }
  }]);

  function Vec2(x, y) {
    var _this;

    _this = _MathBase.call(this) || this;

    if (x && typeof x === 'object') {
      if (ArrayBuffer.isView(x)) {
        _this._array = x;
      } else {
        var v = x.array;
        _this._array = MathBase.createFloatArray(2);
        _this._array[0] = v[0];
        _this._array[1] = v[1];
      }
    } else {
      _this._array = MathBase.createFloatArray(2);
      _this._array[0] = x || 0;
      _this._array[1] = y || 0;
    }

    return _this;
  }

  var _proto = Vec2.prototype;

  _proto.clone = function clone() {
    return new Vec2(this._array[0], this._array[1]);
  };

  _proto.set = function set(x, y) {
    if (x && typeof x === 'object') {
      this._array[0] = x.x;
      this._array[1] = x.y;
    } else {
      this._array[0] = x || 0;
      this._array[1] = y || 0;
    }

    return this;
  };

  _proto.equals = function equals(other, epsilon) {
    if (epsilon === void 0) {
      epsilon = EPSILON;
    }

    var v = other.array;
    return Math.abs(this._array[0] - v[0]) <= epsilon * Math.max(1.0, Math.abs(this._array[0]), Math.abs(v[0])) && Math.abs(this._array[1] - v[1]) <= epsilon * Math.max(1.0, Math.abs(this._array[1]), Math.abs(v[1]));
  };

  _proto.equals2f = function equals2f(x, y, epsilon) {
    if (epsilon === void 0) {
      epsilon = EPSILON;
    }

    return Math.abs(this._array[0] - x) <= epsilon * Math.max(1.0, Math.abs(this._array[0]), Math.abs(x)) && Math.abs(this._array[1] - y) <= epsilon * Math.max(1.0, Math.abs(this._array[1]), Math.abs(y));
  };

  _proto.strictEquals = function strictEquals(other) {
    var v = other.array;
    return other && this._array[0] === v[0] && this._array[1] === v[1];
  };

  _proto.strictEquals2f = function strictEquals2f(x, y) {
    return this._array[0] === x && this._array[1] === y;
  };

  _proto.toString = function toString() {
    return "(" + this._array[0].toFixed(2) + ", " + this._array[1].toFixed(2) + ")";
  };

  _proto.lerp = function lerp(to, ratio) {
    var x = this._array[0];
    var y = this._array[1];
    var v = to.array;
    this._array[0] = x + ratio * (v[0] - x);
    this._array[1] = y + ratio * (v[1] - y);
    return this;
  };

  _proto.clampf = function clampf(minInclusive, maxInclusive) {
    var min = minInclusive.array;
    var max = maxInclusive.array;
    this._array[0] = clamp(this._array[0], min[0], max[0]);
    this._array[1] = clamp(this._array[1], min[1], max[1]);
    return this;
  };

  _proto.add = function add(other) {
    var v = other.array;
    this._array[0] += v[0];
    this._array[1] += v[1];
    return this;
  };

  _proto.add2f = function add2f(x, y) {
    this._array[0] += x;
    this._array[1] += y;
    return this;
  };

  _proto.subtract = function subtract(other) {
    var v = other.array;
    this._array[0] -= v[0];
    this._array[1] -= v[1];
    return this;
  };

  _proto.subtract2f = function subtract2f(x, y) {
    this._array[0] -= x;
    this._array[1] -= y;
    return this;
  };

  _proto.multiplyScalar = function multiplyScalar(scalar) {
    if (typeof scalar === 'object') {
      console.warn('should use Vec2.multiply for vector * vector operation');
    }

    this._array[0] *= scalar;
    this._array[1] *= scalar;
    return this;
  };

  _proto.multiply = function multiply(other) {
    if (typeof other !== 'object') {
      console.warn('should use Vec2.scale for vector * scalar operation');
    }

    var v = other.array;
    this._array[0] *= v[0];
    this._array[1] *= v[1];
    return this;
  };

  _proto.multiply2f = function multiply2f(x, y) {
    this._array[0] *= x;
    this._array[1] *= y;
    return this;
  };

  _proto.divide = function divide(other) {
    var v = other.array;
    this._array[0] /= v[0];
    this._array[1] /= v[1];
    return this;
  };

  _proto.divide2f = function divide2f(x, y) {
    this._array[0] /= x;
    this._array[1] /= y;
    return this;
  };

  _proto.negative = function negative() {
    this._array[0] = -this._array[0];
    this._array[1] = -this._array[1];
    return this;
  };

  _proto.dot = function dot(other) {
    var v = other.array;
    return this._array[0] * v[0] + this._array[1] * v[1];
  };

  _proto.cross = function cross(other) {
    var v = other.array;
    return this._array[0] * v[1] - this._array[1] * v[0];
  };

  _proto.length = function length() {
    return Math.sqrt(this._array[0] * this._array[0] + this._array[1] * this._array[1]);
  };

  _proto.lengthSqr = function lengthSqr() {
    return this._array[0] * this._array[0] + this._array[1] * this._array[1];
  };

  _proto.normalize = function normalize() {
    var x = this._array[0];
    var y = this._array[1];
    var len = x * x + y * y;

    if (len > 0) {
      len = 1 / Math.sqrt(len);
      this._array[0] *= len;
      this._array[1] *= len;
    }

    return this;
  };

  _proto.angle = function angle(other) {
    var magSqr1 = this.lengthSqr();
    var magSqr2 = other.lengthSqr();

    if (magSqr1 === 0 || magSqr2 === 0) {
      console.warn('Can\'t get angle between zero vector');
      return 0.0;
    }

    var dot = this.dot(other);
    var theta = dot / Math.sqrt(magSqr1 * magSqr2);
    theta = clamp(theta, -1.0, 1.0);
    return Math.acos(theta);
  };

  _proto.signAngle = function signAngle(other) {
    var angle = this.angle(other);
    return this.cross(other) < 0 ? -angle : angle;
  };

  _proto.rotate = function rotate(radians) {
    var x = this._array[0];
    var y = this._array[1];
    var sin = Math.sin(radians);
    var cos = Math.cos(radians);
    this._array[0] = cos * x - sin * y;
    this._array[1] = sin * x + cos * y;
    return this;
  };

  _proto.project = function project(other) {
    var v = other.array;
    var scalar = this.dot(other) / other.dot(other);
    this._array[0] = v[0] * scalar;
    this._array[1] = v[1] * scalar;
    return this;
  };

  _proto.transformMat4 = function transformMat4(matrix) {
    var x = this._array[0];
    var y = this._array[1];
    var v = matrix.array;
    this._array[0] = v[0] * x + v[4] * y + v[12];
    this._array[1] = v[1] * x + v[5] * y + v[13];
    return this;
  };

  return Vec2;
}(MathBase);
Vec2.ZERO = Object.freeze(new Vec2(0, 0));
Vec2.ONE = Object.freeze(new Vec2(1, 1));
Vec2.NEG_ONE = Object.freeze(new Vec2(-1, -1));
Vec2.UNIT_X = Object.freeze(new Vec2(1, 0));
Vec2.UNIT_Y = Object.freeze(new Vec2(0, 1));
var v2_1 = new Vec2();
var v2_2 = new Vec2();
enumerableProps(Vec2.prototype, ['x', 'y']);
CCClass.fastDefine('cc.Vec2', Vec2, {
  x: 0,
  y: 0
});
legacyCC.Vec2 = Vec2;
function v2(x, y) {
  return new Vec2(x, y);
}
legacyCC.v2 = v2;

var Vec4 = function (_MathBase) {
  _inheritsLoose(Vec4, _MathBase);

  Vec4.clone = function clone(a) {
    return new Vec4(a.x, a.y, a.z, a.w);
  };

  Vec4.copy = function copy(out, a) {
    out.x = a.x;
    out.y = a.y;
    out.z = a.z;
    out.w = a.w;
    return out;
  };

  Vec4.set = function set(out, x, y, z, w) {
    out.x = x;
    out.y = y;
    out.z = z;
    out.w = w;
    return out;
  };

  Vec4.add = function add(out, a, b) {
    out.x = a.x + b.x;
    out.y = a.y + b.y;
    out.z = a.z + b.z;
    out.w = a.w + b.w;
    return out;
  };

  Vec4.subtract = function subtract(out, a, b) {
    out.x = a.x - b.x;
    out.y = a.y - b.y;
    out.z = a.z - b.z;
    out.w = a.w - b.w;
    return out;
  };

  Vec4.multiply = function multiply(out, a, b) {
    out.x = a.x * b.x;
    out.y = a.y * b.y;
    out.z = a.z * b.z;
    out.w = a.w * b.w;
    return out;
  };

  Vec4.divide = function divide(out, a, b) {
    out.x = a.x / b.x;
    out.y = a.y / b.y;
    out.z = a.z / b.z;
    out.w = a.w / b.w;
    return out;
  };

  Vec4.ceil = function ceil(out, a) {
    out.x = Math.ceil(a.x);
    out.y = Math.ceil(a.y);
    out.z = Math.ceil(a.z);
    out.w = Math.ceil(a.w);
    return out;
  };

  Vec4.floor = function floor(out, a) {
    out.x = Math.floor(a.x);
    out.y = Math.floor(a.y);
    out.z = Math.floor(a.z);
    out.w = Math.floor(a.w);
    return out;
  };

  Vec4.min = function min(out, a, b) {
    out.x = Math.min(a.x, b.x);
    out.y = Math.min(a.y, b.y);
    out.z = Math.min(a.z, b.z);
    out.w = Math.min(a.w, b.w);
    return out;
  };

  Vec4.max = function max(out, a, b) {
    out.x = Math.max(a.x, b.x);
    out.y = Math.max(a.y, b.y);
    out.z = Math.max(a.z, b.z);
    out.w = Math.max(a.w, b.w);
    return out;
  };

  Vec4.round = function round(out, a) {
    out.x = Math.round(a.x);
    out.y = Math.round(a.y);
    out.z = Math.round(a.z);
    out.w = Math.round(a.w);
    return out;
  };

  Vec4.multiplyScalar = function multiplyScalar(out, a, b) {
    out.x = a.x * b;
    out.y = a.y * b;
    out.z = a.z * b;
    out.w = a.w * b;
    return out;
  };

  Vec4.scaleAndAdd = function scaleAndAdd(out, a, b, scale) {
    out.x = a.x + b.x * scale;
    out.y = a.y + b.y * scale;
    out.z = a.z + b.z * scale;
    out.w = a.w + b.w * scale;
    return out;
  };

  Vec4.distance = function distance(a, b) {
    var x = b.x - a.x;
    var y = b.y - a.y;
    var z = b.z - a.z;
    var w = b.w - a.w;
    return Math.sqrt(x * x + y * y + z * z + w * w);
  };

  Vec4.squaredDistance = function squaredDistance(a, b) {
    var x = b.x - a.x;
    var y = b.y - a.y;
    var z = b.z - a.z;
    var w = b.w - a.w;
    return x * x + y * y + z * z + w * w;
  };

  Vec4.len = function len(a) {
    var x = a.x;
    var y = a.y;
    var z = a.z;
    var w = a.w;
    return Math.sqrt(x * x + y * y + z * z + w * w);
  };

  Vec4.lengthSqr = function lengthSqr(a) {
    var x = a.x;
    var y = a.y;
    var z = a.z;
    var w = a.w;
    return x * x + y * y + z * z + w * w;
  };

  Vec4.negate = function negate(out, a) {
    out.x = -a.x;
    out.y = -a.y;
    out.z = -a.z;
    out.w = -a.w;
    return out;
  };

  Vec4.inverse = function inverse(out, a) {
    out.x = 1.0 / a.x;
    out.y = 1.0 / a.y;
    out.z = 1.0 / a.z;
    out.w = 1.0 / a.w;
    return out;
  };

  Vec4.inverseSafe = function inverseSafe(out, a) {
    var x = a.x;
    var y = a.y;
    var z = a.z;
    var w = a.w;

    if (Math.abs(x) < EPSILON) {
      out.x = 0;
    } else {
      out.x = 1.0 / x;
    }

    if (Math.abs(y) < EPSILON) {
      out.y = 0;
    } else {
      out.y = 1.0 / y;
    }

    if (Math.abs(z) < EPSILON) {
      out.z = 0;
    } else {
      out.z = 1.0 / z;
    }

    if (Math.abs(w) < EPSILON) {
      out.w = 0;
    } else {
      out.w = 1.0 / w;
    }

    return out;
  };

  Vec4.normalize = function normalize(out, a) {
    var x = a.x;
    var y = a.y;
    var z = a.z;
    var w = a.w;
    var len = x * x + y * y + z * z + w * w;

    if (len > 0) {
      len = 1 / Math.sqrt(len);
      out.x = x * len;
      out.y = y * len;
      out.z = z * len;
      out.w = w * len;
    }

    return out;
  };

  Vec4.dot = function dot(a, b) {
    return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w;
  };

  Vec4.lerp = function lerp(out, a, b, t) {
    out.x = a.x + t * (b.x - a.x);
    out.y = a.y + t * (b.y - a.y);
    out.z = a.z + t * (b.z - a.z);
    out.w = a.w + t * (b.w - a.w);
    return out;
  };

  Vec4.random = function random$1(out, scale) {
    scale = scale || 1.0;
    var phi = random() * 2.0 * Math.PI;
    var cosTheta = random() * 2 - 1;
    var sinTheta = Math.sqrt(1 - cosTheta * cosTheta);
    out.x = sinTheta * Math.cos(phi) * scale;
    out.y = sinTheta * Math.sin(phi) * scale;
    out.z = cosTheta * scale;
    out.w = 0;
    return out;
  };

  Vec4.transformMat4 = function transformMat4(out, a, m) {
    var x = a.x;
    var y = a.y;
    var z = a.z;
    var w = a.w;
    out.x = m.m00 * x + m.m04 * y + m.m08 * z + m.m12 * w;
    out.y = m.m01 * x + m.m05 * y + m.m09 * z + m.m13 * w;
    out.z = m.m02 * x + m.m06 * y + m.m10 * z + m.m14 * w;
    out.w = m.m03 * x + m.m07 * y + m.m11 * z + m.m15 * w;
    return out;
  };

  Vec4.transformAffine = function transformAffine(out, v, m) {
    var x = v.x;
    var y = v.y;
    var z = v.z;
    var w = v.w;
    out.x = m.m00 * x + m.m01 * y + m.m02 * z + m.m03 * w;
    out.y = m.m04 * x + m.m05 * y + m.m06 * z + m.m07 * w;
    out.x = m.m08 * x + m.m09 * y + m.m10 * z + m.m11 * w;
    out.w = v.w;
    return out;
  };

  Vec4.transformQuat = function transformQuat(out, a, q) {
    var x = a.x,
        y = a.y,
        z = a.z;
    var _x = q.x;
    var _y = q.y;
    var _z = q.z;
    var _w = q.w;
    var ix = _w * x + _y * z - _z * y;
    var iy = _w * y + _z * x - _x * z;
    var iz = _w * z + _x * y - _y * x;
    var iw = -_x * x - _y * y - _z * z;
    out.x = ix * _w + iw * -_x + iy * -_z - iz * -_y;
    out.y = iy * _w + iw * -_y + iz * -_x - ix * -_z;
    out.z = iz * _w + iw * -_z + ix * -_y - iy * -_x;
    out.w = a.w;
    return out;
  };

  Vec4.toArray = function toArray(out, v, ofs) {
    if (ofs === void 0) {
      ofs = 0;
    }

    out[ofs + 0] = v.x;
    out[ofs + 1] = v.y;
    out[ofs + 2] = v.z;
    out[ofs + 3] = v.w;
    return out;
  };

  Vec4.fromArray = function fromArray(out, arr, ofs) {
    if (ofs === void 0) {
      ofs = 0;
    }

    out.x = arr[ofs + 0];
    out.y = arr[ofs + 1];
    out.z = arr[ofs + 2];
    out.w = arr[ofs + 3];
    return out;
  };

  Vec4.strictEquals = function strictEquals(a, b) {
    return a.x === b.x && a.y === b.y && a.z === b.z && a.w === b.w;
  };

  Vec4.equals = function equals(a, b, epsilon) {
    if (epsilon === void 0) {
      epsilon = EPSILON;
    }

    return Math.abs(a.x - b.x) <= epsilon * Math.max(1.0, Math.abs(a.x), Math.abs(b.x)) && Math.abs(a.y - b.y) <= epsilon * Math.max(1.0, Math.abs(a.y), Math.abs(b.y)) && Math.abs(a.z - b.z) <= epsilon * Math.max(1.0, Math.abs(a.z), Math.abs(b.z)) && Math.abs(a.w - b.w) <= epsilon * Math.max(1.0, Math.abs(a.w), Math.abs(b.w));
  };

  _createClass(Vec4, [{
    key: "x",
    get: function get() {
      return this._array[0];
    },
    set: function set(x) {
      this._array[0] = x;
    }
  }, {
    key: "y",
    get: function get() {
      return this._array[1];
    },
    set: function set(y) {
      this._array[1] = y;
    }
  }, {
    key: "z",
    get: function get() {
      return this._array[2];
    },
    set: function set(z) {
      this._array[2] = z;
    }
  }, {
    key: "w",
    get: function get() {
      return this._array[3];
    },
    set: function set(w) {
      this._array[3] = w;
    }
  }]);

  function Vec4(x, y, z, w) {
    var _this;

    _this = _MathBase.call(this) || this;

    if (x && typeof x === 'object') {
      if (ArrayBuffer.isView(x)) {
        _this._array = x;

        _this._array.fill(0);
      } else {
        var v = x.array;
        _this._array = MathBase.createFloatArray(4);
        _this._array[0] = v[0];
        _this._array[1] = v[1];
        _this._array[2] = v[2];
        _this._array[3] = v[3];
      }
    } else {
      _this._array = MathBase.createFloatArray(4);
      _this._array[0] = x || 0;
      _this._array[1] = y || 0;
      _this._array[2] = z || 0;
      _this._array[3] = w || 0;
    }

    return _this;
  }

  var _proto = Vec4.prototype;

  _proto.clone = function clone() {
    return new Vec4(this._array[0], this._array[1], this._array[2], this._array[3]);
  };

  _proto.set = function set(x, y, z, w) {
    if (x && typeof x === 'object') {
      this._array[0] = x.x;
      this._array[1] = x.y;
      this._array[2] = x.z;
      this._array[3] = x.w;
    } else {
      this._array[0] = x || 0;
      this._array[1] = y || 0;
      this._array[2] = z || 0;
      this._array[3] = w || 0;
    }

    return this;
  };

  _proto.equals = function equals(other, epsilon) {
    if (epsilon === void 0) {
      epsilon = EPSILON;
    }

    var v = other.array;
    return Math.abs(this._array[0] - v[0]) <= epsilon * Math.max(1.0, Math.abs(this._array[0]), Math.abs(v[0])) && Math.abs(this._array[1] - v[1]) <= epsilon * Math.max(1.0, Math.abs(this._array[1]), Math.abs(v[1])) && Math.abs(this._array[2] - v[2]) <= epsilon * Math.max(1.0, Math.abs(this._array[2]), Math.abs(v[2])) && Math.abs(this._array[3] - v[3]) <= epsilon * Math.max(1.0, Math.abs(this._array[3]), Math.abs(v[3]));
  };

  _proto.equals4f = function equals4f(x, y, z, w, epsilon) {
    if (epsilon === void 0) {
      epsilon = EPSILON;
    }

    return Math.abs(this._array[0] - x) <= epsilon * Math.max(1.0, Math.abs(this._array[0]), Math.abs(x)) && Math.abs(this._array[1] - y) <= epsilon * Math.max(1.0, Math.abs(this._array[1]), Math.abs(y)) && Math.abs(this._array[2] - z) <= epsilon * Math.max(1.0, Math.abs(this._array[2]), Math.abs(z)) && Math.abs(this._array[3] - w) <= epsilon * Math.max(1.0, Math.abs(this._array[3]), Math.abs(w));
  };

  _proto.strictEquals = function strictEquals(other) {
    var v = other.array;
    return this._array[0] === v[0] && this._array[1] === v[1] && this._array[2] === v[2] && this._array[3] === v[3];
  };

  _proto.strictEquals4f = function strictEquals4f(x, y, z, w) {
    return this._array[0] === x && this._array[1] === y && this._array[2] === z && this._array[3] === w;
  };

  _proto.lerp = function lerp(to, ratio) {
    var x = this._array[0];
    var y = this._array[1];
    var z = this._array[2];
    var w = this._array[3];
    var v = to.array;
    this._array[0] = x + ratio * (v[0] - x);
    this._array[1] = y + ratio * (v[1] - y);
    this._array[2] = z + ratio * (v[2] - z);
    this._array[3] = w + ratio * (v[3] - w);
    return this;
  };

  _proto.toString = function toString() {
    return "(" + this._array[0].toFixed(2) + ", " + this._array[1].toFixed(2) + ", " + this._array[2].toFixed(2) + ", " + this._array[3].toFixed(2) + ")";
  };

  _proto.clampf = function clampf(minInclusive, maxInclusive) {
    var min = minInclusive.array;
    var max = maxInclusive.array;
    this._array[0] = clamp(this._array[0], min[0], max[0]);
    this._array[1] = clamp(this._array[1], min[1], max[1]);
    this._array[2] = clamp(this._array[2], min[2], max[2]);
    this._array[3] = clamp(this._array[3], min[3], max[3]);
    return this;
  };

  _proto.add = function add(other) {
    var v = other.array;
    this._array[0] += v[0];
    this._array[1] += v[1];
    this._array[2] += v[2];
    this._array[3] += v[3];
    return this;
  };

  _proto.add4f = function add4f(x, y, z, w) {
    this._array[0] += x;
    this._array[1] += y;
    this._array[2] += z;
    this._array[3] += w;
    return this;
  };

  _proto.subtract = function subtract(other) {
    var v = other.array;
    this._array[0] -= v[0];
    this._array[1] -= v[1];
    this._array[2] -= -v[2];
    this._array[3] -= v[3];
    return this;
  };

  _proto.subtract4f = function subtract4f(x, y, z, w) {
    this._array[0] -= x;
    this._array[1] -= y;
    this._array[2] -= z;
    this._array[3] -= w;
    return this;
  };

  _proto.multiplyScalar = function multiplyScalar(scalar) {
    if (typeof scalar === 'object') {
      console.warn('should use Vec4.multiply for vector * vector operation');
    }

    this._array[0] *= scalar;
    this._array[1] *= scalar;
    this._array[2] *= scalar;
    this._array[3] *= scalar;
    return this;
  };

  _proto.multiply = function multiply(other) {
    if (typeof other !== 'object') {
      console.warn('should use Vec4.scale for vector * scalar operation');
    }

    var v = other.array;
    this._array[0] *= v[0];
    this._array[1] *= v[1];
    this._array[2] *= v[2];
    this._array[3] *= v[3];
    return this;
  };

  _proto.multiply4f = function multiply4f(x, y, z, w) {
    this._array[0] *= x;
    this._array[1] *= y;
    this._array[2] *= z;
    this._array[3] *= w;
    return this;
  };

  _proto.divide = function divide(other) {
    var v = other.array;
    this._array[0] /= v[0];
    this._array[1] /= v[1];
    this._array[2] /= v[2];
    this._array[3] /= v[3];
    return this;
  };

  _proto.divide4f = function divide4f(x, y, z, w) {
    this._array[0] /= x;
    this._array[1] /= y;
    this._array[2] /= z;
    this._array[3] /= w;
    return this;
  };

  _proto.negative = function negative() {
    this._array[0] = -this._array[0];
    this._array[1] = -this._array[1];
    this._array[2] = -this._array[2];
    this._array[3] = -this._array[3];
    return this;
  };

  _proto.dot = function dot(other) {
    var v = other.array;
    return this._array[0] * v[0] + this._array[1] * v[1] + this._array[2] * v[2] + this._array[3] * v[3];
  };

  _proto.cross = function cross(other) {
    var ax = this._array[0];
    var ay = this._array[1];
    var az = this._array[2];
    var v = other.array;
    var bx = v[0];
    var by = v[1];
    var bz = v[2];
    this._array[0] = ay * bz - az * by;
    this._array[1] = az * bx - ax * bz;
    this._array[2] = ax * by - ay * bx;
    return this;
  };

  _proto.length = function length() {
    var x = this._array[0];
    var y = this._array[1];
    var z = this._array[2];
    var w = this._array[3];
    return Math.sqrt(x * x + y * y + z * z + w * w);
  };

  _proto.lengthSqr = function lengthSqr() {
    var x = this._array[0];
    var y = this._array[1];
    var z = this._array[2];
    var w = this._array[3];
    return x * x + y * y + z * z + w * w;
  };

  _proto.normalize = function normalize() {
    var x = this._array[0];
    var y = this._array[1];
    var z = this._array[2];
    var w = this._array[3];
    var len = x * x + y * y + z * z + w * w;

    if (len > 0) {
      len = 1 / Math.sqrt(len);
      this._array[0] = x * len;
      this._array[1] = y * len;
      this._array[2] = z * len;
      this._array[3] = w * len;
    }

    return this;
  };

  _proto.transformMat4 = function transformMat4(matrix) {
    var x = this._array[0];
    var y = this._array[1];
    var z = this._array[2];
    var w = this._array[3];
    var v = matrix.array;
    this._array[0] = v[0] * x + v[4] * y + v[8] * z + v[12] * w;
    this._array[1] = v[1] * x + v[5] * y + v[9] * z + v[13] * w;
    this._array[2] = v[2] * x + v[6] * y + v[10] * z + v[14] * w;
    this._array[3] = v[3] * x + v[7] * y + v[11] * z + v[15] * w;
    return this;
  };

  return Vec4;
}(MathBase);
Vec4.ZERO = Object.freeze(new Vec4(0, 0, 0, 0));
Vec4.ONE = Object.freeze(new Vec4(1, 1, 1, 1));
Vec4.NEG_ONE = Object.freeze(new Vec4(-1, -1, -1, -1));
enumerableProps(Vec4.prototype, ['x', 'y', 'z', 'w']);
CCClass.fastDefine('cc.Vec4', Vec4, {
  x: 0,
  y: 0,
  z: 0,
  w: 0
});
legacyCC.Vec4 = Vec4;
function v4(x, y, z, w) {
  return new Vec4(x, y, z, w);
}
legacyCC.v4 = v4;

exports.replaceProperty(Vec2, 'Vec2', [{
  name: 'sub',
  newName: 'subtract',
  target: Vec2,
  targetName: 'Vec2'
}, {
  name: 'mul',
  newName: 'multiply',
  target: Vec2,
  targetName: 'Vec2'
}, {
  name: 'div',
  newName: 'divide',
  target: Vec2,
  targetName: 'Vec2'
}, {
  name: 'dist',
  newName: 'distance',
  target: Vec2,
  targetName: 'Vec2'
}, {
  name: 'sqrDist',
  newName: 'squaredDistance',
  target: Vec2,
  targetName: 'Vec2'
}, {
  name: 'mag',
  newName: 'len',
  target: Vec2,
  targetName: 'Vec2'
}, {
  name: 'sqrMag',
  newName: 'lengthSqr',
  target: Vec2,
  targetName: 'Vec2'
}, {
  name: 'scale',
  newName: 'multiplyScalar',
  target: Vec2,
  targetName: 'Vec2'
}, {
  name: 'exactEquals',
  newName: 'strictEquals',
  target: Vec2,
  targetName: 'Vec2'
}]);
exports.replaceProperty(Vec2.prototype, 'Vec2', [{
  name: 'mag',
  newName: 'length',
  target: Vec2.prototype,
  targetName: 'Vec2'
}, {
  name: 'magSqr',
  newName: 'lengthSqr',
  target: Vec2.prototype,
  targetName: 'Vec2'
}, {
  name: 'scale',
  newName: 'multiplyScalar',
  target: Vec2.prototype,
  targetName: 'Vec2'
}, {
  name: 'exactEquals',
  newName: 'strictEquals',
  target: Vec2.prototype,
  targetName: 'Vec2'
}]);
exports.replaceProperty(Vec3, 'Vec3', [{
  name: 'sub',
  newName: 'subtract',
  target: Vec3,
  targetName: 'Vec3'
}, {
  name: 'mul',
  newName: 'multiply',
  target: Vec3,
  targetName: 'Vec3'
}, {
  name: 'div',
  newName: 'divide',
  target: Vec3,
  targetName: 'Vec3'
}, {
  name: 'dist',
  newName: 'distance',
  target: Vec3,
  targetName: 'Vec3'
}, {
  name: 'sqrDist',
  newName: 'squaredDistance',
  target: Vec3,
  targetName: 'Vec3'
}, {
  name: 'mag',
  newName: 'len',
  target: Vec3,
  targetName: 'Vec3'
}, {
  name: 'sqrMag',
  newName: 'lengthSqr',
  target: Vec3,
  targetName: 'Vec3'
}, {
  name: 'scale',
  newName: 'multiplyScalar',
  target: Vec3,
  targetName: 'Vec3'
}, {
  name: 'exactEquals',
  newName: 'strictEquals',
  target: Vec3,
  targetName: 'Vec3'
}]);
exports.replaceProperty(Vec3.prototype, 'Vec3', [{
  name: 'mag',
  newName: 'length',
  target: Vec3.prototype,
  targetName: 'Vec3'
}, {
  name: 'magSqr',
  newName: 'lengthSqr',
  target: Vec3.prototype,
  targetName: 'Vec3'
}, {
  name: 'scale',
  newName: 'multiplyScalar',
  target: Vec3.prototype,
  targetName: 'Vec3'
}, {
  name: 'exactEquals',
  newName: 'strictEquals',
  target: Vec3.prototype,
  targetName: 'Vec3'
}]);
exports.replaceProperty(Vec4, 'Vec4', [{
  name: 'sub',
  newName: 'subtract',
  target: Vec4,
  targetName: 'Vec4'
}, {
  name: 'mul',
  newName: 'multiply',
  target: Vec4,
  targetName: 'Vec4'
}, {
  name: 'div',
  newName: 'divide',
  target: Vec4,
  targetName: 'Vec4'
}, {
  name: 'dist',
  newName: 'distance',
  target: Vec4,
  targetName: 'Vec4'
}, {
  name: 'sqrDist',
  newName: 'squaredDistance',
  target: Vec4,
  targetName: 'Vec4'
}, {
  name: 'mag',
  newName: 'len',
  target: Vec4,
  targetName: 'Vec4'
}, {
  name: 'sqrMag',
  newName: 'lengthSqr',
  target: Vec4,
  targetName: 'Vec4'
}, {
  name: 'scale',
  newName: 'multiplyScalar',
  target: Vec4,
  targetName: 'Vec4'
}, {
  name: 'exactEquals',
  newName: 'strictEquals',
  target: Vec4,
  targetName: 'Vec4'
}]);
exports.replaceProperty(Vec4.prototype, 'Vec4', [{
  name: 'mag',
  newName: 'length',
  target: Vec4.prototype,
  targetName: 'Vec4'
}, {
  name: 'magSqr',
  newName: 'lengthSqr',
  target: Vec4.prototype,
  targetName: 'Vec4'
}, {
  name: 'scale',
  newName: 'multiplyScalar',
  target: Vec4.prototype,
  targetName: 'Vec4'
}, {
  name: 'exactEquals',
  newName: 'strictEquals',
  target: Vec4.prototype,
  targetName: 'Vec4'
}]);
exports.replaceProperty(Quat, 'Quat', [{
  name: 'mag',
  newName: 'len',
  target: Quat,
  targetName: 'Quat'
}, {
  name: 'mul',
  newName: 'multiply',
  target: Quat,
  targetName: 'Quat'
}, {
  name: 'sqrMag',
  newName: 'lengthSqr',
  target: Quat,
  targetName: 'Quat'
}, {
  name: 'scale',
  newName: 'multiplyScalar',
  target: Quat,
  targetName: 'Quat'
}, {
  name: 'exactEquals',
  newName: 'strictEquals',
  target: Quat,
  targetName: 'Quat'
}]);
exports.replaceProperty(Quat.prototype, 'Quat', [{
  name: 'scale',
  newName: 'multiplyScalar',
  target: Quat.prototype,
  targetName: 'Quat'
}, {
  name: 'exactEquals',
  newName: 'strictEquals',
  target: Quat.prototype,
  targetName: 'Quat'
}]);
exports.replaceProperty(Color, 'Color', [{
  name: 'sub',
  newName: 'subtract',
  target: Color,
  targetName: 'Color'
}, {
  name: 'mul',
  newName: 'multiply',
  target: Color,
  targetName: 'Color'
}, {
  name: 'div',
  newName: 'divide',
  target: Color,
  targetName: 'Color'
}, {
  name: 'exactEquals',
  newName: 'strictEquals',
  target: Color,
  targetName: 'Color'
}, {
  name: 'fromHex',
  newName: 'fromHEX',
  customFunction: function customFunction() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var arg1 = args[1].toString(16);
    return legacyCC.Color.fromHEX(args[0], arg1);
  }
}]);
exports.replaceProperty(Mat3, 'Mat3', [{
  name: 'sub',
  newName: 'subtract',
  target: Mat3,
  targetName: 'Mat3'
}, {
  name: 'mul',
  newName: 'multiply',
  target: Mat3,
  targetName: 'Mat3'
}, {
  name: 'exactEquals',
  newName: 'strictEquals',
  target: Mat3,
  targetName: 'Mat3'
}, {
  name: 'transfrom',
  newName: 'transform',
  target: Mat3,
  targetName: 'Mat3'
}]);
exports.replaceProperty(Mat3.prototype, 'Mat3', [{
  name: 'sub',
  newName: 'subtract',
  target: Mat3.prototype,
  targetName: 'Mat3'
}, {
  name: 'mul',
  newName: 'multiply',
  target: Mat3.prototype,
  targetName: 'Mat3'
}, {
  name: 'mulScalar',
  newName: 'multiplyScalar',
  target: Mat3.prototype,
  targetName: 'Mat3'
}, {
  name: 'exactEquals',
  newName: 'strictEquals',
  target: Mat3.prototype,
  targetName: 'Mat3'
}]);
exports.replaceProperty(Mat4, 'Mat4', [{
  name: 'sub',
  newName: 'subtract',
  target: Mat4,
  targetName: 'Mat4'
}, {
  name: 'mul',
  newName: 'multiply',
  target: Mat4,
  targetName: 'Mat4'
}, {
  name: 'exactEquals',
  newName: 'strictEquals',
  target: Mat4,
  targetName: 'Mat4'
}]);
exports.replaceProperty(Mat4.prototype, 'Mat4', [{
  name: 'sub',
  newName: 'subtract',
  target: Mat4.prototype,
  targetName: 'Mat4'
}, {
  name: 'mul',
  newName: 'multiply',
  target: Mat4.prototype,
  targetName: 'Mat4'
}, {
  name: 'mulScalar',
  newName: 'multiplyScalar',
  target: Mat4.prototype,
  targetName: 'Mat4'
}, {
  name: 'exactEquals',
  newName: 'strictEquals',
  target: Mat4.prototype,
  targetName: 'Mat4'
}]);

var AffineTransform = function () {
  AffineTransform.identity = function identity() {
    return new AffineTransform();
  };

  AffineTransform.clone = function clone(affineTransform) {
    return new AffineTransform(affineTransform.a, affineTransform.b, affineTransform.c, affineTransform.d, affineTransform.tx, affineTransform.ty);
  };

  AffineTransform.concat = function concat(out, t1, t2) {
    var a = t1.a;
    var b = t1.b;
    var c = t1.c;
    var d = t1.d;
    var tx = t1.tx;
    var ty = t1.ty;
    out.a = a * t2.a + b * t2.c;
    out.b = a * t2.b + b * t2.d;
    out.c = c * t2.a + d * t2.c;
    out.d = c * t2.b + d * t2.d;
    out.tx = tx * t2.a + ty * t2.c + t2.tx;
    out.ty = tx * t2.b + ty * t2.d + t2.ty;
  };

  AffineTransform.invert = function invert(out, t) {
    var determinant = 1 / (t.a * t.d - t.b * t.c);
    out.a = determinant * t.d;
    out.b = -determinant * t.b;
    out.c = -determinant * t.c;
    out.d = determinant * t.a;
    out.tx = determinant * (t.c * t.ty - t.d * t.tx);
    out.ty = determinant * (t.b * t.tx - t.a * t.ty);
  };

  AffineTransform.fromMat4 = function fromMat4(out, mat) {
    out.a = mat.m00;
    out.b = mat.m01;
    out.c = mat.m04;
    out.d = mat.m05;
    out.tx = mat.m12;
    out.ty = mat.m13;
  };

  AffineTransform.transformVec2 = function transformVec2(out, point, transOrY, t) {
    var x;
    var y;

    if (t === undefined) {
      t = transOrY;
      x = point.x;
      y = point.y;
    } else {
      x = point;
      y = transOrY;
    }

    out.x = t.a * x + t.c * y + t.tx;
    out.y = t.b * x + t.d * y + t.ty;
  };

  AffineTransform.transformSize = function transformSize(out, size, t) {
    out.width = t.a * size.width + t.c * size.height;
    out.height = t.b * size.width + t.d * size.height;
  };

  AffineTransform.transformRect = function transformRect(out, rect, t) {
    var or = rect.x + rect.width;
    var ot = rect.y + rect.height;
    var lbx = t.a * rect.x + t.c * rect.y + t.tx;
    var lby = t.b * rect.x + t.d * rect.y + t.ty;
    var rbx = t.a * or + t.c * rect.y + t.tx;
    var rby = t.b * or + t.d * rect.y + t.ty;
    var ltx = t.a * rect.x + t.c * ot + t.tx;
    var lty = t.b * rect.x + t.d * ot + t.ty;
    var rtx = t.a * or + t.c * ot + t.tx;
    var rty = t.b * or + t.d * ot + t.ty;
    var minX = Math.min(lbx, rbx, ltx, rtx);
    var maxX = Math.max(lbx, rbx, ltx, rtx);
    var minY = Math.min(lby, rby, lty, rty);
    var maxY = Math.max(lby, rby, lty, rty);
    out.x = minX;
    out.y = minY;
    out.width = maxX - minX;
    out.height = maxY - minY;
  };

  AffineTransform.transformObb = function transformObb(out_bl, out_tl, out_tr, out_br, rect, anAffineTransform) {
    var tx = anAffineTransform.a * rect.x + anAffineTransform.c * rect.y + anAffineTransform.tx;
    var ty = anAffineTransform.b * rect.x + anAffineTransform.d * rect.y + anAffineTransform.ty;
    var xa = anAffineTransform.a * rect.width;
    var xb = anAffineTransform.b * rect.width;
    var yc = anAffineTransform.c * rect.height;
    var yd = anAffineTransform.d * rect.height;
    out_tl.x = tx;
    out_tl.y = ty;
    out_tr.x = xa + tx;
    out_tr.y = xb + ty;
    out_bl.x = yc + tx;
    out_bl.y = yd + ty;
    out_br.x = xa + yc + tx;
    out_br.y = xb + yd + ty;
  };

  function AffineTransform(a, b, c, d, tx, ty) {
    if (a === void 0) {
      a = 1;
    }

    if (b === void 0) {
      b = 0;
    }

    if (c === void 0) {
      c = 0;
    }

    if (d === void 0) {
      d = 1;
    }

    if (tx === void 0) {
      tx = 0;
    }

    if (ty === void 0) {
      ty = 0;
    }

    this.a = a;
    this.b = b;
    this.c = c;
    this.d = d;
    this.tx = tx;
    this.ty = ty;
  }

  return AffineTransform;
}();
legacyCC.AffineTransform = AffineTransform;

var Size = function (_ValueType) {
  _inheritsLoose(Size, _ValueType);

  Size.lerp = function lerp(out, from, to, ratio) {
    out.width = from.width + (to.width - from.width) * ratio;
    out.height = from.height + (to.height - from.height) * ratio;
    return out;
  };

  _createClass(Size, [{
    key: "x",
    set: function set(val) {
      this.width = val;
    },
    get: function get() {
      return this.width;
    }
  }, {
    key: "y",
    set: function set(val) {
      this.height = val;
    },
    get: function get() {
      return this.height;
    }
  }]);

  function Size(width, height) {
    var _this;

    _this = _ValueType.call(this) || this;

    if (width && typeof width === 'object') {
      _this.width = width.width;
      _this.height = width.height;
    } else {
      _this.width = width || 0;
      _this.height = height || 0;
    }

    return _this;
  }

  var _proto = Size.prototype;

  _proto.clone = function clone() {
    return new Size(this.width, this.height);
  };

  _proto.set = function set(width, height) {
    if (width && typeof width === 'object') {
      this.height = width.height;
      this.width = width.width;
    } else {
      this.width = width || 0;
      this.height = height || 0;
    }

    return this;
  };

  _proto.equals = function equals(other) {
    return this.width === other.width && this.height === other.height;
  };

  _proto.lerp = function lerp(to, ratio) {
    this.width += (to.width - this.width) * ratio;
    this.height += (to.height - this.height) * ratio;
    return this;
  };

  _proto.toString = function toString() {
    return "(" + this.width.toFixed(2) + ", " + this.height.toFixed(2) + ")";
  };

  return Size;
}(ValueType);
Size.ZERO = Object.freeze(new Size(0, 0));
Size.ONE = Object.freeze(new Size(1, 1));
enumerableProps(Size.prototype, ['x', 'y']);
CCClass.fastDefine('cc.Size', Size, {
  width: 0,
  height: 0
});
function size(width, height) {
  if (width === void 0) {
    width = 0;
  }

  if (height === void 0) {
    height = 0;
  }

  return new Size(width, height);
}
legacyCC.size = size;
legacyCC.Size = Size;

var Rect = function (_MathBase) {
  _inheritsLoose(Rect, _MathBase);

  Rect.fromMinMax = function fromMinMax(out, v1, v2) {
    var minX = Math.min(v1.x, v2.x);
    var minY = Math.min(v1.y, v2.y);
    var maxX = Math.max(v1.x, v2.x);
    var maxY = Math.max(v1.y, v2.y);
    out.x = minX;
    out.y = minY;
    out.width = maxX - minX;
    out.height = maxY - minY;
    return out;
  };

  Rect.lerp = function lerp(out, from, to, ratio) {
    var x = from.x;
    var y = from.y;
    var w = from.width;
    var h = from.height;
    out.x = x + (to.x - x) * ratio;
    out.y = y + (to.y - y) * ratio;
    out.width = w + (to.width - w) * ratio;
    out.height = h + (to.height - h) * ratio;
    return out;
  };

  Rect.intersection = function intersection(out, one, other) {
    var axMin = one.x;
    var ayMin = one.y;
    var axMax = one.x + one.width;
    var ayMax = one.y + one.height;
    var bxMin = other.x;
    var byMin = other.y;
    var bxMax = other.x + other.width;
    var byMax = other.y + other.height;
    out.x = Math.max(axMin, bxMin);
    out.y = Math.max(ayMin, byMin);
    out.width = Math.min(axMax, bxMax) - out.x;
    out.height = Math.min(ayMax, byMax) - out.y;
    return out;
  };

  Rect.union = function union(out, one, other) {
    var x = one.x;
    var y = one.y;
    var w = one.width;
    var h = one.height;
    var bx = other.x;
    var by = other.y;
    var bw = other.width;
    var bh = other.height;
    out.x = Math.min(x, bx);
    out.y = Math.min(y, by);
    out.width = Math.max(x + w, bx + bw) - out.x;
    out.height = Math.max(y + h, by + bh) - out.y;
    return out;
  };

  _createClass(Rect, [{
    key: "xMin",
    get: function get() {
      return this._array[0];
    },
    set: function set(value) {
      this._array[2] += this._array[0] - value;
      this._array[0] = value;
    }
  }, {
    key: "yMin",
    get: function get() {
      return this._array[1];
    },
    set: function set(value) {
      this._array[3] += this._array[1] - value;
      this._array[1] = value;
    }
  }, {
    key: "xMax",
    get: function get() {
      return this._array[0] + this._array[2];
    },
    set: function set(value) {
      this._array[2] = value - this._array[0];
    }
  }, {
    key: "yMax",
    get: function get() {
      return this._array[1] + this._array[3];
    },
    set: function set(value) {
      this._array[3] = value - this._array[1];
    }
  }, {
    key: "center",
    get: function get() {
      return new Vec2(this._array[0] + this._array[2] * 0.5, this._array[1] + this._array[3] * 0.5);
    },
    set: function set(value) {
      this._array[0] = value.x - this._array[2] * 0.5;
      this._array[1] = value.y - this._array[3] * 0.5;
    }
  }, {
    key: "origin",
    get: function get() {
      return new Vec2(this._array[0], this._array[1]);
    },
    set: function set(value) {
      this._array[0] = value.x;
      this._array[1] = value.y;
    }
  }, {
    key: "size",
    get: function get() {
      return new Size(this._array[2], this._array[3]);
    },
    set: function set(value) {
      this._array[2] = value.width;
      this._array[3] = value.height;
    }
  }, {
    key: "x",
    get: function get() {
      return this._array[0];
    },
    set: function set(val) {
      this._array[0] = val;
    }
  }, {
    key: "y",
    get: function get() {
      return this._array[1];
    },
    set: function set(val) {
      this._array[1] = val;
    }
  }, {
    key: "width",
    get: function get() {
      return this._array[2];
    },
    set: function set(val) {
      this._array[2] = val;
    }
  }, {
    key: "z",
    get: function get() {
      return this._array[2];
    },
    set: function set(val) {
      this._array[2] = val;
    }
  }, {
    key: "height",
    get: function get() {
      return this._array[3];
    },
    set: function set(val) {
      this._array[3] = val;
    }
  }, {
    key: "w",
    get: function get() {
      return this._array[3];
    },
    set: function set(val) {
      this._array[3] = val;
    }
  }]);

  function Rect(x, y, width, height) {
    var _this;

    _this = _MathBase.call(this) || this;

    if (x && typeof x === 'object') {
      if (ArrayBuffer.isView(x)) {
        _this._array = x;

        _this._array.fill(0);
      } else {
        var v = x.array;
        _this._array = MathBase.createFloatArray(4);
        _this._array[0] = v[0];
        _this._array[1] = v[1];
        _this._array[2] = v[2];
        _this._array[3] = v[3];
      }
    } else {
      _this._array = MathBase.createFloatArray(4);
      _this._array[0] = x || 0;
      _this._array[1] = y || 0;
      _this._array[2] = width || 0;
      _this._array[3] = height || 0;
    }

    return _this;
  }

  var _proto = Rect.prototype;

  _proto.clone = function clone() {
    return new Rect(this._array[0], this._array[1], this._array[2], this._array[3]);
  };

  _proto.set = function set(x, y, width, height) {
    if (x && typeof x === 'object') {
      var v = x.array;
      this._array[0] = v[0];
      this._array[1] = v[1];
      this._array[2] = v[2];
      this._array[3] = v[3];
    } else {
      this._array[0] = x || 0;
      this._array[1] = y || 0;
      this._array[2] = width || 0;
      this._array[3] = height || 0;
    }

    return this;
  };

  _proto.equals = function equals(other) {
    var v = other.array;
    return this._array[0] === v[0] && this._array[1] === v[1] && this._array[2] === v[2] && this._array[3] === v[3];
  };

  _proto.lerp = function lerp(to, ratio) {
    var x = this._array[0];
    var y = this._array[1];
    var w = this._array[2];
    var h = this._array[3];
    var v = to.array;
    this._array[0] = x + (v[0] - x) * ratio;
    this._array[1] = y + (v[1] - y) * ratio;
    this._array[2] = w + (v[2] - w) * ratio;
    this._array[3] = h + (v[3] - h) * ratio;
    return this;
  };

  _proto.toString = function toString() {
    return "(" + this._array[0].toFixed(2) + ", " + this._array[1].toFixed(2) + ", " + this._array[2].toFixed(2) + ", " + this._array[3].toFixed(2) + ")";
  };

  _proto.intersects = function intersects(other) {
    var maxax = this._array[0] + this._array[2];
    var maxay = this._array[1] + this._array[3];
    var v = other.array;
    var maxbx = v[0] + v[2];
    var maxby = v[1] + v[3];
    return !(maxax < v[0] || maxbx < this._array[0] || maxay < v[1] || maxby < this._array[1]);
  };

  _proto.contains = function contains(point) {
    var v = point.array;
    return this._array[0] <= v[0] && this._array[0] + this._array[2] >= v[0] && this._array[1] <= v[1] && this._array[1] + this._array[3] >= v[1];
  };

  _proto.containsRect = function containsRect(other) {
    var v = other.array;
    return this._array[0] <= v[0] && this._array[0] + this._array[2] >= v[0] + v[2] && this._array[1] <= v[1] && this._array[1] + this._array[3] >= v[1] + v[3];
  };

  _proto.transformMat4 = function transformMat4(mat) {
    var ol = this._array[0];
    var ob = this._array[1];
    var or = ol + this._array[2];
    var ot = ob + this._array[3];
    var v = mat.array;
    var lbx = v[0] * ol + v[4] * ob + v[12];
    var lby = v[1] * ol + v[5] * ob + v[13];
    var rbx = v[0] * or + v[4] * ob + v[12];
    var rby = v[1] * or + v[5] * ob + v[13];
    var ltx = v[0] * ol + v[4] * ot + v[12];
    var lty = v[1] * ol + v[5] * ot + v[13];
    var rtx = v[0] * or + v[4] * ot + v[12];
    var rty = v[1] * or + v[5] * ot + v[13];
    var minX = Math.min(lbx, rbx, ltx, rtx);
    var maxX = Math.max(lbx, rbx, ltx, rtx);
    var minY = Math.min(lby, rby, lty, rty);
    var maxY = Math.max(lby, rby, lty, rty);
    this._array[0] = minX;
    this._array[1] = minY;
    this._array[2] = maxX - minX;
    this._array[3] = maxY - minY;
    return this;
  };

  _proto.transformMat4ToPoints = function transformMat4ToPoints(mat, out_lb, out_lt, out_rt, out_rb) {
    var ol = this.x;
    var ob = this.y;
    var or = ol + this.width;
    var ot = ob + this.height;
    out_lb.x = mat.m00 * ol + mat.m04 * ob + mat.m12;
    out_lb.y = mat.m01 * ol + mat.m05 * ob + mat.m13;
    out_rb.x = mat.m00 * or + mat.m04 * ob + mat.m12;
    out_rb.y = mat.m01 * or + mat.m05 * ob + mat.m13;
    out_lt.x = mat.m00 * ol + mat.m04 * ot + mat.m12;
    out_lt.y = mat.m01 * ol + mat.m05 * ot + mat.m13;
    out_rt.x = mat.m00 * or + mat.m04 * ot + mat.m12;
    out_rt.y = mat.m01 * or + mat.m05 * ot + mat.m13;
  };

  return Rect;
}(MathBase);
enumerableProps(Rect.prototype, ['x', 'y', 'z', 'w', 'width', 'height', 'xMin', 'yMin', 'xMax', 'yMax']);
CCClass.fastDefine('cc.Rect', Rect, {
  x: 0,
  y: 0,
  width: 0,
  height: 0
});
legacyCC.Rect = Rect;
function rect(x, y, width, height) {
  if (x === void 0) {
    x = 0;
  }

  if (y === void 0) {
    y = 0;
  }

  if (width === void 0) {
    width = 0;
  }

  if (height === void 0) {
    height = 0;
  }

  return new Rect(x, y, width, height);
}
legacyCC.rect = rect;

var ScreenAdapter = function (_EventTarget) {
  _inheritsLoose(ScreenAdapter, _EventTarget);

  function ScreenAdapter() {
    var _this;

    _this = _EventTarget.call(this) || this;
    _this._gameFrame = void 0;
    _this._supportFullScreen = false;
    _this._touchEventName = void 0;
    _this._onFullscreenChange = void 0;
    _this._onFullscreenError = void 0;
    _this._fn = {};
    _this._fnGroup = [['requestFullscreen', 'exitFullscreen', 'fullscreenchange', 'fullscreenEnabled', 'fullscreenElement', 'fullscreenerror'], ['requestFullScreen', 'exitFullScreen', 'fullScreenchange', 'fullScreenEnabled', 'fullScreenElement', 'fullscreenerror'], ['webkitRequestFullScreen', 'webkitCancelFullScreen', 'webkitfullscreenchange', 'webkitIsFullScreen', 'webkitCurrentFullScreenElement', 'webkitfullscreenerror'], ['mozRequestFullScreen', 'mozCancelFullScreen', 'mozfullscreenchange', 'mozFullScreen', 'mozFullScreenElement', 'mozfullscreenerror'], ['msRequestFullscreen', 'msExitFullscreen', 'MSFullscreenChange', 'msFullscreenEnabled', 'msFullscreenElement', 'msfullscreenerror']];
    _this._gameFrame = document.getElementById('GameDiv');
    var fnList;
    var fnGroup = _this._fnGroup;

    for (var i = 0; i < fnGroup.length; i++) {
      fnList = fnGroup[i];

      if (typeof document[fnList[1]] !== 'undefined') {
        for (var _i = 0; _i < fnList.length; _i++) {
          _this._fn[fnGroup[0][_i]] = fnList[_i];
        }

        break;
      }
    }

    _this._supportFullScreen = _this._fn.requestFullscreen !== undefined;
    _this._touchEventName = 'ontouchstart' in window ? 'touchend' : 'mousedown';

    _this._registerEvent();

    return _this;
  }

  var _proto = ScreenAdapter.prototype;

  _proto._registerEvent = function _registerEvent() {
    var _this2 = this;

    document.addEventListener(this._fn.fullscreenerror, function () {
      var _this2$_onFullscreenE;

      (_this2$_onFullscreenE = _this2._onFullscreenError) === null || _this2$_onFullscreenE === void 0 ? void 0 : _this2$_onFullscreenE.call(_this2);
    });
    document.addEventListener(this._fn.fullscreenchange, function () {
      var _this2$_onFullscreenC;

      (_this2$_onFullscreenC = _this2._onFullscreenChange) === null || _this2$_onFullscreenC === void 0 ? void 0 : _this2$_onFullscreenC.call(_this2);
    });
    window.addEventListener('resize', function () {
      _this2.emit('window-resize');
    });
    window.addEventListener('orientationchange', function () {
      _this2.emit('orientation-change');
    });
    document.addEventListener(this._fn.fullscreenchange, function () {
      _this2.emit('fullscreen-change');
    });
  };

  _proto._doRequestFullScreen = function _doRequestFullScreen() {
    var _this3 = this;

    return new Promise(function (resolve, reject) {
      if (!_this3._gameFrame) {
        reject(new Error('Cannot access game frame'));
        return;
      }

      if (!_this3._supportFullScreen) {
        reject(new Error('fullscreen is not supported'));
        return;
      }

      _this3._onFullscreenChange = undefined;
      _this3._onFullscreenError = undefined;

      var requestPromise = _this3._gameFrame[_this3._fn.requestFullscreen]();

      if (window.Promise && requestPromise instanceof Promise) {
        requestPromise.then(resolve)["catch"](reject);
      } else {
        _this3._onFullscreenChange = resolve;
        _this3._onFullscreenError = reject;
      }
    });
  };

  _proto.requestFullScreen = function requestFullScreen() {
    var _this4 = this;

    return new Promise(function (resolve, reject) {
      _this4._doRequestFullScreen().then(function () {
        resolve();
      })["catch"](function () {
        if (!_this4._gameFrame) {
          reject(new Error('Cannot access game frame'));
          return;
        }

        _this4._gameFrame.addEventListener(_this4._touchEventName, function () {
          _this4._doRequestFullScreen().then(function () {
            resolve();
          })["catch"](reject);
        }, {
          once: true,
          capture: true
        });
      });
    });
  };

  _proto.exitFullScreen = function exitFullScreen() {
    var _this5 = this;

    return new Promise(function (resolve, reject) {
      var requestPromise = document[_this5._fn.exitFullscreen]();

      if (window.Promise && requestPromise instanceof Promise) {
        requestPromise.then(resolve)["catch"](reject);
        return;
      }

      resolve();
    });
  };

  _createClass(ScreenAdapter, [{
    key: "supportFullScreen",
    get: function get() {
      return this._supportFullScreen;
    }
  }, {
    key: "isFullScreen",
    get: function get() {
      if (!this._supportFullScreen) {
        return false;
      }

      return !!document[this._fn.fullscreenElement];
    }
  }, {
    key: "windowSize",
    get: function get() {
      if (this._gameFrame) {
        return new Size(this._gameFrame.clientWidth, this._gameFrame.clientHeight);
      } else {
        return new Size(window.innerWidth, window.innerHeight);
      }
    },
    set: function set(size) {
      console.warn('Setting window size is not supported yet.');
    }
  }, {
    key: "orientation",
    get: function get() {
      throw new Error('Method not implemented.');
    }
  }, {
    key: "safeAreaEdge",
    get: function get() {
      return {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      };
    }
  }]);

  return ScreenAdapter;
}(EventTarget);

var screenAdapter = new ScreenAdapter();

var windowSize = screenAdapter.windowSize;
var pixelRatio = systemInfo.pixelRatio;
var sys = {
  NetworkType: NetworkType,
  Language: Language,
  OS: exports.OS,
  Platform: Platform,
  BrowserType: exports.BrowserType,
  isNative: systemInfo.isNative,
  isBrowser: systemInfo.isBrowser,
  isMobile: systemInfo.isMobile,
  isLittleEndian: systemInfo.isLittleEndian,
  platform: systemInfo.platform,
  language: systemInfo.language,
  languageCode: systemInfo.nativeLanguage,
  os: systemInfo.os,
  osVersion: systemInfo.osVersion,
  osMainVersion: systemInfo.osMainVersion,
  browserType: systemInfo.browserType,
  browserVersion: systemInfo.browserVersion,
  windowPixelResolution: {
    width: windowSize.width * pixelRatio,
    height: windowSize.height * pixelRatio
  },
  capabilities: {
    canvas: systemInfo.supportCapability.canvas,
    opengl: systemInfo.supportCapability.gl,
    webp: systemInfo.supportCapability.webp,
    imageBitmap: systemInfo.supportCapability.imageBitmap,
    touches: false,
    mouse: false,
    keyboard: false,
    accelerometer: false
  },
  localStorage: {},
  getNetworkType: function getNetworkType() {
    return systemInfo.networkType;
  },
  getBatteryLevel: function getBatteryLevel() {
    return systemInfo.getBatteryLevel();
  },
  garbageCollect: function garbageCollect() {
    systemInfo.triggerGC();
  },
  isObjectValid: function isObjectValid(obj) {
    if (obj === null || obj === undefined) {
      return false;
    }

    return true;
  },
  dump: function dump() {
    var str = '';
    str += "isMobile : " + this.isMobile + "\r\n";
    str += "language : " + this.language + "\r\n";
    str += "browserType : " + this.browserType + "\r\n";
    str += "browserVersion : " + this.browserVersion + "\r\n";
    str += "capabilities : " + JSON.stringify(this.capabilities) + "\r\n";
    str += "os : " + this.os + "\r\n";
    str += "osVersion : " + this.osVersion + "\r\n";
    str += "platform : " + this.platform + "\r\n";
    str += "Using " + (legacyCC.game.renderType === legacyCC.game.RENDER_TYPE_WEBGL ? 'WEBGL' : 'CANVAS') + " renderer.\r\n";
    log(str);
  },
  openURL: function openURL(url) {
    systemInfo.openURL(url);
  },
  now: function now() {
    return systemInfo.now();
  },
  restartVM: function restartVM() {
    systemInfo.restartJSVM();
  },
  getSafeAreaRect: function getSafeAreaRect() {
    var locView = legacyCC.view;
    var edge = screenAdapter.safeAreaEdge;
    var windowSize = screenAdapter.windowSize;
    var leftBottom = new Vec2(edge.left, windowSize.height - edge.bottom);
    var rightTop = new Vec2(windowSize.width - edge.right, edge.top);
    var relatedPos = {
      left: 0,
      top: 0,
      width: windowSize.width,
      height: windowSize.height
    };
    locView.convertToLocationInView(leftBottom.x, leftBottom.y, relatedPos, leftBottom);
    locView.convertToLocationInView(rightTop.x, rightTop.y, relatedPos, rightTop);

    locView._convertPointWithScale(leftBottom);

    locView._convertPointWithScale(rightTop);

    var x = leftBottom.x;
    var y = leftBottom.y;
    var width = rightTop.x - leftBottom.x;
    var height = rightTop.y - leftBottom.y;
    return new Rect(x, y, width, height);
  }
};

(function initSys() {
  try {
    var localStorage = sys.localStorage = window.localStorage;
    localStorage.setItem('storage', '');
    localStorage.removeItem('storage');
    localStorage = null;
  } catch (e) {
    var warn = function warn() {
      warnID(5200);
    };

    sys.localStorage = {
      getItem: warn,
      setItem: warn,
      clear: warn,
      removeItem: warn
    };
  }

  var win = window;
  var nav = win.navigator;
  var doc = document;
  var docEle = doc.documentElement;
  var capabilities = sys.capabilities;

  if (docEle.ontouchstart !== undefined || doc.ontouchstart !== undefined || nav.msPointerEnabled) {
    capabilities.touches = true;
  }

  if (docEle.onmouseup !== undefined) {
    capabilities.mouse = true;
  }

  if (docEle.onkeyup !== undefined) {
    capabilities.keyboard = true;
  }

  if (win.DeviceMotionEvent || win.DeviceOrientationEvent) {
    capabilities.accelerometer = true;
  }

  sys.__isWebIOS14OrIPadOS14Env = (sys.os === exports.OS.IOS || sys.os === exports.OS.OSX) && systemInfo.isBrowser && /(OS 1[4-9])|(Version\/1[4-9])/.test(window.navigator.userAgent);
  screenAdapter.on('window-resize', function () {
    var windowSize = screenAdapter.windowSize;
    sys.windowPixelResolution = {
      width: Math.round(windowSize.width * pixelRatio),
      height: Math.round(windowSize.height * pixelRatio)
    };
  });
})();

legacyCC.sys = sys;

var EXTNAME_RE = /(\.[^\.\/\?\\]*)(\?.*)?$/;
var DIRNAME_RE = /((.*)(\/|\\|\\\\))?(.*?\..*$)?/;
var NORMALIZE_RE = /[^\.\/]+\/\.\.\//;
function join() {
  var result = '';

  for (var _len = arguments.length, segments = new Array(_len), _key = 0; _key < _len; _key++) {
    segments[_key] = arguments[_key];
  }

  for (var _i = 0, _segments = segments; _i < _segments.length; _i++) {
    var segment = _segments[_i];
    result = (result + (result === '' ? '' : '/') + segment).replace(/(\/|\\\\)$/, '');
  }

  return result;
}
function extname(path) {
  var temp = EXTNAME_RE.exec(path);
  return temp ? temp[1] : '';
}
function mainFileName(fileName) {
  if (fileName) {
    var idx = fileName.lastIndexOf('.');

    if (idx !== -1) {
      return fileName.substring(0, idx);
    }
  }

  return fileName;
}
function basename(path, extName) {
  var index = path.indexOf('?');

  if (index > 0) {
    path = path.substring(0, index);
  }

  var reg = /(\/|\\)([^\/\\]+)$/g;
  var result = reg.exec(path.replace(/(\/|\\)$/, ''));

  if (!result) {
    return path;
  }

  var baseName = result[2];

  if (extName && path.substring(path.length - extName.length).toLowerCase() === extName.toLowerCase()) {
    return baseName.substring(0, baseName.length - extName.length);
  }

  return baseName;
}
function dirname(path) {
  var temp = DIRNAME_RE.exec(path);
  return temp ? temp[2] : '';
}
function changeExtname(path, extName) {
  extName = extName || '';
  var index = path.indexOf('?');
  var tempStr = '';

  if (index > 0) {
    tempStr = path.substring(index);
    path = path.substring(0, index);
  }

  index = path.lastIndexOf('.');

  if (index < 0) {
    return path + extName + tempStr;
  }

  return path.substring(0, index) + extName + tempStr;
}
function changeBasename(path, baseName, isSameExt) {
  if (baseName.indexOf('.') === 0) {
    return changeExtname(path, baseName);
  }

  var index = path.indexOf('?');
  var tempStr = '';
  var ext = isSameExt ? extname(path) : '';

  if (index > 0) {
    tempStr = path.substring(index);
    path = path.substring(0, index);
  }

  index = path.lastIndexOf('/');
  index = index <= 0 ? 0 : index + 1;
  return path.substring(0, index) + baseName + ext + tempStr;
}
function _normalize(url) {
  var oldUrl = url = String(url);

  do {
    oldUrl = url;
    url = url.replace(NORMALIZE_RE, '');
  } while (oldUrl.length !== url.length);

  return url;
}
function stripSep(path) {
  return path.replace(/[\/\\]$/, '');
}
function getSeperator() {
  return sys.os === exports.OS.WINDOWS ? '\\' : '/';
}

var path = /*#__PURE__*/Object.freeze({
    __proto__: null,
    join: join,
    extname: extname,
    mainFileName: mainFileName,
    basename: basename,
    dirname: dirname,
    changeExtname: changeExtname,
    changeBasename: changeBasename,
    _normalize: _normalize,
    stripSep: stripSep,
    getSeperator: getSeperator
});

var Ambient = function () {
  _createClass(Ambient, [{
    key: "colorArray",
    get: function get() {
      return this._colorArray;
    }
  }, {
    key: "albedoArray",
    get: function get() {
      return this._albedoArray;
    }
  }, {
    key: "enabled",
    set: function set(val) {
      this._enabled = val;
    },
    get: function get() {
      return this._enabled;
    }
  }, {
    key: "skyColor",
    get: function get() {
      return this._skyColor;
    },
    set: function set(color) {
      this._skyColor.set(color);

      Color.toArray(this._colorArray, this._skyColor);
    }
  }, {
    key: "skyIllum",
    get: function get() {
      return this._skyIllum;
    },
    set: function set(illum) {
      this._skyIllum = illum;
    }
  }, {
    key: "groundAlbedo",
    get: function get() {
      return this._groundAlbedo;
    },
    set: function set(color) {
      this._groundAlbedo.set(color);

      Vec3.toArray(this._albedoArray, this._groundAlbedo);
    }
  }, {
    key: "native",
    get: function get() {
      return this._nativeObj;
    }
  }]);

  function Ambient() {
    this._skyColor = new Color(51, 128, 204, 1.0);
    this._groundAlbedo = new Color(51, 51, 51, 255);
    this._albedoArray = Float32Array.from([0.2, 0.2, 0.2, 1.0]);
    this._colorArray = Float32Array.from([0.2, 0.5, 0.8, 1.0]);
    this._enabled = false;
    this._skyIllum = 0;
  }

  var _proto = Ambient.prototype;

  _proto.initialize = function initialize(ambientInfo) {
    this.skyColor = ambientInfo.skyColor;
    this.groundAlbedo = ambientInfo.groundAlbedo;
    this.skyIllum = ambientInfo.skyIllum;
  };

  _proto._destroy = function _destroy() {
  };

  _proto.destroy = function destroy() {
    this._destroy();
  };

  return Ambient;
}();
Ambient.SUN_ILLUM = 65000.0;
Ambient.SKY_ILLUM = 20000.0;
legacyCC.Ambient = Ambient;

var X = new Vec3();
var Y = new Vec3();
var Z = new Vec3();
var d = new Vec3();
var min$1 = new Vec3();
var max$1 = new Vec3();
var u = new Array(3);
var e = new Array(3);
function point_plane(point, plane_) {
  return Vec3.dot(plane_.n, point) - plane_.d;
}
function pt_point_plane(out, point, plane_) {
  var t = point_plane(point, plane_);
  return Vec3.subtract(out, point, Vec3.multiplyScalar(out, plane_.n, t));
}
function pt_point_aabb(out, point, aabb_) {
  Vec3.copy(out, point);
  Vec3.subtract(min$1, aabb_.center, aabb_.halfExtents);
  Vec3.add(max$1, aabb_.center, aabb_.halfExtents);
  out.x = out.x < min$1.x ? min$1.x : out.x;
  out.y = out.y < min$1.y ? min$1.y : out.y;
  out.z = out.z < min$1.z ? min$1.z : out.z;
  out.x = out.x > max$1.x ? max$1.x : out.x;
  out.y = out.y > max$1.y ? max$1.y : out.y;
  out.z = out.z > max$1.z ? max$1.z : out.z;
  return out;
}
function pt_point_obb(out, point, obb_) {
  Vec3.set(X, obb_.orientation.m00, obb_.orientation.m01, obb_.orientation.m02);
  Vec3.set(Y, obb_.orientation.m03, obb_.orientation.m04, obb_.orientation.m05);
  Vec3.set(Z, obb_.orientation.m06, obb_.orientation.m07, obb_.orientation.m08);
  u[0] = X;
  u[1] = Y;
  u[2] = Z;
  e[0] = obb_.halfExtents.x;
  e[1] = obb_.halfExtents.y;
  e[2] = obb_.halfExtents.z;
  Vec3.subtract(d, point, obb_.center);
  Vec3.set(out, obb_.center.x, obb_.center.y, obb_.center.z);

  for (var i = 0; i < 3; i++) {
    var dist = Vec3.dot(d, u[i]);

    if (dist > e[i]) {
      dist = e[i];
    }

    if (dist < -e[i]) {
      dist = -e[i];
    }

    out.x += dist * u[i].x;
    out.y += dist * u[i].y;
    out.z += dist * u[i].z;
  }

  return out;
}
function pt_point_line(out, point, linePointA, linePointB) {
  Vec3.subtract(X, linePointA, linePointB);
  var dir = X;
  var dirSquaredLength = Vec3.lengthSqr(dir);

  if (dirSquaredLength == 0) {
    Vec3.copy(out, linePointA);
  } else {
    Vec3.subtract(X, point, linePointA);
    var t = Vec3.dot(X, dir) / dirSquaredLength;

    if (t < 0) {
      Vec3.copy(out, linePointA);
    } else if (t > 1) {
      Vec3.copy(out, linePointB);
    } else {
      Vec3.scaleAndAdd(out, linePointA, dir, t);
    }
  }
}

var distance = /*#__PURE__*/Object.freeze({
    __proto__: null,
    point_plane: point_plane,
    pt_point_plane: pt_point_plane,
    pt_point_aabb: pt_point_aabb,
    pt_point_obb: pt_point_obb,
    pt_point_line: pt_point_line
});

var enums = {
  SHAPE_RAY: 1 << 0,
  SHAPE_LINE: 1 << 1,
  SHAPE_SPHERE: 1 << 2,
  SHAPE_AABB: 1 << 3,
  SHAPE_OBB: 1 << 4,
  SHAPE_PLANE: 1 << 5,
  SHAPE_TRIANGLE: 1 << 6,
  SHAPE_FRUSTUM: 1 << 7,
  SHAPE_FRUSTUM_ACCURATE: 1 << 8,
  SHAPE_CAPSULE: 1 << 9
};

var Line = function () {
  Line.create = function create(sx, sy, sz, ex, ey, ez) {
    return new Line(sx, sy, sz, ex, ey, ez);
  };

  Line.clone = function clone(a) {
    return new Line(a.s.x, a.s.y, a.s.z, a.e.x, a.e.y, a.e.z);
  };

  Line.copy = function copy(out, a) {
    Vec3.copy(out.s, a.s);
    Vec3.copy(out.e, a.e);
    return out;
  };

  Line.fromPoints = function fromPoints(out, start, end) {
    Vec3.copy(out.s, start);
    Vec3.copy(out.e, end);
    return out;
  };

  Line.set = function set(out, sx, sy, sz, ex, ey, ez) {
    out.s.x = sx;
    out.s.y = sy;
    out.s.z = sz;
    out.e.x = ex;
    out.e.y = ey;
    out.e.z = ez;
    return out;
  };

  Line.len = function len(a) {
    return Vec3.distance(a.s, a.e);
  };

  _createClass(Line, [{
    key: "type",
    get: function get() {
      return this._type;
    }
  }]);

  function Line(sx, sy, sz, ex, ey, ez) {
    if (sx === void 0) {
      sx = 0;
    }

    if (sy === void 0) {
      sy = 0;
    }

    if (sz === void 0) {
      sz = 0;
    }

    if (ex === void 0) {
      ex = 0;
    }

    if (ey === void 0) {
      ey = 0;
    }

    if (ez === void 0) {
      ez = -1;
    }

    this.s = void 0;
    this.e = void 0;
    this._type = void 0;
    this._type = enums.SHAPE_LINE;
    this.s = new Vec3(sx, sy, sz);
    this.e = new Vec3(ex, ey, ez);
  }

  var _proto = Line.prototype;

  _proto.length = function length() {
    return Vec3.distance(this.s, this.e);
  };

  return Line;
}();

var Ray = function () {
  Ray.create = function create(ox, oy, oz, dx, dy, dz) {
    if (ox === void 0) {
      ox = 0;
    }

    if (oy === void 0) {
      oy = 0;
    }

    if (oz === void 0) {
      oz = 0;
    }

    if (dx === void 0) {
      dx = 0;
    }

    if (dy === void 0) {
      dy = 0;
    }

    if (dz === void 0) {
      dz = 1;
    }

    return new Ray(ox, oy, oz, dx, dy, dz);
  };

  Ray.clone = function clone(a) {
    return new Ray(a.o.x, a.o.y, a.o.z, a.d.x, a.d.y, a.d.z);
  };

  Ray.copy = function copy(out, a) {
    Vec3.copy(out.o, a.o);
    Vec3.copy(out.d, a.d);
    return out;
  };

  Ray.fromPoints = function fromPoints(out, origin, target) {
    Vec3.copy(out.o, origin);
    Vec3.normalize(out.d, Vec3.subtract(out.d, target, origin));
    return out;
  };

  Ray.set = function set(out, ox, oy, oz, dx, dy, dz) {
    out.o.x = ox;
    out.o.y = oy;
    out.o.z = oz;
    out.d.x = dx;
    out.d.y = dy;
    out.d.z = dz;
    return out;
  };

  _createClass(Ray, [{
    key: "type",
    get: function get() {
      return this._type;
    }
  }]);

  function Ray(ox, oy, oz, dx, dy, dz) {
    if (ox === void 0) {
      ox = 0;
    }

    if (oy === void 0) {
      oy = 0;
    }

    if (oz === void 0) {
      oz = 0;
    }

    if (dx === void 0) {
      dx = 0;
    }

    if (dy === void 0) {
      dy = 0;
    }

    if (dz === void 0) {
      dz = -1;
    }

    this.o = void 0;
    this.d = void 0;
    this._type = void 0;
    this._type = enums.SHAPE_RAY;
    this.o = new Vec3(ox, oy, oz);
    this.d = new Vec3(dx, dy, dz);
  }

  var _proto = Ray.prototype;

  _proto.computeHit = function computeHit(out, distance) {
    Vec3.normalize(out, this.d);
    Vec3.scaleAndAdd(out, this.o, out, distance);
  };

  return Ray;
}();

var _v3_tmp = new Vec3();

var _offset = new Vec3();

var _min = new Vec3();

var _max = new Vec3();

function maxComponent(v) {
  return Math.max(Math.max(v.x, v.y), v.z);
}

var Sphere = function () {
  Sphere.create = function create(cx, cy, cz, r) {
    return new Sphere(cx, cy, cz, r);
  };

  Sphere.clone = function clone(p) {
    return new Sphere(p.center.x, p.center.y, p.center.z, p.radius);
  };

  Sphere.copy = function copy(out, p) {
    Vec3.copy(out.center, p.center);
    out.radius = p.radius;
    return out;
  };

  Sphere.fromPoints = function fromPoints(out, minPos, maxPos) {
    Vec3.multiplyScalar(out.center, Vec3.add(_v3_tmp, minPos, maxPos), 0.5);
    out.radius = Vec3.subtract(_v3_tmp, maxPos, minPos).length() * 0.5;
    return out;
  };

  Sphere.set = function set(out, cx, cy, cz, r) {
    out.center.x = cx;
    out.center.y = cy;
    out.center.z = cz;
    out.radius = r;
    return out;
  };

  Sphere.mergePoint = function mergePoint(out, s, point) {
    if (s.radius < 0.0) {
      out.center.set(point);
      out.radius = 0.0;
      return out;
    }

    Vec3.subtract(_offset, point, s.center);

    var dist = _offset.length();

    if (dist > s.radius) {
      var half = (dist - s.radius) * 0.5;
      out.radius += half;
      Vec3.multiplyScalar(_offset, _offset, half / dist);
      Vec3.add(out.center, out.center, _offset);
    }

    return out;
  };

  Sphere.mergeAABB = function mergeAABB(out, s, a) {
    a.getBoundary(_min, _max);
    Sphere.mergePoint(out, s, _min);
    Sphere.mergePoint(out, s, _max);
    return out;
  };

  _createClass(Sphere, [{
    key: "center",
    get: function get() {
      return this._center;
    },
    set: function set(val) {
      this._center = val;
    }
  }, {
    key: "radius",
    get: function get() {
      return this._radius;
    },
    set: function set(val) {
      this._radius = val;
    }
  }, {
    key: "type",
    get: function get() {
      return this._type;
    }
  }]);

  function Sphere(cx, cy, cz, r) {
    if (cx === void 0) {
      cx = 0;
    }

    if (cy === void 0) {
      cy = 0;
    }

    if (cz === void 0) {
      cz = 0;
    }

    if (r === void 0) {
      r = 1;
    }

    this._center = new Vec3(0, 0, 0);
    this._radius = 0;
    this._type = void 0;
    this._type = enums.SHAPE_SPHERE;
    this._center = new Vec3(cx, cy, cz);
    this._radius = r;
  }

  var _proto = Sphere.prototype;

  _proto.destroy = function destroy() {};

  _proto.clone = function clone() {
    return Sphere.clone(this);
  };

  _proto.copy = function copy(a) {
    return Sphere.copy(this, a);
  };

  _proto.getBoundary = function getBoundary(minPos, maxPos) {
    Vec3.set(minPos, this.center.x - this.radius, this.center.y - this.radius, this.center.z - this.radius);
    Vec3.set(maxPos, this.center.x + this.radius, this.center.y + this.radius, this.center.z + this.radius);
  };

  _proto.transform = function transform(m, pos, rot, scale, out) {
    Vec3.transformMat4(out.center, this.center, m);
    out.radius = this.radius * maxComponent(scale);
  };

  _proto.translateAndRotate = function translateAndRotate(m, rot, out) {
    Vec3.transformMat4(out.center, this.center, m);
  };

  _proto.setScale = function setScale(scale, out) {
    out.radius = this.radius * maxComponent(scale);
  };

  return Sphere;
}();

var Triangle = function () {
  Triangle.create = function create(ax, ay, az, bx, by, bz, cx, cy, cz) {
    if (ax === void 0) {
      ax = 1;
    }

    if (ay === void 0) {
      ay = 0;
    }

    if (az === void 0) {
      az = 0;
    }

    if (bx === void 0) {
      bx = 0;
    }

    if (by === void 0) {
      by = 0;
    }

    if (bz === void 0) {
      bz = 0;
    }

    if (cx === void 0) {
      cx = 0;
    }

    if (cy === void 0) {
      cy = 0;
    }

    if (cz === void 0) {
      cz = 1;
    }

    return new Triangle(ax, ay, az, bx, by, bz, cx, cy, cz);
  };

  Triangle.clone = function clone(t) {
    return new Triangle(t.a.x, t.a.y, t.a.z, t.b.x, t.b.y, t.b.z, t.c.x, t.c.y, t.c.z);
  };

  Triangle.copy = function copy(out, t) {
    Vec3.copy(out.a, t.a);
    Vec3.copy(out.b, t.b);
    Vec3.copy(out.c, t.c);
    return out;
  };

  Triangle.fromPoints = function fromPoints(out, a, b, c) {
    Vec3.copy(out.a, a);
    Vec3.copy(out.b, b);
    Vec3.copy(out.c, c);
    return out;
  };

  Triangle.set = function set(out, ax, ay, az, bx, by, bz, cx, cy, cz) {
    out.a.x = ax;
    out.a.y = ay;
    out.a.z = az;
    out.b.x = bx;
    out.b.y = by;
    out.b.z = bz;
    out.c.x = cx;
    out.c.y = cy;
    out.c.z = cz;
    return out;
  };

  _createClass(Triangle, [{
    key: "type",
    get: function get() {
      return this._type;
    }
  }]);

  function Triangle(ax, ay, az, bx, by, bz, cx, cy, cz) {
    if (ax === void 0) {
      ax = 0;
    }

    if (ay === void 0) {
      ay = 0;
    }

    if (az === void 0) {
      az = 0;
    }

    if (bx === void 0) {
      bx = 1;
    }

    if (by === void 0) {
      by = 0;
    }

    if (bz === void 0) {
      bz = 0;
    }

    if (cx === void 0) {
      cx = 0;
    }

    if (cy === void 0) {
      cy = 1;
    }

    if (cz === void 0) {
      cz = 0;
    }

    this.a = void 0;
    this.b = void 0;
    this.c = void 0;
    this._type = void 0;
    this._type = enums.SHAPE_TRIANGLE;
    this.a = new Vec3(ax, ay, az);
    this.b = new Vec3(bx, by, bz);
    this.c = new Vec3(cx, cy, cz);
  }

  return Triangle;
}();

var deepCopy = function deepCopy(target, source, Ctor) {
  for (var i = 0; i < source.length; ++i) {
    if (target.length <= i) target.push(new Ctor());
    target[i].copy(source[i]);
  }

  target.length = source.length;
};

(function (ObjectType) {
  ObjectType[ObjectType["UNKNOWN"] = 0] = "UNKNOWN";
  ObjectType[ObjectType["BUFFER"] = 1] = "BUFFER";
  ObjectType[ObjectType["TEXTURE"] = 2] = "TEXTURE";
  ObjectType[ObjectType["RENDER_PASS"] = 3] = "RENDER_PASS";
  ObjectType[ObjectType["FRAMEBUFFER"] = 4] = "FRAMEBUFFER";
  ObjectType[ObjectType["SAMPLER"] = 5] = "SAMPLER";
  ObjectType[ObjectType["SHADER"] = 6] = "SHADER";
  ObjectType[ObjectType["DESCRIPTOR_SET_LAYOUT"] = 7] = "DESCRIPTOR_SET_LAYOUT";
  ObjectType[ObjectType["PIPELINE_LAYOUT"] = 8] = "PIPELINE_LAYOUT";
  ObjectType[ObjectType["PIPELINE_STATE"] = 9] = "PIPELINE_STATE";
  ObjectType[ObjectType["DESCRIPTOR_SET"] = 10] = "DESCRIPTOR_SET";
  ObjectType[ObjectType["INPUT_ASSEMBLER"] = 11] = "INPUT_ASSEMBLER";
  ObjectType[ObjectType["COMMAND_BUFFER"] = 12] = "COMMAND_BUFFER";
  ObjectType[ObjectType["QUEUE"] = 13] = "QUEUE";
  ObjectType[ObjectType["GLOBAL_BARRIER"] = 14] = "GLOBAL_BARRIER";
  ObjectType[ObjectType["TEXTURE_BARRIER"] = 15] = "TEXTURE_BARRIER";
  ObjectType[ObjectType["BUFFER_BARRIER"] = 16] = "BUFFER_BARRIER";
})(exports.ObjectType || (exports.ObjectType = {}));

(function (Status) {
  Status[Status["UNREADY"] = 0] = "UNREADY";
  Status[Status["FAILED"] = 1] = "FAILED";
  Status[Status["SUCCESS"] = 2] = "SUCCESS";
})(exports.Status || (exports.Status = {}));

(function (API) {
  API[API["UNKNOWN"] = 0] = "UNKNOWN";
  API[API["GLES2"] = 1] = "GLES2";
  API[API["GLES3"] = 2] = "GLES3";
  API[API["METAL"] = 3] = "METAL";
  API[API["VULKAN"] = 4] = "VULKAN";
  API[API["WEBGL"] = 5] = "WEBGL";
  API[API["WEBGL2"] = 6] = "WEBGL2";
  API[API["WEBGPU"] = 7] = "WEBGPU";
})(exports.API || (exports.API = {}));

(function (SurfaceTransform) {
  SurfaceTransform[SurfaceTransform["IDENTITY"] = 0] = "IDENTITY";
  SurfaceTransform[SurfaceTransform["ROTATE_90"] = 1] = "ROTATE_90";
  SurfaceTransform[SurfaceTransform["ROTATE_180"] = 2] = "ROTATE_180";
  SurfaceTransform[SurfaceTransform["ROTATE_270"] = 3] = "ROTATE_270";
})(exports.SurfaceTransform || (exports.SurfaceTransform = {}));

(function (Feature) {
  Feature[Feature["COLOR_FLOAT"] = 0] = "COLOR_FLOAT";
  Feature[Feature["COLOR_HALF_FLOAT"] = 1] = "COLOR_HALF_FLOAT";
  Feature[Feature["TEXTURE_FLOAT"] = 2] = "TEXTURE_FLOAT";
  Feature[Feature["TEXTURE_HALF_FLOAT"] = 3] = "TEXTURE_HALF_FLOAT";
  Feature[Feature["TEXTURE_FLOAT_LINEAR"] = 4] = "TEXTURE_FLOAT_LINEAR";
  Feature[Feature["TEXTURE_HALF_FLOAT_LINEAR"] = 5] = "TEXTURE_HALF_FLOAT_LINEAR";
  Feature[Feature["FORMAT_R11G11B10F"] = 6] = "FORMAT_R11G11B10F";
  Feature[Feature["FORMAT_SRGB"] = 7] = "FORMAT_SRGB";
  Feature[Feature["FORMAT_ETC1"] = 8] = "FORMAT_ETC1";
  Feature[Feature["FORMAT_ETC2"] = 9] = "FORMAT_ETC2";
  Feature[Feature["FORMAT_DXT"] = 10] = "FORMAT_DXT";
  Feature[Feature["FORMAT_PVRTC"] = 11] = "FORMAT_PVRTC";
  Feature[Feature["FORMAT_ASTC"] = 12] = "FORMAT_ASTC";
  Feature[Feature["FORMAT_RGB8"] = 13] = "FORMAT_RGB8";
  Feature[Feature["ELEMENT_INDEX_UINT"] = 14] = "ELEMENT_INDEX_UINT";
  Feature[Feature["INSTANCED_ARRAYS"] = 15] = "INSTANCED_ARRAYS";
  Feature[Feature["MULTIPLE_RENDER_TARGETS"] = 16] = "MULTIPLE_RENDER_TARGETS";
  Feature[Feature["BLEND_MINMAX"] = 17] = "BLEND_MINMAX";
  Feature[Feature["COMPUTE_SHADER"] = 18] = "COMPUTE_SHADER";
  Feature[Feature["COUNT"] = 19] = "COUNT";
})(exports.Feature || (exports.Feature = {}));

(function (Format) {
  Format[Format["UNKNOWN"] = 0] = "UNKNOWN";
  Format[Format["A8"] = 1] = "A8";
  Format[Format["L8"] = 2] = "L8";
  Format[Format["LA8"] = 3] = "LA8";
  Format[Format["R8"] = 4] = "R8";
  Format[Format["R8SN"] = 5] = "R8SN";
  Format[Format["R8UI"] = 6] = "R8UI";
  Format[Format["R8I"] = 7] = "R8I";
  Format[Format["R16F"] = 8] = "R16F";
  Format[Format["R16UI"] = 9] = "R16UI";
  Format[Format["R16I"] = 10] = "R16I";
  Format[Format["R32F"] = 11] = "R32F";
  Format[Format["R32UI"] = 12] = "R32UI";
  Format[Format["R32I"] = 13] = "R32I";
  Format[Format["RG8"] = 14] = "RG8";
  Format[Format["RG8SN"] = 15] = "RG8SN";
  Format[Format["RG8UI"] = 16] = "RG8UI";
  Format[Format["RG8I"] = 17] = "RG8I";
  Format[Format["RG16F"] = 18] = "RG16F";
  Format[Format["RG16UI"] = 19] = "RG16UI";
  Format[Format["RG16I"] = 20] = "RG16I";
  Format[Format["RG32F"] = 21] = "RG32F";
  Format[Format["RG32UI"] = 22] = "RG32UI";
  Format[Format["RG32I"] = 23] = "RG32I";
  Format[Format["RGB8"] = 24] = "RGB8";
  Format[Format["SRGB8"] = 25] = "SRGB8";
  Format[Format["RGB8SN"] = 26] = "RGB8SN";
  Format[Format["RGB8UI"] = 27] = "RGB8UI";
  Format[Format["RGB8I"] = 28] = "RGB8I";
  Format[Format["RGB16F"] = 29] = "RGB16F";
  Format[Format["RGB16UI"] = 30] = "RGB16UI";
  Format[Format["RGB16I"] = 31] = "RGB16I";
  Format[Format["RGB32F"] = 32] = "RGB32F";
  Format[Format["RGB32UI"] = 33] = "RGB32UI";
  Format[Format["RGB32I"] = 34] = "RGB32I";
  Format[Format["RGBA8"] = 35] = "RGBA8";
  Format[Format["BGRA8"] = 36] = "BGRA8";
  Format[Format["SRGB8_A8"] = 37] = "SRGB8_A8";
  Format[Format["RGBA8SN"] = 38] = "RGBA8SN";
  Format[Format["RGBA8UI"] = 39] = "RGBA8UI";
  Format[Format["RGBA8I"] = 40] = "RGBA8I";
  Format[Format["RGBA16F"] = 41] = "RGBA16F";
  Format[Format["RGBA16UI"] = 42] = "RGBA16UI";
  Format[Format["RGBA16I"] = 43] = "RGBA16I";
  Format[Format["RGBA32F"] = 44] = "RGBA32F";
  Format[Format["RGBA32UI"] = 45] = "RGBA32UI";
  Format[Format["RGBA32I"] = 46] = "RGBA32I";
  Format[Format["R5G6B5"] = 47] = "R5G6B5";
  Format[Format["R11G11B10F"] = 48] = "R11G11B10F";
  Format[Format["RGB5A1"] = 49] = "RGB5A1";
  Format[Format["RGBA4"] = 50] = "RGBA4";
  Format[Format["RGB10A2"] = 51] = "RGB10A2";
  Format[Format["RGB10A2UI"] = 52] = "RGB10A2UI";
  Format[Format["RGB9E5"] = 53] = "RGB9E5";
  Format[Format["D16"] = 54] = "D16";
  Format[Format["D16S8"] = 55] = "D16S8";
  Format[Format["D24"] = 56] = "D24";
  Format[Format["D24S8"] = 57] = "D24S8";
  Format[Format["D32F"] = 58] = "D32F";
  Format[Format["D32F_S8"] = 59] = "D32F_S8";
  Format[Format["BC1"] = 60] = "BC1";
  Format[Format["BC1_ALPHA"] = 61] = "BC1_ALPHA";
  Format[Format["BC1_SRGB"] = 62] = "BC1_SRGB";
  Format[Format["BC1_SRGB_ALPHA"] = 63] = "BC1_SRGB_ALPHA";
  Format[Format["BC2"] = 64] = "BC2";
  Format[Format["BC2_SRGB"] = 65] = "BC2_SRGB";
  Format[Format["BC3"] = 66] = "BC3";
  Format[Format["BC3_SRGB"] = 67] = "BC3_SRGB";
  Format[Format["BC4"] = 68] = "BC4";
  Format[Format["BC4_SNORM"] = 69] = "BC4_SNORM";
  Format[Format["BC5"] = 70] = "BC5";
  Format[Format["BC5_SNORM"] = 71] = "BC5_SNORM";
  Format[Format["BC6H_UF16"] = 72] = "BC6H_UF16";
  Format[Format["BC6H_SF16"] = 73] = "BC6H_SF16";
  Format[Format["BC7"] = 74] = "BC7";
  Format[Format["BC7_SRGB"] = 75] = "BC7_SRGB";
  Format[Format["ETC_RGB8"] = 76] = "ETC_RGB8";
  Format[Format["ETC2_RGB8"] = 77] = "ETC2_RGB8";
  Format[Format["ETC2_SRGB8"] = 78] = "ETC2_SRGB8";
  Format[Format["ETC2_RGB8_A1"] = 79] = "ETC2_RGB8_A1";
  Format[Format["ETC2_SRGB8_A1"] = 80] = "ETC2_SRGB8_A1";
  Format[Format["ETC2_RGBA8"] = 81] = "ETC2_RGBA8";
  Format[Format["ETC2_SRGB8_A8"] = 82] = "ETC2_SRGB8_A8";
  Format[Format["EAC_R11"] = 83] = "EAC_R11";
  Format[Format["EAC_R11SN"] = 84] = "EAC_R11SN";
  Format[Format["EAC_RG11"] = 85] = "EAC_RG11";
  Format[Format["EAC_RG11SN"] = 86] = "EAC_RG11SN";
  Format[Format["PVRTC_RGB2"] = 87] = "PVRTC_RGB2";
  Format[Format["PVRTC_RGBA2"] = 88] = "PVRTC_RGBA2";
  Format[Format["PVRTC_RGB4"] = 89] = "PVRTC_RGB4";
  Format[Format["PVRTC_RGBA4"] = 90] = "PVRTC_RGBA4";
  Format[Format["PVRTC2_2BPP"] = 91] = "PVRTC2_2BPP";
  Format[Format["PVRTC2_4BPP"] = 92] = "PVRTC2_4BPP";
  Format[Format["ASTC_RGBA_4X4"] = 93] = "ASTC_RGBA_4X4";
  Format[Format["ASTC_RGBA_5X4"] = 94] = "ASTC_RGBA_5X4";
  Format[Format["ASTC_RGBA_5X5"] = 95] = "ASTC_RGBA_5X5";
  Format[Format["ASTC_RGBA_6X5"] = 96] = "ASTC_RGBA_6X5";
  Format[Format["ASTC_RGBA_6X6"] = 97] = "ASTC_RGBA_6X6";
  Format[Format["ASTC_RGBA_8X5"] = 98] = "ASTC_RGBA_8X5";
  Format[Format["ASTC_RGBA_8X6"] = 99] = "ASTC_RGBA_8X6";
  Format[Format["ASTC_RGBA_8X8"] = 100] = "ASTC_RGBA_8X8";
  Format[Format["ASTC_RGBA_10X5"] = 101] = "ASTC_RGBA_10X5";
  Format[Format["ASTC_RGBA_10X6"] = 102] = "ASTC_RGBA_10X6";
  Format[Format["ASTC_RGBA_10X8"] = 103] = "ASTC_RGBA_10X8";
  Format[Format["ASTC_RGBA_10X10"] = 104] = "ASTC_RGBA_10X10";
  Format[Format["ASTC_RGBA_12X10"] = 105] = "ASTC_RGBA_12X10";
  Format[Format["ASTC_RGBA_12X12"] = 106] = "ASTC_RGBA_12X12";
  Format[Format["ASTC_SRGBA_4X4"] = 107] = "ASTC_SRGBA_4X4";
  Format[Format["ASTC_SRGBA_5X4"] = 108] = "ASTC_SRGBA_5X4";
  Format[Format["ASTC_SRGBA_5X5"] = 109] = "ASTC_SRGBA_5X5";
  Format[Format["ASTC_SRGBA_6X5"] = 110] = "ASTC_SRGBA_6X5";
  Format[Format["ASTC_SRGBA_6X6"] = 111] = "ASTC_SRGBA_6X6";
  Format[Format["ASTC_SRGBA_8X5"] = 112] = "ASTC_SRGBA_8X5";
  Format[Format["ASTC_SRGBA_8X6"] = 113] = "ASTC_SRGBA_8X6";
  Format[Format["ASTC_SRGBA_8X8"] = 114] = "ASTC_SRGBA_8X8";
  Format[Format["ASTC_SRGBA_10X5"] = 115] = "ASTC_SRGBA_10X5";
  Format[Format["ASTC_SRGBA_10X6"] = 116] = "ASTC_SRGBA_10X6";
  Format[Format["ASTC_SRGBA_10X8"] = 117] = "ASTC_SRGBA_10X8";
  Format[Format["ASTC_SRGBA_10X10"] = 118] = "ASTC_SRGBA_10X10";
  Format[Format["ASTC_SRGBA_12X10"] = 119] = "ASTC_SRGBA_12X10";
  Format[Format["ASTC_SRGBA_12X12"] = 120] = "ASTC_SRGBA_12X12";
  Format[Format["COUNT"] = 121] = "COUNT";
})(exports.Format || (exports.Format = {}));

(function (FormatType) {
  FormatType[FormatType["NONE"] = 0] = "NONE";
  FormatType[FormatType["UNORM"] = 1] = "UNORM";
  FormatType[FormatType["SNORM"] = 2] = "SNORM";
  FormatType[FormatType["UINT"] = 3] = "UINT";
  FormatType[FormatType["INT"] = 4] = "INT";
  FormatType[FormatType["UFLOAT"] = 5] = "UFLOAT";
  FormatType[FormatType["FLOAT"] = 6] = "FLOAT";
})(exports.FormatType || (exports.FormatType = {}));

(function (Type) {
  Type[Type["UNKNOWN"] = 0] = "UNKNOWN";
  Type[Type["BOOL"] = 1] = "BOOL";
  Type[Type["BOOL2"] = 2] = "BOOL2";
  Type[Type["BOOL3"] = 3] = "BOOL3";
  Type[Type["BOOL4"] = 4] = "BOOL4";
  Type[Type["INT"] = 5] = "INT";
  Type[Type["INT2"] = 6] = "INT2";
  Type[Type["INT3"] = 7] = "INT3";
  Type[Type["INT4"] = 8] = "INT4";
  Type[Type["UINT"] = 9] = "UINT";
  Type[Type["UINT2"] = 10] = "UINT2";
  Type[Type["UINT3"] = 11] = "UINT3";
  Type[Type["UINT4"] = 12] = "UINT4";
  Type[Type["FLOAT"] = 13] = "FLOAT";
  Type[Type["FLOAT2"] = 14] = "FLOAT2";
  Type[Type["FLOAT3"] = 15] = "FLOAT3";
  Type[Type["FLOAT4"] = 16] = "FLOAT4";
  Type[Type["MAT2"] = 17] = "MAT2";
  Type[Type["MAT2X3"] = 18] = "MAT2X3";
  Type[Type["MAT2X4"] = 19] = "MAT2X4";
  Type[Type["MAT3X2"] = 20] = "MAT3X2";
  Type[Type["MAT3"] = 21] = "MAT3";
  Type[Type["MAT3X4"] = 22] = "MAT3X4";
  Type[Type["MAT4X2"] = 23] = "MAT4X2";
  Type[Type["MAT4X3"] = 24] = "MAT4X3";
  Type[Type["MAT4"] = 25] = "MAT4";
  Type[Type["SAMPLER1D"] = 26] = "SAMPLER1D";
  Type[Type["SAMPLER1D_ARRAY"] = 27] = "SAMPLER1D_ARRAY";
  Type[Type["SAMPLER2D"] = 28] = "SAMPLER2D";
  Type[Type["SAMPLER2D_ARRAY"] = 29] = "SAMPLER2D_ARRAY";
  Type[Type["SAMPLER3D"] = 30] = "SAMPLER3D";
  Type[Type["SAMPLER_CUBE"] = 31] = "SAMPLER_CUBE";
  Type[Type["SAMPLER"] = 32] = "SAMPLER";
  Type[Type["TEXTURE1D"] = 33] = "TEXTURE1D";
  Type[Type["TEXTURE1D_ARRAY"] = 34] = "TEXTURE1D_ARRAY";
  Type[Type["TEXTURE2D"] = 35] = "TEXTURE2D";
  Type[Type["TEXTURE2D_ARRAY"] = 36] = "TEXTURE2D_ARRAY";
  Type[Type["TEXTURE3D"] = 37] = "TEXTURE3D";
  Type[Type["TEXTURE_CUBE"] = 38] = "TEXTURE_CUBE";
  Type[Type["IMAGE1D"] = 39] = "IMAGE1D";
  Type[Type["IMAGE1D_ARRAY"] = 40] = "IMAGE1D_ARRAY";
  Type[Type["IMAGE2D"] = 41] = "IMAGE2D";
  Type[Type["IMAGE2D_ARRAY"] = 42] = "IMAGE2D_ARRAY";
  Type[Type["IMAGE3D"] = 43] = "IMAGE3D";
  Type[Type["IMAGE_CUBE"] = 44] = "IMAGE_CUBE";
  Type[Type["SUBPASS_INPUT"] = 45] = "SUBPASS_INPUT";
  Type[Type["COUNT"] = 46] = "COUNT";
})(exports.Type || (exports.Type = {}));

(function (BufferUsageBit) {
  BufferUsageBit[BufferUsageBit["NONE"] = 0] = "NONE";
  BufferUsageBit[BufferUsageBit["TRANSFER_SRC"] = 1] = "TRANSFER_SRC";
  BufferUsageBit[BufferUsageBit["TRANSFER_DST"] = 2] = "TRANSFER_DST";
  BufferUsageBit[BufferUsageBit["INDEX"] = 4] = "INDEX";
  BufferUsageBit[BufferUsageBit["VERTEX"] = 8] = "VERTEX";
  BufferUsageBit[BufferUsageBit["UNIFORM"] = 16] = "UNIFORM";
  BufferUsageBit[BufferUsageBit["STORAGE"] = 32] = "STORAGE";
  BufferUsageBit[BufferUsageBit["INDIRECT"] = 64] = "INDIRECT";
})(exports.BufferUsageBit || (exports.BufferUsageBit = {}));

(function (BufferFlagBit) {
  BufferFlagBit[BufferFlagBit["NONE"] = 0] = "NONE";
})(exports.BufferFlagBit || (exports.BufferFlagBit = {}));

(function (MemoryAccessBit) {
  MemoryAccessBit[MemoryAccessBit["NONE"] = 0] = "NONE";
  MemoryAccessBit[MemoryAccessBit["READ_ONLY"] = 1] = "READ_ONLY";
  MemoryAccessBit[MemoryAccessBit["WRITE_ONLY"] = 2] = "WRITE_ONLY";
  MemoryAccessBit[MemoryAccessBit["READ_WRITE"] = 3] = "READ_WRITE";
})(exports.MemoryAccessBit || (exports.MemoryAccessBit = {}));

(function (MemoryUsageBit) {
  MemoryUsageBit[MemoryUsageBit["NONE"] = 0] = "NONE";
  MemoryUsageBit[MemoryUsageBit["DEVICE"] = 1] = "DEVICE";
  MemoryUsageBit[MemoryUsageBit["HOST"] = 2] = "HOST";
})(exports.MemoryUsageBit || (exports.MemoryUsageBit = {}));

(function (TextureType) {
  TextureType[TextureType["TEX1D"] = 0] = "TEX1D";
  TextureType[TextureType["TEX2D"] = 1] = "TEX2D";
  TextureType[TextureType["TEX3D"] = 2] = "TEX3D";
  TextureType[TextureType["CUBE"] = 3] = "CUBE";
  TextureType[TextureType["TEX1D_ARRAY"] = 4] = "TEX1D_ARRAY";
  TextureType[TextureType["TEX2D_ARRAY"] = 5] = "TEX2D_ARRAY";
})(exports.TextureType || (exports.TextureType = {}));

(function (TextureUsageBit) {
  TextureUsageBit[TextureUsageBit["NONE"] = 0] = "NONE";
  TextureUsageBit[TextureUsageBit["TRANSFER_SRC"] = 1] = "TRANSFER_SRC";
  TextureUsageBit[TextureUsageBit["TRANSFER_DST"] = 2] = "TRANSFER_DST";
  TextureUsageBit[TextureUsageBit["SAMPLED"] = 4] = "SAMPLED";
  TextureUsageBit[TextureUsageBit["STORAGE"] = 8] = "STORAGE";
  TextureUsageBit[TextureUsageBit["COLOR_ATTACHMENT"] = 16] = "COLOR_ATTACHMENT";
  TextureUsageBit[TextureUsageBit["DEPTH_STENCIL_ATTACHMENT"] = 32] = "DEPTH_STENCIL_ATTACHMENT";
  TextureUsageBit[TextureUsageBit["INPUT_ATTACHMENT"] = 64] = "INPUT_ATTACHMENT";
})(exports.TextureUsageBit || (exports.TextureUsageBit = {}));

(function (TextureFlagBit) {
  TextureFlagBit[TextureFlagBit["NONE"] = 0] = "NONE";
  TextureFlagBit[TextureFlagBit["GEN_MIPMAP"] = 1] = "GEN_MIPMAP";
  TextureFlagBit[TextureFlagBit["IMMUTABLE"] = 2] = "IMMUTABLE";
  TextureFlagBit[TextureFlagBit["GENERAL_LAYOUT"] = 4] = "GENERAL_LAYOUT";
})(exports.TextureFlagBit || (exports.TextureFlagBit = {}));

(function (SampleCount) {
  SampleCount[SampleCount["X1"] = 1] = "X1";
  SampleCount[SampleCount["X2"] = 2] = "X2";
  SampleCount[SampleCount["X4"] = 4] = "X4";
  SampleCount[SampleCount["X8"] = 8] = "X8";
  SampleCount[SampleCount["X16"] = 16] = "X16";
  SampleCount[SampleCount["X32"] = 32] = "X32";
  SampleCount[SampleCount["X64"] = 64] = "X64";
})(exports.SampleCount || (exports.SampleCount = {}));

(function (Filter) {
  Filter[Filter["NONE"] = 0] = "NONE";
  Filter[Filter["POINT"] = 1] = "POINT";
  Filter[Filter["LINEAR"] = 2] = "LINEAR";
  Filter[Filter["ANISOTROPIC"] = 3] = "ANISOTROPIC";
})(exports.Filter || (exports.Filter = {}));

(function (Address) {
  Address[Address["WRAP"] = 0] = "WRAP";
  Address[Address["MIRROR"] = 1] = "MIRROR";
  Address[Address["CLAMP"] = 2] = "CLAMP";
  Address[Address["BORDER"] = 3] = "BORDER";
})(exports.Address || (exports.Address = {}));

(function (ComparisonFunc) {
  ComparisonFunc[ComparisonFunc["NEVER"] = 0] = "NEVER";
  ComparisonFunc[ComparisonFunc["LESS"] = 1] = "LESS";
  ComparisonFunc[ComparisonFunc["EQUAL"] = 2] = "EQUAL";
  ComparisonFunc[ComparisonFunc["LESS_EQUAL"] = 3] = "LESS_EQUAL";
  ComparisonFunc[ComparisonFunc["GREATER"] = 4] = "GREATER";
  ComparisonFunc[ComparisonFunc["NOT_EQUAL"] = 5] = "NOT_EQUAL";
  ComparisonFunc[ComparisonFunc["GREATER_EQUAL"] = 6] = "GREATER_EQUAL";
  ComparisonFunc[ComparisonFunc["ALWAYS"] = 7] = "ALWAYS";
})(exports.ComparisonFunc || (exports.ComparisonFunc = {}));

(function (StencilOp) {
  StencilOp[StencilOp["ZERO"] = 0] = "ZERO";
  StencilOp[StencilOp["KEEP"] = 1] = "KEEP";
  StencilOp[StencilOp["REPLACE"] = 2] = "REPLACE";
  StencilOp[StencilOp["INCR"] = 3] = "INCR";
  StencilOp[StencilOp["DECR"] = 4] = "DECR";
  StencilOp[StencilOp["INVERT"] = 5] = "INVERT";
  StencilOp[StencilOp["INCR_WRAP"] = 6] = "INCR_WRAP";
  StencilOp[StencilOp["DECR_WRAP"] = 7] = "DECR_WRAP";
})(exports.StencilOp || (exports.StencilOp = {}));

(function (BlendFactor) {
  BlendFactor[BlendFactor["ZERO"] = 0] = "ZERO";
  BlendFactor[BlendFactor["ONE"] = 1] = "ONE";
  BlendFactor[BlendFactor["SRC_ALPHA"] = 2] = "SRC_ALPHA";
  BlendFactor[BlendFactor["DST_ALPHA"] = 3] = "DST_ALPHA";
  BlendFactor[BlendFactor["ONE_MINUS_SRC_ALPHA"] = 4] = "ONE_MINUS_SRC_ALPHA";
  BlendFactor[BlendFactor["ONE_MINUS_DST_ALPHA"] = 5] = "ONE_MINUS_DST_ALPHA";
  BlendFactor[BlendFactor["SRC_COLOR"] = 6] = "SRC_COLOR";
  BlendFactor[BlendFactor["DST_COLOR"] = 7] = "DST_COLOR";
  BlendFactor[BlendFactor["ONE_MINUS_SRC_COLOR"] = 8] = "ONE_MINUS_SRC_COLOR";
  BlendFactor[BlendFactor["ONE_MINUS_DST_COLOR"] = 9] = "ONE_MINUS_DST_COLOR";
  BlendFactor[BlendFactor["SRC_ALPHA_SATURATE"] = 10] = "SRC_ALPHA_SATURATE";
  BlendFactor[BlendFactor["CONSTANT_COLOR"] = 11] = "CONSTANT_COLOR";
  BlendFactor[BlendFactor["ONE_MINUS_CONSTANT_COLOR"] = 12] = "ONE_MINUS_CONSTANT_COLOR";
  BlendFactor[BlendFactor["CONSTANT_ALPHA"] = 13] = "CONSTANT_ALPHA";
  BlendFactor[BlendFactor["ONE_MINUS_CONSTANT_ALPHA"] = 14] = "ONE_MINUS_CONSTANT_ALPHA";
})(exports.BlendFactor || (exports.BlendFactor = {}));

(function (BlendOp) {
  BlendOp[BlendOp["ADD"] = 0] = "ADD";
  BlendOp[BlendOp["SUB"] = 1] = "SUB";
  BlendOp[BlendOp["REV_SUB"] = 2] = "REV_SUB";
  BlendOp[BlendOp["MIN"] = 3] = "MIN";
  BlendOp[BlendOp["MAX"] = 4] = "MAX";
})(exports.BlendOp || (exports.BlendOp = {}));

(function (ColorMask) {
  ColorMask[ColorMask["NONE"] = 0] = "NONE";
  ColorMask[ColorMask["R"] = 1] = "R";
  ColorMask[ColorMask["G"] = 2] = "G";
  ColorMask[ColorMask["B"] = 4] = "B";
  ColorMask[ColorMask["A"] = 8] = "A";
  ColorMask[ColorMask["ALL"] = 15] = "ALL";
})(exports.ColorMask || (exports.ColorMask = {}));

(function (ShaderStageFlagBit) {
  ShaderStageFlagBit[ShaderStageFlagBit["NONE"] = 0] = "NONE";
  ShaderStageFlagBit[ShaderStageFlagBit["VERTEX"] = 1] = "VERTEX";
  ShaderStageFlagBit[ShaderStageFlagBit["CONTROL"] = 2] = "CONTROL";
  ShaderStageFlagBit[ShaderStageFlagBit["EVALUATION"] = 4] = "EVALUATION";
  ShaderStageFlagBit[ShaderStageFlagBit["GEOMETRY"] = 8] = "GEOMETRY";
  ShaderStageFlagBit[ShaderStageFlagBit["FRAGMENT"] = 16] = "FRAGMENT";
  ShaderStageFlagBit[ShaderStageFlagBit["COMPUTE"] = 32] = "COMPUTE";
  ShaderStageFlagBit[ShaderStageFlagBit["ALL"] = 63] = "ALL";
})(exports.ShaderStageFlagBit || (exports.ShaderStageFlagBit = {}));

(function (LoadOp) {
  LoadOp[LoadOp["LOAD"] = 0] = "LOAD";
  LoadOp[LoadOp["CLEAR"] = 1] = "CLEAR";
  LoadOp[LoadOp["DISCARD"] = 2] = "DISCARD";
})(exports.LoadOp || (exports.LoadOp = {}));

(function (StoreOp) {
  StoreOp[StoreOp["STORE"] = 0] = "STORE";
  StoreOp[StoreOp["DISCARD"] = 1] = "DISCARD";
})(exports.StoreOp || (exports.StoreOp = {}));

(function (AccessType) {
  AccessType[AccessType["NONE"] = 0] = "NONE";
  AccessType[AccessType["INDIRECT_BUFFER"] = 1] = "INDIRECT_BUFFER";
  AccessType[AccessType["INDEX_BUFFER"] = 2] = "INDEX_BUFFER";
  AccessType[AccessType["VERTEX_BUFFER"] = 3] = "VERTEX_BUFFER";
  AccessType[AccessType["VERTEX_SHADER_READ_UNIFORM_BUFFER"] = 4] = "VERTEX_SHADER_READ_UNIFORM_BUFFER";
  AccessType[AccessType["VERTEX_SHADER_READ_TEXTURE"] = 5] = "VERTEX_SHADER_READ_TEXTURE";
  AccessType[AccessType["VERTEX_SHADER_READ_OTHER"] = 6] = "VERTEX_SHADER_READ_OTHER";
  AccessType[AccessType["FRAGMENT_SHADER_READ_UNIFORM_BUFFER"] = 7] = "FRAGMENT_SHADER_READ_UNIFORM_BUFFER";
  AccessType[AccessType["FRAGMENT_SHADER_READ_TEXTURE"] = 8] = "FRAGMENT_SHADER_READ_TEXTURE";
  AccessType[AccessType["FRAGMENT_SHADER_READ_COLOR_INPUT_ATTACHMENT"] = 9] = "FRAGMENT_SHADER_READ_COLOR_INPUT_ATTACHMENT";
  AccessType[AccessType["FRAGMENT_SHADER_READ_DEPTH_STENCIL_INPUT_ATTACHMENT"] = 10] = "FRAGMENT_SHADER_READ_DEPTH_STENCIL_INPUT_ATTACHMENT";
  AccessType[AccessType["FRAGMENT_SHADER_READ_OTHER"] = 11] = "FRAGMENT_SHADER_READ_OTHER";
  AccessType[AccessType["COLOR_ATTACHMENT_READ"] = 12] = "COLOR_ATTACHMENT_READ";
  AccessType[AccessType["DEPTH_STENCIL_ATTACHMENT_READ"] = 13] = "DEPTH_STENCIL_ATTACHMENT_READ";
  AccessType[AccessType["COMPUTE_SHADER_READ_UNIFORM_BUFFER"] = 14] = "COMPUTE_SHADER_READ_UNIFORM_BUFFER";
  AccessType[AccessType["COMPUTE_SHADER_READ_TEXTURE"] = 15] = "COMPUTE_SHADER_READ_TEXTURE";
  AccessType[AccessType["COMPUTE_SHADER_READ_OTHER"] = 16] = "COMPUTE_SHADER_READ_OTHER";
  AccessType[AccessType["TRANSFER_READ"] = 17] = "TRANSFER_READ";
  AccessType[AccessType["HOST_READ"] = 18] = "HOST_READ";
  AccessType[AccessType["PRESENT"] = 19] = "PRESENT";
  AccessType[AccessType["VERTEX_SHADER_WRITE"] = 20] = "VERTEX_SHADER_WRITE";
  AccessType[AccessType["FRAGMENT_SHADER_WRITE"] = 21] = "FRAGMENT_SHADER_WRITE";
  AccessType[AccessType["COLOR_ATTACHMENT_WRITE"] = 22] = "COLOR_ATTACHMENT_WRITE";
  AccessType[AccessType["DEPTH_STENCIL_ATTACHMENT_WRITE"] = 23] = "DEPTH_STENCIL_ATTACHMENT_WRITE";
  AccessType[AccessType["COMPUTE_SHADER_WRITE"] = 24] = "COMPUTE_SHADER_WRITE";
  AccessType[AccessType["TRANSFER_WRITE"] = 25] = "TRANSFER_WRITE";
  AccessType[AccessType["HOST_PREINITIALIZED"] = 26] = "HOST_PREINITIALIZED";
  AccessType[AccessType["HOST_WRITE"] = 27] = "HOST_WRITE";
})(exports.AccessType || (exports.AccessType = {}));

(function (ResolveMode) {
  ResolveMode[ResolveMode["NONE"] = 0] = "NONE";
  ResolveMode[ResolveMode["SAMPLE_ZERO"] = 1] = "SAMPLE_ZERO";
  ResolveMode[ResolveMode["AVERAGE"] = 2] = "AVERAGE";
  ResolveMode[ResolveMode["MIN"] = 3] = "MIN";
  ResolveMode[ResolveMode["MAX"] = 4] = "MAX";
})(exports.ResolveMode || (exports.ResolveMode = {}));

(function (PipelineBindPoint) {
  PipelineBindPoint[PipelineBindPoint["GRAPHICS"] = 0] = "GRAPHICS";
  PipelineBindPoint[PipelineBindPoint["COMPUTE"] = 1] = "COMPUTE";
  PipelineBindPoint[PipelineBindPoint["RAY_TRACING"] = 2] = "RAY_TRACING";
})(exports.PipelineBindPoint || (exports.PipelineBindPoint = {}));

(function (PrimitiveMode) {
  PrimitiveMode[PrimitiveMode["POINT_LIST"] = 0] = "POINT_LIST";
  PrimitiveMode[PrimitiveMode["LINE_LIST"] = 1] = "LINE_LIST";
  PrimitiveMode[PrimitiveMode["LINE_STRIP"] = 2] = "LINE_STRIP";
  PrimitiveMode[PrimitiveMode["LINE_LOOP"] = 3] = "LINE_LOOP";
  PrimitiveMode[PrimitiveMode["LINE_LIST_ADJACENCY"] = 4] = "LINE_LIST_ADJACENCY";
  PrimitiveMode[PrimitiveMode["LINE_STRIP_ADJACENCY"] = 5] = "LINE_STRIP_ADJACENCY";
  PrimitiveMode[PrimitiveMode["ISO_LINE_LIST"] = 6] = "ISO_LINE_LIST";
  PrimitiveMode[PrimitiveMode["TRIANGLE_LIST"] = 7] = "TRIANGLE_LIST";
  PrimitiveMode[PrimitiveMode["TRIANGLE_STRIP"] = 8] = "TRIANGLE_STRIP";
  PrimitiveMode[PrimitiveMode["TRIANGLE_FAN"] = 9] = "TRIANGLE_FAN";
  PrimitiveMode[PrimitiveMode["TRIANGLE_LIST_ADJACENCY"] = 10] = "TRIANGLE_LIST_ADJACENCY";
  PrimitiveMode[PrimitiveMode["TRIANGLE_STRIP_ADJACENCY"] = 11] = "TRIANGLE_STRIP_ADJACENCY";
  PrimitiveMode[PrimitiveMode["TRIANGLE_PATCH_ADJACENCY"] = 12] = "TRIANGLE_PATCH_ADJACENCY";
  PrimitiveMode[PrimitiveMode["QUAD_PATCH_LIST"] = 13] = "QUAD_PATCH_LIST";
})(exports.PrimitiveMode || (exports.PrimitiveMode = {}));

(function (PolygonMode) {
  PolygonMode[PolygonMode["FILL"] = 0] = "FILL";
  PolygonMode[PolygonMode["POINT"] = 1] = "POINT";
  PolygonMode[PolygonMode["LINE"] = 2] = "LINE";
})(exports.PolygonMode || (exports.PolygonMode = {}));

(function (ShadeModel) {
  ShadeModel[ShadeModel["GOURAND"] = 0] = "GOURAND";
  ShadeModel[ShadeModel["FLAT"] = 1] = "FLAT";
})(exports.ShadeModel || (exports.ShadeModel = {}));

(function (CullMode) {
  CullMode[CullMode["NONE"] = 0] = "NONE";
  CullMode[CullMode["FRONT"] = 1] = "FRONT";
  CullMode[CullMode["BACK"] = 2] = "BACK";
})(exports.CullMode || (exports.CullMode = {}));

(function (DynamicStateFlagBit) {
  DynamicStateFlagBit[DynamicStateFlagBit["NONE"] = 0] = "NONE";
  DynamicStateFlagBit[DynamicStateFlagBit["VIEWPORT"] = 1] = "VIEWPORT";
  DynamicStateFlagBit[DynamicStateFlagBit["SCISSOR"] = 2] = "SCISSOR";
  DynamicStateFlagBit[DynamicStateFlagBit["LINE_WIDTH"] = 4] = "LINE_WIDTH";
  DynamicStateFlagBit[DynamicStateFlagBit["DEPTH_BIAS"] = 8] = "DEPTH_BIAS";
  DynamicStateFlagBit[DynamicStateFlagBit["BLEND_CONSTANTS"] = 16] = "BLEND_CONSTANTS";
  DynamicStateFlagBit[DynamicStateFlagBit["DEPTH_BOUNDS"] = 32] = "DEPTH_BOUNDS";
  DynamicStateFlagBit[DynamicStateFlagBit["STENCIL_WRITE_MASK"] = 64] = "STENCIL_WRITE_MASK";
  DynamicStateFlagBit[DynamicStateFlagBit["STENCIL_COMPARE_MASK"] = 128] = "STENCIL_COMPARE_MASK";
})(exports.DynamicStateFlagBit || (exports.DynamicStateFlagBit = {}));

(function (StencilFace) {
  StencilFace[StencilFace["FRONT"] = 1] = "FRONT";
  StencilFace[StencilFace["BACK"] = 2] = "BACK";
  StencilFace[StencilFace["ALL"] = 3] = "ALL";
})(exports.StencilFace || (exports.StencilFace = {}));

(function (DescriptorType) {
  DescriptorType[DescriptorType["UNKNOWN"] = 0] = "UNKNOWN";
  DescriptorType[DescriptorType["UNIFORM_BUFFER"] = 1] = "UNIFORM_BUFFER";
  DescriptorType[DescriptorType["DYNAMIC_UNIFORM_BUFFER"] = 2] = "DYNAMIC_UNIFORM_BUFFER";
  DescriptorType[DescriptorType["STORAGE_BUFFER"] = 4] = "STORAGE_BUFFER";
  DescriptorType[DescriptorType["DYNAMIC_STORAGE_BUFFER"] = 8] = "DYNAMIC_STORAGE_BUFFER";
  DescriptorType[DescriptorType["SAMPLER_TEXTURE"] = 16] = "SAMPLER_TEXTURE";
  DescriptorType[DescriptorType["SAMPLER"] = 32] = "SAMPLER";
  DescriptorType[DescriptorType["TEXTURE"] = 64] = "TEXTURE";
  DescriptorType[DescriptorType["STORAGE_IMAGE"] = 128] = "STORAGE_IMAGE";
  DescriptorType[DescriptorType["INPUT_ATTACHMENT"] = 256] = "INPUT_ATTACHMENT";
})(exports.DescriptorType || (exports.DescriptorType = {}));

(function (QueueType) {
  QueueType[QueueType["GRAPHICS"] = 0] = "GRAPHICS";
  QueueType[QueueType["COMPUTE"] = 1] = "COMPUTE";
  QueueType[QueueType["TRANSFER"] = 2] = "TRANSFER";
})(exports.QueueType || (exports.QueueType = {}));

(function (CommandBufferType) {
  CommandBufferType[CommandBufferType["PRIMARY"] = 0] = "PRIMARY";
  CommandBufferType[CommandBufferType["SECONDARY"] = 1] = "SECONDARY";
})(exports.CommandBufferType || (exports.CommandBufferType = {}));

(function (ClearFlagBit) {
  ClearFlagBit[ClearFlagBit["NONE"] = 0] = "NONE";
  ClearFlagBit[ClearFlagBit["COLOR"] = 1] = "COLOR";
  ClearFlagBit[ClearFlagBit["DEPTH"] = 2] = "DEPTH";
  ClearFlagBit[ClearFlagBit["STENCIL"] = 4] = "STENCIL";
  ClearFlagBit[ClearFlagBit["DEPTH_STENCIL"] = 6] = "DEPTH_STENCIL";
  ClearFlagBit[ClearFlagBit["ALL"] = 7] = "ALL";
})(exports.ClearFlagBit || (exports.ClearFlagBit = {}));

var Size$1 = function () {
  function Size(x, y, z) {
    if (x === void 0) {
      x = 0;
    }

    if (y === void 0) {
      y = 0;
    }

    if (z === void 0) {
      z = 0;
    }

    this.x = x;
    this.y = y;
    this.z = z;
  }

  var _proto = Size.prototype;

  _proto.copy = function copy(info) {
    this.x = info.x;
    this.y = info.y;
    this.z = info.z;
    return this;
  };

  return Size;
}();
var DeviceCaps = function () {
  function DeviceCaps(maxVertexAttributes, maxVertexUniformVectors, maxFragmentUniformVectors, maxTextureUnits, maxImageUnits, maxVertexTextureUnits, maxColorRenderTargets, maxShaderStorageBufferBindings, maxShaderStorageBlockSize, maxUniformBufferBindings, maxUniformBlockSize, maxTextureSize, maxCubeMapTextureSize, depthBits, stencilBits, uboOffsetAlignment, maxComputeSharedMemorySize, maxComputeWorkGroupInvocations, maxComputeWorkGroupSize, maxComputeWorkGroupCount, clipSpaceMinZ, screenSpaceSignY, clipSpaceSignY) {
    if (maxVertexAttributes === void 0) {
      maxVertexAttributes = 0;
    }

    if (maxVertexUniformVectors === void 0) {
      maxVertexUniformVectors = 0;
    }

    if (maxFragmentUniformVectors === void 0) {
      maxFragmentUniformVectors = 0;
    }

    if (maxTextureUnits === void 0) {
      maxTextureUnits = 0;
    }

    if (maxImageUnits === void 0) {
      maxImageUnits = 0;
    }

    if (maxVertexTextureUnits === void 0) {
      maxVertexTextureUnits = 0;
    }

    if (maxColorRenderTargets === void 0) {
      maxColorRenderTargets = 0;
    }

    if (maxShaderStorageBufferBindings === void 0) {
      maxShaderStorageBufferBindings = 0;
    }

    if (maxShaderStorageBlockSize === void 0) {
      maxShaderStorageBlockSize = 0;
    }

    if (maxUniformBufferBindings === void 0) {
      maxUniformBufferBindings = 0;
    }

    if (maxUniformBlockSize === void 0) {
      maxUniformBlockSize = 0;
    }

    if (maxTextureSize === void 0) {
      maxTextureSize = 0;
    }

    if (maxCubeMapTextureSize === void 0) {
      maxCubeMapTextureSize = 0;
    }

    if (depthBits === void 0) {
      depthBits = 0;
    }

    if (stencilBits === void 0) {
      stencilBits = 0;
    }

    if (uboOffsetAlignment === void 0) {
      uboOffsetAlignment = 1;
    }

    if (maxComputeSharedMemorySize === void 0) {
      maxComputeSharedMemorySize = 0;
    }

    if (maxComputeWorkGroupInvocations === void 0) {
      maxComputeWorkGroupInvocations = 0;
    }

    if (maxComputeWorkGroupSize === void 0) {
      maxComputeWorkGroupSize = new Size$1();
    }

    if (maxComputeWorkGroupCount === void 0) {
      maxComputeWorkGroupCount = new Size$1();
    }

    if (clipSpaceMinZ === void 0) {
      clipSpaceMinZ = -1;
    }

    if (screenSpaceSignY === void 0) {
      screenSpaceSignY = 1;
    }

    if (clipSpaceSignY === void 0) {
      clipSpaceSignY = 1;
    }

    this.maxVertexAttributes = maxVertexAttributes;
    this.maxVertexUniformVectors = maxVertexUniformVectors;
    this.maxFragmentUniformVectors = maxFragmentUniformVectors;
    this.maxTextureUnits = maxTextureUnits;
    this.maxImageUnits = maxImageUnits;
    this.maxVertexTextureUnits = maxVertexTextureUnits;
    this.maxColorRenderTargets = maxColorRenderTargets;
    this.maxShaderStorageBufferBindings = maxShaderStorageBufferBindings;
    this.maxShaderStorageBlockSize = maxShaderStorageBlockSize;
    this.maxUniformBufferBindings = maxUniformBufferBindings;
    this.maxUniformBlockSize = maxUniformBlockSize;
    this.maxTextureSize = maxTextureSize;
    this.maxCubeMapTextureSize = maxCubeMapTextureSize;
    this.depthBits = depthBits;
    this.stencilBits = stencilBits;
    this.uboOffsetAlignment = uboOffsetAlignment;
    this.maxComputeSharedMemorySize = maxComputeSharedMemorySize;
    this.maxComputeWorkGroupInvocations = maxComputeWorkGroupInvocations;
    this.maxComputeWorkGroupSize = maxComputeWorkGroupSize;
    this.maxComputeWorkGroupCount = maxComputeWorkGroupCount;
    this.clipSpaceMinZ = clipSpaceMinZ;
    this.screenSpaceSignY = screenSpaceSignY;
    this.clipSpaceSignY = clipSpaceSignY;
  }

  var _proto2 = DeviceCaps.prototype;

  _proto2.copy = function copy(info) {
    this.maxVertexAttributes = info.maxVertexAttributes;
    this.maxVertexUniformVectors = info.maxVertexUniformVectors;
    this.maxFragmentUniformVectors = info.maxFragmentUniformVectors;
    this.maxTextureUnits = info.maxTextureUnits;
    this.maxImageUnits = info.maxImageUnits;
    this.maxVertexTextureUnits = info.maxVertexTextureUnits;
    this.maxColorRenderTargets = info.maxColorRenderTargets;
    this.maxShaderStorageBufferBindings = info.maxShaderStorageBufferBindings;
    this.maxShaderStorageBlockSize = info.maxShaderStorageBlockSize;
    this.maxUniformBufferBindings = info.maxUniformBufferBindings;
    this.maxUniformBlockSize = info.maxUniformBlockSize;
    this.maxTextureSize = info.maxTextureSize;
    this.maxCubeMapTextureSize = info.maxCubeMapTextureSize;
    this.depthBits = info.depthBits;
    this.stencilBits = info.stencilBits;
    this.uboOffsetAlignment = info.uboOffsetAlignment;
    this.maxComputeSharedMemorySize = info.maxComputeSharedMemorySize;
    this.maxComputeWorkGroupInvocations = info.maxComputeWorkGroupInvocations;
    this.maxComputeWorkGroupSize.copy(info.maxComputeWorkGroupSize);
    this.maxComputeWorkGroupCount.copy(info.maxComputeWorkGroupCount);
    this.clipSpaceMinZ = info.clipSpaceMinZ;
    this.screenSpaceSignY = info.screenSpaceSignY;
    this.clipSpaceSignY = info.clipSpaceSignY;
    return this;
  };

  return DeviceCaps;
}();
var Offset = function () {
  function Offset(x, y, z) {
    if (x === void 0) {
      x = 0;
    }

    if (y === void 0) {
      y = 0;
    }

    if (z === void 0) {
      z = 0;
    }

    this.x = x;
    this.y = y;
    this.z = z;
  }

  var _proto3 = Offset.prototype;

  _proto3.copy = function copy(info) {
    this.x = info.x;
    this.y = info.y;
    this.z = info.z;
    return this;
  };

  return Offset;
}();
var Rect$1 = function () {
  function Rect(x, y, width, height) {
    if (x === void 0) {
      x = 0;
    }

    if (y === void 0) {
      y = 0;
    }

    if (width === void 0) {
      width = 0;
    }

    if (height === void 0) {
      height = 0;
    }

    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;
  }

  var _proto4 = Rect.prototype;

  _proto4.copy = function copy(info) {
    this.x = info.x;
    this.y = info.y;
    this.width = info.width;
    this.height = info.height;
    return this;
  };

  return Rect;
}();
var Extent = function () {
  function Extent(width, height, depth) {
    if (width === void 0) {
      width = 0;
    }

    if (height === void 0) {
      height = 0;
    }

    if (depth === void 0) {
      depth = 1;
    }

    this.width = width;
    this.height = height;
    this.depth = depth;
  }

  var _proto5 = Extent.prototype;

  _proto5.copy = function copy(info) {
    this.width = info.width;
    this.height = info.height;
    this.depth = info.depth;
    return this;
  };

  return Extent;
}();
var TextureSubresLayers = function () {
  function TextureSubresLayers(mipLevel, baseArrayLayer, layerCount) {
    if (mipLevel === void 0) {
      mipLevel = 0;
    }

    if (baseArrayLayer === void 0) {
      baseArrayLayer = 0;
    }

    if (layerCount === void 0) {
      layerCount = 1;
    }

    this.mipLevel = mipLevel;
    this.baseArrayLayer = baseArrayLayer;
    this.layerCount = layerCount;
  }

  var _proto6 = TextureSubresLayers.prototype;

  _proto6.copy = function copy(info) {
    this.mipLevel = info.mipLevel;
    this.baseArrayLayer = info.baseArrayLayer;
    this.layerCount = info.layerCount;
    return this;
  };

  return TextureSubresLayers;
}();
var TextureSubresRange = function () {
  function TextureSubresRange(baseMipLevel, levelCount, baseArrayLayer, layerCount) {
    if (baseMipLevel === void 0) {
      baseMipLevel = 0;
    }

    if (levelCount === void 0) {
      levelCount = 1;
    }

    if (baseArrayLayer === void 0) {
      baseArrayLayer = 0;
    }

    if (layerCount === void 0) {
      layerCount = 1;
    }

    this.baseMipLevel = baseMipLevel;
    this.levelCount = levelCount;
    this.baseArrayLayer = baseArrayLayer;
    this.layerCount = layerCount;
  }

  var _proto7 = TextureSubresRange.prototype;

  _proto7.copy = function copy(info) {
    this.baseMipLevel = info.baseMipLevel;
    this.levelCount = info.levelCount;
    this.baseArrayLayer = info.baseArrayLayer;
    this.layerCount = info.layerCount;
    return this;
  };

  return TextureSubresRange;
}();
var TextureCopy = function () {
  function TextureCopy(srcSubres, srcOffset, dstSubres, dstOffset, extent) {
    if (srcSubres === void 0) {
      srcSubres = new TextureSubresLayers();
    }

    if (srcOffset === void 0) {
      srcOffset = new Offset();
    }

    if (dstSubres === void 0) {
      dstSubres = new TextureSubresLayers();
    }

    if (dstOffset === void 0) {
      dstOffset = new Offset();
    }

    if (extent === void 0) {
      extent = new Extent();
    }

    this.srcSubres = srcSubres;
    this.srcOffset = srcOffset;
    this.dstSubres = dstSubres;
    this.dstOffset = dstOffset;
    this.extent = extent;
  }

  var _proto8 = TextureCopy.prototype;

  _proto8.copy = function copy(info) {
    this.srcSubres.copy(info.srcSubres);
    this.srcOffset.copy(info.srcOffset);
    this.dstSubres.copy(info.dstSubres);
    this.dstOffset.copy(info.dstOffset);
    this.extent.copy(info.extent);
    return this;
  };

  return TextureCopy;
}();
var TextureBlit = function () {
  function TextureBlit(srcSubres, srcOffset, srcExtent, dstSubres, dstOffset, dstExtent) {
    if (srcSubres === void 0) {
      srcSubres = new TextureSubresLayers();
    }

    if (srcOffset === void 0) {
      srcOffset = new Offset();
    }

    if (srcExtent === void 0) {
      srcExtent = new Extent();
    }

    if (dstSubres === void 0) {
      dstSubres = new TextureSubresLayers();
    }

    if (dstOffset === void 0) {
      dstOffset = new Offset();
    }

    if (dstExtent === void 0) {
      dstExtent = new Extent();
    }

    this.srcSubres = srcSubres;
    this.srcOffset = srcOffset;
    this.srcExtent = srcExtent;
    this.dstSubres = dstSubres;
    this.dstOffset = dstOffset;
    this.dstExtent = dstExtent;
  }

  var _proto9 = TextureBlit.prototype;

  _proto9.copy = function copy(info) {
    this.srcSubres.copy(info.srcSubres);
    this.srcOffset.copy(info.srcOffset);
    this.srcExtent.copy(info.srcExtent);
    this.dstSubres.copy(info.dstSubres);
    this.dstOffset.copy(info.dstOffset);
    this.dstExtent.copy(info.dstExtent);
    return this;
  };

  return TextureBlit;
}();
var BufferTextureCopy = function () {
  function BufferTextureCopy(buffStride, buffTexHeight, texOffset, texExtent, texSubres) {
    if (buffStride === void 0) {
      buffStride = 0;
    }

    if (buffTexHeight === void 0) {
      buffTexHeight = 0;
    }

    if (texOffset === void 0) {
      texOffset = new Offset();
    }

    if (texExtent === void 0) {
      texExtent = new Extent();
    }

    if (texSubres === void 0) {
      texSubres = new TextureSubresLayers();
    }

    this.buffStride = buffStride;
    this.buffTexHeight = buffTexHeight;
    this.texOffset = texOffset;
    this.texExtent = texExtent;
    this.texSubres = texSubres;
  }

  var _proto10 = BufferTextureCopy.prototype;

  _proto10.copy = function copy(info) {
    this.buffStride = info.buffStride;
    this.buffTexHeight = info.buffTexHeight;
    this.texOffset.copy(info.texOffset);
    this.texExtent.copy(info.texExtent);
    this.texSubres.copy(info.texSubres);
    return this;
  };

  return BufferTextureCopy;
}();
var Viewport = function () {
  function Viewport(left, top, width, height, minDepth, maxDepth) {
    if (left === void 0) {
      left = 0;
    }

    if (top === void 0) {
      top = 0;
    }

    if (width === void 0) {
      width = 0;
    }

    if (height === void 0) {
      height = 0;
    }

    if (minDepth === void 0) {
      minDepth = 0;
    }

    if (maxDepth === void 0) {
      maxDepth = 1;
    }

    this.left = left;
    this.top = top;
    this.width = width;
    this.height = height;
    this.minDepth = minDepth;
    this.maxDepth = maxDepth;
  }

  var _proto11 = Viewport.prototype;

  _proto11.copy = function copy(info) {
    this.left = info.left;
    this.top = info.top;
    this.width = info.width;
    this.height = info.height;
    this.minDepth = info.minDepth;
    this.maxDepth = info.maxDepth;
    return this;
  };

  return Viewport;
}();
var Color$1 = function () {
  function Color(x, y, z, w) {
    if (x === void 0) {
      x = 0;
    }

    if (y === void 0) {
      y = 0;
    }

    if (z === void 0) {
      z = 0;
    }

    if (w === void 0) {
      w = 0;
    }

    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
  }

  var _proto12 = Color.prototype;

  _proto12.copy = function copy(info) {
    this.x = info.x;
    this.y = info.y;
    this.z = info.z;
    this.w = info.w;
    return this;
  };

  return Color;
}();
var BindingMappingInfo = function () {
  function BindingMappingInfo(bufferOffsets, samplerOffsets, flexibleSet) {
    if (bufferOffsets === void 0) {
      bufferOffsets = [];
    }

    if (samplerOffsets === void 0) {
      samplerOffsets = [];
    }

    if (flexibleSet === void 0) {
      flexibleSet = 0;
    }

    this.bufferOffsets = bufferOffsets;
    this.samplerOffsets = samplerOffsets;
    this.flexibleSet = flexibleSet;
  }

  var _proto13 = BindingMappingInfo.prototype;

  _proto13.copy = function copy(info) {
    this.bufferOffsets = info.bufferOffsets.slice();
    this.samplerOffsets = info.samplerOffsets.slice();
    this.flexibleSet = info.flexibleSet;
    return this;
  };

  return BindingMappingInfo;
}();
var BufferInfo = function () {
  function BufferInfo(usage, memUsage, size, stride, flags) {
    if (usage === void 0) {
      usage = exports.BufferUsageBit.NONE;
    }

    if (memUsage === void 0) {
      memUsage = exports.MemoryUsageBit.NONE;
    }

    if (size === void 0) {
      size = 0;
    }

    if (stride === void 0) {
      stride = 0;
    }

    if (flags === void 0) {
      flags = exports.BufferFlagBit.NONE;
    }

    this.usage = usage;
    this.memUsage = memUsage;
    this.size = size;
    this.stride = stride;
    this.flags = flags;
  }

  var _proto14 = BufferInfo.prototype;

  _proto14.copy = function copy(info) {
    this.usage = info.usage;
    this.memUsage = info.memUsage;
    this.size = info.size;
    this.stride = info.stride;
    this.flags = info.flags;
    return this;
  };

  return BufferInfo;
}();
var BufferViewInfo = function () {
  function BufferViewInfo(buffer, offset, range) {
    if (buffer === void 0) {
      buffer = null;
    }

    if (offset === void 0) {
      offset = 0;
    }

    if (range === void 0) {
      range = 0;
    }

    this.buffer = buffer;
    this.offset = offset;
    this.range = range;
  }

  var _proto15 = BufferViewInfo.prototype;

  _proto15.copy = function copy(info) {
    this.buffer = info.buffer;
    this.offset = info.offset;
    this.range = info.range;
    return this;
  };

  return BufferViewInfo;
}();
var DrawInfo = function () {
  function DrawInfo(vertexCount, firstVertex, indexCount, firstIndex, vertexOffset, instanceCount, firstInstance) {
    if (vertexCount === void 0) {
      vertexCount = 0;
    }

    if (firstVertex === void 0) {
      firstVertex = 0;
    }

    if (indexCount === void 0) {
      indexCount = 0;
    }

    if (firstIndex === void 0) {
      firstIndex = 0;
    }

    if (vertexOffset === void 0) {
      vertexOffset = 0;
    }

    if (instanceCount === void 0) {
      instanceCount = 0;
    }

    if (firstInstance === void 0) {
      firstInstance = 0;
    }

    this.vertexCount = vertexCount;
    this.firstVertex = firstVertex;
    this.indexCount = indexCount;
    this.firstIndex = firstIndex;
    this.vertexOffset = vertexOffset;
    this.instanceCount = instanceCount;
    this.firstInstance = firstInstance;
  }

  var _proto16 = DrawInfo.prototype;

  _proto16.copy = function copy(info) {
    this.vertexCount = info.vertexCount;
    this.firstVertex = info.firstVertex;
    this.indexCount = info.indexCount;
    this.firstIndex = info.firstIndex;
    this.vertexOffset = info.vertexOffset;
    this.instanceCount = info.instanceCount;
    this.firstInstance = info.firstInstance;
    return this;
  };

  return DrawInfo;
}();
var DispatchInfo = function () {
  function DispatchInfo(groupCountX, groupCountY, groupCountZ, indirectBuffer, indirectOffset) {
    if (groupCountX === void 0) {
      groupCountX = 0;
    }

    if (groupCountY === void 0) {
      groupCountY = 0;
    }

    if (groupCountZ === void 0) {
      groupCountZ = 0;
    }

    if (indirectBuffer === void 0) {
      indirectBuffer = null;
    }

    if (indirectOffset === void 0) {
      indirectOffset = 0;
    }

    this.groupCountX = groupCountX;
    this.groupCountY = groupCountY;
    this.groupCountZ = groupCountZ;
    this.indirectBuffer = indirectBuffer;
    this.indirectOffset = indirectOffset;
  }

  var _proto17 = DispatchInfo.prototype;

  _proto17.copy = function copy(info) {
    this.groupCountX = info.groupCountX;
    this.groupCountY = info.groupCountY;
    this.groupCountZ = info.groupCountZ;
    this.indirectBuffer = info.indirectBuffer;
    this.indirectOffset = info.indirectOffset;
    return this;
  };

  return DispatchInfo;
}();
var IndirectBuffer = function () {
  function IndirectBuffer(drawInfos) {
    if (drawInfos === void 0) {
      drawInfos = [];
    }

    this.drawInfos = drawInfos;
  }

  var _proto18 = IndirectBuffer.prototype;

  _proto18.copy = function copy(info) {
    deepCopy(this.drawInfos, info.drawInfos, DrawInfo);
    return this;
  };

  return IndirectBuffer;
}();
var TextureInfo = function () {
  function TextureInfo(type, usage, format, width, height, flags, layerCount, levelCount, samples, depth) {
    if (type === void 0) {
      type = exports.TextureType.TEX2D;
    }

    if (usage === void 0) {
      usage = exports.TextureUsageBit.NONE;
    }

    if (format === void 0) {
      format = exports.Format.UNKNOWN;
    }

    if (width === void 0) {
      width = 0;
    }

    if (height === void 0) {
      height = 0;
    }

    if (flags === void 0) {
      flags = exports.TextureFlagBit.NONE;
    }

    if (layerCount === void 0) {
      layerCount = 1;
    }

    if (levelCount === void 0) {
      levelCount = 1;
    }

    if (samples === void 0) {
      samples = exports.SampleCount.X1;
    }

    if (depth === void 0) {
      depth = 1;
    }

    this.type = type;
    this.usage = usage;
    this.format = format;
    this.width = width;
    this.height = height;
    this.flags = flags;
    this.layerCount = layerCount;
    this.levelCount = levelCount;
    this.samples = samples;
    this.depth = depth;
  }

  var _proto19 = TextureInfo.prototype;

  _proto19.copy = function copy(info) {
    this.type = info.type;
    this.usage = info.usage;
    this.format = info.format;
    this.width = info.width;
    this.height = info.height;
    this.flags = info.flags;
    this.layerCount = info.layerCount;
    this.levelCount = info.levelCount;
    this.samples = info.samples;
    this.depth = info.depth;
    return this;
  };

  return TextureInfo;
}();
var TextureViewInfo = function () {
  function TextureViewInfo(texture, type, format, baseLevel, levelCount, baseLayer, layerCount) {
    if (texture === void 0) {
      texture = null;
    }

    if (type === void 0) {
      type = exports.TextureType.TEX2D;
    }

    if (format === void 0) {
      format = exports.Format.UNKNOWN;
    }

    if (baseLevel === void 0) {
      baseLevel = 0;
    }

    if (levelCount === void 0) {
      levelCount = 1;
    }

    if (baseLayer === void 0) {
      baseLayer = 0;
    }

    if (layerCount === void 0) {
      layerCount = 1;
    }

    this.texture = texture;
    this.type = type;
    this.format = format;
    this.baseLevel = baseLevel;
    this.levelCount = levelCount;
    this.baseLayer = baseLayer;
    this.layerCount = layerCount;
  }

  var _proto20 = TextureViewInfo.prototype;

  _proto20.copy = function copy(info) {
    this.texture = info.texture;
    this.type = info.type;
    this.format = info.format;
    this.baseLevel = info.baseLevel;
    this.levelCount = info.levelCount;
    this.baseLayer = info.baseLayer;
    this.layerCount = info.layerCount;
    return this;
  };

  return TextureViewInfo;
}();
var SamplerInfo = function () {
  function SamplerInfo(minFilter, magFilter, mipFilter, addressU, addressV, addressW, maxAnisotropy, cmpFunc, borderColor, mipLODBias) {
    if (minFilter === void 0) {
      minFilter = exports.Filter.LINEAR;
    }

    if (magFilter === void 0) {
      magFilter = exports.Filter.LINEAR;
    }

    if (mipFilter === void 0) {
      mipFilter = exports.Filter.NONE;
    }

    if (addressU === void 0) {
      addressU = exports.Address.WRAP;
    }

    if (addressV === void 0) {
      addressV = exports.Address.WRAP;
    }

    if (addressW === void 0) {
      addressW = exports.Address.WRAP;
    }

    if (maxAnisotropy === void 0) {
      maxAnisotropy = 0;
    }

    if (cmpFunc === void 0) {
      cmpFunc = exports.ComparisonFunc.ALWAYS;
    }

    if (borderColor === void 0) {
      borderColor = new Color$1();
    }

    if (mipLODBias === void 0) {
      mipLODBias = 0;
    }

    this.minFilter = minFilter;
    this.magFilter = magFilter;
    this.mipFilter = mipFilter;
    this.addressU = addressU;
    this.addressV = addressV;
    this.addressW = addressW;
    this.maxAnisotropy = maxAnisotropy;
    this.cmpFunc = cmpFunc;
    this.borderColor = borderColor;
    this.mipLODBias = mipLODBias;
  }

  var _proto21 = SamplerInfo.prototype;

  _proto21.copy = function copy(info) {
    this.minFilter = info.minFilter;
    this.magFilter = info.magFilter;
    this.mipFilter = info.mipFilter;
    this.addressU = info.addressU;
    this.addressV = info.addressV;
    this.addressW = info.addressW;
    this.maxAnisotropy = info.maxAnisotropy;
    this.cmpFunc = info.cmpFunc;
    this.borderColor.copy(info.borderColor);
    this.mipLODBias = info.mipLODBias;
    return this;
  };

  return SamplerInfo;
}();
var Uniform = function () {
  function Uniform(name, type, count) {
    if (name === void 0) {
      name = '';
    }

    if (type === void 0) {
      type = exports.Type.UNKNOWN;
    }

    if (count === void 0) {
      count = 0;
    }

    this.name = name;
    this.type = type;
    this.count = count;
  }

  var _proto22 = Uniform.prototype;

  _proto22.copy = function copy(info) {
    this.name = info.name;
    this.type = info.type;
    this.count = info.count;
    return this;
  };

  return Uniform;
}();
var UniformBlock = function () {
  function UniformBlock(set, binding, name, members, count) {
    if (set === void 0) {
      set = 0;
    }

    if (binding === void 0) {
      binding = 0;
    }

    if (name === void 0) {
      name = '';
    }

    if (members === void 0) {
      members = [];
    }

    if (count === void 0) {
      count = 0;
    }

    this.set = set;
    this.binding = binding;
    this.name = name;
    this.members = members;
    this.count = count;
  }

  var _proto23 = UniformBlock.prototype;

  _proto23.copy = function copy(info) {
    this.set = info.set;
    this.binding = info.binding;
    this.name = info.name;
    deepCopy(this.members, info.members, Uniform);
    this.count = info.count;
    return this;
  };

  return UniformBlock;
}();
var UniformSamplerTexture = function () {
  function UniformSamplerTexture(set, binding, name, type, count) {
    if (set === void 0) {
      set = 0;
    }

    if (binding === void 0) {
      binding = 0;
    }

    if (name === void 0) {
      name = '';
    }

    if (type === void 0) {
      type = exports.Type.UNKNOWN;
    }

    if (count === void 0) {
      count = 0;
    }

    this.set = set;
    this.binding = binding;
    this.name = name;
    this.type = type;
    this.count = count;
  }

  var _proto24 = UniformSamplerTexture.prototype;

  _proto24.copy = function copy(info) {
    this.set = info.set;
    this.binding = info.binding;
    this.name = info.name;
    this.type = info.type;
    this.count = info.count;
    return this;
  };

  return UniformSamplerTexture;
}();
var UniformSampler = function () {
  function UniformSampler(set, binding, name, count) {
    if (set === void 0) {
      set = 0;
    }

    if (binding === void 0) {
      binding = 0;
    }

    if (name === void 0) {
      name = '';
    }

    if (count === void 0) {
      count = 0;
    }

    this.set = set;
    this.binding = binding;
    this.name = name;
    this.count = count;
  }

  var _proto25 = UniformSampler.prototype;

  _proto25.copy = function copy(info) {
    this.set = info.set;
    this.binding = info.binding;
    this.name = info.name;
    this.count = info.count;
    return this;
  };

  return UniformSampler;
}();
var UniformTexture = function () {
  function UniformTexture(set, binding, name, type, count) {
    if (set === void 0) {
      set = 0;
    }

    if (binding === void 0) {
      binding = 0;
    }

    if (name === void 0) {
      name = '';
    }

    if (type === void 0) {
      type = exports.Type.UNKNOWN;
    }

    if (count === void 0) {
      count = 0;
    }

    this.set = set;
    this.binding = binding;
    this.name = name;
    this.type = type;
    this.count = count;
  }

  var _proto26 = UniformTexture.prototype;

  _proto26.copy = function copy(info) {
    this.set = info.set;
    this.binding = info.binding;
    this.name = info.name;
    this.type = info.type;
    this.count = info.count;
    return this;
  };

  return UniformTexture;
}();
var UniformStorageImage = function () {
  function UniformStorageImage(set, binding, name, type, count, memoryAccess) {
    if (set === void 0) {
      set = 0;
    }

    if (binding === void 0) {
      binding = 0;
    }

    if (name === void 0) {
      name = '';
    }

    if (type === void 0) {
      type = exports.Type.UNKNOWN;
    }

    if (count === void 0) {
      count = 0;
    }

    if (memoryAccess === void 0) {
      memoryAccess = exports.MemoryAccessBit.READ_WRITE;
    }

    this.set = set;
    this.binding = binding;
    this.name = name;
    this.type = type;
    this.count = count;
    this.memoryAccess = memoryAccess;
  }

  var _proto27 = UniformStorageImage.prototype;

  _proto27.copy = function copy(info) {
    this.set = info.set;
    this.binding = info.binding;
    this.name = info.name;
    this.type = info.type;
    this.count = info.count;
    this.memoryAccess = info.memoryAccess;
    return this;
  };

  return UniformStorageImage;
}();
var UniformStorageBuffer = function () {
  function UniformStorageBuffer(set, binding, name, count, memoryAccess) {
    if (set === void 0) {
      set = 0;
    }

    if (binding === void 0) {
      binding = 0;
    }

    if (name === void 0) {
      name = '';
    }

    if (count === void 0) {
      count = 0;
    }

    if (memoryAccess === void 0) {
      memoryAccess = exports.MemoryAccessBit.READ_WRITE;
    }

    this.set = set;
    this.binding = binding;
    this.name = name;
    this.count = count;
    this.memoryAccess = memoryAccess;
  }

  var _proto28 = UniformStorageBuffer.prototype;

  _proto28.copy = function copy(info) {
    this.set = info.set;
    this.binding = info.binding;
    this.name = info.name;
    this.count = info.count;
    this.memoryAccess = info.memoryAccess;
    return this;
  };

  return UniformStorageBuffer;
}();
var UniformInputAttachment = function () {
  function UniformInputAttachment(set, binding, name, count) {
    if (set === void 0) {
      set = 0;
    }

    if (binding === void 0) {
      binding = 0;
    }

    if (name === void 0) {
      name = '';
    }

    if (count === void 0) {
      count = 0;
    }

    this.set = set;
    this.binding = binding;
    this.name = name;
    this.count = count;
  }

  var _proto29 = UniformInputAttachment.prototype;

  _proto29.copy = function copy(info) {
    this.set = info.set;
    this.binding = info.binding;
    this.name = info.name;
    this.count = info.count;
    return this;
  };

  return UniformInputAttachment;
}();
var ShaderStage = function () {
  function ShaderStage(stage, source) {
    if (stage === void 0) {
      stage = exports.ShaderStageFlagBit.NONE;
    }

    if (source === void 0) {
      source = '';
    }

    this.stage = stage;
    this.source = source;
  }

  var _proto30 = ShaderStage.prototype;

  _proto30.copy = function copy(info) {
    this.stage = info.stage;
    this.source = info.source;
    return this;
  };

  return ShaderStage;
}();
var Attribute = function () {
  function Attribute(name, format, isNormalized, stream, isInstanced, location) {
    if (name === void 0) {
      name = '';
    }

    if (format === void 0) {
      format = exports.Format.UNKNOWN;
    }

    if (isNormalized === void 0) {
      isNormalized = false;
    }

    if (stream === void 0) {
      stream = 0;
    }

    if (isInstanced === void 0) {
      isInstanced = false;
    }

    if (location === void 0) {
      location = 0;
    }

    this.name = name;
    this.format = format;
    this.isNormalized = isNormalized;
    this.stream = stream;
    this.isInstanced = isInstanced;
    this.location = location;
  }

  var _proto31 = Attribute.prototype;

  _proto31.copy = function copy(info) {
    this.name = info.name;
    this.format = info.format;
    this.isNormalized = info.isNormalized;
    this.stream = info.stream;
    this.isInstanced = info.isInstanced;
    this.location = info.location;
    return this;
  };

  return Attribute;
}();
var ShaderInfo = function () {
  function ShaderInfo(name, stages, attributes, blocks, buffers, samplerTextures, samplers, textures, images, subpassInputs) {
    if (name === void 0) {
      name = '';
    }

    if (stages === void 0) {
      stages = [];
    }

    if (attributes === void 0) {
      attributes = [];
    }

    if (blocks === void 0) {
      blocks = [];
    }

    if (buffers === void 0) {
      buffers = [];
    }

    if (samplerTextures === void 0) {
      samplerTextures = [];
    }

    if (samplers === void 0) {
      samplers = [];
    }

    if (textures === void 0) {
      textures = [];
    }

    if (images === void 0) {
      images = [];
    }

    if (subpassInputs === void 0) {
      subpassInputs = [];
    }

    this.name = name;
    this.stages = stages;
    this.attributes = attributes;
    this.blocks = blocks;
    this.buffers = buffers;
    this.samplerTextures = samplerTextures;
    this.samplers = samplers;
    this.textures = textures;
    this.images = images;
    this.subpassInputs = subpassInputs;
  }

  var _proto32 = ShaderInfo.prototype;

  _proto32.copy = function copy(info) {
    this.name = info.name;
    deepCopy(this.stages, info.stages, ShaderStage);
    deepCopy(this.attributes, info.attributes, Attribute);
    deepCopy(this.blocks, info.blocks, UniformBlock);
    deepCopy(this.buffers, info.buffers, UniformStorageBuffer);
    deepCopy(this.samplerTextures, info.samplerTextures, UniformSamplerTexture);
    deepCopy(this.samplers, info.samplers, UniformSampler);
    deepCopy(this.textures, info.textures, UniformTexture);
    deepCopy(this.images, info.images, UniformStorageImage);
    deepCopy(this.subpassInputs, info.subpassInputs, UniformInputAttachment);
    return this;
  };

  return ShaderInfo;
}();
var InputAssemblerInfo = function () {
  function InputAssemblerInfo(attributes, vertexBuffers, indexBuffer, indirectBuffer) {
    if (attributes === void 0) {
      attributes = [];
    }

    if (vertexBuffers === void 0) {
      vertexBuffers = [];
    }

    if (indexBuffer === void 0) {
      indexBuffer = null;
    }

    if (indirectBuffer === void 0) {
      indirectBuffer = null;
    }

    this.attributes = attributes;
    this.vertexBuffers = vertexBuffers;
    this.indexBuffer = indexBuffer;
    this.indirectBuffer = indirectBuffer;
  }

  var _proto33 = InputAssemblerInfo.prototype;

  _proto33.copy = function copy(info) {
    deepCopy(this.attributes, info.attributes, Attribute);
    this.vertexBuffers = info.vertexBuffers.slice();
    this.indexBuffer = info.indexBuffer;
    this.indirectBuffer = info.indirectBuffer;
    return this;
  };

  return InputAssemblerInfo;
}();
var ColorAttachment = function () {
  function ColorAttachment(format, sampleCount, loadOp, storeOp, beginAccesses, endAccesses, isGeneralLayout) {
    if (format === void 0) {
      format = exports.Format.UNKNOWN;
    }

    if (sampleCount === void 0) {
      sampleCount = exports.SampleCount.X1;
    }

    if (loadOp === void 0) {
      loadOp = exports.LoadOp.CLEAR;
    }

    if (storeOp === void 0) {
      storeOp = exports.StoreOp.STORE;
    }

    if (beginAccesses === void 0) {
      beginAccesses = [];
    }

    if (endAccesses === void 0) {
      endAccesses = [exports.AccessType.PRESENT];
    }

    if (isGeneralLayout === void 0) {
      isGeneralLayout = false;
    }

    this.format = format;
    this.sampleCount = sampleCount;
    this.loadOp = loadOp;
    this.storeOp = storeOp;
    this.beginAccesses = beginAccesses;
    this.endAccesses = endAccesses;
    this.isGeneralLayout = isGeneralLayout;
  }

  var _proto34 = ColorAttachment.prototype;

  _proto34.copy = function copy(info) {
    this.format = info.format;
    this.sampleCount = info.sampleCount;
    this.loadOp = info.loadOp;
    this.storeOp = info.storeOp;
    this.beginAccesses = info.beginAccesses.slice();
    this.endAccesses = info.endAccesses.slice();
    this.isGeneralLayout = info.isGeneralLayout;
    return this;
  };

  return ColorAttachment;
}();
var DepthStencilAttachment = function () {
  function DepthStencilAttachment(format, sampleCount, depthLoadOp, depthStoreOp, stencilLoadOp, stencilStoreOp, beginAccesses, endAccesses, isGeneralLayout) {
    if (format === void 0) {
      format = exports.Format.UNKNOWN;
    }

    if (sampleCount === void 0) {
      sampleCount = exports.SampleCount.X1;
    }

    if (depthLoadOp === void 0) {
      depthLoadOp = exports.LoadOp.CLEAR;
    }

    if (depthStoreOp === void 0) {
      depthStoreOp = exports.StoreOp.STORE;
    }

    if (stencilLoadOp === void 0) {
      stencilLoadOp = exports.LoadOp.CLEAR;
    }

    if (stencilStoreOp === void 0) {
      stencilStoreOp = exports.StoreOp.STORE;
    }

    if (beginAccesses === void 0) {
      beginAccesses = [];
    }

    if (endAccesses === void 0) {
      endAccesses = [exports.AccessType.DEPTH_STENCIL_ATTACHMENT_WRITE];
    }

    if (isGeneralLayout === void 0) {
      isGeneralLayout = false;
    }

    this.format = format;
    this.sampleCount = sampleCount;
    this.depthLoadOp = depthLoadOp;
    this.depthStoreOp = depthStoreOp;
    this.stencilLoadOp = stencilLoadOp;
    this.stencilStoreOp = stencilStoreOp;
    this.beginAccesses = beginAccesses;
    this.endAccesses = endAccesses;
    this.isGeneralLayout = isGeneralLayout;
  }

  var _proto35 = DepthStencilAttachment.prototype;

  _proto35.copy = function copy(info) {
    this.format = info.format;
    this.sampleCount = info.sampleCount;
    this.depthLoadOp = info.depthLoadOp;
    this.depthStoreOp = info.depthStoreOp;
    this.stencilLoadOp = info.stencilLoadOp;
    this.stencilStoreOp = info.stencilStoreOp;
    this.beginAccesses = info.beginAccesses.slice();
    this.endAccesses = info.endAccesses.slice();
    this.isGeneralLayout = info.isGeneralLayout;
    return this;
  };

  return DepthStencilAttachment;
}();
var SubpassInfo = function () {
  function SubpassInfo(inputs, colors, resolves, preserves, depthStencil, depthStencilResolve, depthResolveMode, stencilResolveMode) {
    if (inputs === void 0) {
      inputs = [];
    }

    if (colors === void 0) {
      colors = [];
    }

    if (resolves === void 0) {
      resolves = [];
    }

    if (preserves === void 0) {
      preserves = [];
    }

    if (depthStencil === void 0) {
      depthStencil = -1;
    }

    if (depthStencilResolve === void 0) {
      depthStencilResolve = -1;
    }

    if (depthResolveMode === void 0) {
      depthResolveMode = exports.ResolveMode.NONE;
    }

    if (stencilResolveMode === void 0) {
      stencilResolveMode = exports.ResolveMode.NONE;
    }

    this.inputs = inputs;
    this.colors = colors;
    this.resolves = resolves;
    this.preserves = preserves;
    this.depthStencil = depthStencil;
    this.depthStencilResolve = depthStencilResolve;
    this.depthResolveMode = depthResolveMode;
    this.stencilResolveMode = stencilResolveMode;
  }

  var _proto36 = SubpassInfo.prototype;

  _proto36.copy = function copy(info) {
    this.inputs = info.inputs.slice();
    this.colors = info.colors.slice();
    this.resolves = info.resolves.slice();
    this.preserves = info.preserves.slice();
    this.depthStencil = info.depthStencil;
    this.depthStencilResolve = info.depthStencilResolve;
    this.depthResolveMode = info.depthResolveMode;
    this.stencilResolveMode = info.stencilResolveMode;
    return this;
  };

  return SubpassInfo;
}();
var SubpassDependency = function () {
  function SubpassDependency(srcSubpass, dstSubpass, srcAccesses, dstAccesses) {
    if (srcSubpass === void 0) {
      srcSubpass = 0;
    }

    if (dstSubpass === void 0) {
      dstSubpass = 0;
    }

    if (srcAccesses === void 0) {
      srcAccesses = [];
    }

    if (dstAccesses === void 0) {
      dstAccesses = [];
    }

    this.srcSubpass = srcSubpass;
    this.dstSubpass = dstSubpass;
    this.srcAccesses = srcAccesses;
    this.dstAccesses = dstAccesses;
  }

  var _proto37 = SubpassDependency.prototype;

  _proto37.copy = function copy(info) {
    this.srcSubpass = info.srcSubpass;
    this.dstSubpass = info.dstSubpass;
    this.srcAccesses = info.srcAccesses.slice();
    this.dstAccesses = info.dstAccesses.slice();
    return this;
  };

  return SubpassDependency;
}();
var RenderPassInfo = function () {
  function RenderPassInfo(colorAttachments, depthStencilAttachment, subpasses, dependencies) {
    if (colorAttachments === void 0) {
      colorAttachments = [];
    }

    if (depthStencilAttachment === void 0) {
      depthStencilAttachment = new DepthStencilAttachment();
    }

    if (subpasses === void 0) {
      subpasses = [];
    }

    if (dependencies === void 0) {
      dependencies = [];
    }

    this.colorAttachments = colorAttachments;
    this.depthStencilAttachment = depthStencilAttachment;
    this.subpasses = subpasses;
    this.dependencies = dependencies;
  }

  var _proto38 = RenderPassInfo.prototype;

  _proto38.copy = function copy(info) {
    deepCopy(this.colorAttachments, info.colorAttachments, ColorAttachment);
    this.depthStencilAttachment.copy(info.depthStencilAttachment);
    deepCopy(this.subpasses, info.subpasses, SubpassInfo);
    deepCopy(this.dependencies, info.dependencies, SubpassDependency);
    return this;
  };

  return RenderPassInfo;
}();
var GlobalBarrierInfo = function () {
  function GlobalBarrierInfo(prevAccesses, nextAccesses) {
    if (prevAccesses === void 0) {
      prevAccesses = [];
    }

    if (nextAccesses === void 0) {
      nextAccesses = [];
    }

    this.prevAccesses = prevAccesses;
    this.nextAccesses = nextAccesses;
  }

  var _proto39 = GlobalBarrierInfo.prototype;

  _proto39.copy = function copy(info) {
    this.prevAccesses = info.prevAccesses.slice();
    this.nextAccesses = info.nextAccesses.slice();
    return this;
  };

  return GlobalBarrierInfo;
}();
var TextureBarrierInfo = function () {
  function TextureBarrierInfo(prevAccesses, nextAccesses, discardContents, srcQueue, dstQueue) {
    if (prevAccesses === void 0) {
      prevAccesses = [];
    }

    if (nextAccesses === void 0) {
      nextAccesses = [];
    }

    if (discardContents === void 0) {
      discardContents = false;
    }

    if (srcQueue === void 0) {
      srcQueue = null;
    }

    if (dstQueue === void 0) {
      dstQueue = null;
    }

    this.prevAccesses = prevAccesses;
    this.nextAccesses = nextAccesses;
    this.discardContents = discardContents;
    this.srcQueue = srcQueue;
    this.dstQueue = dstQueue;
  }

  var _proto40 = TextureBarrierInfo.prototype;

  _proto40.copy = function copy(info) {
    this.prevAccesses = info.prevAccesses.slice();
    this.nextAccesses = info.nextAccesses.slice();
    this.discardContents = info.discardContents;
    this.srcQueue = info.srcQueue;
    this.dstQueue = info.dstQueue;
    return this;
  };

  return TextureBarrierInfo;
}();
var FramebufferInfo = function () {
  function FramebufferInfo(renderPass, colorTextures, depthStencilTexture) {
    if (renderPass === void 0) {
      renderPass = null;
    }

    if (colorTextures === void 0) {
      colorTextures = [];
    }

    if (depthStencilTexture === void 0) {
      depthStencilTexture = null;
    }

    this.renderPass = renderPass;
    this.colorTextures = colorTextures;
    this.depthStencilTexture = depthStencilTexture;
  }

  var _proto41 = FramebufferInfo.prototype;

  _proto41.copy = function copy(info) {
    this.renderPass = info.renderPass;
    this.colorTextures = info.colorTextures.slice();
    this.depthStencilTexture = info.depthStencilTexture;
    return this;
  };

  return FramebufferInfo;
}();
var DescriptorSetLayoutBinding = function () {
  function DescriptorSetLayoutBinding(binding, descriptorType, count, stageFlags, immutableSamplers) {
    if (binding === void 0) {
      binding = -1;
    }

    if (descriptorType === void 0) {
      descriptorType = exports.DescriptorType.UNKNOWN;
    }

    if (count === void 0) {
      count = 0;
    }

    if (stageFlags === void 0) {
      stageFlags = exports.ShaderStageFlagBit.NONE;
    }

    if (immutableSamplers === void 0) {
      immutableSamplers = [];
    }

    this.binding = binding;
    this.descriptorType = descriptorType;
    this.count = count;
    this.stageFlags = stageFlags;
    this.immutableSamplers = immutableSamplers;
  }

  var _proto42 = DescriptorSetLayoutBinding.prototype;

  _proto42.copy = function copy(info) {
    this.binding = info.binding;
    this.descriptorType = info.descriptorType;
    this.count = info.count;
    this.stageFlags = info.stageFlags;
    this.immutableSamplers = info.immutableSamplers.slice();
    return this;
  };

  return DescriptorSetLayoutBinding;
}();
var DescriptorSetLayoutInfo = function () {
  function DescriptorSetLayoutInfo(bindings) {
    if (bindings === void 0) {
      bindings = [];
    }

    this.bindings = bindings;
  }

  var _proto43 = DescriptorSetLayoutInfo.prototype;

  _proto43.copy = function copy(info) {
    deepCopy(this.bindings, info.bindings, DescriptorSetLayoutBinding);
    return this;
  };

  return DescriptorSetLayoutInfo;
}();
var DescriptorSetInfo = function () {
  function DescriptorSetInfo(layout) {
    if (layout === void 0) {
      layout = null;
    }

    this.layout = layout;
  }

  var _proto44 = DescriptorSetInfo.prototype;

  _proto44.copy = function copy(info) {
    this.layout = info.layout;
    return this;
  };

  return DescriptorSetInfo;
}();
var PipelineLayoutInfo = function () {
  function PipelineLayoutInfo(setLayouts) {
    if (setLayouts === void 0) {
      setLayouts = [];
    }

    this.setLayouts = setLayouts;
  }

  var _proto45 = PipelineLayoutInfo.prototype;

  _proto45.copy = function copy(info) {
    this.setLayouts = info.setLayouts.slice();
    return this;
  };

  return PipelineLayoutInfo;
}();
var InputState = function () {
  function InputState(attributes) {
    if (attributes === void 0) {
      attributes = [];
    }

    this.attributes = attributes;
  }

  var _proto46 = InputState.prototype;

  _proto46.copy = function copy(info) {
    deepCopy(this.attributes, info.attributes, Attribute);
    return this;
  };

  return InputState;
}();
var CommandBufferInfo = function () {
  function CommandBufferInfo(queue, type) {
    if (queue === void 0) {
      queue = null;
    }

    if (type === void 0) {
      type = exports.CommandBufferType.PRIMARY;
    }

    this.queue = queue;
    this.type = type;
  }

  var _proto47 = CommandBufferInfo.prototype;

  _proto47.copy = function copy(info) {
    this.queue = info.queue;
    this.type = info.type;
    return this;
  };

  return CommandBufferInfo;
}();
var QueueInfo = function () {
  function QueueInfo(type) {
    if (type === void 0) {
      type = exports.QueueType.GRAPHICS;
    }

    this.type = type;
  }

  var _proto48 = QueueInfo.prototype;

  _proto48.copy = function copy(info) {
    this.type = info.type;
    return this;
  };

  return QueueInfo;
}();
var FormatInfo = function FormatInfo(name, size, count, type, hasAlpha, hasDepth, hasStencil, isCompressed) {
  if (name === void 0) {
    name = '';
  }

  if (size === void 0) {
    size = 0;
  }

  if (count === void 0) {
    count = 0;
  }

  if (type === void 0) {
    type = exports.FormatType.NONE;
  }

  if (hasAlpha === void 0) {
    hasAlpha = false;
  }

  if (hasDepth === void 0) {
    hasDepth = false;
  }

  if (hasStencil === void 0) {
    hasStencil = false;
  }

  if (isCompressed === void 0) {
    isCompressed = false;
  }

  this.name = name;
  this.size = size;
  this.count = count;
  this.type = type;
  this.hasAlpha = hasAlpha;
  this.hasDepth = hasDepth;
  this.hasStencil = hasStencil;
  this.isCompressed = isCompressed;
};
var MemoryStatus = function () {
  function MemoryStatus(bufferSize, textureSize) {
    if (bufferSize === void 0) {
      bufferSize = 0;
    }

    if (textureSize === void 0) {
      textureSize = 0;
    }

    this.bufferSize = bufferSize;
    this.textureSize = textureSize;
  }

  var _proto49 = MemoryStatus.prototype;

  _proto49.copy = function copy(info) {
    this.bufferSize = info.bufferSize;
    this.textureSize = info.textureSize;
    return this;
  };

  return MemoryStatus;
}();
var DynamicStencilStates = function () {
  function DynamicStencilStates(writeMask, compareMask, reference) {
    if (writeMask === void 0) {
      writeMask = 0;
    }

    if (compareMask === void 0) {
      compareMask = 0;
    }

    if (reference === void 0) {
      reference = 0;
    }

    this.writeMask = writeMask;
    this.compareMask = compareMask;
    this.reference = reference;
  }

  var _proto50 = DynamicStencilStates.prototype;

  _proto50.copy = function copy(info) {
    this.writeMask = info.writeMask;
    this.compareMask = info.compareMask;
    this.reference = info.reference;
    return this;
  };

  return DynamicStencilStates;
}();
var DynamicStates = function () {
  function DynamicStates(viewport, scissor, blendConstant, lineWidth, depthBiasConstant, depthBiasClamp, depthBiasSlope, depthMinBounds, depthMaxBounds, stencilStatesFront, stencilStatesBack) {
    if (viewport === void 0) {
      viewport = new Viewport();
    }

    if (scissor === void 0) {
      scissor = new Rect$1();
    }

    if (blendConstant === void 0) {
      blendConstant = new Color$1();
    }

    if (lineWidth === void 0) {
      lineWidth = 1;
    }

    if (depthBiasConstant === void 0) {
      depthBiasConstant = 0;
    }

    if (depthBiasClamp === void 0) {
      depthBiasClamp = 0;
    }

    if (depthBiasSlope === void 0) {
      depthBiasSlope = 0;
    }

    if (depthMinBounds === void 0) {
      depthMinBounds = 0;
    }

    if (depthMaxBounds === void 0) {
      depthMaxBounds = 0;
    }

    if (stencilStatesFront === void 0) {
      stencilStatesFront = new DynamicStencilStates();
    }

    if (stencilStatesBack === void 0) {
      stencilStatesBack = new DynamicStencilStates();
    }

    this.viewport = viewport;
    this.scissor = scissor;
    this.blendConstant = blendConstant;
    this.lineWidth = lineWidth;
    this.depthBiasConstant = depthBiasConstant;
    this.depthBiasClamp = depthBiasClamp;
    this.depthBiasSlope = depthBiasSlope;
    this.depthMinBounds = depthMinBounds;
    this.depthMaxBounds = depthMaxBounds;
    this.stencilStatesFront = stencilStatesFront;
    this.stencilStatesBack = stencilStatesBack;
  }

  var _proto51 = DynamicStates.prototype;

  _proto51.copy = function copy(info) {
    this.viewport.copy(info.viewport);
    this.scissor.copy(info.scissor);
    this.blendConstant.copy(info.blendConstant);
    this.lineWidth = info.lineWidth;
    this.depthBiasConstant = info.depthBiasConstant;
    this.depthBiasClamp = info.depthBiasClamp;
    this.depthBiasSlope = info.depthBiasSlope;
    this.depthMinBounds = info.depthMinBounds;
    this.depthMaxBounds = info.depthMaxBounds;
    this.stencilStatesFront.copy(info.stencilStatesFront);
    this.stencilStatesBack.copy(info.stencilStatesBack);
    return this;
  };

  return DynamicStates;
}();
var Obj = function () {
  _createClass(Obj, [{
    key: "gfxType",
    get: function get() {
      return this._gfxType;
    }
  }]);

  function Obj(gfxType) {
    this._gfxType = exports.ObjectType.UNKNOWN;
    this._gfxType = gfxType;
  }

  return Obj;
}();
var DeviceInfo = function DeviceInfo(canvasElm, isAntialias, isPremultipliedAlpha, devicePixelRatio, width, height, bindingMappingInfo) {
  if (isAntialias === void 0) {
    isAntialias = true;
  }

  if (isPremultipliedAlpha === void 0) {
    isPremultipliedAlpha = true;
  }

  if (devicePixelRatio === void 0) {
    devicePixelRatio = 1;
  }

  if (width === void 0) {
    width = 1;
  }

  if (height === void 0) {
    height = 1;
  }

  if (bindingMappingInfo === void 0) {
    bindingMappingInfo = new BindingMappingInfo();
  }

  this.canvasElm = canvasElm;
  this.isAntialias = isAntialias;
  this.isPremultipliedAlpha = isPremultipliedAlpha;
  this.devicePixelRatio = devicePixelRatio;
  this.width = width;
  this.height = height;
  this.bindingMappingInfo = bindingMappingInfo;
};

(function (AttributeName) {
  AttributeName["ATTR_POSITION"] = "a_position";
  AttributeName["ATTR_NORMAL"] = "a_normal";
  AttributeName["ATTR_TANGENT"] = "a_tangent";
  AttributeName["ATTR_BITANGENT"] = "a_bitangent";
  AttributeName["ATTR_WEIGHTS"] = "a_weights";
  AttributeName["ATTR_JOINTS"] = "a_joints";
  AttributeName["ATTR_COLOR"] = "a_color";
  AttributeName["ATTR_COLOR1"] = "a_color1";
  AttributeName["ATTR_COLOR2"] = "a_color2";
  AttributeName["ATTR_TEX_COORD"] = "a_texCoord";
  AttributeName["ATTR_TEX_COORD1"] = "a_texCoord1";
  AttributeName["ATTR_TEX_COORD2"] = "a_texCoord2";
  AttributeName["ATTR_TEX_COORD3"] = "a_texCoord3";
  AttributeName["ATTR_TEX_COORD4"] = "a_texCoord4";
  AttributeName["ATTR_TEX_COORD5"] = "a_texCoord5";
  AttributeName["ATTR_TEX_COORD6"] = "a_texCoord6";
  AttributeName["ATTR_TEX_COORD7"] = "a_texCoord7";
  AttributeName["ATTR_TEX_COORD8"] = "a_texCoord8";
  AttributeName["ATTR_BATCH_ID"] = "a_batch_id";
  AttributeName["ATTR_BATCH_UV"] = "a_batch_uv";
})(exports.AttributeName || (exports.AttributeName = {}));

var FormatInfos = Object.freeze([new FormatInfo('UNKNOWN', 0, 0, exports.FormatType.NONE, false, false, false, false), new FormatInfo('A8', 1, 1, exports.FormatType.UNORM, true, false, false, false), new FormatInfo('L8', 1, 1, exports.FormatType.UNORM, false, false, false, false), new FormatInfo('LA8', 1, 2, exports.FormatType.UNORM, true, false, false, false), new FormatInfo('R8', 1, 1, exports.FormatType.UNORM, false, false, false, false), new FormatInfo('R8SN', 1, 1, exports.FormatType.SNORM, false, false, false, false), new FormatInfo('R8UI', 1, 1, exports.FormatType.UINT, false, false, false, false), new FormatInfo('R8I', 1, 1, exports.FormatType.INT, false, false, false, false), new FormatInfo('R16F', 2, 1, exports.FormatType.FLOAT, false, false, false, false), new FormatInfo('R16UI', 2, 1, exports.FormatType.UINT, false, false, false, false), new FormatInfo('R16I', 2, 1, exports.FormatType.INT, false, false, false, false), new FormatInfo('R32F', 4, 1, exports.FormatType.FLOAT, false, false, false, false), new FormatInfo('R32UI', 4, 1, exports.FormatType.UINT, false, false, false, false), new FormatInfo('R32I', 4, 1, exports.FormatType.INT, false, false, false, false), new FormatInfo('RG8', 2, 2, exports.FormatType.UNORM, false, false, false, false), new FormatInfo('RG8SN', 2, 2, exports.FormatType.SNORM, false, false, false, false), new FormatInfo('RG8UI', 2, 2, exports.FormatType.UINT, false, false, false, false), new FormatInfo('RG8I', 2, 2, exports.FormatType.INT, false, false, false, false), new FormatInfo('RG16F', 4, 2, exports.FormatType.FLOAT, false, false, false, false), new FormatInfo('RG16UI', 4, 2, exports.FormatType.UINT, false, false, false, false), new FormatInfo('RG16I', 4, 2, exports.FormatType.INT, false, false, false, false), new FormatInfo('RG32F', 8, 2, exports.FormatType.FLOAT, false, false, false, false), new FormatInfo('RG32UI', 8, 2, exports.FormatType.UINT, false, false, false, false), new FormatInfo('RG32I', 8, 2, exports.FormatType.INT, false, false, false, false), new FormatInfo('RGB8', 3, 3, exports.FormatType.UNORM, false, false, false, false), new FormatInfo('SRGB8', 3, 3, exports.FormatType.UNORM, false, false, false, false), new FormatInfo('RGB8SN', 3, 3, exports.FormatType.SNORM, false, false, false, false), new FormatInfo('RGB8UI', 3, 3, exports.FormatType.UINT, false, false, false, false), new FormatInfo('RGB8I', 3, 3, exports.FormatType.INT, false, false, false, false), new FormatInfo('RGB16F', 6, 3, exports.FormatType.FLOAT, false, false, false, false), new FormatInfo('RGB16UI', 6, 3, exports.FormatType.UINT, false, false, false, false), new FormatInfo('RGB16I', 6, 3, exports.FormatType.INT, false, false, false, false), new FormatInfo('RGB32F', 12, 3, exports.FormatType.FLOAT, false, false, false, false), new FormatInfo('RGB32UI', 12, 3, exports.FormatType.UINT, false, false, false, false), new FormatInfo('RGB32I', 12, 3, exports.FormatType.INT, false, false, false, false), new FormatInfo('RGBA8', 4, 4, exports.FormatType.UNORM, true, false, false, false), new FormatInfo('BGRA8', 4, 4, exports.FormatType.UNORM, true, false, false, false), new FormatInfo('SRGB8_A8', 4, 4, exports.FormatType.UNORM, true, false, false, false), new FormatInfo('RGBA8SN', 4, 4, exports.FormatType.SNORM, true, false, false, false), new FormatInfo('RGBA8UI', 4, 4, exports.FormatType.UINT, true, false, false, false), new FormatInfo('RGBA8I', 4, 4, exports.FormatType.INT, true, false, false, false), new FormatInfo('RGBA16F', 8, 4, exports.FormatType.FLOAT, true, false, false, false), new FormatInfo('RGBA16UI', 8, 4, exports.FormatType.UINT, true, false, false, false), new FormatInfo('RGBA16I', 8, 4, exports.FormatType.INT, true, false, false, false), new FormatInfo('RGBA32F', 16, 4, exports.FormatType.FLOAT, true, false, false, false), new FormatInfo('RGBA32UI', 16, 4, exports.FormatType.UINT, true, false, false, false), new FormatInfo('RGBA32I', 16, 4, exports.FormatType.INT, true, false, false, false), new FormatInfo('R5G6B5', 2, 3, exports.FormatType.UNORM, false, false, false, false), new FormatInfo('R11G11B10F', 4, 3, exports.FormatType.FLOAT, false, false, false, false), new FormatInfo('RGB5A1', 2, 4, exports.FormatType.UNORM, true, false, false, false), new FormatInfo('RGBA4', 2, 4, exports.FormatType.UNORM, true, false, false, false), new FormatInfo('RGB10A2', 2, 4, exports.FormatType.UNORM, true, false, false, false), new FormatInfo('RGB10A2UI', 2, 4, exports.FormatType.UINT, true, false, false, false), new FormatInfo('RGB9E5', 2, 4, exports.FormatType.FLOAT, true, false, false, false), new FormatInfo('D16', 2, 1, exports.FormatType.UINT, false, true, false, false), new FormatInfo('D16S8', 3, 2, exports.FormatType.UINT, false, true, true, false), new FormatInfo('D24', 3, 1, exports.FormatType.UINT, false, true, false, false), new FormatInfo('D24S8', 4, 2, exports.FormatType.UINT, false, true, true, false), new FormatInfo('D32F', 4, 1, exports.FormatType.FLOAT, false, true, false, false), new FormatInfo('D32FS8', 5, 2, exports.FormatType.FLOAT, false, true, true, false), new FormatInfo('BC1', 1, 3, exports.FormatType.UNORM, false, false, false, true), new FormatInfo('BC1_ALPHA', 1, 4, exports.FormatType.UNORM, true, false, false, true), new FormatInfo('BC1_SRGB', 1, 3, exports.FormatType.UNORM, false, false, false, true), new FormatInfo('BC1_SRGB_ALPHA', 1, 4, exports.FormatType.UNORM, true, false, false, true), new FormatInfo('BC2', 1, 4, exports.FormatType.UNORM, true, false, false, true), new FormatInfo('BC2_SRGB', 1, 4, exports.FormatType.UNORM, true, false, false, true), new FormatInfo('BC3', 1, 4, exports.FormatType.UNORM, true, false, false, true), new FormatInfo('BC3_SRGB', 1, 4, exports.FormatType.UNORM, true, false, false, true), new FormatInfo('BC4', 1, 1, exports.FormatType.UNORM, false, false, false, true), new FormatInfo('BC4_SNORM', 1, 1, exports.FormatType.SNORM, false, false, false, true), new FormatInfo('BC5', 1, 2, exports.FormatType.UNORM, false, false, false, true), new FormatInfo('BC5_SNORM', 1, 2, exports.FormatType.SNORM, false, false, false, true), new FormatInfo('BC6H_UF16', 1, 3, exports.FormatType.UFLOAT, false, false, false, true), new FormatInfo('BC6H_SF16', 1, 3, exports.FormatType.FLOAT, false, false, false, true), new FormatInfo('BC7', 1, 4, exports.FormatType.UNORM, true, false, false, true), new FormatInfo('BC7_SRGB', 1, 4, exports.FormatType.UNORM, true, false, false, true), new FormatInfo('ETC_RGB8', 1, 3, exports.FormatType.UNORM, false, false, false, true), new FormatInfo('ETC2_RGB8', 1, 3, exports.FormatType.UNORM, false, false, false, true), new FormatInfo('ETC2_SRGB8', 1, 3, exports.FormatType.UNORM, false, false, false, true), new FormatInfo('ETC2_RGB8_A1', 1, 4, exports.FormatType.UNORM, true, false, false, true), new FormatInfo('ETC2_SRGB8_A1', 1, 4, exports.FormatType.UNORM, true, false, false, true), new FormatInfo('ETC2_RGBA8', 2, 4, exports.FormatType.UNORM, true, false, false, true), new FormatInfo('ETC2_SRGB8_A8', 2, 4, exports.FormatType.UNORM, true, false, false, true), new FormatInfo('EAC_R11', 1, 1, exports.FormatType.UNORM, false, false, false, true), new FormatInfo('EAC_R11SN', 1, 1, exports.FormatType.SNORM, false, false, false, true), new FormatInfo('EAC_RG11', 2, 2, exports.FormatType.UNORM, false, false, false, true), new FormatInfo('EAC_RG11SN', 2, 2, exports.FormatType.SNORM, false, false, false, true), new FormatInfo('PVRTC_RGB2', 2, 3, exports.FormatType.UNORM, false, false, false, true), new FormatInfo('PVRTC_RGBA2', 2, 4, exports.FormatType.UNORM, true, false, false, true), new FormatInfo('PVRTC_RGB4', 2, 3, exports.FormatType.UNORM, false, false, false, true), new FormatInfo('PVRTC_RGBA4', 2, 4, exports.FormatType.UNORM, true, false, false, true), new FormatInfo('PVRTC2_2BPP', 2, 4, exports.FormatType.UNORM, true, false, false, true), new FormatInfo('PVRTC2_4BPP', 2, 4, exports.FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_RGBA_4x4', 1, 4, exports.FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_RGBA_5x4', 1, 4, exports.FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_RGBA_5x5', 1, 4, exports.FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_RGBA_6x5', 1, 4, exports.FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_RGBA_6x6', 1, 4, exports.FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_RGBA_8x5', 1, 4, exports.FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_RGBA_8x6', 1, 4, exports.FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_RGBA_8x8', 1, 4, exports.FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_RGBA_10x5', 1, 4, exports.FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_RGBA_10x6', 1, 4, exports.FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_RGBA_10x8', 1, 4, exports.FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_RGBA_10x10', 1, 4, exports.FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_RGBA_12x10', 1, 4, exports.FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_RGBA_12x12', 1, 4, exports.FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_SRGBA_4x4', 1, 4, exports.FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_SRGBA_5x4', 1, 4, exports.FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_SRGBA_5x5', 1, 4, exports.FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_SRGBA_6x5', 1, 4, exports.FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_SRGBA_6x6', 1, 4, exports.FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_SRGBA_8x5', 1, 4, exports.FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_SRGBA_8x6', 1, 4, exports.FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_SRGBA_8x8', 1, 4, exports.FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_SRGBA_10x5', 1, 4, exports.FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_SRGBA_10x6', 1, 4, exports.FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_SRGBA_10x8', 1, 4, exports.FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_SRGBA_10x10', 1, 4, exports.FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_SRGBA_12x10', 1, 4, exports.FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_SRGBA_12x12', 1, 4, exports.FormatType.UNORM, true, false, false, true)]);
var DESCRIPTOR_BUFFER_TYPE = exports.DescriptorType.UNIFORM_BUFFER | exports.DescriptorType.DYNAMIC_UNIFORM_BUFFER | exports.DescriptorType.STORAGE_BUFFER | exports.DescriptorType.DYNAMIC_STORAGE_BUFFER;
var DESCRIPTOR_SAMPLER_TYPE = exports.DescriptorType.SAMPLER_TEXTURE | exports.DescriptorType.SAMPLER | exports.DescriptorType.TEXTURE | exports.DescriptorType.STORAGE_IMAGE | exports.DescriptorType.INPUT_ATTACHMENT;
var DESCRIPTOR_DYNAMIC_TYPE = exports.DescriptorType.DYNAMIC_STORAGE_BUFFER | exports.DescriptorType.DYNAMIC_UNIFORM_BUFFER;
var DRAW_INFO_SIZE = 28;
function IsPowerOf2(x) {
  return x > 0 && (x & x - 1) === 0;
}
function FormatSize(format, width, height, depth) {
  if (!FormatInfos[format].isCompressed) {
    return width * height * depth * FormatInfos[format].size;
  } else {
    switch (format) {
      case exports.Format.BC1:
      case exports.Format.BC1_ALPHA:
      case exports.Format.BC1_SRGB:
      case exports.Format.BC1_SRGB_ALPHA:
        return Math.ceil(width / 4) * Math.ceil(height / 4) * 8 * depth;

      case exports.Format.BC2:
      case exports.Format.BC2_SRGB:
      case exports.Format.BC3:
      case exports.Format.BC3_SRGB:
      case exports.Format.BC4:
      case exports.Format.BC4_SNORM:
      case exports.Format.BC6H_SF16:
      case exports.Format.BC6H_UF16:
      case exports.Format.BC7:
      case exports.Format.BC7_SRGB:
        return Math.ceil(width / 4) * Math.ceil(height / 4) * 16 * depth;

      case exports.Format.BC5:
      case exports.Format.BC5_SNORM:
        return Math.ceil(width / 4) * Math.ceil(height / 4) * 32 * depth;

      case exports.Format.ETC_RGB8:
      case exports.Format.ETC2_RGB8:
      case exports.Format.ETC2_SRGB8:
      case exports.Format.ETC2_RGB8_A1:
      case exports.Format.EAC_R11:
      case exports.Format.EAC_R11SN:
        return Math.ceil(width / 4) * Math.ceil(height / 4) * 8 * depth;

      case exports.Format.ETC2_RGBA8:
      case exports.Format.ETC2_SRGB8_A1:
      case exports.Format.EAC_RG11:
      case exports.Format.EAC_RG11SN:
        return Math.ceil(width / 4) * Math.ceil(height / 4) * 16 * depth;

      case exports.Format.PVRTC_RGB2:
      case exports.Format.PVRTC_RGBA2:
      case exports.Format.PVRTC2_2BPP:
        return Math.ceil(Math.max(width, 16) * Math.max(height, 8) / 4) * depth;

      case exports.Format.PVRTC_RGB4:
      case exports.Format.PVRTC_RGBA4:
      case exports.Format.PVRTC2_4BPP:
        return Math.ceil(Math.max(width, 8) * Math.max(height, 8) / 2) * depth;

      case exports.Format.ASTC_RGBA_4X4:
      case exports.Format.ASTC_SRGBA_4X4:
        return Math.ceil(width / 4) * Math.ceil(height / 4) * 16 * depth;

      case exports.Format.ASTC_RGBA_5X4:
      case exports.Format.ASTC_SRGBA_5X4:
        return Math.ceil(width / 5) * Math.ceil(height / 4) * 16 * depth;

      case exports.Format.ASTC_RGBA_5X5:
      case exports.Format.ASTC_SRGBA_5X5:
        return Math.ceil(width / 5) * Math.ceil(height / 5) * 16 * depth;

      case exports.Format.ASTC_RGBA_6X5:
      case exports.Format.ASTC_SRGBA_6X5:
        return Math.ceil(width / 6) * Math.ceil(height / 5) * 16 * depth;

      case exports.Format.ASTC_RGBA_6X6:
      case exports.Format.ASTC_SRGBA_6X6:
        return Math.ceil(width / 6) * Math.ceil(height / 6) * 16 * depth;

      case exports.Format.ASTC_RGBA_8X5:
      case exports.Format.ASTC_SRGBA_8X5:
        return Math.ceil(width / 8) * Math.ceil(height / 5) * 16 * depth;

      case exports.Format.ASTC_RGBA_8X6:
      case exports.Format.ASTC_SRGBA_8X6:
        return Math.ceil(width / 8) * Math.ceil(height / 6) * 16 * depth;

      case exports.Format.ASTC_RGBA_8X8:
      case exports.Format.ASTC_SRGBA_8X8:
        return Math.ceil(width / 8) * Math.ceil(height / 8) * 16 * depth;

      case exports.Format.ASTC_RGBA_10X5:
      case exports.Format.ASTC_SRGBA_10X5:
        return Math.ceil(width / 10) * Math.ceil(height / 5) * 16 * depth;

      case exports.Format.ASTC_RGBA_10X6:
      case exports.Format.ASTC_SRGBA_10X6:
        return Math.ceil(width / 10) * Math.ceil(height / 6) * 16 * depth;

      case exports.Format.ASTC_RGBA_10X8:
      case exports.Format.ASTC_SRGBA_10X8:
        return Math.ceil(width / 10) * Math.ceil(height / 8) * 16 * depth;

      case exports.Format.ASTC_RGBA_10X10:
      case exports.Format.ASTC_SRGBA_10X10:
        return Math.ceil(width / 10) * Math.ceil(height / 10) * 16 * depth;

      case exports.Format.ASTC_RGBA_12X10:
      case exports.Format.ASTC_SRGBA_12X10:
        return Math.ceil(width / 12) * Math.ceil(height / 10) * 16 * depth;

      case exports.Format.ASTC_RGBA_12X12:
      case exports.Format.ASTC_SRGBA_12X12:
        return Math.ceil(width / 12) * Math.ceil(height / 12) * 16 * depth;

      default:
        {
          return 0;
        }
    }
  }
}
function FormatSurfaceSize(format, width, height, depth, mips) {
  var size = 0;

  for (var i = 0; i < mips; ++i) {
    size += FormatSize(format, width, height, depth);
    width = Math.max(width >> 1, 1);
    height = Math.max(height >> 1, 1);
  }

  return size;
}
var _type2size = [0, 4, 8, 12, 16, 4, 8, 12, 16, 4, 8, 12, 16, 4, 8, 12, 16, 16, 24, 32, 24, 36, 48, 32, 48, 64, 4, 4, 4, 4, 4, 4];
function GetTypeSize(type) {
  return _type2size[type] || 0;
}
function getTypedArrayConstructor(info) {
  var stride = info.size / info.count;

  switch (info.type) {
    case exports.FormatType.UNORM:
    case exports.FormatType.UINT:
      {
        switch (stride) {
          case 1:
            return Uint8Array;

          case 2:
            return Uint16Array;

          case 4:
            return Uint32Array;
        }

        break;
      }

    case exports.FormatType.SNORM:
    case exports.FormatType.INT:
      {
        switch (stride) {
          case 1:
            return Int8Array;

          case 2:
            return Int16Array;

          case 4:
            return Int32Array;
        }

        break;
      }

    case exports.FormatType.FLOAT:
      {
        return Float32Array;
      }
  }

  return Float32Array;
}

var defines = /*#__PURE__*/Object.freeze({
    __proto__: null,
    get ObjectType () { return exports.ObjectType; },
    get Status () { return exports.Status; },
    get API () { return exports.API; },
    get SurfaceTransform () { return exports.SurfaceTransform; },
    get Feature () { return exports.Feature; },
    get Format () { return exports.Format; },
    get FormatType () { return exports.FormatType; },
    get Type () { return exports.Type; },
    get BufferUsageBit () { return exports.BufferUsageBit; },
    get BufferFlagBit () { return exports.BufferFlagBit; },
    get MemoryAccessBit () { return exports.MemoryAccessBit; },
    get MemoryUsageBit () { return exports.MemoryUsageBit; },
    get TextureType () { return exports.TextureType; },
    get TextureUsageBit () { return exports.TextureUsageBit; },
    get TextureFlagBit () { return exports.TextureFlagBit; },
    get SampleCount () { return exports.SampleCount; },
    get Filter () { return exports.Filter; },
    get Address () { return exports.Address; },
    get ComparisonFunc () { return exports.ComparisonFunc; },
    get StencilOp () { return exports.StencilOp; },
    get BlendFactor () { return exports.BlendFactor; },
    get BlendOp () { return exports.BlendOp; },
    get ColorMask () { return exports.ColorMask; },
    get ShaderStageFlagBit () { return exports.ShaderStageFlagBit; },
    get LoadOp () { return exports.LoadOp; },
    get StoreOp () { return exports.StoreOp; },
    get AccessType () { return exports.AccessType; },
    get ResolveMode () { return exports.ResolveMode; },
    get PipelineBindPoint () { return exports.PipelineBindPoint; },
    get PrimitiveMode () { return exports.PrimitiveMode; },
    get PolygonMode () { return exports.PolygonMode; },
    get ShadeModel () { return exports.ShadeModel; },
    get CullMode () { return exports.CullMode; },
    get DynamicStateFlagBit () { return exports.DynamicStateFlagBit; },
    get StencilFace () { return exports.StencilFace; },
    get DescriptorType () { return exports.DescriptorType; },
    get QueueType () { return exports.QueueType; },
    get CommandBufferType () { return exports.CommandBufferType; },
    get ClearFlagBit () { return exports.ClearFlagBit; },
    Size: Size$1,
    DeviceCaps: DeviceCaps,
    Offset: Offset,
    Rect: Rect$1,
    Extent: Extent,
    TextureSubresLayers: TextureSubresLayers,
    TextureSubresRange: TextureSubresRange,
    TextureCopy: TextureCopy,
    TextureBlit: TextureBlit,
    BufferTextureCopy: BufferTextureCopy,
    Viewport: Viewport,
    Color: Color$1,
    BindingMappingInfo: BindingMappingInfo,
    BufferInfo: BufferInfo,
    BufferViewInfo: BufferViewInfo,
    DrawInfo: DrawInfo,
    DispatchInfo: DispatchInfo,
    IndirectBuffer: IndirectBuffer,
    TextureInfo: TextureInfo,
    TextureViewInfo: TextureViewInfo,
    SamplerInfo: SamplerInfo,
    Uniform: Uniform,
    UniformBlock: UniformBlock,
    UniformSamplerTexture: UniformSamplerTexture,
    UniformSampler: UniformSampler,
    UniformTexture: UniformTexture,
    UniformStorageImage: UniformStorageImage,
    UniformStorageBuffer: UniformStorageBuffer,
    UniformInputAttachment: UniformInputAttachment,
    ShaderStage: ShaderStage,
    Attribute: Attribute,
    ShaderInfo: ShaderInfo,
    InputAssemblerInfo: InputAssemblerInfo,
    ColorAttachment: ColorAttachment,
    DepthStencilAttachment: DepthStencilAttachment,
    SubpassInfo: SubpassInfo,
    SubpassDependency: SubpassDependency,
    RenderPassInfo: RenderPassInfo,
    GlobalBarrierInfo: GlobalBarrierInfo,
    TextureBarrierInfo: TextureBarrierInfo,
    FramebufferInfo: FramebufferInfo,
    DescriptorSetLayoutBinding: DescriptorSetLayoutBinding,
    DescriptorSetLayoutInfo: DescriptorSetLayoutInfo,
    DescriptorSetInfo: DescriptorSetInfo,
    PipelineLayoutInfo: PipelineLayoutInfo,
    InputState: InputState,
    CommandBufferInfo: CommandBufferInfo,
    QueueInfo: QueueInfo,
    FormatInfo: FormatInfo,
    MemoryStatus: MemoryStatus,
    DynamicStencilStates: DynamicStencilStates,
    DynamicStates: DynamicStates,
    Obj: Obj,
    DeviceInfo: DeviceInfo,
    get AttributeName () { return exports.AttributeName; },
    FormatInfos: FormatInfos,
    DESCRIPTOR_BUFFER_TYPE: DESCRIPTOR_BUFFER_TYPE,
    DESCRIPTOR_SAMPLER_TYPE: DESCRIPTOR_SAMPLER_TYPE,
    DESCRIPTOR_DYNAMIC_TYPE: DESCRIPTOR_DYNAMIC_TYPE,
    DRAW_INFO_SIZE: DRAW_INFO_SIZE,
    IsPowerOf2: IsPowerOf2,
    FormatSize: FormatSize,
    FormatSurfaceSize: FormatSurfaceSize,
    GetTypeSize: GetTypeSize,
    getTypedArrayConstructor: getTypedArrayConstructor
});

var Buffer = function (_Obj) {
  _inheritsLoose(Buffer, _Obj);

  _createClass(Buffer, [{
    key: "usage",
    get: function get() {
      return this._usage;
    }
  }, {
    key: "memUsage",
    get: function get() {
      return this._memUsage;
    }
  }, {
    key: "size",
    get: function get() {
      return this._size;
    }
  }, {
    key: "stride",
    get: function get() {
      return this._stride;
    }
  }, {
    key: "count",
    get: function get() {
      return this._count;
    }
  }, {
    key: "flags",
    get: function get() {
      return this._flags;
    }
  }]);

  function Buffer(device) {
    var _this;

    _this = _Obj.call(this, exports.ObjectType.BUFFER) || this;
    _this._device = void 0;
    _this._usage = exports.BufferUsageBit.NONE;
    _this._memUsage = exports.MemoryUsageBit.NONE;
    _this._size = 0;
    _this._stride = 1;
    _this._count = 0;
    _this._flags = exports.BufferFlagBit.NONE;
    _this._indirectBuffer = null;
    _this._isBufferView = false;
    _this._device = device;
    return _this;
  }

  return Buffer;
}(Obj);

var CommandBuffer = function (_Obj) {
  _inheritsLoose(CommandBuffer, _Obj);

  _createClass(CommandBuffer, [{
    key: "type",
    get: function get() {
      return this._type;
    }
  }, {
    key: "queue",
    get: function get() {
      return this._queue;
    }
  }, {
    key: "numDrawCalls",
    get: function get() {
      return this._numDrawCalls;
    }
  }, {
    key: "numInstances",
    get: function get() {
      return this._numInstances;
    }
  }, {
    key: "numTris",
    get: function get() {
      return this._numTris;
    }
  }]);

  function CommandBuffer(device) {
    var _this;

    _this = _Obj.call(this, exports.ObjectType.COMMAND_BUFFER) || this;
    _this._device = void 0;
    _this._queue = null;
    _this._type = exports.CommandBufferType.PRIMARY;
    _this._numDrawCalls = 0;
    _this._numInstances = 0;
    _this._numTris = 0;
    _this._device = device;
    return _this;
  }

  return CommandBuffer;
}(Obj);

ccenum(exports.Format);
var Device = function () {
  function Device() {
    this._canvas = null;
    this._canvas2D = null;
    this._gfxAPI = exports.API.UNKNOWN;
    this._transform = exports.SurfaceTransform.IDENTITY;
    this._deviceName = '';
    this._renderer = '';
    this._vendor = '';
    this._version = '';
    this._features = new Array(exports.Feature.COUNT);
    this._queue = null;
    this._cmdBuff = null;
    this._devicePixelRatio = 1.0;
    this._width = 0;
    this._height = 0;
    this._colorFmt = exports.Format.UNKNOWN;
    this._depthStencilFmt = exports.Format.UNKNOWN;
    this._numDrawCalls = 0;
    this._numInstances = 0;
    this._numTris = 0;
    this._memoryStatus = new MemoryStatus();
    this._caps = new DeviceCaps();
  }

  var _proto = Device.prototype;

  _proto.hasFeature = function hasFeature(feature) {
    return this._features[feature];
  };

  _createClass(Device, [{
    key: "canvas",
    get: function get() {
      return this._canvas;
    }
  }, {
    key: "canvas2D",
    get: function get() {
      return this._canvas2D;
    }
  }, {
    key: "gfxAPI",
    get: function get() {
      return this._gfxAPI;
    }
  }, {
    key: "queue",
    get: function get() {
      return this._queue;
    }
  }, {
    key: "commandBuffer",
    get: function get() {
      return this._cmdBuff;
    }
  }, {
    key: "devicePixelRatio",
    get: function get() {
      return this._devicePixelRatio;
    }
  }, {
    key: "width",
    get: function get() {
      return this._width;
    }
  }, {
    key: "height",
    get: function get() {
      return this._height;
    }
  }, {
    key: "renderer",
    get: function get() {
      return this._renderer;
    }
  }, {
    key: "vendor",
    get: function get() {
      return this._vendor;
    }
  }, {
    key: "colorFormat",
    get: function get() {
      return this._colorFmt;
    }
  }, {
    key: "depthStencilFormat",
    get: function get() {
      return this._depthStencilFmt;
    }
  }, {
    key: "numDrawCalls",
    get: function get() {
      return this._numDrawCalls;
    }
  }, {
    key: "numInstances",
    get: function get() {
      return this._numInstances;
    }
  }, {
    key: "numTris",
    get: function get() {
      return this._numTris;
    }
  }, {
    key: "memoryStatus",
    get: function get() {
      return this._memoryStatus;
    }
  }, {
    key: "capabilities",
    get: function get() {
      return this._caps;
    }
  }, {
    key: "surfaceTransform",
    get: function get() {
      return this._transform;
    }
  }]);

  return Device;
}();

var Framebuffer = function (_Obj) {
  _inheritsLoose(Framebuffer, _Obj);

  _createClass(Framebuffer, [{
    key: "renderPass",
    get: function get() {
      return this._renderPass;
    }
  }, {
    key: "colorTextures",
    get: function get() {
      return this._colorTextures;
    }
  }, {
    key: "depthStencilTexture",
    get: function get() {
      return this._depthStencilTexture;
    }
  }]);

  function Framebuffer(device) {
    var _this;

    _this = _Obj.call(this, exports.ObjectType.FRAMEBUFFER) || this;
    _this._device = void 0;
    _this._renderPass = null;
    _this._colorTextures = [];
    _this._depthStencilTexture = null;
    _this._device = device;
    return _this;
  }

  return Framebuffer;
}(Obj);

var getUint8ForString = String.prototype.charCodeAt;

function getUint8ForArray(idx) {
  return this[idx];
}

function murmurhash2_32_gc(input, seed) {
  var l = input.length;
  var h = seed ^ l;
  var i = 0;
  var getUint8 = typeof input === 'string' ? getUint8ForString : getUint8ForArray;

  while (l >= 4) {
    var k = getUint8.call(input, i) & 0xff | (getUint8.call(input, ++i) & 0xff) << 8 | (getUint8.call(input, ++i) & 0xff) << 16 | (getUint8.call(input, ++i) & 0xff) << 24;
    k = (k & 0xffff) * 0x5bd1e995 + (((k >>> 16) * 0x5bd1e995 & 0xffff) << 16);
    k ^= k >>> 24;
    k = (k & 0xffff) * 0x5bd1e995 + (((k >>> 16) * 0x5bd1e995 & 0xffff) << 16);
    h = (h & 0xffff) * 0x5bd1e995 + (((h >>> 16) * 0x5bd1e995 & 0xffff) << 16) ^ k;
    l -= 4;
    ++i;
  }

  switch (l) {
    case 3:
      h ^= (getUint8.call(input, i + 2) & 0xff) << 16;

    case 2:
      h ^= (getUint8.call(input, i + 1) & 0xff) << 8;

    case 1:
      h ^= getUint8.call(input, i) & 0xff;
      h = (h & 0xffff) * 0x5bd1e995 + (((h >>> 16) * 0x5bd1e995 & 0xffff) << 16);
  }

  h ^= h >>> 13;
  h = (h & 0xffff) * 0x5bd1e995 + (((h >>> 16) * 0x5bd1e995 & 0xffff) << 16);
  h ^= h >>> 15;
  return h >>> 0;
}

var InputAssembler = function (_Obj) {
  _inheritsLoose(InputAssembler, _Obj);

  _createClass(InputAssembler, [{
    key: "vertexBuffers",
    get: function get() {
      return this._vertexBuffers;
    }
  }, {
    key: "indexBuffer",
    get: function get() {
      return this._indexBuffer;
    }
  }, {
    key: "attributes",
    get: function get() {
      return this._attributes;
    }
  }, {
    key: "attributesHash",
    get: function get() {
      return this._attributesHash;
    }
  }, {
    key: "vertexCount",
    get: function get() {
      return this._vertexCount;
    },
    set: function set(count) {
      this._vertexCount = count;
    }
  }, {
    key: "firstVertex",
    get: function get() {
      return this._firstVertex;
    },
    set: function set(first) {
      this._firstVertex = first;
    }
  }, {
    key: "indexCount",
    get: function get() {
      return this._indexCount;
    },
    set: function set(count) {
      this._indexCount = count;
    }
  }, {
    key: "firstIndex",
    get: function get() {
      return this._firstIndex;
    },
    set: function set(first) {
      this._firstIndex = first;
    }
  }, {
    key: "vertexOffset",
    get: function get() {
      return this._vertexOffset;
    },
    set: function set(offset) {
      this._vertexOffset = offset;
    }
  }, {
    key: "instanceCount",
    get: function get() {
      return this._instanceCount;
    },
    set: function set(count) {
      this._instanceCount = count;
    }
  }, {
    key: "firstInstance",
    get: function get() {
      return this._firstInstance;
    },
    set: function set(first) {
      this._firstInstance = first;
    }
  }, {
    key: "indirectBuffer",
    get: function get() {
      return this._indirectBuffer;
    }
  }]);

  function InputAssembler(device) {
    var _this;

    _this = _Obj.call(this, exports.ObjectType.INPUT_ASSEMBLER) || this;
    _this._device = void 0;
    _this._attributes = [];
    _this._vertexBuffers = [];
    _this._indexBuffer = null;
    _this._vertexCount = 0;
    _this._firstVertex = 0;
    _this._indexCount = 0;
    _this._firstIndex = 0;
    _this._vertexOffset = 0;
    _this._instanceCount = 0;
    _this._firstInstance = 0;
    _this._attributesHash = 0;
    _this._indirectBuffer = null;
    _this._device = device;
    return _this;
  }

  var _proto = InputAssembler.prototype;

  _proto.getVertexBuffer = function getVertexBuffer(stream) {
    if (stream === void 0) {
      stream = 0;
    }

    if (stream < this._vertexBuffers.length) {
      return this._vertexBuffers[stream];
    } else {
      return null;
    }
  };

  _proto.computeAttributesHash = function computeAttributesHash() {
    var res = 'attrs';

    for (var i = 0; i < this.attributes.length; ++i) {
      var at = this.attributes[i];
      res += "," + at.name + "," + at.format + "," + at.isNormalized + "," + at.stream + "," + at.isInstanced;
    }

    return murmurhash2_32_gc(res, 666);
  };

  return InputAssembler;
}(Obj);

var DescriptorSet = function (_Obj) {
  _inheritsLoose(DescriptorSet, _Obj);

  _createClass(DescriptorSet, [{
    key: "layout",
    get: function get() {
      return this._layout;
    }
  }]);

  function DescriptorSet(device) {
    var _this;

    _this = _Obj.call(this, exports.ObjectType.DESCRIPTOR_SET) || this;
    _this._device = void 0;
    _this._layout = null;
    _this._buffers = [];
    _this._textures = [];
    _this._samplers = [];
    _this._isDirty = false;
    _this._device = device;
    return _this;
  }

  var _proto = DescriptorSet.prototype;

  _proto.bindBuffer = function bindBuffer(binding, buffer, index) {
    if (index === void 0) {
      index = 0;
    }

    var bindingIndex = this._layout.bindingIndices[binding];
    var info = this._layout.bindings[bindingIndex];

    if (!info) {
      return;
    }

    if (info.descriptorType & DESCRIPTOR_BUFFER_TYPE) {
      var descriptorIndex = this._layout.descriptorIndices[binding];

      if (this._buffers[descriptorIndex + index] !== buffer) {
        this._buffers[descriptorIndex + index] = buffer;
        this._isDirty = true;
      }
    }
  };

  _proto.bindSampler = function bindSampler(binding, sampler, index) {
    if (index === void 0) {
      index = 0;
    }

    var bindingIndex = this._layout.bindingIndices[binding];
    var info = this._layout.bindings[bindingIndex];

    if (!info) {
      return;
    }

    if (info.descriptorType & DESCRIPTOR_SAMPLER_TYPE) {
      var descriptorIndex = this._layout.descriptorIndices[binding];

      if (this._samplers[descriptorIndex + index] !== sampler) {
        this._samplers[descriptorIndex + index] = sampler;
        this._isDirty = true;
      }
    }
  };

  _proto.bindTexture = function bindTexture(binding, texture, index) {
    if (index === void 0) {
      index = 0;
    }

    var bindingIndex = this._layout.bindingIndices[binding];
    var info = this._layout.bindings[bindingIndex];

    if (!info) {
      return;
    }

    if (info.descriptorType & DESCRIPTOR_SAMPLER_TYPE) {
      var descriptorIndex = this._layout.descriptorIndices[binding];

      if (this._textures[descriptorIndex + index] !== texture) {
        this._textures[descriptorIndex + index] = texture;
        this._isDirty = true;
      }
    }
  };

  _proto.getBuffer = function getBuffer(binding, index) {
    if (index === void 0) {
      index = 0;
    }

    var descriptorIndex = this._layout.descriptorIndices[binding];
    return this._buffers[descriptorIndex + index];
  };

  _proto.getSampler = function getSampler(binding, index) {
    if (index === void 0) {
      index = 0;
    }

    var descriptorIndex = this._layout.descriptorIndices[binding];
    return this._samplers[descriptorIndex + index];
  };

  _proto.getTexture = function getTexture(binding, index) {
    if (index === void 0) {
      index = 0;
    }

    var descriptorIndex = this._layout.descriptorIndices[binding];
    return this._textures[descriptorIndex + index];
  };

  return DescriptorSet;
}(Obj);

var DescriptorSetLayout = function (_Obj) {
  _inheritsLoose(DescriptorSetLayout, _Obj);

  _createClass(DescriptorSetLayout, [{
    key: "bindings",
    get: function get() {
      return this._bindings;
    }
  }, {
    key: "bindingIndices",
    get: function get() {
      return this._bindingIndices;
    }
  }, {
    key: "descriptorIndices",
    get: function get() {
      return this._descriptorIndices;
    }
  }]);

  function DescriptorSetLayout(device) {
    var _this;

    _this = _Obj.call(this, exports.ObjectType.DESCRIPTOR_SET_LAYOUT) || this;
    _this._device = void 0;
    _this._bindings = [];
    _this._bindingIndices = [];
    _this._descriptorIndices = [];
    _this._device = device;
    return _this;
  }

  return DescriptorSetLayout;
}(Obj);

var PipelineLayout = function (_Obj) {
  _inheritsLoose(PipelineLayout, _Obj);

  _createClass(PipelineLayout, [{
    key: "setLayouts",
    get: function get() {
      return this._setLayouts;
    }
  }]);

  function PipelineLayout(device) {
    var _this;

    _this = _Obj.call(this, exports.ObjectType.PIPELINE_LAYOUT) || this;
    _this._device = void 0;
    _this._setLayouts = [];
    _this._device = device;
    return _this;
  }

  return PipelineLayout;
}(Obj);

var RasterizerState = function () {
  _createClass(RasterizerState, [{
    key: "native",
    get: function get() {
      return this;
    }
  }]);

  function RasterizerState(isDiscard, polygonMode, shadeModel, cullMode, isFrontFaceCCW, depthBiasEnabled, depthBias, depthBiasClamp, depthBiasSlop, isDepthClip, isMultisample, lineWidth) {
    if (isDiscard === void 0) {
      isDiscard = false;
    }

    if (polygonMode === void 0) {
      polygonMode = exports.PolygonMode.FILL;
    }

    if (shadeModel === void 0) {
      shadeModel = exports.ShadeModel.GOURAND;
    }

    if (cullMode === void 0) {
      cullMode = exports.CullMode.BACK;
    }

    if (isFrontFaceCCW === void 0) {
      isFrontFaceCCW = true;
    }

    if (depthBiasEnabled === void 0) {
      depthBiasEnabled = false;
    }

    if (depthBias === void 0) {
      depthBias = 0;
    }

    if (depthBiasClamp === void 0) {
      depthBiasClamp = 0.0;
    }

    if (depthBiasSlop === void 0) {
      depthBiasSlop = 0.0;
    }

    if (isDepthClip === void 0) {
      isDepthClip = true;
    }

    if (isMultisample === void 0) {
      isMultisample = false;
    }

    if (lineWidth === void 0) {
      lineWidth = 1.0;
    }

    this.isDiscard = isDiscard;
    this.polygonMode = polygonMode;
    this.shadeModel = shadeModel;
    this.cullMode = cullMode;
    this.isFrontFaceCCW = isFrontFaceCCW;
    this.depthBiasEnabled = depthBiasEnabled;
    this.depthBias = depthBias;
    this.depthBiasClamp = depthBiasClamp;
    this.depthBiasSlop = depthBiasSlop;
    this.isDepthClip = isDepthClip;
    this.isMultisample = isMultisample;
    this.lineWidth = lineWidth;
  }

  var _proto = RasterizerState.prototype;

  _proto.reset = function reset() {
    this.isDiscard = false;
    this.polygonMode = exports.PolygonMode.FILL;
    this.shadeModel = exports.ShadeModel.GOURAND;
    this.cullMode = exports.CullMode.BACK;
    this.isFrontFaceCCW = true;
    this.depthBiasEnabled = false;
    this.depthBias = 0;
    this.depthBiasClamp = 0.0;
    this.depthBiasSlop = 0.0;
    this.isDepthClip = true;
    this.isMultisample = false;
    this.lineWidth = 1.0;
  };

  _proto.assign = function assign(rs) {
    Object.assign(this, rs);
  };

  _proto.destroy = function destroy() {};

  return RasterizerState;
}();
var DepthStencilState = function () {
  _createClass(DepthStencilState, [{
    key: "native",
    get: function get() {
      return this;
    }
  }]);

  function DepthStencilState(depthTest, depthWrite, depthFunc, stencilTestFront, stencilFuncFront, stencilReadMaskFront, stencilWriteMaskFront, stencilFailOpFront, stencilZFailOpFront, stencilPassOpFront, stencilRefFront, stencilTestBack, stencilFuncBack, stencilReadMaskBack, stencilWriteMaskBack, stencilFailOpBack, stencilZFailOpBack, stencilPassOpBack, stencilRefBack) {
    if (depthTest === void 0) {
      depthTest = true;
    }

    if (depthWrite === void 0) {
      depthWrite = true;
    }

    if (depthFunc === void 0) {
      depthFunc = exports.ComparisonFunc.LESS;
    }

    if (stencilTestFront === void 0) {
      stencilTestFront = false;
    }

    if (stencilFuncFront === void 0) {
      stencilFuncFront = exports.ComparisonFunc.ALWAYS;
    }

    if (stencilReadMaskFront === void 0) {
      stencilReadMaskFront = 0xffff;
    }

    if (stencilWriteMaskFront === void 0) {
      stencilWriteMaskFront = 0xffff;
    }

    if (stencilFailOpFront === void 0) {
      stencilFailOpFront = exports.StencilOp.KEEP;
    }

    if (stencilZFailOpFront === void 0) {
      stencilZFailOpFront = exports.StencilOp.KEEP;
    }

    if (stencilPassOpFront === void 0) {
      stencilPassOpFront = exports.StencilOp.KEEP;
    }

    if (stencilRefFront === void 0) {
      stencilRefFront = 1;
    }

    if (stencilTestBack === void 0) {
      stencilTestBack = false;
    }

    if (stencilFuncBack === void 0) {
      stencilFuncBack = exports.ComparisonFunc.ALWAYS;
    }

    if (stencilReadMaskBack === void 0) {
      stencilReadMaskBack = 0xffff;
    }

    if (stencilWriteMaskBack === void 0) {
      stencilWriteMaskBack = 0xffff;
    }

    if (stencilFailOpBack === void 0) {
      stencilFailOpBack = exports.StencilOp.KEEP;
    }

    if (stencilZFailOpBack === void 0) {
      stencilZFailOpBack = exports.StencilOp.KEEP;
    }

    if (stencilPassOpBack === void 0) {
      stencilPassOpBack = exports.StencilOp.KEEP;
    }

    if (stencilRefBack === void 0) {
      stencilRefBack = 1;
    }

    this.depthTest = depthTest;
    this.depthWrite = depthWrite;
    this.depthFunc = depthFunc;
    this.stencilTestFront = stencilTestFront;
    this.stencilFuncFront = stencilFuncFront;
    this.stencilReadMaskFront = stencilReadMaskFront;
    this.stencilWriteMaskFront = stencilWriteMaskFront;
    this.stencilFailOpFront = stencilFailOpFront;
    this.stencilZFailOpFront = stencilZFailOpFront;
    this.stencilPassOpFront = stencilPassOpFront;
    this.stencilRefFront = stencilRefFront;
    this.stencilTestBack = stencilTestBack;
    this.stencilFuncBack = stencilFuncBack;
    this.stencilReadMaskBack = stencilReadMaskBack;
    this.stencilWriteMaskBack = stencilWriteMaskBack;
    this.stencilFailOpBack = stencilFailOpBack;
    this.stencilZFailOpBack = stencilZFailOpBack;
    this.stencilPassOpBack = stencilPassOpBack;
    this.stencilRefBack = stencilRefBack;
  }

  var _proto2 = DepthStencilState.prototype;

  _proto2.reset = function reset() {
    this.depthTest = true;
    this.depthWrite = true;
    this.depthFunc = exports.ComparisonFunc.LESS;
    this.stencilTestFront = false;
    this.stencilFuncFront = exports.ComparisonFunc.ALWAYS;
    this.stencilReadMaskFront = 0xffff;
    this.stencilWriteMaskFront = 0xffff;
    this.stencilFailOpFront = exports.StencilOp.KEEP;
    this.stencilZFailOpFront = exports.StencilOp.KEEP;
    this.stencilPassOpFront = exports.StencilOp.KEEP;
    this.stencilRefFront = 1;
    this.stencilTestBack = false;
    this.stencilFuncBack = exports.ComparisonFunc.ALWAYS;
    this.stencilReadMaskBack = 0xffff;
    this.stencilWriteMaskBack = 0xffff;
    this.stencilFailOpBack = exports.StencilOp.KEEP;
    this.stencilZFailOpBack = exports.StencilOp.KEEP;
    this.stencilPassOpBack = exports.StencilOp.KEEP;
    this.stencilRefBack = 1;
  };

  _proto2.assign = function assign(dss) {
    Object.assign(this, dss);
  };

  _proto2.destroy = function destroy() {};

  return DepthStencilState;
}();
var BlendTarget = function () {
  function BlendTarget(blend, blendSrc, blendDst, blendEq, blendSrcAlpha, blendDstAlpha, blendAlphaEq, blendColorMask) {
    if (blend === void 0) {
      blend = false;
    }

    if (blendSrc === void 0) {
      blendSrc = exports.BlendFactor.ONE;
    }

    if (blendDst === void 0) {
      blendDst = exports.BlendFactor.ZERO;
    }

    if (blendEq === void 0) {
      blendEq = exports.BlendOp.ADD;
    }

    if (blendSrcAlpha === void 0) {
      blendSrcAlpha = exports.BlendFactor.ONE;
    }

    if (blendDstAlpha === void 0) {
      blendDstAlpha = exports.BlendFactor.ZERO;
    }

    if (blendAlphaEq === void 0) {
      blendAlphaEq = exports.BlendOp.ADD;
    }

    if (blendColorMask === void 0) {
      blendColorMask = exports.ColorMask.ALL;
    }

    this.blend = blend;
    this.blendSrc = blendSrc;
    this.blendDst = blendDst;
    this.blendEq = blendEq;
    this.blendSrcAlpha = blendSrcAlpha;
    this.blendDstAlpha = blendDstAlpha;
    this.blendAlphaEq = blendAlphaEq;
    this.blendColorMask = blendColorMask;
  }

  var _proto3 = BlendTarget.prototype;

  _proto3.reset = function reset() {
    this.blend = false;
    this.blendSrc = exports.BlendFactor.ONE;
    this.blendDst = exports.BlendFactor.ZERO;
    this.blendEq = exports.BlendOp.ADD;
    this.blendSrcAlpha = exports.BlendFactor.ONE;
    this.blendDstAlpha = exports.BlendFactor.ZERO;
    this.blendAlphaEq = exports.BlendOp.ADD;
    this.blendColorMask = exports.ColorMask.ALL;
  };

  _proto3.assign = function assign(target) {
    Object.assign(this, target);
  };

  _proto3.destroy = function destroy() {};

  return BlendTarget;
}();
var BlendState = function () {
  _createClass(BlendState, [{
    key: "native",
    get: function get() {
      return this;
    }
  }]);

  function BlendState(isA2C, isIndepend, blendColor, targets) {
    if (isA2C === void 0) {
      isA2C = false;
    }

    if (isIndepend === void 0) {
      isIndepend = false;
    }

    if (blendColor === void 0) {
      blendColor = new Color$1();
    }

    if (targets === void 0) {
      targets = [new BlendTarget()];
    }

    this.isA2C = isA2C;
    this.isIndepend = isIndepend;
    this.blendColor = blendColor;
    this.targets = targets;
  }

  var _proto4 = BlendState.prototype;

  _proto4.setTarget = function setTarget(index, target) {
    var tg = this.targets[index];

    if (!tg) {
      tg = this.targets[index] = new BlendTarget();
    }

    Object.assign(tg, target);
  };

  _proto4.reset = function reset() {
    this.isA2C = false;
    this.isIndepend = false;
    this.blendColor.x = 0;
    this.blendColor.y = 0;
    this.blendColor.z = 0;
    this.blendColor.w = 0;
    this.targets.length = 1;
    this.targets[0].reset();
  };

  _proto4.destroy = function destroy() {};

  return BlendState;
}();
var PipelineStateInfo = function PipelineStateInfo(shader, pipelineLayout, renderPass, inputState, rasterizerState, depthStencilState, blendState, primitive, dynamicStates, bindPoint) {
  if (shader === void 0) {
    shader = null;
  }

  if (pipelineLayout === void 0) {
    pipelineLayout = null;
  }

  if (renderPass === void 0) {
    renderPass = null;
  }

  if (inputState === void 0) {
    inputState = new InputState();
  }

  if (rasterizerState === void 0) {
    rasterizerState = new RasterizerState();
  }

  if (depthStencilState === void 0) {
    depthStencilState = new DepthStencilState();
  }

  if (blendState === void 0) {
    blendState = new BlendState();
  }

  if (primitive === void 0) {
    primitive = exports.PrimitiveMode.TRIANGLE_LIST;
  }

  if (dynamicStates === void 0) {
    dynamicStates = exports.DynamicStateFlagBit.NONE;
  }

  if (bindPoint === void 0) {
    bindPoint = exports.PipelineBindPoint.GRAPHICS;
  }

  this.shader = shader;
  this.pipelineLayout = pipelineLayout;
  this.renderPass = renderPass;
  this.inputState = inputState;
  this.rasterizerState = rasterizerState;
  this.depthStencilState = depthStencilState;
  this.blendState = blendState;
  this.primitive = primitive;
  this.dynamicStates = dynamicStates;
  this.bindPoint = bindPoint;
};
var PipelineState = function (_Obj) {
  _inheritsLoose(PipelineState, _Obj);

  _createClass(PipelineState, [{
    key: "shader",
    get: function get() {
      return this._shader;
    }
  }, {
    key: "pipelineLayout",
    get: function get() {
      return this._pipelineLayout;
    }
  }, {
    key: "primitive",
    get: function get() {
      return this._primitive;
    }
  }, {
    key: "rasterizerState",
    get: function get() {
      return this._rs;
    }
  }, {
    key: "depthStencilState",
    get: function get() {
      return this._dss;
    }
  }, {
    key: "blendState",
    get: function get() {
      return this._bs;
    }
  }, {
    key: "inputState",
    get: function get() {
      return this._is;
    }
  }, {
    key: "dynamicStates",
    get: function get() {
      return this._dynamicStates;
    }
  }, {
    key: "renderPass",
    get: function get() {
      return this._renderPass;
    }
  }]);

  function PipelineState(device) {
    var _this;

    _this = _Obj.call(this, exports.ObjectType.PIPELINE_STATE) || this;
    _this._device = void 0;
    _this._shader = null;
    _this._pipelineLayout = null;
    _this._primitive = exports.PrimitiveMode.TRIANGLE_LIST;
    _this._is = null;
    _this._rs = new RasterizerState();
    _this._dss = new DepthStencilState();
    _this._bs = new BlendState();
    _this._dynamicStates = exports.DynamicStateFlagBit.NONE;
    _this._renderPass = null;
    _this._device = device;
    return _this;
  }

  return PipelineState;
}(Obj);

var Queue = function (_Obj) {
  _inheritsLoose(Queue, _Obj);

  _createClass(Queue, [{
    key: "type",
    get: function get() {
      return this._type;
    }
  }]);

  function Queue(device) {
    var _this;

    _this = _Obj.call(this, exports.ObjectType.QUEUE) || this;
    _this._device = void 0;
    _this._type = exports.QueueType.GRAPHICS;
    _this._isAsync = false;
    _this._device = device;
    return _this;
  }

  var _proto = Queue.prototype;

  _proto.isAsync = function isAsync() {
    return this._isAsync;
  };

  return Queue;
}(Obj);

var RenderPass = function (_Obj) {
  _inheritsLoose(RenderPass, _Obj);

  _createClass(RenderPass, [{
    key: "colorAttachments",
    get: function get() {
      return this._colorInfos;
    }
  }, {
    key: "depthStencilAttachment",
    get: function get() {
      return this._depthStencilInfo;
    }
  }, {
    key: "subPasses",
    get: function get() {
      return this._subpasses;
    }
  }, {
    key: "hash",
    get: function get() {
      return this._hash;
    }
  }]);

  function RenderPass(device) {
    var _this;

    _this = _Obj.call(this, exports.ObjectType.RENDER_PASS) || this;
    _this._device = void 0;
    _this._colorInfos = [];
    _this._depthStencilInfo = null;
    _this._subpasses = [];
    _this._hash = 0;
    _this._device = device;
    return _this;
  }

  var _proto = RenderPass.prototype;

  _proto.computeHash = function computeHash() {
    var res = '';

    if (this._subpasses.length) {
      for (var i = 0; i < this._subpasses.length; ++i) {
        var subpass = this._subpasses[i];

        if (subpass.inputs.length) {
          res += 'ia';

          for (var j = 0; j < subpass.inputs.length; ++j) {
            var ia = this._colorInfos[subpass.inputs[j]];
            res += "," + ia.format + "," + ia.sampleCount;
          }
        }

        if (subpass.colors.length) {
          res += 'ca';

          for (var _j = 0; _j < subpass.inputs.length; ++_j) {
            var ca = this._colorInfos[subpass.inputs[_j]];
            res += "," + ca.format + "," + ca.sampleCount;
          }
        }

        if (subpass.depthStencil >= 0) {
          var ds = this._colorInfos[subpass.depthStencil];
          res += "ds," + ds.format + "," + ds.sampleCount;
        }
      }
    } else {
      res += 'ca';

      for (var _i = 0; _i < this._colorInfos.length; ++_i) {
        var _ca = this._colorInfos[_i];
        res += "," + _ca.format + "," + _ca.sampleCount;
      }

      var _ds = this._depthStencilInfo;

      if (_ds) {
        res += "ds," + _ds.format + "," + _ds.sampleCount;
      }
    }

    return murmurhash2_32_gc(res, 666);
  };

  return RenderPass;
}(Obj);

var Sampler = function (_Obj) {
  _inheritsLoose(Sampler, _Obj);

  _createClass(Sampler, [{
    key: "minFilter",
    get: function get() {
      return this._minFilter;
    }
  }, {
    key: "magFilter",
    get: function get() {
      return this._magFilter;
    }
  }, {
    key: "mipFilter",
    get: function get() {
      return this._mipFilter;
    }
  }, {
    key: "addressU",
    get: function get() {
      return this._addressU;
    }
  }, {
    key: "addressV",
    get: function get() {
      return this._addressV;
    }
  }, {
    key: "addressW",
    get: function get() {
      return this._addressW;
    }
  }, {
    key: "maxAnisotropy",
    get: function get() {
      return this._maxAnisotropy;
    }
  }, {
    key: "cmpFunc",
    get: function get() {
      return this._cmpFunc;
    }
  }, {
    key: "borderColor",
    get: function get() {
      return this._borderColor;
    }
  }, {
    key: "mipLODBias",
    get: function get() {
      return this._mipLODBias;
    }
  }]);

  function Sampler(device) {
    var _this;

    _this = _Obj.call(this, exports.ObjectType.SAMPLER) || this;
    _this._device = void 0;
    _this._minFilter = exports.Filter.LINEAR;
    _this._magFilter = exports.Filter.LINEAR;
    _this._mipFilter = exports.Filter.NONE;
    _this._addressU = exports.Address.WRAP;
    _this._addressV = exports.Address.WRAP;
    _this._addressW = exports.Address.WRAP;
    _this._maxAnisotropy = 16;
    _this._cmpFunc = exports.ComparisonFunc.NEVER;
    _this._borderColor = new Color$1();
    _this._mipLODBias = 0.0;
    _this._device = device;
    return _this;
  }

  return Sampler;
}(Obj);

var Shader = function (_Obj) {
  _inheritsLoose(Shader, _Obj);

  _createClass(Shader, [{
    key: "id",
    get: function get() {
      return this._id;
    }
  }, {
    key: "name",
    get: function get() {
      return this._name;
    }
  }, {
    key: "attributes",
    get: function get() {
      return this._attributes;
    }
  }, {
    key: "blocks",
    get: function get() {
      return this._blocks;
    }
  }, {
    key: "samplers",
    get: function get() {
      return this._samplers;
    }
  }]);

  function Shader(device) {
    var _this;

    _this = _Obj.call(this, exports.ObjectType.SHADER) || this;
    _this._device = void 0;
    _this._id = void 0;
    _this._name = '';
    _this._stages = [];
    _this._attributes = [];
    _this._blocks = [];
    _this._samplers = [];
    _this._device = device;
    _this._id = Shader._shaderIdGen++;
    return _this;
  }

  return Shader;
}(Obj);
Shader._shaderIdGen = 0;

var Texture = function (_Obj) {
  _inheritsLoose(Texture, _Obj);

  _createClass(Texture, [{
    key: "type",
    get: function get() {
      return this._type;
    }
  }, {
    key: "usage",
    get: function get() {
      return this._usage;
    }
  }, {
    key: "format",
    get: function get() {
      return this._format;
    }
  }, {
    key: "width",
    get: function get() {
      return this._width;
    }
  }, {
    key: "height",
    get: function get() {
      return this._height;
    }
  }, {
    key: "depth",
    get: function get() {
      return this._depth;
    }
  }, {
    key: "layerCount",
    get: function get() {
      return this._layerCount;
    }
  }, {
    key: "levelCount",
    get: function get() {
      return this._levelCount;
    }
  }, {
    key: "samples",
    get: function get() {
      return this._samples;
    }
  }, {
    key: "flags",
    get: function get() {
      return this._flags;
    }
  }, {
    key: "size",
    get: function get() {
      return this._size;
    }
  }]);

  function Texture(device) {
    var _this;

    _this = _Obj.call(this, exports.ObjectType.TEXTURE) || this;
    _this._device = void 0;
    _this._type = exports.TextureType.TEX2D;
    _this._usage = exports.TextureUsageBit.NONE;
    _this._format = exports.Format.UNKNOWN;
    _this._width = 0;
    _this._height = 0;
    _this._depth = 1;
    _this._layerCount = 1;
    _this._levelCount = 1;
    _this._samples = exports.SampleCount.X1;
    _this._flags = exports.TextureFlagBit.NONE;
    _this._isPowerOf2 = false;
    _this._size = 0;
    _this._device = device;
    return _this;
  }

  return Texture;
}(Obj);

var GlobalBarrier = function (_Obj) {
  _inheritsLoose(GlobalBarrier, _Obj);

  function GlobalBarrier(device) {
    var _this;

    _this = _Obj.call(this, exports.ObjectType.GLOBAL_BARRIER) || this;
    _this._device = void 0;
    _this._info = new GlobalBarrierInfo();
    _this._device = device;
    return _this;
  }

  var _proto = GlobalBarrier.prototype;

  _proto.initialize = function initialize(info) {
    this._info.copy(info);

    return true;
  };

  return GlobalBarrier;
}(Obj);

var TextureBarrier = function (_Obj) {
  _inheritsLoose(TextureBarrier, _Obj);

  function TextureBarrier(device) {
    var _this;

    _this = _Obj.call(this, exports.ObjectType.TEXTURE_BARRIER) || this;
    _this._device = void 0;
    _this._info = new TextureBarrierInfo();
    _this._device = device;
    return _this;
  }

  var _proto = TextureBarrier.prototype;

  _proto.initialize = function initialize(info) {
    this._info.copy(info);

    return true;
  };

  return TextureBarrier;
}(Obj);

var polyfills = {
  Device: Device,
  Buffer: Buffer,
  Texture: Texture,
  Sampler: Sampler,
  Shader: Shader,
  InputAssembler: InputAssembler,
  RenderPass: RenderPass,
  Framebuffer: Framebuffer,
  DescriptorSet: DescriptorSet,
  DescriptorSetLayout: DescriptorSetLayout,
  PipelineLayout: PipelineLayout,
  PipelineState: PipelineState,
  CommandBuffer: CommandBuffer,
  Queue: Queue,
  GlobalBarrier: GlobalBarrier,
  TextureBarrier: TextureBarrier,
  RasterizerState: RasterizerState,
  BlendState: BlendState,
  BlendTarget: BlendTarget,
  DepthStencilState: DepthStencilState,
  PipelineStateInfo: PipelineStateInfo
};
Object.assign(polyfills, defines);
legacyCC.gfx = polyfills;

var customMappings = {
  Obj: 'GFXObject',
  DRAW_INFO_SIZE: 'GFX_DRAW_INFO_SIZE',
  DESCRIPTOR_BUFFER_TYPE: '',
  DESCRIPTOR_SAMPLER_TYPE: '',
  DESCRIPTOR_DYNAMIC_TYPE: '',
  getTypedArrayConstructor: ''
};

for (var api in legacyCC.gfx) {
  if (api === '__esModule') continue;
  var deprecated = customMappings[api];

  if (deprecated === '') {
    deprecated = api;
  } else if (deprecated === undefined) {
    deprecated = "GFX" + api;
  }

  exports.replaceProperty(legacyCC, 'cc', [{
    name: deprecated,
    newName: api,
    target: legacyCC.gfx,
    targetName: 'cc.gfx'
  }]);
}

(function (ERaycastMode) {
  ERaycastMode[ERaycastMode["ALL"] = 0] = "ALL";
  ERaycastMode[ERaycastMode["CLOSEST"] = 1] = "CLOSEST";
  ERaycastMode[ERaycastMode["ANY"] = 2] = "ANY";
})(exports.ERaycastMode || (exports.ERaycastMode = {}));

var rayPlane = function () {
  var pt = new Vec3(0, 0, 0);
  return function (ray, plane) {
    var denom = Vec3.dot(ray.d, plane.n);

    if (Math.abs(denom) < Number.EPSILON) {
      return 0;
    }

    Vec3.multiplyScalar(pt, plane.n, plane.d);
    var t = Vec3.dot(Vec3.subtract(pt, pt, ray.o), plane.n) / denom;

    if (t < 0) {
      return 0;
    }

    return t;
  };
}();

var rayTriangle = function () {
  var ab = new Vec3(0, 0, 0);
  var ac = new Vec3(0, 0, 0);
  var pvec = new Vec3(0, 0, 0);
  var tvec = new Vec3(0, 0, 0);
  var qvec = new Vec3(0, 0, 0);
  return function (ray, triangle, doubleSided) {
    Vec3.subtract(ab, triangle.b, triangle.a);
    Vec3.subtract(ac, triangle.c, triangle.a);
    Vec3.cross(pvec, ray.d, ac);
    var det = Vec3.dot(ab, pvec);

    if (det < Number.EPSILON && (!doubleSided || det > -Number.EPSILON)) {
      return 0;
    }

    var inv_det = 1 / det;
    Vec3.subtract(tvec, ray.o, triangle.a);
    var u = Vec3.dot(tvec, pvec) * inv_det;

    if (u < 0 || u > 1) {
      return 0;
    }

    Vec3.cross(qvec, tvec, ab);
    var v = Vec3.dot(ray.d, qvec) * inv_det;

    if (v < 0 || u + v > 1) {
      return 0;
    }

    var t = Vec3.dot(ac, qvec) * inv_det;
    return t < 0 ? 0 : t;
  };
}();

var raySphere = function () {
  var e = new Vec3(0, 0, 0);
  return function (ray, sphere) {
    var r = sphere.radius;
    var c = sphere.center;
    var o = ray.o;
    var d = ray.d;
    var rSq = r * r;
    Vec3.subtract(e, c, o);
    var eSq = e.lengthSqr();
    var aLength = Vec3.dot(e, d);
    var fSq = rSq - (eSq - aLength * aLength);

    if (fSq < 0) {
      return 0;
    }

    var f = Math.sqrt(fSq);
    var t = eSq < rSq ? aLength + f : aLength - f;

    if (t < 0) {
      return 0;
    }

    return t;
  };
}();

var rayAABB = function () {
  var min = new Vec3();
  var max = new Vec3();
  return function (ray, aabb) {
    Vec3.subtract(min, aabb.center, aabb.halfExtents);
    Vec3.add(max, aabb.center, aabb.halfExtents);
    return rayAABB2(ray, min, max);
  };
}();

function rayAABB2(ray, min, max) {
  var o = ray.o;
  var d = ray.d;
  var ix = 1 / d.x;
  var iy = 1 / d.y;
  var iz = 1 / d.z;
  var t1 = (min.x - o.x) * ix;
  var t2 = (max.x - o.x) * ix;
  var t3 = (min.y - o.y) * iy;
  var t4 = (max.y - o.y) * iy;
  var t5 = (min.z - o.z) * iz;
  var t6 = (max.z - o.z) * iz;
  var tmin = Math.max(Math.max(Math.min(t1, t2), Math.min(t3, t4)), Math.min(t5, t6));
  var tmax = Math.min(Math.min(Math.max(t1, t2), Math.max(t3, t4)), Math.max(t5, t6));

  if (tmax < 0 || tmin > tmax) {
    return 0;
  }

  return tmin > 0 ? tmin : tmax;
}

var rayOBB = function () {
  var center = new Vec3();
  var o = new Vec3();
  var d = new Vec3();
  var X = new Vec3();
  var Y = new Vec3();
  var Z = new Vec3();
  var p = new Vec3();
  var size = new Array(3);
  var f = new Array(3);
  var e = new Array(3);
  var t = new Array(6);
  return function (ray, obb) {
    size[0] = obb.halfExtents.x;
    size[1] = obb.halfExtents.y;
    size[2] = obb.halfExtents.z;
    center = obb.center;
    o = ray.o;
    d = ray.d;
    Vec3.set(X, obb.orientation.m00, obb.orientation.m01, obb.orientation.m02);
    Vec3.set(Y, obb.orientation.m03, obb.orientation.m04, obb.orientation.m05);
    Vec3.set(Z, obb.orientation.m06, obb.orientation.m07, obb.orientation.m08);
    Vec3.subtract(p, center, o);
    f[0] = Vec3.dot(X, d);
    f[1] = Vec3.dot(Y, d);
    f[2] = Vec3.dot(Z, d);
    e[0] = Vec3.dot(X, p);
    e[1] = Vec3.dot(Y, p);
    e[2] = Vec3.dot(Z, p);

    for (var i = 0; i < 3; ++i) {
      if (f[i] === 0) {
        if (-e[i] - size[i] > 0 || -e[i] + size[i] < 0) {
          return 0;
        }

        f[i] = 0.0000001;
      }

      t[i * 2 + 0] = (e[i] + size[i]) / f[i];
      t[i * 2 + 1] = (e[i] - size[i]) / f[i];
    }

    var tmin = Math.max(Math.max(Math.min(t[0], t[1]), Math.min(t[2], t[3])), Math.min(t[4], t[5]));
    var tmax = Math.min(Math.min(Math.max(t[0], t[1]), Math.max(t[2], t[3])), Math.max(t[4], t[5]));

    if (tmax < 0 || tmin > tmax) {
      return 0;
    }

    return tmin > 0 ? tmin : tmax;
  };
}();

var rayCapsule = function () {
  var v3_0 = new Vec3();
  var v3_1 = new Vec3();
  var v3_2 = new Vec3();
  var v3_3 = new Vec3();
  var v3_4 = new Vec3();
  var v3_5 = new Vec3();
  var v3_6 = new Vec3();
  var sphere_0 = new Sphere();
  return function (ray, capsule) {
    var radiusSqr = capsule.radius * capsule.radius;
    var vRayNorm = Vec3.normalize(v3_0, ray.d);
    var A = capsule.ellipseCenter0;
    var B = capsule.ellipseCenter1;
    var BA = Vec3.subtract(v3_1, B, A);

    if (BA.equals(Vec3.ZERO)) {
      sphere_0.radius = capsule.radius;
      sphere_0.center.set(capsule.ellipseCenter0);
      return intersect.raySphere(ray, sphere_0);
    }

    var O = ray.o;
    var OA = Vec3.subtract(v3_2, O, A);
    var VxBA = Vec3.cross(v3_3, vRayNorm, BA);
    var a = VxBA.lengthSqr();

    if (a === 0) {
      sphere_0.radius = capsule.radius;
      var BO = Vec3.subtract(v3_4, B, O);

      if (OA.lengthSqr() < BO.lengthSqr()) {
        sphere_0.center.set(capsule.ellipseCenter0);
      } else {
        sphere_0.center.set(capsule.ellipseCenter1);
      }

      return intersect.raySphere(ray, sphere_0);
    }

    var OAxBA = Vec3.cross(v3_4, OA, BA);
    var ab2 = BA.lengthSqr();
    var b = 2 * Vec3.dot(VxBA, OAxBA);
    var c = OAxBA.lengthSqr() - radiusSqr * ab2;
    var d = b * b - 4 * a * c;

    if (d < 0) {
      return 0;
    }

    var t = (-b - Math.sqrt(d)) / (2 * a);

    if (t < 0) {
      sphere_0.radius = capsule.radius;

      var _BO = Vec3.subtract(v3_5, B, O);

      if (OA.lengthSqr() < _BO.lengthSqr()) {
        sphere_0.center.set(capsule.ellipseCenter0);
      } else {
        sphere_0.center.set(capsule.ellipseCenter1);
      }

      return intersect.raySphere(ray, sphere_0);
    } else {
      var iPos = Vec3.scaleAndAdd(v3_5, ray.o, vRayNorm, t);
      var iPosLen = Vec3.subtract(v3_6, iPos, A);
      var tLimit = Vec3.dot(iPosLen, BA) / ab2;

      if (tLimit >= 0 && tLimit <= 1) {
        return t;
      } else if (tLimit < 0) {
        sphere_0.radius = capsule.radius;
        sphere_0.center.set(capsule.ellipseCenter0);
        return intersect.raySphere(ray, sphere_0);
      } else if (tLimit > 1) {
        sphere_0.radius = capsule.radius;
        sphere_0.center.set(capsule.ellipseCenter1);
        return intersect.raySphere(ray, sphere_0);
      } else {
        return 0;
      }
    }
  };
}();

var raySubMesh = function () {
  var tri = Triangle.create();
  var deOpt = {
    distance: Infinity,
    doubleSided: false,
    mode: exports.ERaycastMode.ANY
  };
  var minDis = 0;

  var fillResult = function fillResult(m, d, i0, i1, i2, r) {
    if (m === exports.ERaycastMode.CLOSEST) {
      if (minDis > d || minDis === 0) {
        minDis = d;

        if (r) {
          if (r.length === 0) {
            r.push({
              distance: d,
              vertexIndex0: i0 / 3,
              vertexIndex1: i1 / 3,
              vertexIndex2: i2 / 3
            });
          } else {
            r[0].distance = d;
            r[0].vertexIndex0 = i0 / 3;
            r[0].vertexIndex1 = i1 / 3;
            r[0].vertexIndex2 = i2 / 3;
          }
        }
      }
    } else {
      minDis = d;
      if (r) r.push({
        distance: d,
        vertexIndex0: i0 / 3,
        vertexIndex1: i1 / 3,
        vertexIndex2: i2 / 3
      });
    }
  };

  var narrowphase = function narrowphase(vb, ib, pm, ray, opt) {
    if (pm === exports.PrimitiveMode.TRIANGLE_LIST) {
      var cnt = ib.length;

      for (var j = 0; j < cnt; j += 3) {
        var i0 = ib[j] * 3;
        var i1 = ib[j + 1] * 3;
        var i2 = ib[j + 2] * 3;
        Vec3.set(tri.a, vb[i0], vb[i0 + 1], vb[i0 + 2]);
        Vec3.set(tri.b, vb[i1], vb[i1 + 1], vb[i1 + 2]);
        Vec3.set(tri.c, vb[i2], vb[i2 + 1], vb[i2 + 2]);
        var dist = intersect.rayTriangle(ray, tri, opt.doubleSided);
        if (dist === 0 || dist > opt.distance) continue;
        fillResult(opt.mode, dist, i0, i1, i2, opt.result);
        if (opt.mode === exports.ERaycastMode.ANY) return dist;
      }
    } else if (pm === exports.PrimitiveMode.TRIANGLE_STRIP) {
      var _cnt = ib.length - 2;

      var rev = 0;

      for (var _j = 0; _j < _cnt; _j += 1) {
        var _i = ib[_j - rev] * 3;

        var _i2 = ib[_j + rev + 1] * 3;

        var _i3 = ib[_j + 2] * 3;

        Vec3.set(tri.a, vb[_i], vb[_i + 1], vb[_i + 2]);
        Vec3.set(tri.b, vb[_i2], vb[_i2 + 1], vb[_i2 + 2]);
        Vec3.set(tri.c, vb[_i3], vb[_i3 + 1], vb[_i3 + 2]);
        rev = ~rev;

        var _dist = intersect.rayTriangle(ray, tri, opt.doubleSided);

        if (_dist === 0 || _dist > opt.distance) continue;
        fillResult(opt.mode, _dist, _i, _i2, _i3, opt.result);
        if (opt.mode === exports.ERaycastMode.ANY) return _dist;
      }
    } else if (pm === exports.PrimitiveMode.TRIANGLE_FAN) {
      var _cnt2 = ib.length - 1;

      var _i4 = ib[0] * 3;

      Vec3.set(tri.a, vb[_i4], vb[_i4 + 1], vb[_i4 + 2]);

      for (var _j2 = 1; _j2 < _cnt2; _j2 += 1) {
        var _i5 = ib[_j2] * 3;

        var _i6 = ib[_j2 + 1] * 3;

        Vec3.set(tri.b, vb[_i5], vb[_i5 + 1], vb[_i5 + 2]);
        Vec3.set(tri.c, vb[_i6], vb[_i6 + 1], vb[_i6 + 2]);

        var _dist2 = intersect.rayTriangle(ray, tri, opt.doubleSided);

        if (_dist2 === 0 || _dist2 > opt.distance) continue;
        fillResult(opt.mode, _dist2, _i4, _i5, _i6, opt.result);
        if (opt.mode === exports.ERaycastMode.ANY) return _dist2;
      }
    }

    return minDis;
  };

  return function (ray, submesh, options) {
    minDis = 0;
    if (submesh.geometricInfo.positions.length === 0) return minDis;
    var opt = options === undefined ? deOpt : options;
    var min = submesh.geometricInfo.boundingBox.min;
    var max = submesh.geometricInfo.boundingBox.max;

    if (rayAABB2(ray, min, max)) {
      var pm = submesh.primitiveMode;
      var _submesh$geometricInf = submesh.geometricInfo,
          vb = _submesh$geometricInf.positions,
          ib = _submesh$geometricInf.indices;
      narrowphase(vb, ib, pm, ray, opt);
    }

    return minDis;
  };
}();

var rayMesh = function () {
  var minDis = 0;
  var deOpt = {
    distance: Infinity,
    doubleSided: false,
    mode: exports.ERaycastMode.ANY
  };
  return function (ray, mesh, options) {
    minDis = 0;
    var opt = options === undefined ? deOpt : options;
    var length = mesh.renderingSubMeshes.length;
    var min = mesh.struct.minPosition;
    var max = mesh.struct.maxPosition;
    if (min && max && !rayAABB2(ray, min, max)) return minDis;

    for (var i = 0; i < length; i++) {
      var sm = mesh.renderingSubMeshes[i];
      var dis = raySubMesh(ray, sm, opt);

      if (dis) {
        if (opt.mode === exports.ERaycastMode.CLOSEST) {
          if (minDis === 0 || minDis > dis) {
            minDis = dis;
            if (opt.subIndices) opt.subIndices[0] = i;
          }
        } else {
          minDis = dis;
          if (opt.subIndices) opt.subIndices.push(i);

          if (opt.mode === exports.ERaycastMode.ANY) {
            return dis;
          }
        }
      }
    }

    if (minDis && opt.mode === exports.ERaycastMode.CLOSEST) {
      if (opt.result) {
        opt.result[0].distance = minDis;
        opt.result.length = 1;
      }

      if (opt.subIndices) opt.subIndices.length = 1;
    }

    return minDis;
  };
}();

var rayModel = function () {
  var minDis = 0;
  var deOpt = {
    distance: Infinity,
    doubleSided: false,
    mode: exports.ERaycastMode.ANY
  };
  var modelRay = new Ray();
  var m4 = new Mat4();
  return function (r, model, options) {
    minDis = 0;
    var opt = options === undefined ? deOpt : options;
    var wb = model.worldBounds;
    if (wb && !rayAABB(r, wb)) return minDis;
    Ray.copy(modelRay, r);

    if (model.node) {
      Mat4.invert(m4, model.node.getWorldMatrix(m4));
      Vec3.transformMat4(modelRay.o, r.o, m4);
      Vec3.transformMat4Normal(modelRay.d, r.d, m4);
    }

    var subModels = model.subModels;

    for (var i = 0; i < subModels.length; i++) {
      var subMesh = subModels[i].subMesh;
      var dis = raySubMesh(modelRay, subMesh, opt);

      if (dis) {
        if (opt.mode === exports.ERaycastMode.CLOSEST) {
          if (minDis === 0 || minDis > dis) {
            minDis = dis;
            if (opt.subIndices) opt.subIndices[0] = i;
          }
        } else {
          minDis = dis;
          if (opt.subIndices) opt.subIndices.push(i);

          if (opt.mode === exports.ERaycastMode.ANY) {
            return dis;
          }
        }
      }
    }

    if (minDis && opt.mode === exports.ERaycastMode.CLOSEST) {
      if (opt.result) {
        opt.result[0].distance = minDis;
        opt.result.length = 1;
      }

      if (opt.subIndices) opt.subIndices.length = 1;
    }

    return minDis;
  };
}();

var linePlane = function () {
  var ab = new Vec3(0, 0, 0);
  return function (line, plane) {
    Vec3.subtract(ab, line.e, line.s);
    var t = (plane.d - Vec3.dot(line.s, plane.n)) / Vec3.dot(ab, plane.n);

    if (t < 0 || t > 1) {
      return 0;
    }

    return t;
  };
}();

var lineTriangle = function () {
  var ab = new Vec3(0, 0, 0);
  var ac = new Vec3(0, 0, 0);
  var qp = new Vec3(0, 0, 0);
  var ap = new Vec3(0, 0, 0);
  var n = new Vec3(0, 0, 0);
  var e = new Vec3(0, 0, 0);
  return function (line, triangle, outPt) {
    Vec3.subtract(ab, triangle.b, triangle.a);
    Vec3.subtract(ac, triangle.c, triangle.a);
    Vec3.subtract(qp, line.s, line.e);
    Vec3.cross(n, ab, ac);
    var det = Vec3.dot(qp, n);

    if (det <= 0.0) {
      return 0;
    }

    Vec3.subtract(ap, line.s, triangle.a);
    var t = Vec3.dot(ap, n);

    if (t < 0 || t > det) {
      return 0;
    }

    Vec3.cross(e, qp, ap);
    var v = Vec3.dot(ac, e);

    if (v < 0 || v > det) {
      return 0;
    }

    var w = -Vec3.dot(ab, e);

    if (w < 0.0 || v + w > det) {
      return 0;
    }

    if (outPt) {
      var invDet = 1.0 / det;
      v *= invDet;
      w *= invDet;
      var u = 1.0 - v - w;
      Vec3.set(outPt, triangle.a.x * u + triangle.b.x * v + triangle.c.x * w, triangle.a.y * u + triangle.b.y * v + triangle.c.y * w, triangle.a.z * u + triangle.b.z * v + triangle.c.z * w);
    }

    return 1;
  };
}();

var r_t = new Ray();

function lineAABB(line, aabb) {
  r_t.o.set(line.s);
  Vec3.subtract(r_t.d, line.e, line.s);
  r_t.d.normalize();
  var min = rayAABB(r_t, aabb);
  var len = line.length();

  if (min <= len) {
    return min;
  } else {
    return 0;
  }
}

function lineOBB(line, obb) {
  r_t.o.set(line.s);
  Vec3.subtract(r_t.d, line.e, line.s);
  r_t.d.normalize();
  var min = rayOBB(r_t, obb);
  var len = line.length();

  if (min <= len) {
    return min;
  } else {
    return 0;
  }
}

function lineSphere(line, sphere) {
  r_t.o.set(line.s);
  Vec3.subtract(r_t.d, line.e, line.s);
  r_t.d.normalize();
  var min = raySphere(r_t, sphere);
  var len = line.length();

  if (min <= len) {
    return min;
  } else {
    return 0;
  }
}

var aabbWithAABB = function () {
  var aMin = new Vec3();
  var aMax = new Vec3();
  var bMin = new Vec3();
  var bMax = new Vec3();
  return function (aabb1, aabb2) {
    Vec3.subtract(aMin, aabb1.center, aabb1.halfExtents);
    Vec3.add(aMax, aabb1.center, aabb1.halfExtents);
    Vec3.subtract(bMin, aabb2.center, aabb2.halfExtents);
    Vec3.add(bMax, aabb2.center, aabb2.halfExtents);
    return aMin.x <= bMax.x && aMax.x >= bMin.x && aMin.y <= bMax.y && aMax.y >= bMin.y && aMin.z <= bMax.z && aMax.z >= bMin.z;
  };
}();

function getAABBVertices(min, max, out) {
  Vec3.set(out[0], min.x, max.y, max.z);
  Vec3.set(out[1], min.x, max.y, min.z);
  Vec3.set(out[2], min.x, min.y, max.z);
  Vec3.set(out[3], min.x, min.y, min.z);
  Vec3.set(out[4], max.x, max.y, max.z);
  Vec3.set(out[5], max.x, max.y, min.z);
  Vec3.set(out[6], max.x, min.y, max.z);
  Vec3.set(out[7], max.x, min.y, min.z);
}

function getOBBVertices(c, e, a1, a2, a3, out) {
  Vec3.set(out[0], c.x + a1.x * e.x + a2.x * e.y + a3.x * e.z, c.y + a1.y * e.x + a2.y * e.y + a3.y * e.z, c.z + a1.z * e.x + a2.z * e.y + a3.z * e.z);
  Vec3.set(out[1], c.x - a1.x * e.x + a2.x * e.y + a3.x * e.z, c.y - a1.y * e.x + a2.y * e.y + a3.y * e.z, c.z - a1.z * e.x + a2.z * e.y + a3.z * e.z);
  Vec3.set(out[2], c.x + a1.x * e.x - a2.x * e.y + a3.x * e.z, c.y + a1.y * e.x - a2.y * e.y + a3.y * e.z, c.z + a1.z * e.x - a2.z * e.y + a3.z * e.z);
  Vec3.set(out[3], c.x + a1.x * e.x + a2.x * e.y - a3.x * e.z, c.y + a1.y * e.x + a2.y * e.y - a3.y * e.z, c.z + a1.z * e.x + a2.z * e.y - a3.z * e.z);
  Vec3.set(out[4], c.x - a1.x * e.x - a2.x * e.y - a3.x * e.z, c.y - a1.y * e.x - a2.y * e.y - a3.y * e.z, c.z - a1.z * e.x - a2.z * e.y - a3.z * e.z);
  Vec3.set(out[5], c.x + a1.x * e.x - a2.x * e.y - a3.x * e.z, c.y + a1.y * e.x - a2.y * e.y - a3.y * e.z, c.z + a1.z * e.x - a2.z * e.y - a3.z * e.z);
  Vec3.set(out[6], c.x - a1.x * e.x + a2.x * e.y - a3.x * e.z, c.y - a1.y * e.x + a2.y * e.y - a3.y * e.z, c.z - a1.z * e.x + a2.z * e.y - a3.z * e.z);
  Vec3.set(out[7], c.x - a1.x * e.x - a2.x * e.y + a3.x * e.z, c.y - a1.y * e.x - a2.y * e.y + a3.y * e.z, c.z - a1.z * e.x - a2.z * e.y + a3.z * e.z);
}

function getInterval(vertices, axis) {
  var min = Vec3.dot(axis, vertices[0]);
  var max = min;

  for (var i = 1; i < 8; ++i) {
    var projection = Vec3.dot(axis, vertices[i]);
    min = projection < min ? projection : min;
    max = projection > max ? projection : max;
  }

  return [min, max];
}

var aabbWithOBB = function () {
  var test = new Array(15);

  for (var i = 0; i < 15; i++) {
    test[i] = new Vec3(0, 0, 0);
  }

  var vertices = new Array(8);
  var vertices2 = new Array(8);

  for (var _i7 = 0; _i7 < 8; _i7++) {
    vertices[_i7] = new Vec3(0, 0, 0);
    vertices2[_i7] = new Vec3(0, 0, 0);
  }

  var min = new Vec3();
  var max = new Vec3();
  return function (aabb, obb) {
    Vec3.set(test[0], 1, 0, 0);
    Vec3.set(test[1], 0, 1, 0);
    Vec3.set(test[2], 0, 0, 1);
    Vec3.set(test[3], obb.orientation.m00, obb.orientation.m01, obb.orientation.m02);
    Vec3.set(test[4], obb.orientation.m03, obb.orientation.m04, obb.orientation.m05);
    Vec3.set(test[5], obb.orientation.m06, obb.orientation.m07, obb.orientation.m08);

    for (var _i8 = 0; _i8 < 3; ++_i8) {
      Vec3.cross(test[6 + _i8 * 3 + 0], test[_i8], test[0]);
      Vec3.cross(test[6 + _i8 * 3 + 1], test[_i8], test[1]);
      Vec3.cross(test[6 + _i8 * 3 + 1], test[_i8], test[2]);
    }

    Vec3.subtract(min, aabb.center, aabb.halfExtents);
    Vec3.add(max, aabb.center, aabb.halfExtents);
    getAABBVertices(min, max, vertices);
    getOBBVertices(obb.center, obb.halfExtents, test[3], test[4], test[5], vertices2);

    for (var j = 0; j < 15; ++j) {
      var a = getInterval(vertices, test[j]);
      var b = getInterval(vertices2, test[j]);

      if (b[0] > a[1] || a[0] > b[1]) {
        return 0;
      }
    }

    return 1;
  };
}();

var aabbPlane = function aabbPlane(aabb, plane) {
  var r = aabb.halfExtents.x * Math.abs(plane.n.x) + aabb.halfExtents.y * Math.abs(plane.n.y) + aabb.halfExtents.z * Math.abs(plane.n.z);
  var dot = Vec3.dot(plane.n, aabb.center);

  if (dot + r < plane.d) {
    return -1;
  } else if (dot - r > plane.d) {
    return 0;
  }

  return 1;
};

var aabbFrustum = function aabbFrustum(aabb, frustum) {
  for (var i = 0; i < frustum.planes.length; i++) {
    if (aabbPlane(aabb, frustum.planes[i]) === -1) {
      return 0;
    }
  }

  return 1;
};

var aabbFrustumAccurate = function () {
  var tmp = new Array(8);
  var out1 = 0;
  var out2 = 0;

  for (var i = 0; i < tmp.length; i++) {
    tmp[i] = new Vec3(0, 0, 0);
  }

  return function (aabb, frustum) {
    var result = 0;
    var intersects = false;

    for (var _i9 = 0; _i9 < frustum.planes.length; _i9++) {
      result = aabbPlane(aabb, frustum.planes[_i9]);
      if (result === -1) return 0;else if (result === 1) {
          intersects = true;
        }
    }

    if (!intersects) {
      return 1;
    }

    for (var _i10 = 0; _i10 < frustum.vertices.length; _i10++) {
      Vec3.subtract(tmp[_i10], frustum.vertices[_i10], aabb.center);
    }

    out1 = 0, out2 = 0;

    for (var _i11 = 0; _i11 < frustum.vertices.length; _i11++) {
      if (tmp[_i11].x > aabb.halfExtents.x) {
        out1++;
      } else if (tmp[_i11].x < -aabb.halfExtents.x) {
        out2++;
      }
    }

    if (out1 === frustum.vertices.length || out2 === frustum.vertices.length) {
      return 0;
    }

    out1 = 0;
    out2 = 0;

    for (var _i12 = 0; _i12 < frustum.vertices.length; _i12++) {
      if (tmp[_i12].y > aabb.halfExtents.y) {
        out1++;
      } else if (tmp[_i12].y < -aabb.halfExtents.y) {
        out2++;
      }
    }

    if (out1 === frustum.vertices.length || out2 === frustum.vertices.length) {
      return 0;
    }

    out1 = 0;
    out2 = 0;

    for (var _i13 = 0; _i13 < frustum.vertices.length; _i13++) {
      if (tmp[_i13].z > aabb.halfExtents.z) {
        out1++;
      } else if (tmp[_i13].z < -aabb.halfExtents.z) {
        out2++;
      }
    }

    if (out1 === frustum.vertices.length || out2 === frustum.vertices.length) {
      return 0;
    }

    return 1;
  };
}();

var obbPoint = function () {
  var tmp = new Vec3(0, 0, 0);
  var m3 = new Mat3();

  var lessThan = function lessThan(a, b) {
    return Math.abs(a.x) < b.x && Math.abs(a.y) < b.y && Math.abs(a.z) < b.z;
  };

  return function (obb, point) {
    Vec3.subtract(tmp, point, obb.center);
    Vec3.transformMat3(tmp, tmp, Mat3.transpose(m3, obb.orientation));
    return lessThan(tmp, obb.halfExtents);
  };
}();

var obbPlane = function () {
  var absDot = function absDot(n, x, y, z) {
    return Math.abs(n.x * x + n.y * y + n.z * z);
  };

  return function (obb, plane) {
    var r = obb.halfExtents.x * absDot(plane.n, obb.orientation.m00, obb.orientation.m01, obb.orientation.m02) + obb.halfExtents.y * absDot(plane.n, obb.orientation.m03, obb.orientation.m04, obb.orientation.m05) + obb.halfExtents.z * absDot(plane.n, obb.orientation.m06, obb.orientation.m07, obb.orientation.m08);
    var dot = Vec3.dot(plane.n, obb.center);

    if (dot + r < plane.d) {
      return -1;
    } else if (dot - r > plane.d) {
      return 0;
    }

    return 1;
  };
}();

var obbFrustum = function obbFrustum(obb, frustum) {
  for (var i = 0; i < frustum.planes.length; i++) {
    if (obbPlane(obb, frustum.planes[i]) === -1) {
      return 0;
    }
  }

  return 1;
};

var obbFrustumAccurate = function () {
  var tmp = new Array(8);
  var dist = 0;
  var out1 = 0;
  var out2 = 0;

  for (var i = 0; i < tmp.length; i++) {
    tmp[i] = new Vec3(0, 0, 0);
  }

  var dot = function dot(n, x, y, z) {
    return n.x * x + n.y * y + n.z * z;
  };

  return function (obb, frustum) {
    var result = 0;
    var intersects = false;

    for (var _i14 = 0; _i14 < frustum.planes.length; _i14++) {
      result = obbPlane(obb, frustum.planes[_i14]);
      if (result === -1) return 0;else if (result === 1) {
          intersects = true;
        }
    }

    if (!intersects) {
      return 1;
    }

    for (var _i15 = 0; _i15 < frustum.vertices.length; _i15++) {
      Vec3.subtract(tmp[_i15], frustum.vertices[_i15], obb.center);
    }

    out1 = 0, out2 = 0;

    for (var _i16 = 0; _i16 < frustum.vertices.length; _i16++) {
      dist = dot(tmp[_i16], obb.orientation.m00, obb.orientation.m01, obb.orientation.m02);

      if (dist > obb.halfExtents.x) {
        out1++;
      } else if (dist < -obb.halfExtents.x) {
        out2++;
      }
    }

    if (out1 === frustum.vertices.length || out2 === frustum.vertices.length) {
      return 0;
    }

    out1 = 0;
    out2 = 0;

    for (var _i17 = 0; _i17 < frustum.vertices.length; _i17++) {
      dist = dot(tmp[_i17], obb.orientation.m03, obb.orientation.m04, obb.orientation.m05);

      if (dist > obb.halfExtents.y) {
        out1++;
      } else if (dist < -obb.halfExtents.y) {
        out2++;
      }
    }

    if (out1 === frustum.vertices.length || out2 === frustum.vertices.length) {
      return 0;
    }

    out1 = 0;
    out2 = 0;

    for (var _i18 = 0; _i18 < frustum.vertices.length; _i18++) {
      dist = dot(tmp[_i18], obb.orientation.m06, obb.orientation.m07, obb.orientation.m08);

      if (dist > obb.halfExtents.z) {
        out1++;
      } else if (dist < -obb.halfExtents.z) {
        out2++;
      }
    }

    if (out1 === frustum.vertices.length || out2 === frustum.vertices.length) {
      return 0;
    }

    return 1;
  };
}();

var obbWithOBB = function () {
  var test = new Array(15);

  for (var i = 0; i < 15; i++) {
    test[i] = new Vec3(0, 0, 0);
  }

  var vertices = new Array(8);
  var vertices2 = new Array(8);

  for (var _i19 = 0; _i19 < 8; _i19++) {
    vertices[_i19] = new Vec3(0, 0, 0);
    vertices2[_i19] = new Vec3(0, 0, 0);
  }

  return function (obb1, obb2) {
    Vec3.set(test[0], obb1.orientation.m00, obb1.orientation.m01, obb1.orientation.m02);
    Vec3.set(test[1], obb1.orientation.m03, obb1.orientation.m04, obb1.orientation.m05);
    Vec3.set(test[2], obb1.orientation.m06, obb1.orientation.m07, obb1.orientation.m08);
    Vec3.set(test[3], obb2.orientation.m00, obb2.orientation.m01, obb2.orientation.m02);
    Vec3.set(test[4], obb2.orientation.m03, obb2.orientation.m04, obb2.orientation.m05);
    Vec3.set(test[5], obb2.orientation.m06, obb2.orientation.m07, obb2.orientation.m08);

    for (var _i20 = 0; _i20 < 3; ++_i20) {
      Vec3.cross(test[6 + _i20 * 3 + 0], test[_i20], test[3]);
      Vec3.cross(test[6 + _i20 * 3 + 1], test[_i20], test[4]);
      Vec3.cross(test[6 + _i20 * 3 + 2], test[_i20], test[5]);
    }

    getOBBVertices(obb1.center, obb1.halfExtents, test[0], test[1], test[2], vertices);
    getOBBVertices(obb2.center, obb2.halfExtents, test[3], test[4], test[5], vertices2);

    for (var _i21 = 0; _i21 < 15; ++_i21) {
      var a = getInterval(vertices, test[_i21]);
      var b = getInterval(vertices2, test[_i21]);

      if (b[0] > a[1] || a[0] > b[1]) {
        return 0;
      }
    }

    return 1;
  };
}();

var obbCapsule = function () {
  var sphere_0 = new Sphere();
  var v3_0 = new Vec3();
  var v3_1 = new Vec3();
  var v3_2 = new Vec3();
  var v3_verts8 = new Array(8);

  for (var i = 0; i < 8; i++) {
    v3_verts8[i] = new Vec3();
  }

  var v3_axis8 = new Array(8);

  for (var _i22 = 0; _i22 < 8; _i22++) {
    v3_axis8[_i22] = new Vec3();
  }

  return function (obb, capsule) {
    var h = Vec3.squaredDistance(capsule.ellipseCenter0, capsule.ellipseCenter1);

    if (h === 0) {
      sphere_0.radius = capsule.radius;
      sphere_0.center.set(capsule.ellipseCenter0);
      return intersect.sphereOBB(sphere_0, obb);
    } else {
      v3_0.x = obb.orientation.m00;
      v3_0.y = obb.orientation.m01;
      v3_0.z = obb.orientation.m02;
      v3_1.x = obb.orientation.m03;
      v3_1.y = obb.orientation.m04;
      v3_1.z = obb.orientation.m05;
      v3_2.x = obb.orientation.m06;
      v3_2.y = obb.orientation.m07;
      v3_2.z = obb.orientation.m08;
      getOBBVertices(obb.center, obb.halfExtents, v3_0, v3_1, v3_2, v3_verts8);
      var axes = v3_axis8;
      var a0 = Vec3.copy(axes[0], v3_0);
      var a1 = Vec3.copy(axes[1], v3_1);
      var a2 = Vec3.copy(axes[2], v3_2);
      var C = Vec3.subtract(axes[3], capsule.center, obb.center);
      C.normalize();
      var B = Vec3.subtract(axes[4], capsule.ellipseCenter0, capsule.ellipseCenter1);
      B.normalize();
      Vec3.cross(axes[5], a0, B);
      Vec3.cross(axes[6], a1, B);
      Vec3.cross(axes[7], a2, B);

      for (var _i23 = 0; _i23 < 8; ++_i23) {
        var a = getInterval(v3_verts8, axes[_i23]);
        var d0 = Vec3.dot(axes[_i23], capsule.ellipseCenter0);
        var d1 = Vec3.dot(axes[_i23], capsule.ellipseCenter1);
        var max_d = Math.max(d0, d1);
        var min_d = Math.min(d0, d1);
        var d_min = min_d - capsule.radius;
        var d_max = max_d + capsule.radius;

        if (d_min > a[1] || a[0] > d_max) {
          return 0;
        }
      }

      return 1;
    }
  };
}();

var spherePlane = function spherePlane(sphere, plane) {
  var dot = Vec3.dot(plane.n, sphere.center);
  var r = sphere.radius * plane.n.length();

  if (dot + r < plane.d) {
    return -1;
  } else if (dot - r > plane.d) {
    return 0;
  }

  return 1;
};

var sphereFrustum = function sphereFrustum(sphere, frustum) {
  for (var i = 0; i < frustum.planes.length; i++) {
    if (spherePlane(sphere, frustum.planes[i]) === -1) {
      return 0;
    }
  }

  return 1;
};

var sphereFrustumAccurate = function () {
  var pt = new Vec3(0, 0, 0);
  var map = [1, -1, 1, -1, 1, -1];
  return function (sphere, frustum) {
    for (var i = 0; i < 6; i++) {
      var plane = frustum.planes[i];
      var r = sphere.radius;
      var c = sphere.center;
      var n = plane.n;
      var d = plane.d;
      var dot = Vec3.dot(n, c);
      if (dot + r < d) return 0;else if (dot - r > d) {
          continue;
        }
      Vec3.add(pt, c, Vec3.multiplyScalar(pt, n, r));

      for (var j = 0; j < 6; j++) {
        if (j === i || j === i + map[i]) {
          continue;
        }

        var test = frustum.planes[j];

        if (Vec3.dot(test.n, pt) < test.d) {
          return 0;
        }
      }
    }

    return 1;
  };
}();

var sphereWithSphere = function sphereWithSphere(sphere0, sphere1) {
  var r = sphere0.radius + sphere1.radius;
  return Vec3.squaredDistance(sphere0.center, sphere1.center) < r * r;
};

var sphereAABB = function () {
  var pt = new Vec3();
  return function (sphere, aabb) {
    pt_point_aabb(pt, sphere.center, aabb);
    return Vec3.squaredDistance(sphere.center, pt) < sphere.radius * sphere.radius;
  };
}();

var sphereOBB = function () {
  var pt = new Vec3();
  return function (sphere, obb) {
    pt_point_obb(pt, sphere.center, obb);
    return Vec3.squaredDistance(sphere.center, pt) < sphere.radius * sphere.radius;
  };
}();

var sphereCapsule = function () {
  var v3_0 = new Vec3();
  var v3_1 = new Vec3();
  return function (sphere, capsule) {
    var r = sphere.radius + capsule.radius;
    var squaredR = r * r;
    var h = Vec3.squaredDistance(capsule.ellipseCenter0, capsule.ellipseCenter1);

    if (h === 0) {
      return Vec3.squaredDistance(sphere.center, capsule.center) < squaredR;
    } else {
      Vec3.subtract(v3_0, sphere.center, capsule.ellipseCenter0);
      Vec3.subtract(v3_1, capsule.ellipseCenter1, capsule.ellipseCenter0);
      var t = Vec3.dot(v3_0, v3_1) / h;

      if (t < 0) {
        return Vec3.squaredDistance(sphere.center, capsule.ellipseCenter0) < squaredR;
      } else if (t > 1) {
        return Vec3.squaredDistance(sphere.center, capsule.ellipseCenter1) < squaredR;
      } else {
        Vec3.scaleAndAdd(v3_0, capsule.ellipseCenter0, v3_1, t);
        return Vec3.squaredDistance(sphere.center, v3_0) < squaredR;
      }
    }
  };
}();

var capsuleWithCapsule = function () {
  var v3_0 = new Vec3();
  var v3_1 = new Vec3();
  var v3_2 = new Vec3();
  var v3_3 = new Vec3();
  var v3_4 = new Vec3();
  var v3_5 = new Vec3();
  return function capsuleWithCapsule(capsuleA, capsuleB) {
    var u = Vec3.subtract(v3_0, capsuleA.ellipseCenter1, capsuleA.ellipseCenter0);
    var v = Vec3.subtract(v3_1, capsuleB.ellipseCenter1, capsuleB.ellipseCenter0);
    var w = Vec3.subtract(v3_2, capsuleA.ellipseCenter0, capsuleB.ellipseCenter0);
    var a = Vec3.dot(u, u);
    var b = Vec3.dot(u, v);
    var c = Vec3.dot(v, v);
    var d = Vec3.dot(u, w);
    var e = Vec3.dot(v, w);
    var D = a * c - b * b;
    var sN;
    var sD = D;
    var tN;
    var tD = D;

    if (D < EPSILON) {
      sN = 0.0;
      sD = 1.0;
      tN = e;
      tD = c;
    } else {
      sN = b * e - c * d;
      tN = a * e - b * d;

      if (sN < 0.0) {
        sN = 0.0;
        tN = e;
        tD = c;
      } else if (sN > sD) {
        sN = sD;
        tN = e + b;
        tD = c;
      }
    }

    if (tN < 0.0) {
      tN = 0.0;

      if (-d < 0.0) {
        sN = 0.0;
      } else if (-d > a) {
        sN = sD;
      } else {
        sN = -d;
        sD = a;
      }
    } else if (tN > tD) {
      tN = tD;

      if (-d + b < 0.0) {
        sN = 0;
      } else if (-d + b > a) {
        sN = sD;
      } else {
        sN = -d + b;
        sD = a;
      }
    }

    var sc = Math.abs(sN) < EPSILON ? 0.0 : sN / sD;
    var tc = Math.abs(tN) < EPSILON ? 0.0 : tN / tD;
    var dP = v3_3;
    dP.set(w);
    dP.add(Vec3.multiplyScalar(v3_4, u, sc));
    dP.subtract(Vec3.multiplyScalar(v3_5, v, tc));
    var radius = capsuleA.radius + capsuleB.radius;
    return dP.lengthSqr() < radius * radius;
  };
}();

var intersect = {
  raySphere: raySphere,
  rayAABB: rayAABB,
  rayOBB: rayOBB,
  rayPlane: rayPlane,
  rayTriangle: rayTriangle,
  rayCapsule: rayCapsule,
  raySubMesh: raySubMesh,
  rayMesh: rayMesh,
  rayModel: rayModel,
  lineSphere: lineSphere,
  lineAABB: lineAABB,
  lineOBB: lineOBB,
  linePlane: linePlane,
  lineTriangle: lineTriangle,
  sphereWithSphere: sphereWithSphere,
  sphereAABB: sphereAABB,
  sphereOBB: sphereOBB,
  spherePlane: spherePlane,
  sphereFrustum: sphereFrustum,
  sphereFrustumAccurate: sphereFrustumAccurate,
  sphereCapsule: sphereCapsule,
  aabbWithAABB: aabbWithAABB,
  aabbWithOBB: aabbWithOBB,
  aabbPlane: aabbPlane,
  aabbFrustum: aabbFrustum,
  aabbFrustumAccurate: aabbFrustumAccurate,
  obbWithOBB: obbWithOBB,
  obbPlane: obbPlane,
  obbFrustum: obbFrustum,
  obbFrustumAccurate: obbFrustumAccurate,
  obbPoint: obbPoint,
  obbCapsule: obbCapsule,
  capsuleWithCapsule: capsuleWithCapsule,
  resolve: function resolve(g1, g2, outPt) {
    if (outPt === void 0) {
      outPt = null;
    }

    var type1 = g1._type;
    var type2 = g2._type;
    var resolver = this[type1 | type2];
    return type1 < type2 ? resolver(g1, g2, outPt) : resolver(g2, g1, outPt);
  }
};
intersect[enums.SHAPE_RAY | enums.SHAPE_SPHERE] = raySphere;
intersect[enums.SHAPE_RAY | enums.SHAPE_AABB] = rayAABB;
intersect[enums.SHAPE_RAY | enums.SHAPE_OBB] = rayOBB;
intersect[enums.SHAPE_RAY | enums.SHAPE_PLANE] = rayPlane;
intersect[enums.SHAPE_RAY | enums.SHAPE_TRIANGLE] = rayTriangle;
intersect[enums.SHAPE_RAY | enums.SHAPE_CAPSULE] = rayCapsule;
intersect[enums.SHAPE_LINE | enums.SHAPE_SPHERE] = lineSphere;
intersect[enums.SHAPE_LINE | enums.SHAPE_AABB] = lineAABB;
intersect[enums.SHAPE_LINE | enums.SHAPE_OBB] = lineOBB;
intersect[enums.SHAPE_LINE | enums.SHAPE_PLANE] = linePlane;
intersect[enums.SHAPE_LINE | enums.SHAPE_TRIANGLE] = lineTriangle;
intersect[enums.SHAPE_SPHERE] = sphereWithSphere;
intersect[enums.SHAPE_SPHERE | enums.SHAPE_AABB] = sphereAABB;
intersect[enums.SHAPE_SPHERE | enums.SHAPE_OBB] = sphereOBB;
intersect[enums.SHAPE_SPHERE | enums.SHAPE_PLANE] = spherePlane;
intersect[enums.SHAPE_SPHERE | enums.SHAPE_FRUSTUM] = sphereFrustum;
intersect[enums.SHAPE_SPHERE | enums.SHAPE_FRUSTUM_ACCURATE] = sphereFrustumAccurate;
intersect[enums.SHAPE_SPHERE | enums.SHAPE_CAPSULE] = sphereCapsule;
intersect[enums.SHAPE_AABB] = aabbWithAABB;
intersect[enums.SHAPE_AABB | enums.SHAPE_OBB] = aabbWithOBB;
intersect[enums.SHAPE_AABB | enums.SHAPE_PLANE] = aabbPlane;
intersect[enums.SHAPE_AABB | enums.SHAPE_FRUSTUM] = aabbFrustum;
intersect[enums.SHAPE_AABB | enums.SHAPE_FRUSTUM_ACCURATE] = aabbFrustumAccurate;
intersect[enums.SHAPE_OBB] = obbWithOBB;
intersect[enums.SHAPE_OBB | enums.SHAPE_PLANE] = obbPlane;
intersect[enums.SHAPE_OBB | enums.SHAPE_FRUSTUM] = obbFrustum;
intersect[enums.SHAPE_OBB | enums.SHAPE_FRUSTUM_ACCURATE] = obbFrustumAccurate;
intersect[enums.SHAPE_OBB | enums.SHAPE_CAPSULE] = obbCapsule;
intersect[enums.SHAPE_CAPSULE] = capsuleWithCapsule;

exports.replaceProperty(Line.prototype, 'line', [{
  name: 'mag',
  newName: 'len'
}, {
  name: 'magnitude',
  newName: 'len'
}]);
exports.removeProperty(intersect, 'intersect', [{
  name: 'line_quad'
}]);

var v1 = new Vec3(0, 0, 0);
var v2$1 = new Vec3(0, 0, 0);
var temp_mat = legacyCC.mat4();
var temp_vec4 = legacyCC.v4();
var Plane = function () {
  Plane.create = function create(nx, ny, nz, d) {
    return new Plane(nx, ny, nz, d);
  };

  Plane.clone = function clone(p) {
    return new Plane(p.n.x, p.n.y, p.n.z, p.d);
  };

  Plane.copy = function copy(out, p) {
    Vec3.copy(out.n, p.n);
    out.d = p.d;
    return out;
  };

  Plane.fromPoints = function fromPoints(out, a, b, c) {
    Vec3.subtract(v1, b, a);
    Vec3.subtract(v2$1, c, a);
    Vec3.normalize(out.n, Vec3.cross(out.n, v1, v2$1));
    out.d = Vec3.dot(out.n, a);
    return out;
  };

  Plane.set = function set(out, nx, ny, nz, d) {
    out.n.x = nx;
    out.n.y = ny;
    out.n.z = nz;
    out.d = d;
    return out;
  };

  Plane.fromNormalAndPoint = function fromNormalAndPoint(out, normal, point) {
    Vec3.copy(out.n, normal);
    out.d = Vec3.dot(normal, point);
    return out;
  };

  Plane.normalize = function normalize(out, a) {
    var len = a.n.length();
    Vec3.normalize(out.n, a.n);

    if (len > 0) {
      out.d = a.d / len;
    }

    return out;
  };

  _createClass(Plane, [{
    key: "type",
    get: function get() {
      return this._type;
    }
  }, {
    key: "x",
    set: function set(val) {
      this.n.x = val;
    },
    get: function get() {
      return this.n.x;
    }
  }, {
    key: "y",
    set: function set(val) {
      this.n.y = val;
    },
    get: function get() {
      return this.n.y;
    }
  }, {
    key: "z",
    set: function set(val) {
      this.n.z = val;
    },
    get: function get() {
      return this.n.z;
    }
  }, {
    key: "w",
    set: function set(val) {
      this.d = val;
    },
    get: function get() {
      return this.d;
    }
  }]);

  function Plane(nx, ny, nz, d) {
    if (nx === void 0) {
      nx = 0;
    }

    if (ny === void 0) {
      ny = 1;
    }

    if (nz === void 0) {
      nz = 0;
    }

    if (d === void 0) {
      d = 0;
    }

    this.n = void 0;
    this.d = void 0;
    this._type = void 0;
    this._type = enums.SHAPE_PLANE;
    this.n = new Vec3(nx, ny, nz);
    this.d = d;
  }

  var _proto = Plane.prototype;

  _proto.transform = function transform(mat) {
    Mat4.invert(temp_mat, mat);
    Mat4.transpose(temp_mat, temp_mat);
    Vec4.set(temp_vec4, this.n.x, this.n.y, this.n.z, this.d);
    Vec4.transformMat4(temp_vec4, temp_vec4, temp_mat);
    Vec3.set(this.n, temp_vec4.x, temp_vec4.y, temp_vec4.z);
    this.d = temp_vec4.w;
  };

  return Plane;
}();

var NativeBufferPool = function () {
  function NativeBufferPool(dataType, entryBits, stride) {
    this._arrayBuffers = [];
    this._chunkSize = void 0;
    this._chunkSize = stride * (1 << entryBits);
  }

  var _proto = NativeBufferPool.prototype;

  _proto.allocateNewChunk = function allocateNewChunk() {
    return new ArrayBuffer(this._chunkSize);
  };

  return NativeBufferPool;
}();

var _NodeViewDataType, _NodeViewDataMembers, _PassViewDataType, _PassViewDataMembers, _AABBViewDataType, _AABBViewDataMembers;

var BufferDataType;

(function (BufferDataType) {
  BufferDataType[BufferDataType["UINT32"] = 0] = "UINT32";
  BufferDataType[BufferDataType["FLOAT32"] = 1] = "FLOAT32";
  BufferDataType[BufferDataType["NEVER"] = 2] = "NEVER";
})(BufferDataType || (BufferDataType = {}));

var BufferPool = function () {
  function BufferPool(poolType, dataType, dataMembers, enumType, entryBits) {
    if (entryBits === void 0) {
      entryBits = 8;
    }

    this._dataType = void 0;
    this._dataMembers = void 0;
    this._elementCount = void 0;
    this._entryBits = void 0;
    this._stride = void 0;
    this._entriesPerChunk = void 0;
    this._entryMask = void 0;
    this._chunkMask = void 0;
    this._poolFlag = void 0;
    this._arrayBuffers = [];
    this._freeLists = [];
    this._uint32BufferViews = [];
    this._float32BufferViews = [];
    this._hasUint32 = false;
    this._hasFloat32 = false;
    this._nativePool = void 0;
    this._elementCount = enumType.COUNT;
    this._entryBits = entryBits;
    this._dataType = dataType;
    this._dataMembers = dataMembers;
    var bytesPerElement = 4;
    this._stride = bytesPerElement * this._elementCount;
    this._entriesPerChunk = 1 << entryBits;
    this._entryMask = this._entriesPerChunk - 1;
    this._poolFlag = 1 << 30;
    this._chunkMask = ~(this._entryMask | this._poolFlag);
    this._nativePool = new NativeBufferPool(poolType, entryBits, this._stride);
    var type = BufferDataType.NEVER;
    var hasFloat32 = false;
    var hasUint32 = false;

    for (var e in dataType) {
      hasFloat32 = this._hasFloat32;
      hasUint32 = this._hasUint32;

      if (hasUint32 && hasFloat32) {
        break;
      }

      type = dataType[e];

      if (!hasFloat32 && type === BufferDataType.FLOAT32) {
        this._hasFloat32 = true;
      } else if (!hasUint32 && type === BufferDataType.UINT32) {
        this._hasUint32 = true;
      }
    }
  }

  var _proto = BufferPool.prototype;

  _proto.alloc = function alloc() {
    var i = 0;

    for (; i < this._freeLists.length; i++) {
      var list = this._freeLists[i];

      if (list.length) {
        var j = list[list.length - 1];
        list.length--;
        return (i << this._entryBits) + j + this._poolFlag;
      }
    }

    var buffer = this._nativePool.allocateNewChunk();

    var float32BufferViews = [];
    var uint32BufferViews = [];
    var freeList = [];
    var hasFloat32 = this._hasFloat32;
    var hasUint32 = this._hasUint32;

    for (var _j = 0; _j < this._entriesPerChunk; _j++) {
      if (hasFloat32) {
        float32BufferViews.push(new Float32Array(buffer, this._stride * _j, this._elementCount));
      }

      if (hasUint32) {
        uint32BufferViews.push(new Uint32Array(buffer, this._stride * _j, this._elementCount));
      }

      if (_j) {
        freeList.push(_j);
      }
    }

    if (hasUint32) {
      this._uint32BufferViews.push(uint32BufferViews);
    }

    if (hasFloat32) {
      this._float32BufferViews.push(float32BufferViews);
    }

    this._freeLists.push(freeList);

    this._arrayBuffers.push(buffer);

    var handle = (i << this._entryBits) + this._poolFlag;
    return handle;
  };

  _proto.getBuffer = function getBuffer(handle) {
    var chunk = (this._chunkMask & handle) >> this._entryBits;
    var entry = this._entryMask & handle;
    var bufferViews = this._hasFloat32 ? this._float32BufferViews : this._uint32BufferViews;

    return bufferViews[chunk][entry];
  };

  _proto.getTypedArray = function getTypedArray(handle, element) {
    var chunk = (this._chunkMask & handle) >> this._entryBits;
    var entry = this._entryMask & handle;
    var bufferViews = this._dataType[element] === BufferDataType.UINT32 ? this._uint32BufferViews : this._float32BufferViews;

    var index = element;
    var view = bufferViews[chunk][entry];
    var count = this._dataMembers[element];
    return view.subarray(index, index + count);
  };

  _proto.free = function free(handle) {
    var chunk = (this._chunkMask & handle) >> this._entryBits;
    var entry = this._entryMask & handle;

    var bufferViews = this._hasUint32 ? this._uint32BufferViews : this._float32BufferViews;
    bufferViews[chunk][entry].fill(0);

    this._freeLists[chunk].push(entry);
  };

  return BufferPool;
}();

(function (PoolType) {
  PoolType[PoolType["NODE"] = 0] = "NODE";
  PoolType[PoolType["PASS"] = 1] = "PASS";
  PoolType[PoolType["AABB"] = 2] = "AABB";
})(exports.PoolType || (exports.PoolType = {}));

var NULL_HANDLE = 0;

(function (NodeView) {
  NodeView[NodeView["DIRTY_FLAG"] = 0] = "DIRTY_FLAG";
  NodeView[NodeView["LAYER"] = 1] = "LAYER";
  NodeView[NodeView["WORLD_SCALE"] = 2] = "WORLD_SCALE";
  NodeView[NodeView["WORLD_POSITION"] = 5] = "WORLD_POSITION";
  NodeView[NodeView["WORLD_ROTATION"] = 8] = "WORLD_ROTATION";
  NodeView[NodeView["WORLD_MATRIX"] = 12] = "WORLD_MATRIX";
  NodeView[NodeView["LOCAL_SCALE"] = 28] = "LOCAL_SCALE";
  NodeView[NodeView["LOCAL_POSITION"] = 31] = "LOCAL_POSITION";
  NodeView[NodeView["LOCAL_ROTATION"] = 34] = "LOCAL_ROTATION";
  NodeView[NodeView["COUNT"] = 38] = "COUNT";
})(exports.NodeView || (exports.NodeView = {}));

var NodeViewDataType = (_NodeViewDataType = {}, _NodeViewDataType[exports.NodeView.DIRTY_FLAG] = BufferDataType.UINT32, _NodeViewDataType[exports.NodeView.LAYER] = BufferDataType.UINT32, _NodeViewDataType[exports.NodeView.WORLD_SCALE] = BufferDataType.FLOAT32, _NodeViewDataType[exports.NodeView.WORLD_POSITION] = BufferDataType.FLOAT32, _NodeViewDataType[exports.NodeView.WORLD_ROTATION] = BufferDataType.FLOAT32, _NodeViewDataType[exports.NodeView.WORLD_MATRIX] = BufferDataType.FLOAT32, _NodeViewDataType[exports.NodeView.LOCAL_SCALE] = BufferDataType.FLOAT32, _NodeViewDataType[exports.NodeView.LOCAL_POSITION] = BufferDataType.FLOAT32, _NodeViewDataType[exports.NodeView.LOCAL_ROTATION] = BufferDataType.FLOAT32, _NodeViewDataType[exports.NodeView.COUNT] = BufferDataType.NEVER, _NodeViewDataType);
var NodeViewDataMembers = (_NodeViewDataMembers = {}, _NodeViewDataMembers[exports.NodeView.DIRTY_FLAG] = exports.NodeView.LAYER - exports.NodeView.DIRTY_FLAG, _NodeViewDataMembers[exports.NodeView.LAYER] = exports.NodeView.WORLD_SCALE - exports.NodeView.LAYER, _NodeViewDataMembers[exports.NodeView.WORLD_SCALE] = exports.NodeView.WORLD_POSITION - exports.NodeView.WORLD_SCALE, _NodeViewDataMembers[exports.NodeView.WORLD_POSITION] = exports.NodeView.WORLD_ROTATION - exports.NodeView.WORLD_POSITION, _NodeViewDataMembers[exports.NodeView.WORLD_ROTATION] = exports.NodeView.WORLD_MATRIX - exports.NodeView.WORLD_ROTATION, _NodeViewDataMembers[exports.NodeView.WORLD_MATRIX] = exports.NodeView.LOCAL_SCALE - exports.NodeView.WORLD_MATRIX, _NodeViewDataMembers[exports.NodeView.LOCAL_SCALE] = exports.NodeView.LOCAL_POSITION - exports.NodeView.LOCAL_SCALE, _NodeViewDataMembers[exports.NodeView.LOCAL_POSITION] = exports.NodeView.LOCAL_ROTATION - exports.NodeView.LOCAL_POSITION, _NodeViewDataMembers[exports.NodeView.LOCAL_ROTATION] = exports.NodeView.COUNT - exports.NodeView.LOCAL_ROTATION, _NodeViewDataMembers[exports.NodeView.COUNT] = 1, _NodeViewDataMembers);
var NodePool = new BufferPool(exports.PoolType.NODE, NodeViewDataType, NodeViewDataMembers, exports.NodeView);

(function (PassView) {
  PassView[PassView["PRIORITY"] = 0] = "PRIORITY";
  PassView[PassView["STAGE"] = 1] = "STAGE";
  PassView[PassView["PHASE"] = 2] = "PHASE";
  PassView[PassView["PRIMITIVE"] = 3] = "PRIMITIVE";
  PassView[PassView["BATCHING_SCHEME"] = 4] = "BATCHING_SCHEME";
  PassView[PassView["DYNAMIC_STATE"] = 5] = "DYNAMIC_STATE";
  PassView[PassView["HASH"] = 6] = "HASH";
  PassView[PassView["COUNT"] = 7] = "COUNT";
})(exports.PassView || (exports.PassView = {}));

var PassViewDataType = (_PassViewDataType = {}, _PassViewDataType[exports.PassView.PRIORITY] = BufferDataType.UINT32, _PassViewDataType[exports.PassView.STAGE] = BufferDataType.UINT32, _PassViewDataType[exports.PassView.PHASE] = BufferDataType.UINT32, _PassViewDataType[exports.PassView.PRIMITIVE] = BufferDataType.UINT32, _PassViewDataType[exports.PassView.BATCHING_SCHEME] = BufferDataType.UINT32, _PassViewDataType[exports.PassView.DYNAMIC_STATE] = BufferDataType.UINT32, _PassViewDataType[exports.PassView.HASH] = BufferDataType.UINT32, _PassViewDataType[exports.PassView.COUNT] = BufferDataType.NEVER, _PassViewDataType);
var PassViewDataMembers = (_PassViewDataMembers = {}, _PassViewDataMembers[exports.PassView.PRIORITY] = exports.PassView.STAGE - exports.PassView.PRIORITY, _PassViewDataMembers[exports.PassView.STAGE] = exports.PassView.PHASE - exports.PassView.STAGE, _PassViewDataMembers[exports.PassView.PHASE] = exports.PassView.PRIMITIVE - exports.PassView.PHASE, _PassViewDataMembers[exports.PassView.PRIMITIVE] = exports.PassView.BATCHING_SCHEME - exports.PassView.PRIMITIVE, _PassViewDataMembers[exports.PassView.BATCHING_SCHEME] = exports.PassView.DYNAMIC_STATE - exports.PassView.BATCHING_SCHEME, _PassViewDataMembers[exports.PassView.DYNAMIC_STATE] = exports.PassView.HASH - exports.PassView.DYNAMIC_STATE, _PassViewDataMembers[exports.PassView.HASH] = exports.PassView.COUNT - exports.PassView.HASH, _PassViewDataMembers[exports.PassView.COUNT] = 1, _PassViewDataMembers);
var PassPool = new BufferPool(exports.PoolType.PASS, PassViewDataType, PassViewDataMembers, exports.PassView);

(function (AABBView) {
  AABBView[AABBView["CENTER"] = 0] = "CENTER";
  AABBView[AABBView["HALFEXTENTS"] = 3] = "HALFEXTENTS";
  AABBView[AABBView["COUNT"] = 6] = "COUNT";
})(exports.AABBView || (exports.AABBView = {}));

var AABBViewDataType = (_AABBViewDataType = {}, _AABBViewDataType[exports.AABBView.CENTER] = BufferDataType.FLOAT32, _AABBViewDataType[exports.AABBView.HALFEXTENTS] = BufferDataType.FLOAT32, _AABBViewDataType[exports.AABBView.COUNT] = BufferDataType.NEVER, _AABBViewDataType);
var AABBViewDataMembers = (_AABBViewDataMembers = {}, _AABBViewDataMembers[exports.AABBView.CENTER] = exports.AABBView.HALFEXTENTS - exports.AABBView.CENTER, _AABBViewDataMembers[exports.AABBView.HALFEXTENTS] = exports.AABBView.COUNT - exports.AABBView.HALFEXTENTS, _AABBViewDataMembers[exports.AABBView.COUNT] = 1, _AABBViewDataMembers);
var AABBPool = new BufferPool(exports.PoolType.AABB, AABBViewDataType, AABBViewDataMembers, exports.AABBView);

var _v3_tmp$1 = new Vec3();

var _v3_tmp2 = new Vec3();

var _v3_tmp3 = new Vec3();

var _v3_tmp4 = new Vec3();

var _m3_tmp = new Mat3();

var transform_extent_m4 = function transform_extent_m4(out, extent, m4) {
  _m3_tmp.m00 = Math.abs(m4.m00);
  _m3_tmp.m01 = Math.abs(m4.m01);
  _m3_tmp.m02 = Math.abs(m4.m02);
  _m3_tmp.m03 = Math.abs(m4.m04);
  _m3_tmp.m04 = Math.abs(m4.m05);
  _m3_tmp.m05 = Math.abs(m4.m06);
  _m3_tmp.m06 = Math.abs(m4.m08);
  _m3_tmp.m07 = Math.abs(m4.m09);
  _m3_tmp.m08 = Math.abs(m4.m10);
  Vec3.transformMat3(out, extent, _m3_tmp);
};

var AABB = function () {
  AABB.create = function create(px, py, pz, hw, hh, hl) {
    return new AABB(px, py, pz, hw, hh, hl);
  };

  AABB.clone = function clone(a) {
    return new AABB(a.center.x, a.center.y, a.center.z, a.halfExtents.x, a.halfExtents.y, a.halfExtents.z);
  };

  AABB.copy = function copy(out, a) {
    Vec3.copy(out.center, a.center);
    Vec3.copy(out.halfExtents, a.halfExtents);
    return out;
  };

  AABB.fromPoints = function fromPoints(out, minPos, maxPos) {
    Vec3.add(_v3_tmp$1, maxPos, minPos);
    Vec3.subtract(_v3_tmp2, maxPos, minPos);
    Vec3.multiplyScalar(out.center, _v3_tmp$1, 0.5);
    Vec3.multiplyScalar(out.halfExtents, _v3_tmp2, 0.5);
    return out;
  };

  AABB.set = function set(out, px, py, pz, hw, hh, hl) {
    Vec3.set(out.center, px, py, pz);
    Vec3.set(out.halfExtents, hw, hh, hl);
    return out;
  };

  AABB.merge = function merge(out, a, b) {
    Vec3.subtract(_v3_tmp$1, a.center, a.halfExtents);
    Vec3.subtract(_v3_tmp2, b.center, b.halfExtents);
    Vec3.add(_v3_tmp3, a.center, a.halfExtents);
    Vec3.add(_v3_tmp4, b.center, b.halfExtents);
    Vec3.max(_v3_tmp4, _v3_tmp3, _v3_tmp4);
    Vec3.min(_v3_tmp3, _v3_tmp$1, _v3_tmp2);
    return AABB.fromPoints(out, _v3_tmp3, _v3_tmp4);
  };

  AABB.toBoundingSphere = function toBoundingSphere(out, a) {
    a.getBoundary(_v3_tmp$1, _v3_tmp2);
    out.center.set(_v3_tmp$1);
    out.radius = 0.0;
    Vec3.subtract(_v3_tmp3, _v3_tmp2, out.center);

    var dist = _v3_tmp3.length();

    var half = dist * 0.5;
    out.radius += half;
    Vec3.multiplyScalar(_v3_tmp3, _v3_tmp3, half / dist);
    Vec3.add(out.center, out.center, _v3_tmp3);
    return out;
  };

  AABB.transform = function transform(out, a, matrix) {
    Vec3.transformMat4(out.center, a.center, matrix);
    transform_extent_m4(out.halfExtents, a.halfExtents, matrix);
    return out;
  };

  _createClass(AABB, [{
    key: "type",
    get: function get() {
      return this._type;
    }
  }]);

  function AABB(px, py, pz, hw, hh, hl) {
    if (px === void 0) {
      px = 0;
    }

    if (py === void 0) {
      py = 0;
    }

    if (pz === void 0) {
      pz = 0;
    }

    if (hw === void 0) {
      hw = 1;
    }

    if (hh === void 0) {
      hh = 1;
    }

    if (hl === void 0) {
      hl = 1;
    }

    this.center = void 0;
    this.halfExtents = void 0;
    this._type = void 0;
    this._aabbHandle = NULL_HANDLE;
    this._type = enums.SHAPE_AABB;

    this.center = new Vec3(px, py, pz);
    this.halfExtents = new Vec3(hw, hh, hl);
  }

  var _proto = AABB.prototype;

  _proto.getBoundary = function getBoundary(minPos, maxPos) {
    Vec3.subtract(minPos, this.center, this.halfExtents);
    Vec3.add(maxPos, this.center, this.halfExtents);
  };

  _proto.transform = function transform(m, pos, rot, scale, out) {
    Vec3.transformMat4(out.center, this.center, m);
    transform_extent_m4(out.halfExtents, this.halfExtents, m);
  };

  _proto.clone = function clone() {
    return AABB.clone(this);
  };

  _proto.copy = function copy(a) {
    return AABB.copy(this, a);
  };

  _createClass(AABB, [{
    key: "native",
    get: function get() {
      return this._nativeObj;
    }
  }]);

  return AABB;
}();

var _v3_tmp$2 = new Vec3();

var _v3_tmp2$1 = new Vec3();

var _m3_tmp$1 = new Mat3();

var transform_extent_m3 = function transform_extent_m3(out, extent, m3) {
  _m3_tmp$1.m00 = Math.abs(m3.m00);
  _m3_tmp$1.m01 = Math.abs(m3.m01);
  _m3_tmp$1.m02 = Math.abs(m3.m02);
  _m3_tmp$1.m03 = Math.abs(m3.m03);
  _m3_tmp$1.m04 = Math.abs(m3.m04);
  _m3_tmp$1.m05 = Math.abs(m3.m05);
  _m3_tmp$1.m06 = Math.abs(m3.m06);
  _m3_tmp$1.m07 = Math.abs(m3.m07);
  _m3_tmp$1.m08 = Math.abs(m3.m08);
  Vec3.transformMat3(out, extent, _m3_tmp$1);
};

var OBB = function () {
  OBB.create = function create(cx, cy, cz, hw, hh, hl, ox_1, ox_2, ox_3, oy_1, oy_2, oy_3, oz_1, oz_2, oz_3) {
    return new OBB(cx, cy, cz, hw, hh, hl, ox_1, ox_2, ox_3, oy_1, oy_2, oy_3, oz_1, oz_2, oz_3);
  };

  OBB.clone = function clone(a) {
    return new OBB(a.center.x, a.center.y, a.center.z, a.halfExtents.x, a.halfExtents.y, a.halfExtents.z, a.orientation.m00, a.orientation.m01, a.orientation.m02, a.orientation.m03, a.orientation.m04, a.orientation.m05, a.orientation.m06, a.orientation.m07, a.orientation.m08);
  };

  OBB.copy = function copy(out, a) {
    Vec3.copy(out.center, a.center);
    Vec3.copy(out.halfExtents, a.halfExtents);
    Mat3.copy(out.orientation, a.orientation);
    return out;
  };

  OBB.fromPoints = function fromPoints(out, minPos, maxPos) {
    Vec3.multiplyScalar(out.center, Vec3.add(_v3_tmp$2, minPos, maxPos), 0.5);
    Vec3.multiplyScalar(out.halfExtents, Vec3.subtract(_v3_tmp2$1, maxPos, minPos), 0.5);
    Mat3.identity(out.orientation);
    return out;
  };

  OBB.set = function set(out, cx, cy, cz, hw, hh, hl, ox_1, ox_2, ox_3, oy_1, oy_2, oy_3, oz_1, oz_2, oz_3) {
    Vec3.set(out.center, cx, cy, cz);
    Vec3.set(out.halfExtents, hw, hh, hl);
    Mat3.set(out.orientation, ox_1, ox_2, ox_3, oy_1, oy_2, oy_3, oz_1, oz_2, oz_3);
    return out;
  };

  _createClass(OBB, [{
    key: "type",
    get: function get() {
      return this._type;
    }
  }]);

  function OBB(cx, cy, cz, hw, hh, hl, ox_1, ox_2, ox_3, oy_1, oy_2, oy_3, oz_1, oz_2, oz_3) {
    if (cx === void 0) {
      cx = 0;
    }

    if (cy === void 0) {
      cy = 0;
    }

    if (cz === void 0) {
      cz = 0;
    }

    if (hw === void 0) {
      hw = 1;
    }

    if (hh === void 0) {
      hh = 1;
    }

    if (hl === void 0) {
      hl = 1;
    }

    if (ox_1 === void 0) {
      ox_1 = 1;
    }

    if (ox_2 === void 0) {
      ox_2 = 0;
    }

    if (ox_3 === void 0) {
      ox_3 = 0;
    }

    if (oy_1 === void 0) {
      oy_1 = 0;
    }

    if (oy_2 === void 0) {
      oy_2 = 1;
    }

    if (oy_3 === void 0) {
      oy_3 = 0;
    }

    if (oz_1 === void 0) {
      oz_1 = 0;
    }

    if (oz_2 === void 0) {
      oz_2 = 0;
    }

    if (oz_3 === void 0) {
      oz_3 = 1;
    }

    this.center = void 0;
    this.halfExtents = void 0;
    this.orientation = void 0;
    this._type = void 0;
    this._type = enums.SHAPE_OBB;
    this.center = new Vec3(cx, cy, cz);
    this.halfExtents = new Vec3(hw, hh, hl);
    this.orientation = new Mat3(ox_1, ox_2, ox_3, oy_1, oy_2, oy_3, oz_1, oz_2, oz_3);
  }

  var _proto = OBB.prototype;

  _proto.getBoundary = function getBoundary(minPos, maxPos) {
    transform_extent_m3(_v3_tmp$2, this.halfExtents, this.orientation);
    Vec3.subtract(minPos, this.center, _v3_tmp$2);
    Vec3.add(maxPos, this.center, _v3_tmp$2);
  };

  _proto.transform = function transform(m, pos, rot, scale, out) {
    Vec3.transformMat4(out.center, this.center, m);
    Mat3.fromQuat(out.orientation, rot);
    Vec3.multiply(out.halfExtents, this.halfExtents, scale);
  };

  _proto.translateAndRotate = function translateAndRotate(m, rot, out) {
    Vec3.transformMat4(out.center, this.center, m);
    Mat3.fromQuat(out.orientation, rot);
  };

  _proto.setScale = function setScale(scale, out) {
    Vec3.multiply(out.halfExtents, this.halfExtents, scale);
  };

  return OBB;
}();

var Capsule = function () {
  _createClass(Capsule, [{
    key: "type",
    get: function get() {
      return this._type;
    }
  }]);

  function Capsule(radius, halfHeight, axis) {
    if (radius === void 0) {
      radius = 0.5;
    }

    if (halfHeight === void 0) {
      halfHeight = 0.5;
    }

    if (axis === void 0) {
      axis = 1;
    }

    this._type = void 0;
    this.radius = void 0;
    this.halfHeight = void 0;
    this.axis = void 0;
    this.center = void 0;
    this.rotation = void 0;
    this.ellipseCenter0 = void 0;
    this.ellipseCenter1 = void 0;
    this._type = enums.SHAPE_CAPSULE;
    this.radius = radius;
    this.halfHeight = halfHeight;
    this.axis = axis;
    this.center = new Vec3();
    this.rotation = new Quat();
    this.ellipseCenter0 = new Vec3(0, halfHeight, 0);
    this.ellipseCenter1 = new Vec3(0, -halfHeight, 0);
    this.updateCache();
  }

  var _proto = Capsule.prototype;

  _proto.transform = function transform(m, pos, rot, scale, out) {
    var ws = scale;
    var s = absMaxComponent(ws);
    out.radius = this.radius * Math.abs(s);
    var halfTotalWorldHeight = (this.halfHeight + this.radius) * Math.abs(ws.y);
    var halfWorldHeight = halfTotalWorldHeight - out.radius;
    if (halfWorldHeight < 0) halfWorldHeight = 0;
    out.halfHeight = halfWorldHeight;
    Vec3.transformMat4(out.center, this.center, m);
    Quat.multiply(out.rotation, this.rotation, rot);
    out.updateCache();
  };

  _proto.updateCache = function updateCache() {
    this.updateLocalCenter();
    Vec3.transformQuat(this.ellipseCenter0, this.ellipseCenter0, this.rotation);
    Vec3.transformQuat(this.ellipseCenter1, this.ellipseCenter1, this.rotation);
    this.ellipseCenter0.add(this.center);
    this.ellipseCenter1.add(this.center);
  };

  _proto.updateLocalCenter = function updateLocalCenter() {
    var halfHeight = this.halfHeight;
    var axis = this.axis;

    switch (axis) {
      case 0:
        this.ellipseCenter0.set(halfHeight, 0, 0);
        this.ellipseCenter1.set(-halfHeight, 0, 0);
        break;

      case 1:
        this.ellipseCenter0.set(0, halfHeight, 0);
        this.ellipseCenter1.set(0, -halfHeight, 0);
        break;

      case 2:
        this.ellipseCenter0.set(0, 0, halfHeight);
        this.ellipseCenter1.set(0, 0, -halfHeight);
        break;
    }
  };

  return Capsule;
}();

var _v = new Array(8);

_v[0] = new Vec3(1, 1, 1);
_v[1] = new Vec3(-1, 1, 1);
_v[2] = new Vec3(-1, -1, 1);
_v[3] = new Vec3(1, -1, 1);
_v[4] = new Vec3(1, 1, -1);
_v[5] = new Vec3(-1, 1, -1);
_v[6] = new Vec3(-1, -1, -1);
_v[7] = new Vec3(1, -1, -1);
var Frustum = function () {
  Frustum.create = function create() {
    return new Frustum();
  };

  Frustum.clone = function clone(f) {
    return Frustum.copy(new Frustum(), f);
  };

  Frustum.copy = function copy(out, f) {
    out._type = f._type;

    for (var i = 0; i < 6; ++i) {
      Plane.copy(out.planes[i], f.planes[i]);
    }

    for (var _i = 0; _i < 8; ++_i) {
      Vec3.copy(out.vertices[_i], f.vertices[_i]);
    }

    return out;
  };

  _createClass(Frustum, [{
    key: "accurate",
    set: function set(b) {
      this._type = b ? enums.SHAPE_FRUSTUM_ACCURATE : enums.SHAPE_FRUSTUM;
    }
  }, {
    key: "type",
    get: function get() {
      return this._type;
    }
  }]);

  function Frustum() {
    this._type = void 0;
    this.planes = void 0;
    this.vertices = void 0;
    this._type = enums.SHAPE_FRUSTUM;
    this.planes = new Array(6);

    for (var i = 0; i < 6; ++i) {
      this.planes[i] = Plane.create(0, 0, 0, 0);
    }

    this.vertices = new Array(8);

    for (var _i2 = 0; _i2 < 8; ++_i2) {
      this.vertices[_i2] = new Vec3();
    }
  }

  var _proto = Frustum.prototype;

  _proto.update = function update(m, inv) {
    Vec3.set(this.planes[0].n, m.m03 + m.m00, m.m07 + m.m04, m.m11 + m.m08);
    this.planes[0].d = -(m.m15 + m.m12);
    Vec3.set(this.planes[1].n, m.m03 - m.m00, m.m07 - m.m04, m.m11 - m.m08);
    this.planes[1].d = -(m.m15 - m.m12);
    Vec3.set(this.planes[2].n, m.m03 + m.m01, m.m07 + m.m05, m.m11 + m.m09);
    this.planes[2].d = -(m.m15 + m.m13);
    Vec3.set(this.planes[3].n, m.m03 - m.m01, m.m07 - m.m05, m.m11 - m.m09);
    this.planes[3].d = -(m.m15 - m.m13);
    Vec3.set(this.planes[4].n, m.m03 + m.m02, m.m07 + m.m06, m.m11 + m.m10);
    this.planes[4].d = -(m.m15 + m.m14);
    Vec3.set(this.planes[5].n, m.m03 - m.m02, m.m07 - m.m06, m.m11 - m.m10);
    this.planes[5].d = -(m.m15 - m.m14);

    if (this._type !== enums.SHAPE_FRUSTUM_ACCURATE) {
      return;
    }

    for (var i = 0; i < 6; i++) {
      var pl = this.planes[i];
      var invDist = 1 / pl.n.length();
      Vec3.multiplyScalar(pl.n, pl.n, invDist);
      pl.d *= invDist;
    }

    for (var _i3 = 0; _i3 < 8; _i3++) {
      Vec3.transformMat4(this.vertices[_i3], _v[_i3], inv);
    }
  };

  _proto.transform = function transform(mat) {
    if (this._type !== enums.SHAPE_FRUSTUM_ACCURATE) {
      return;
    }

    for (var i = 0; i < 8; i++) {
      Vec3.transformMat4(this.vertices[i], this.vertices[i], mat);
    }

    Plane.fromPoints(this.planes[0], this.vertices[1], this.vertices[5], this.vertices[6]);
    Plane.fromPoints(this.planes[1], this.vertices[3], this.vertices[7], this.vertices[4]);
    Plane.fromPoints(this.planes[2], this.vertices[6], this.vertices[7], this.vertices[3]);
    Plane.fromPoints(this.planes[3], this.vertices[0], this.vertices[4], this.vertices[5]);
    Plane.fromPoints(this.planes[4], this.vertices[2], this.vertices[3], this.vertices[0]);
    Plane.fromPoints(this.planes[0], this.vertices[7], this.vertices[6], this.vertices[5]);
  };

  return Frustum;
}();

Frustum.createOrtho = function () {
  var _temp_v3 = new Vec3();

  return function (out, width, height, near, far, transform) {
    var halfWidth = width / 2;
    var halfHeight = height / 2;
    Vec3.set(_temp_v3, halfWidth, halfHeight, near);
    Vec3.transformMat4(out.vertices[0], _temp_v3, transform);
    Vec3.set(_temp_v3, -halfWidth, halfHeight, near);
    Vec3.transformMat4(out.vertices[1], _temp_v3, transform);
    Vec3.set(_temp_v3, -halfWidth, -halfHeight, near);
    Vec3.transformMat4(out.vertices[2], _temp_v3, transform);
    Vec3.set(_temp_v3, halfWidth, -halfHeight, near);
    Vec3.transformMat4(out.vertices[3], _temp_v3, transform);
    Vec3.set(_temp_v3, halfWidth, halfHeight, far);
    Vec3.transformMat4(out.vertices[4], _temp_v3, transform);
    Vec3.set(_temp_v3, -halfWidth, halfHeight, far);
    Vec3.transformMat4(out.vertices[5], _temp_v3, transform);
    Vec3.set(_temp_v3, -halfWidth, -halfHeight, far);
    Vec3.transformMat4(out.vertices[6], _temp_v3, transform);
    Vec3.set(_temp_v3, halfWidth, -halfHeight, far);
    Vec3.transformMat4(out.vertices[7], _temp_v3, transform);
    Plane.fromPoints(out.planes[0], out.vertices[1], out.vertices[6], out.vertices[5]);
    Plane.fromPoints(out.planes[1], out.vertices[3], out.vertices[4], out.vertices[7]);
    Plane.fromPoints(out.planes[2], out.vertices[6], out.vertices[3], out.vertices[7]);
    Plane.fromPoints(out.planes[3], out.vertices[0], out.vertices[5], out.vertices[4]);
    Plane.fromPoints(out.planes[4], out.vertices[2], out.vertices[0], out.vertices[3]);
    Plane.fromPoints(out.planes[0], out.vertices[7], out.vertices[5], out.vertices[6]);
  };
}();

(function (WrapModeMask) {
  WrapModeMask[WrapModeMask["Default"] = 0] = "Default";
  WrapModeMask[WrapModeMask["Normal"] = 1] = "Normal";
  WrapModeMask[WrapModeMask["Loop"] = 2] = "Loop";
  WrapModeMask[WrapModeMask["ShouldWrap"] = 4] = "ShouldWrap";
  WrapModeMask[WrapModeMask["Clamp"] = 8] = "Clamp";
  WrapModeMask[WrapModeMask["PingPong"] = 22] = "PingPong";
  WrapModeMask[WrapModeMask["Reverse"] = 36] = "Reverse";
})(exports.WrapModeMask || (exports.WrapModeMask = {}));

(function (WrapMode) {
  WrapMode[WrapMode["Default"] = exports.WrapModeMask.Default] = "Default";
  WrapMode[WrapMode["Normal"] = exports.WrapModeMask.Normal] = "Normal";
  WrapMode[WrapMode["Reverse"] = exports.WrapModeMask.Reverse] = "Reverse";
  WrapMode[WrapMode["Loop"] = exports.WrapModeMask.Loop] = "Loop";
  WrapMode[WrapMode["LoopReverse"] = exports.WrapModeMask.Loop | exports.WrapModeMask.Reverse] = "LoopReverse";
  WrapMode[WrapMode["PingPong"] = exports.WrapModeMask.PingPong] = "PingPong";
  WrapMode[WrapMode["PingPongReverse"] = exports.WrapModeMask.PingPong | exports.WrapModeMask.Reverse] = "PingPongReverse";
})(exports.WrapMode || (exports.WrapMode = {}));

ccenum(exports.WrapMode);
var WrappedInfo = function () {
  function WrappedInfo(info) {
    this.ratio = 0;
    this.time = 0;
    this.direction = 1;
    this.stopped = true;
    this.iterations = 0;
    this.frameIndex = undefined;

    if (info) {
      this.set(info);
    }
  }

  var _proto = WrappedInfo.prototype;

  _proto.set = function set(info) {
    this.ratio = info.ratio;
    this.time = info.time;
    this.direction = info.direction;
    this.stopped = info.stopped;
    this.iterations = info.iterations;
    this.frameIndex = info.frameIndex;
  };

  return WrappedInfo;
}();
function isLerpable(object) {
  return typeof object.lerp === 'function';
}

function binarySearchEpsilon(array, value, EPSILON) {
  if (EPSILON === void 0) {
    EPSILON = 1e-6;
  }

  var low = 0;
  var high = array.length - 1;
  var middle = high >>> 1;

  for (; low <= high; middle = low + high >>> 1) {
    var test = array[middle];

    if (test > value + EPSILON) {
      high = middle - 1;
    } else if (test < value - EPSILON) {
      low = middle + 1;
    } else {
      return middle;
    }
  }

  return ~low;
}

var emptyDecorator = function emptyDecorator() {};
var emptyDecoratorFn = function emptyDecoratorFn() {
  return emptyDecorator;
};
var emptySmartClassDecorator = makeSmartClassDecorator(function () {});
function makeSmartClassDecorator(decorate) {
  return proxyFn;

  function proxyFn(target) {
    if (typeof target === 'function') {
      return decorate(target);
    } else {
      return function (constructor) {
        return decorate(constructor, target);
      };
    }
  }
}

function writeEditorClassProperty(constructor, propertyName, value) {
  var cache = getClassCache(constructor);

  if (cache) {
    var proto = getSubDict(cache, 'proto');
    getSubDict(proto, 'editor')[propertyName] = value;
  }
}

function makeEditorClassDecoratorFn(propertyName) {
  return function (value) {
    return function (constructor) {
      writeEditorClassProperty(constructor, propertyName, value);
    };
  };
}
var CACHE_KEY = '__ccclassCache__';
function getClassCache(ctor, decoratorName) {

  return getSubDict(ctor, CACHE_KEY);
}
function getSubDict(obj, key) {
  return obj[key] || (obj[key] = {});
}

var ccclass = makeSmartClassDecorator(function (constructor, name) {
  var base = js.getSuper(constructor);

  if (base === Object) {
    base = null;
  }

  var proto = {
    name: name,
    "extends": base,
    ctor: constructor
  };
  var cache = constructor[CACHE_KEY];

  if (cache) {
    var decoratedProto = cache.proto;

    if (decoratedProto) {
      js.mixin(proto, decoratedProto);
    }

    constructor[CACHE_KEY] = undefined;
  }

  var res = CCClass(proto);

  return res;
});

var requireComponent = makeEditorClassDecoratorFn('requireComponent');
var executionOrder = makeEditorClassDecoratorFn('executionOrder');
var disallowMultiple =  emptySmartClassDecorator;

function property(target, propertyKey, descriptor) {
  var options = null;

  function normalized(target, propertyKey, descriptor) {
    var cache = getClassCache(target.constructor);

    if (cache) {
      var ccclassProto = getSubDict(cache, 'proto');
      var properties = getSubDict(ccclassProto, 'properties');
      genProperty(target.constructor, properties, propertyKey, options, descriptor, cache);
    }
  }

  if (target === undefined) {
    return property({
      type: undefined
    });
  } else if (typeof propertyKey === 'undefined') {
    options = target;
    return normalized;
  } else {
    normalized(target, propertyKey, descriptor);
  }
}

function getDefaultFromInitializer(initializer) {
  var value;

  try {
    value = initializer();
  } catch (e) {
    return initializer;
  }

  if (typeof value !== 'object' || value === null) {
    return value;
  } else {
    return initializer;
  }
}

function extractActualDefaultValues(ctor) {
  var dummyObj;

  try {
    dummyObj = new ctor();
  } catch (e) {

    return {};
  }

  return dummyObj;
}

function genProperty(ctor, properties, propertyKey, options, descriptor, cache) {
  var fullOptions;
  var isGetset = descriptor && (descriptor.get || descriptor.set);

  if (options) {
    fullOptions = getFullFormOfProperty(options, isGetset);
  }

  var existsPropertyRecord = properties[propertyKey];
  var propertyRecord = js.mixin(existsPropertyRecord || {}, fullOptions || options || {});

  if (isGetset) {

    if (descriptor.get) {
      propertyRecord.get = descriptor.get;
    }

    if (descriptor.set) {
      propertyRecord.set = descriptor.set;
    }
  } else {

    if (descriptor) {
      if (descriptor.initializer) {
        propertyRecord["default"] = getDefaultFromInitializer(descriptor.initializer);
      }
    } else {
      var actualDefaultValues = cache["default"] || (cache["default"] = extractActualDefaultValues(ctor));

      if (actualDefaultValues.hasOwnProperty(propertyKey)) {
        propertyRecord["default"] = actualDefaultValues[propertyKey];
      }
    }
  }

  properties[propertyKey] = propertyRecord;
}

var serializable = function serializable(target, propertyKey, descriptor) {
  return property(makeSerializable({}))(target, propertyKey, descriptor);
};
function formerlySerializedAs(name) {
  return property(makeSerializable({
    formerlySerializedAs: name
  }));
}
var editorOnly = function editorOnly(target, propertyKey, descriptor) {
  return property({
    editorOnly: true
  })(target, propertyKey, descriptor);
};

function makeSerializable(options) {
  options.__noImplicit = true;

  if (!('serializable' in options)) {
    options.serializable = true;
  }

  return options;
}

var uniquelyReferenced =  emptyDecorator ;

var executeInEditMode =  emptySmartClassDecorator;
var menu =  emptyDecoratorFn;
var playOnFocus =  emptySmartClassDecorator;
var inspector =  emptyDecoratorFn;
var icon =  emptyDecoratorFn;
var help =  emptyDecoratorFn;
var editable =  emptyDecorator ;
var visible =  emptyDecoratorFn ;
var readOnly =  emptyDecorator ;
var displayName =  emptyDecoratorFn ;
var tooltip =  emptyDecoratorFn ;
var range =  emptyDecoratorFn ;
var rangeMin =  emptyDecoratorFn ;
var rangeMax =  emptyDecoratorFn ;
var rangeStep =  emptyDecoratorFn ;
var slide =  emptyDecorator ;
var displayOrder =  emptyDecoratorFn ;
var unit =  emptyDecoratorFn ;
var radian =  emptyDecorator ;
var multiline =  emptyDecorator ;
var disallowAnimation =  emptyDecorator ;

var integer = type(CCInteger);

var _float = type(CCFloat);

var _boolean = type(CCBoolean);
var string = type(CCString);
function type(type) {
  return property({
    type: type
  });
}

var override = function override(target, propertyKey, descriptor) {
  return property({
    __noImplicit: true,
    override: true
  })(target, propertyKey, descriptor);
};

var _Symbol$iterator;

var _dec, _class, _class2, _descriptor, _descriptor2, _temp;
var KeyframeCurve = (_dec = ccclass('cc.KeyframeCurve'), _dec(_class = (_class2 = (_temp = (_Symbol$iterator = Symbol.iterator, function () {
  function KeyframeCurve() {
    _initializerDefineProperty(this, "_times", _descriptor, this);

    _initializerDefineProperty(this, "_values", _descriptor2, this);
  }

  var _proto = KeyframeCurve.prototype;

  _proto[_Symbol$iterator] = function () {
    var _this = this;

    var index = 0;
    return {
      next: function next() {
        if (index >= _this._times.length) {
          return {
            done: true,
            value: undefined
          };
        } else {
          var value = [_this._times[index], _this._values[index]];
          ++index;
          return {
            done: false,
            value: value
          };
        }
      }
    };
  };

  _proto.keyframes = function keyframes() {
    return this;
  };

  _proto.times = function times() {
    return this._times;
  };

  _proto.values = function values() {
    return this._values;
  };

  _proto.getKeyframeTime = function getKeyframeTime(index) {
    return this._times[index];
  };

  _proto.getKeyframeValue = function getKeyframeValue(index) {
    return this._values[index];
  };

  _proto.addKeyFrame = function addKeyFrame(time, keyframeValue) {
    return this._insertNewKeyframe(time, keyframeValue);
  };

  _proto.removeKeyframe = function removeKeyframe(index) {
    this._times.splice(index, 1);

    this._values.splice(index, 1);
  };

  _proto.indexOfKeyframe = function indexOfKeyframe(time) {
    return binarySearchEpsilon(this._times, time);
  };

  _proto.updateTime = function updateTime(index, time) {
    var value = this._values[index];
    this.removeKeyframe(index);

    this._insertNewKeyframe(time, value);
  };

  _proto.assignSorted = function assignSorted(times, values) {
    if (values !== undefined) {
      this.setKeyframes(times.slice(), values.slice());
    } else {
      var _keyframes = Array.from(times);

      this.setKeyframes(_keyframes.map(function (_ref) {
        var time = _ref[0];
        return time;
      }), _keyframes.map(function (_ref2) {
        var value = _ref2[1];
        return value;
      }));
    }
  };

  _proto.clear = function clear() {
    this._times.length = 0;
    this._values.length = 0;
  };

  _proto.searchKeyframe = function searchKeyframe(time) {
    return binarySearchEpsilon(this._times, time);
  };

  _proto.setKeyframes = function setKeyframes(times, values) {
    assertIsTrue(times.length === values.length);
    assertIsTrue(isSorted(times));
    this._times = times;
    this._values = values;
  };

  _proto._insertNewKeyframe = function _insertNewKeyframe(time, value) {
    var times = this._times;
    var values = this._values;
    var nFrames = times.length;
    var index = binarySearchEpsilon(times, time);

    if (index >= 0) {
      return index;
    }

    var iNext = ~index;

    if (iNext === 0) {
      times.unshift(time);
      values.unshift(value);
    } else if (iNext === nFrames) {
      times.push(time);
      values.push(value);
    } else {
      times.splice(iNext - 1, 0, time);
      values.splice(iNext - 1, 0, value);
    }

    return iNext;
  };

  _createClass(KeyframeCurve, [{
    key: "keyFramesCount",
    get: function get() {
      return this._times.length;
    }
  }, {
    key: "rangeMin",
    get: function get() {
      return this._times[0];
    }
  }, {
    key: "rangeMax",
    get: function get() {
      return this._times[this._values.length - 1];
    }
  }]);

  return KeyframeCurve;
}()), _temp), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "_times", [serializable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return [];
  }
}), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "_values", [serializable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return [];
  }
})), _class2)) || _class);

function isSorted(values) {
  return values.every(function (value, index, array) {
    return index === 0 || value > array[index - 1] || approx(value, array[index - 1], 1e-6);
  });
}

(function (RealInterpolationMode) {
  RealInterpolationMode[RealInterpolationMode["LINEAR"] = 0] = "LINEAR";
  RealInterpolationMode[RealInterpolationMode["CONSTANT"] = 1] = "CONSTANT";
  RealInterpolationMode[RealInterpolationMode["CUBIC"] = 2] = "CUBIC";
})(exports.RealInterpolationMode || (exports.RealInterpolationMode = {}));

(function (ExtrapolationMode) {
  ExtrapolationMode[ExtrapolationMode["LINEAR"] = 0] = "LINEAR";
  ExtrapolationMode[ExtrapolationMode["CLAMP"] = 1] = "CLAMP";
  ExtrapolationMode[ExtrapolationMode["LOOP"] = 2] = "LOOP";
  ExtrapolationMode[ExtrapolationMode["PING_PONG"] = 3] = "PING_PONG";
})(exports.ExtrapolationMode || (exports.ExtrapolationMode = {}));

(function (TangentWeightMode) {
  TangentWeightMode[TangentWeightMode["NONE"] = 0] = "NONE";
  TangentWeightMode[TangentWeightMode["LEFT"] = 1] = "LEFT";
  TangentWeightMode[TangentWeightMode["RIGHT"] = 2] = "RIGHT";
  TangentWeightMode[TangentWeightMode["BOTH"] = 3] = "BOTH";
})(exports.TangentWeightMode || (exports.TangentWeightMode = {}));

function solveCubic(coeff0, coeff1, coeff2, coeff3, solutions) {
  var a = coeff2 / coeff3;
  var b = coeff1 / coeff3;
  var c = coeff0 / coeff3;
  var sqrA = a * a;
  var p = 1.0 / 3.0 * (-1.0 / 3 * sqrA + b);
  var q = 1.0 / 2.0 * (2.0 / 27.0 * a * sqrA - 1.0 / 3 * a * b + c);
  var cubicP = p * p * p;
  var d = q * q + cubicP;
  var nSolutions = 0;

  if (isZero(d)) {
    if (isZero(q)) {
      solutions[0] = 0;
      return 1;
    } else {
      var u = Math.cbrt(-q);
      solutions[0] = 2 * u;
      solutions[1] = -u;
      return 2;
    }
  } else if (d < 0) {
    var phi = 1.0 / 3 * Math.acos(-q / Math.sqrt(-cubicP));
    var t = 2 * Math.sqrt(-p);
    solutions[0] = t * Math.cos(phi);
    solutions[1] = -t * Math.cos(phi + Math.PI / 3);
    solutions[2] = -t * Math.cos(phi - Math.PI / 3);
    nSolutions = 3;
  } else {
    var sqrtD = Math.sqrt(d);

    var _u = Math.cbrt(sqrtD - q);

    var v = -Math.cbrt(sqrtD + q);
    solutions[0] = _u + v;
    nSolutions = 1;
  }

  var sub = 1.0 / 3 * a;

  for (var i = 0; i < nSolutions; ++i) {
    solutions[i] -= sub;
  }

  return nSolutions;
}
var EQN_EPS = 1e-9;

function isZero(x) {
  return x > -EQN_EPS && x < EQN_EPS;
}

var EditorExtendable = editorExtendableInternal();

function editorExtendableInternal(Base, className) {
  {
    return Base !== null && Base !== void 0 ? Base : Object;
  }
}

var _decorator = /*#__PURE__*/Object.freeze({
    __proto__: null,
    uniquelyReferenced: uniquelyReferenced,
    ccclass: ccclass,
    property: property,
    requireComponent: requireComponent,
    executionOrder: executionOrder,
    disallowMultiple: disallowMultiple,
    executeInEditMode: executeInEditMode,
    menu: menu,
    playOnFocus: playOnFocus,
    inspector: inspector,
    icon: icon,
    help: help,
    type: type,
    integer: integer,
    float: _float,
    boolean: _boolean,
    string: string
});

var Cache = function () {
  function Cache(map) {
    this._map = null;
    this._count = 0;

    if (map) {
      this._map = map;
      this._count = Object.keys(map).length;
    } else {
      this._map = js.createMap(true);
      this._count = 0;
    }
  }

  var _proto = Cache.prototype;

  _proto.add = function add(key, val) {
    if (!(key in this._map)) {
      this._count++;
    }

    return this._map[key] = val;
  };

  _proto.get = function get(key) {
    return this._map[key];
  };

  _proto.has = function has(key) {
    return key in this._map;
  };

  _proto.remove = function remove(key) {
    var out = this._map[key];

    if (key in this._map) {
      delete this._map[key];
      this._count--;
    }

    return out;
  };

  _proto.clear = function clear() {
    if (this._count !== 0) {
      this._map = js.createMap(true);
      this._count = 0;
    }
  };

  _proto.forEach = function forEach(func) {
    for (var _key in this._map) {
      func(this._map[_key], _key);
    }
  };

  _proto.find = function find(predicate) {
    for (var _key2 in this._map) {
      if (predicate(this._map[_key2], _key2)) {
        return this._map[_key2];
      }
    }

    return null;
  };

  _proto.destroy = function destroy() {
    this._map = null;
  };

  _createClass(Cache, [{
    key: "count",
    get: function get() {
      return this._count;
    }
  }]);

  return Cache;
}();

var Pipeline = function () {
  function Pipeline(name, funcs) {
    this.id = Pipeline._pipelineId++;
    this.name = '';
    this.pipes = [];
    this.name = name;

    for (var i = 0, l = funcs.length; i < l; i++) {
      this.pipes.push(funcs[i]);
    }
  }

  var _proto = Pipeline.prototype;

  _proto.insert = function insert(func, index) {
    if (index > this.pipes.length) {
      warnID(4921);
      return this;
    }

    this.pipes.splice(index, 0, func);
    return this;
  };

  _proto.append = function append(func) {
    this.pipes.push(func);
    return this;
  };

  _proto.remove = function remove(index) {
    this.pipes.splice(index, 1);
    return this;
  };

  _proto.sync = function sync(task) {
    var pipes = this.pipes;

    if (pipes.length === 0) {
      return null;
    }

    task.isFinish = false;

    for (var i = 0, l = pipes.length; i < l;) {
      var pipe = pipes[i];
      var result = pipe(task);

      if (result) {
        task.isFinish = true;
        return result;
      }

      i++;

      if (i !== l) {
        task.input = task.output;
        task.output = null;
      }
    }

    task.isFinish = true;
    return task.output;
  };

  _proto.async = function async(task) {
    var pipes = this.pipes;

    if (pipes.length === 0) {
      return;
    }

    task.isFinish = false;

    this._flow(0, task);
  };

  _proto._flow = function _flow(index, task) {
    var _this = this;

    var pipe = this.pipes[index];
    pipe(task, function (result) {
      if (result) {
        task.isFinish = true;
        task.dispatch('complete', result);
      } else {
        index++;

        if (index < _this.pipes.length) {
          task.input = task.output;
          task.output = null;

          _this._flow(index, task);
        } else {
          task.isFinish = true;
          task.dispatch('complete', result, task.output);
        }
      }
    });
  };

  return Pipeline;
}();
Pipeline._pipelineId = 0;

var WeakCache = function (_Cache) {
  _inheritsLoose(WeakCache, _Cache);

  function WeakCache(map) {
    var _this;

    _this = _Cache.call(this) || this;
    _this._weakMap = {};
    _this._map = null;

    if (map) {
      for (var _key in map) {
        _this._weakMap[_key] = new WeakRef(map[_key]);
      }
    }

    return _this;
  }

  var _proto = WeakCache.prototype;

  _proto.add = function add(key, val) {
    this._weakMap[key] = new WeakRef(val);
    return val;
  };

  _proto.has = function has(key) {
    return key in this._weakMap && !!this._weakMap[key].deref();
  };

  _proto.get = function get(key) {
    return this._weakMap[key] && this._weakMap[key].deref();
  };

  _proto.remove = function remove(key) {
    var out = this._weakMap[key];
    delete this._weakMap[key];
    return out && out.deref();
  };

  _proto.clear = function clear() {
    this._weakMap = js.createMap(true);
  };

  _proto.forEach = function forEach(func) {
    for (var _key2 in this._weakMap) {
      var _val = this.get(_key2);

      if (_val) {
        func(_val, _key2);
      }
    }
  };

  _proto.find = function find(predicate) {
    for (var _key3 in this._weakMap) {
      var _val2 = this.get(_key3);

      if (_val2 && predicate(_val2, _key3)) {
        return this._weakMap[_key3].deref();
      }
    }

    return null;
  };

  _proto.destroy = function destroy() {
    this._weakMap = {};
  };

  _createClass(WeakCache, [{
    key: "count",
    get: function get() {
      return Object.values(this._weakMap).filter(function (weakRef) {
        return weakRef.deref();
      }).length;
    }
  }]);

  return WeakCache;
}(Cache);

var assets =  new Cache();
var files = new Cache();
var parsed = new Cache();
var bundles = new Cache();
var pipeline = new Pipeline('normal load', []);
var fetchPipeline = new Pipeline('fetch', []);
var transformPipeline = new Pipeline('transform url', []);
var references =  null;

(function (RequestType) {
  RequestType["UUID"] = "uuid";
  RequestType["PATH"] = "path";
  RequestType["DIR"] = "dir";
  RequestType["URL"] = "url";
  RequestType["SCENE"] = "scene";
})(exports.RequestType || (exports.RequestType = {}));

var presets = {
  "default": {
    priority: 0
  },
  preload: {
    maxConcurrency: 6,
    maxRequestsPerFrame: 2,
    priority: -1
  },
  scene: {
    maxConcurrency: 20,
    maxRequestsPerFrame: 20,
    priority: 1
  },
  bundle: {
    maxConcurrency: 20,
    maxRequestsPerFrame: 20,
    priority: 2
  },
  remote: {
    maxRetryCount: 4
  }
};

(function (BuiltinBundleName) {
  BuiltinBundleName["RESOURCES"] = "resources";
  BuiltinBundleName["MAIN"] = "main";
  BuiltinBundleName["START_SCENE"] = "start-scene";
})(exports.BuiltinBundleName || (exports.BuiltinBundleName = {}));

var Task = function () {
  Task.create = function create(options) {
    var out;

    if (Task._deadPool.length !== 0) {
      out = Task._deadPool.pop();
      out.set(options);
    } else {
      out = new Task(options);
    }

    return out;
  };

  function Task(options) {
    this.id = Task._taskId++;
    this.onComplete = null;
    this.onProgress = null;
    this.onError = null;
    this.source = null;
    this.output = null;
    this.input = null;
    this.progress = null;
    this.options = null;
    this.isFinish = true;
    this.set(options);
  }

  var _proto = Task.prototype;

  _proto.set = function set(options) {
    if (options === void 0) {
      options = Object.create(null);
    }

    this.onComplete = options.onComplete || null;
    this.onProgress = options.onProgress || null;
    this.onError = options.onError || null;
    this.source = this.input = options.input;
    this.output = null;
    this.progress = options.progress;
    this.options = options.options || Object.create(null);
  };

  _proto.dispatch = function dispatch(event, param1, param2, param3, param4) {
    switch (event) {
      case 'complete':
        if (this.onComplete) {
          this.onComplete(param1, param2);
        }

        break;

      case 'progress':
        if (this.onProgress) {
          this.onProgress(param1, param2, param3, param4);
        }

        break;

      case 'error':
        if (this.onError) {
          this.onError(param1, param2, param3, param4);
        }

        break;

      default:
        {
          var str = "on" + event[0].toUpperCase() + event.substr(1);

          if (typeof this[str] === 'function') {
            this[str](param1, param2, param3, param4);
          }

          break;
        }
    }
  };

  _proto.recycle = function recycle() {
    if (Task._deadPool.length === Task.MAX_DEAD_NUM) {
      return;
    }

    this.onComplete = null;
    this.onProgress = null;
    this.onError = null;
    this.source = this.output = this.input = null;
    this.progress = null;
    this.options = null;

    Task._deadPool.push(this);
  };

  return Task;
}();

Task.MAX_DEAD_NUM = 500;
Task._taskId = 0;
Task._deadPool = [];

var HexChars = '0123456789abcdef'.split('');
var _t = ['', '', '', ''];

var UuidTemplate = _t.concat(_t, '-', _t, '-', _t, '-', _t, '-', _t, _t, _t);

var Indices = UuidTemplate.map(function (x, i) {
  return x === '-' ? NaN : i;
}).filter(isFinite);
function decodeUuid(base64) {
  var strs = base64.split('@');
  var uuid = strs[0];

  if (uuid.length !== 22) {
    return base64;
  }

  UuidTemplate[0] = base64[0];
  UuidTemplate[1] = base64[1];

  for (var i = 2, j = 2; i < 22; i += 2) {
    var lhs = BASE64_VALUES[base64.charCodeAt(i)];
    var rhs = BASE64_VALUES[base64.charCodeAt(i + 1)];
    UuidTemplate[Indices[j++]] = HexChars[lhs >> 2];
    UuidTemplate[Indices[j++]] = HexChars[(lhs & 3) << 2 | rhs >> 4];
    UuidTemplate[Indices[j++]] = HexChars[rhs & 0xF];
  }

  return base64.replace(uuid, UuidTemplate.join(''));
}

var _uuidRegex = /.*[/\\][0-9a-fA-F]{2}[/\\]([0-9a-fA-F-@]{8,}).*/;
function getUuidFromURL(url) {
  var matches = _uuidRegex.exec(url);

  if (matches) {
    return matches[1];
  }

  return '';
}
function getUrlWithUuid(uuid, options) {
  options = options || Object.create(null);
  options.__isNative__ = options.isNative;
  options.ext = options.nativeExt;
  var bundle = bundles.find(function (b) {
    return !!b.getAssetInfo(uuid);
  });

  if (bundle) {
    options.bundle = bundle.name;
  }

  return transform(uuid, options);
}
function isScene(asset) {
  return asset && (asset instanceof legacyCC.SceneAsset || asset instanceof legacyCC.Scene);
}
function normalize(url) {
  if (url) {
    if (url.charCodeAt(0) === 46 && url.charCodeAt(1) === 47) {
      url = url.slice(2);
    } else if (url.charCodeAt(0) === 47) {
      url = url.slice(1);
    }
  }

  return url;
}
function transform(input, options) {
  var subTask = Task.create({
    input: input,
    options: options
  });
  var urls = [];

  try {
    var result = transformPipeline.sync(subTask);

    for (var _iterator = _createForOfIteratorHelperLoose(result), _step; !(_step = _iterator()).done;) {
      var requestItem = _step.value;
      var url = requestItem.url;
      requestItem.recycle();
      urls.push(url);
    }
  } catch (e) {
    for (var _iterator2 = _createForOfIteratorHelperLoose(subTask.output), _step2; !(_step2 = _iterator2()).done;) {
      var item = _step2.value;
      item.recycle();
    }

    error(e.message, e.stack);
  }

  subTask.recycle();
  return urls.length > 1 ? urls : urls[0];
}

var helper = /*#__PURE__*/Object.freeze({
    __proto__: null,
    getUuidFromURL: getUuidFromURL,
    getUrlWithUuid: getUrlWithUuid,
    isScene: isScene,
    normalize: normalize,
    transform: transform,
    decodeUuid: decodeUuid
});

var Event = function () {
  function Event(type, bubbles) {
    this.type = void 0;
    this.bubbles = void 0;
    this.target = null;
    this.currentTarget = null;
    this.eventPhase = 0;
    this.propagationStopped = false;
    this.propagationImmediateStopped = false;
    this.type = type;
    this.bubbles = !!bubbles;
  }

  var _proto = Event.prototype;

  _proto.unuse = function unuse() {
    this.type = Event.NO_TYPE;
    this.target = null;
    this.currentTarget = null;
    this.eventPhase = Event.NONE;
    this.propagationStopped = false;
    this.propagationImmediateStopped = false;
  };

  _proto.reuse = function reuse(type, bubbles) {
    this.type = type;
    this.bubbles = bubbles || false;
  };

  _proto.isStopped = function isStopped() {
    return this.propagationStopped || this.propagationImmediateStopped;
  };

  _proto.getCurrentTarget = function getCurrentTarget() {
    return this.currentTarget;
  };

  _proto.getType = function getType() {
    return this.type;
  };

  return Event;
}();

Event.NO_TYPE = 'no_type';
Event.TOUCH = 'touch';
Event.MOUSE = 'mouse';
Event.KEYBOARD = 'keyboard';
Event.ACCELERATION = 'acceleration';
Event.NONE = 0;
Event.CAPTURING_PHASE = 1;
Event.AT_TARGET = 2;
Event.BUBBLING_PHASE = 3;
legacyCC.Event = Event;

var GarbageCollectionManager = function () {
  function GarbageCollectionManager() {
    this._finalizationRegistry =  null;
  }

  var _proto = GarbageCollectionManager.prototype;

  _proto.registerGCObject = function registerGCObject(gcObject) {
    {
      return gcObject;
    }
  };

  _proto.unregisterGCObject = function unregisterGCObject(gcObject) {
  };

  _proto.init = function init() {};

  _proto.finalizationRegistryCallback = function finalizationRegistryCallback(gcObject) {
    gcObject.destroy();
  };

  _proto.destroy = function destroy() {};

  return GarbageCollectionManager;
}();

var garbageCollectionManager = new GarbageCollectionManager();

var _dec$1, _class$1;
var GCObject = (_dec$1 = ccclass('cc.GCObject'), _dec$1(_class$1 = function (_CCObject) {
  _inheritsLoose(GCObject, _CCObject);

  function GCObject() {
    var _this;

    for (var _len = arguments.length, arg = new Array(_len), _key = 0; _key < _len; _key++) {
      arg[_key] = arguments[_key];
    }

    _this = _CCObject.call.apply(_CCObject, [this].concat(arg)) || this;
    return garbageCollectionManager.registerGCObject(_assertThisInitialized(_this)) || _assertThisInitialized(_this);
  }

  var _proto = GCObject.prototype;

  _proto.equals = function equals(gcObject) {
    if (!gcObject) {
      return false;
    }

    {
      return gcObject === this;
    }
  };

  _proto.destroy = function destroy() {
    garbageCollectionManager.unregisterGCObject(this);
    return _CCObject.prototype.destroy.call(this);
  };

  return GCObject;
}(CCObject)) || _class$1);

var _dec$2, _class$2, _class2$1, _descriptor$1, _temp$1;
var Asset = (_dec$2 = ccclass('cc.Asset'), _dec$2(_class$2 = (_class2$1 = (_temp$1 = function (_Eventify) {
  _inheritsLoose(Asset, _Eventify);

  Asset.deserialize = function deserialize(data) {
    return legacyCC.deserialize(data);
  };

  _createClass(Asset, [{
    key: "nativeUrl",
    get: function get() {
      if (!this._nativeUrl) {
        if (!this._native) return '';
        var name = this._native;

        if (name.charCodeAt(0) === 47) {
          return name.slice(1);
        }

        if (name.charCodeAt(0) === 46) {
          this._nativeUrl = getUrlWithUuid(this._uuid, {
            nativeExt: name,
            isNative: true
          });
        } else {
          this._nativeUrl = getUrlWithUuid(this._uuid, {
            __nativeName__: name,
            nativeExt: extname(name),
            isNative: true
          });
        }
      }

      return this._nativeUrl;
    }
  }, {
    key: "_nativeAsset",
    get: function get() {
      return this._file;
    },
    set: function set(obj) {
      this._file = obj;
    }
  }]);

  function Asset() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _Eventify.call.apply(_Eventify, [this].concat(args)) || this;
    _this.loaded = true;

    _initializerDefineProperty(_this, "_native", _descriptor$1, _assertThisInitialized(_this));

    _this._nativeUrl = '';
    _this._file = null;
    _this._ref = 0;
    Object.defineProperty(_assertThisInitialized(_this), '_uuid', {
      value: '',
      writable: true
    });

    return _this;
  }

  var _proto = Asset.prototype;

  _proto.toString = function toString() {
    return this.nativeUrl;
  };

  _proto.serialize = function serialize() {};

  _proto._setRawAsset = function _setRawAsset(filename, inLibrary) {
    if (inLibrary === void 0) {
      inLibrary = true;
    }

    if (inLibrary !== false) {
      this._native = filename || '';
    } else {
      this._native = "/" + filename;
    }
  };

  _proto.addRef = function addRef() {
    this._ref++;
    return this;
  };

  _proto.decRef = function decRef(autoRelease) {
    if (autoRelease === void 0) {
      autoRelease = true;
    }

    if (this._ref > 0) {
      this._ref--;
    }

    if (autoRelease) {
      legacyCC.assetManager._releaseManager.tryRelease(this);
    }

    return this;
  };

  _proto.onLoaded = function onLoaded() {};

  _proto.initDefault = function initDefault(uuid) {
    if (uuid) {
      this._uuid = uuid;
    }

    this.isDefault = true;
  };

  _proto.validate = function validate() {
    return true;
  };

  _proto.destroy = function destroy() {
    debug(getError(12101, this._uuid));
    return _Eventify.prototype.destroy.call(this);
  };

  _createClass(Asset, [{
    key: "_nativeDep",
    get: function get() {
      if (this._native) {
        return {
          __isNative__: true,
          uuid: this._uuid,
          ext: this._native
        };
      }

      return undefined;
    }
  }, {
    key: "refCount",
    get: function get() {
      return this._ref;
    }
  }]);

  return Asset;
}(Eventify(GCObject)), _temp$1), (_descriptor$1 = _applyDecoratedDescriptor(_class2$1.prototype, "_native", [serializable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return '';
  }
}), _applyDecoratedDescriptor(_class2$1.prototype, "_nativeAsset", [property], Object.getOwnPropertyDescriptor(_class2$1.prototype, "_nativeAsset"), _class2$1.prototype)), _class2$1)) || _class$2);
Asset.prototype.createNode = null;
legacyCC.Asset = Asset;

var _dec$3, _class$3, _dec2, _class2$2, _dec3, _class3;
var Script = (_dec$3 = ccclass('cc.Script'), _dec$3(_class$3 = function (_Asset) {
  _inheritsLoose(Script, _Asset);

  function Script() {
    return _Asset.apply(this, arguments) || this;
  }

  return Script;
}(Asset)) || _class$3);
legacyCC._Script = Script;
var JavaScript = (_dec2 = ccclass('cc.JavaScript'), _dec2(_class2$2 = function (_Script) {
  _inheritsLoose(JavaScript, _Script);

  function JavaScript() {
    return _Script.apply(this, arguments) || this;
  }

  return JavaScript;
}(Script)) || _class2$2);
legacyCC._JavaScript = JavaScript;
var TypeScript = (_dec3 = ccclass('cc.TypeScript'), _dec3(_class3 = function (_Script2) {
  _inheritsLoose(TypeScript, _Script2);

  function TypeScript() {
    return _Script2.apply(this, arguments) || this;
  }

  return TypeScript;
}(Script)) || _class3);
legacyCC._TypeScript = TypeScript;

var _dec$4, _dec2$1, _dec3$1, _dec4, _class$4, _class2$3, _descriptor$2, _descriptor2$1, _descriptor3, _class3$1, _temp$2;
var idGenerator = new IDGenerator('Comp');
var IsOnLoadCalled$1 = CCObject.Flags.IsOnLoadCalled;
var NullNode = null;
var Component = (_dec$4 = ccclass('cc.Component'), _dec2$1 = displayName(), _dec3$1 = type(Script), _dec4 = tooltip(), _dec$4(_class$4 = (_class2$3 = (_temp$2 = _class3$1 = function (_CCObject) {
  _inheritsLoose(Component, _CCObject);

  function Component() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _CCObject.call.apply(_CCObject, [this].concat(args)) || this;

    _initializerDefineProperty(_this, "node", _descriptor$2, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_enabled", _descriptor2$1, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "__prefab", _descriptor3, _assertThisInitialized(_this));

    _this._sceneGetter = null;
    _this._id = idGenerator.getNewId();
    return _this;
  }

  var _proto = Component.prototype;

  _proto._getRenderScene = function _getRenderScene() {
    if (this._sceneGetter) {
      return this._sceneGetter();
    }

    return this.node.scene._renderScene;
  };

  _proto.addComponent = function addComponent(typeOrClassName) {
    return this.node.addComponent(typeOrClassName);
  };

  _proto.getComponent = function getComponent(typeOrClassName) {
    return this.node.getComponent(typeOrClassName);
  };

  _proto.getComponents = function getComponents(typeOrClassName) {
    return this.node.getComponents(typeOrClassName);
  };

  _proto.getComponentInChildren = function getComponentInChildren(typeOrClassName) {
    return this.node.getComponentInChildren(typeOrClassName);
  };

  _proto.getComponentsInChildren = function getComponentsInChildren(typeOrClassName) {
    return this.node.getComponentsInChildren(typeOrClassName);
  };

  _proto.destroy = function destroy() {

    if (_CCObject.prototype.destroy.call(this)) {
      if (this._enabled && this.node.activeInHierarchy) {
        legacyCC.director._compScheduler.disableComp(this);
      }

      return true;
    }

    return false;
  };

  _proto._onPreDestroy = function _onPreDestroy() {
    this.unscheduleAllCallbacks();

    legacyCC.director._nodeActivator.destroyComp(this);

    this.node._removeComponent(this);
  };

  _proto._instantiate = function _instantiate(cloned) {
    if (!cloned) {
      cloned = legacyCC.instantiate._clone(this, this);
    }

    if (cloned) {
      cloned.node = NullNode;
    }

    return cloned;
  };

  _proto.schedule = function schedule(callback, interval, repeat, delay) {
    if (interval === void 0) {
      interval = 0;
    }

    if (repeat === void 0) {
      repeat = legacyCC.macro.REPEAT_FOREVER;
    }

    if (delay === void 0) {
      delay = 0;
    }

    assertID(callback, 1619);
    interval = interval || 0;
    assertID(interval >= 0, 1620);
    repeat = Number.isNaN(repeat) ? legacyCC.macro.REPEAT_FOREVER : repeat;
    delay = delay || 0;
    var scheduler = legacyCC.director.getScheduler();
    var paused = scheduler.isTargetPaused(this);
    scheduler.schedule(callback, this, interval, repeat, delay, paused);
  };

  _proto.scheduleOnce = function scheduleOnce(callback, delay) {
    if (delay === void 0) {
      delay = 0;
    }

    this.schedule(callback, 0, 0, delay);
  };

  _proto.unschedule = function unschedule(callback_fn) {
    if (!callback_fn) {
      return;
    }

    legacyCC.director.getScheduler().unschedule(callback_fn, this);
  };

  _proto.unscheduleAllCallbacks = function unscheduleAllCallbacks() {
    legacyCC.director.getScheduler().unscheduleAllForTarget(this);
  };

  _createClass(Component, [{
    key: "name",
    get: function get() {
      if (this._name) {
        return this._name;
      }

      var className = getClassName(this);
      var trimLeft = className.lastIndexOf('.');

      if (trimLeft >= 0) {
        className = className.slice(trimLeft + 1);
      }

      return this.node.name + "<" + className + ">";
    },
    set: function set(value) {
      this._name = value;
    }
  }, {
    key: "uuid",
    get: function get() {
      return this._id;
    }
  }, {
    key: "__scriptAsset",
    get: function get() {
      return null;
    }
  }, {
    key: "enabled",
    get: function get() {
      return this._enabled;
    },
    set: function set(value) {
      if (this._enabled !== value) {
        this._enabled = value;

        if (this.node.activeInHierarchy) {
          var compScheduler = legacyCC.director._compScheduler;

          if (value) {
            compScheduler.enableComp(this);
          } else {
            compScheduler.disableComp(this);
          }
        }
      }
    }
  }, {
    key: "enabledInHierarchy",
    get: function get() {
      return this._enabled && this.node && this.node.activeInHierarchy;
    }
  }, {
    key: "_isOnLoadCalled",
    get: function get() {
      return this._objFlags & IsOnLoadCalled$1;
    }
  }]);

  return Component;
}(CCObject), _class3$1.system = null, _temp$2), (_applyDecoratedDescriptor(_class2$3.prototype, "__scriptAsset", [_dec2$1, _dec3$1, _dec4, disallowAnimation], Object.getOwnPropertyDescriptor(_class2$3.prototype, "__scriptAsset"), _class2$3.prototype), _descriptor$2 = _applyDecoratedDescriptor(_class2$3.prototype, "node", [serializable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return NullNode;
  }
}), _descriptor2$1 = _applyDecoratedDescriptor(_class2$3.prototype, "_enabled", [serializable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return true;
  }
}), _descriptor3 = _applyDecoratedDescriptor(_class2$3.prototype, "__prefab", [serializable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return null;
  }
})), _class2$3)) || _class$4);
var proto = Component.prototype;
proto.update = null;
proto.lateUpdate = null;
proto.__preload = null;
proto.onLoad = null;
proto.start = null;
proto.onEnable = null;
proto.onDisable = null;
proto.onDestroy = null;
proto.onFocusInEditor = null;
proto.onLostFocusInEditor = null;
proto.resetInEditor = null;
proto._getLocalBounds = null;
proto.onRestore = null;
Component._requireComponent = null;
Component._executionOrder = 0;

value(Component, '_registerEditorProps', function (cls, props) {
  var reqComp = props.requireComponent;

  if (reqComp) {
    cls._requireComponent = reqComp;
  }

  var order = props.executionOrder;

  if (order && typeof order === 'number') {
    cls._executionOrder = order;
  }
});
legacyCC.Component = Component;

var _dec$5, _dec2$2, _class$5, _class2$4, _descriptor$3, _temp$3;
var MissingScript = (_dec$5 = ccclass('cc.MissingScript'), _dec2$2 = inspector(), _dec$5(_class$5 = _dec2$2(_class$5 = (_class2$4 = (_temp$3 = function (_Component) {
  _inheritsLoose(MissingScript, _Component);

  MissingScript.safeFindClass = function safeFindClass(id) {
    var cls = _getClassById(id);

    if (cls) {
      return cls;
    }

    legacyCC.deserialize.reportMissingClass(id);
    return undefined;
  };

  function MissingScript() {
    var _this;

    _this = _Component.call(this) || this;

    _initializerDefineProperty(_this, "_$erialized", _descriptor$3, _assertThisInitialized(_this));

    return _this;
  }

  var _proto = MissingScript.prototype;

  _proto.onLoad = function onLoad() {
    warnID(4600, this.node.name);
  };

  return MissingScript;
}(Component), _temp$3), (_descriptor$3 = _applyDecoratedDescriptor(_class2$4.prototype, "_$erialized", [serializable, editorOnly], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return null;
  }
})), _class2$4)) || _class$5) || _class$5);
legacyCC._MissingScript = MissingScript;

var serializeTag = Symbol('[[Serialize]]');
var deserializeTag = Symbol('[[Deserialize]]');

var VERSION = 1;
var MAGIC = 0x4E4F4343;
var CHUNK_ALIGN_AS = 8;
var CCON = function () {
  function CCON(document, chunks) {
    this._document = void 0;
    this._chunks = void 0;
    this._document = document;
    this._chunks = chunks;
  }

  _createClass(CCON, [{
    key: "document",
    get: function get() {
      return this._document;
    }
  }, {
    key: "chunks",
    get: function get() {
      return this._chunks;
    }
  }]);

  return CCON;
}();
function parseCCONJson(json) {
  var cconPreface = json;
  return {
    chunks: cconPreface.chunks,
    document: cconPreface.document
  };
}
function decodeCCONBinary(bytes) {
  if (bytes.length < 16) {
    throw new InvalidCCONError(getError(13102));
  }

  var dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
  var magic = dataView.getUint32(0, true);

  if (magic !== MAGIC) {
    throw new InvalidCCONError(getError(13100));
  }

  var version = dataView.getUint32(4, true);

  if (version !== VERSION) {
    throw new InvalidCCONError(getError(13101, version));
  }

  var dataByteLength = dataView.getUint32(8, true);

  if (dataByteLength !== dataView.byteLength) {
    throw new InvalidCCONError(getError(13102));
  }

  var chunksStart = 12;
  var jsonDataLength = dataView.getUint32(chunksStart, true);
  chunksStart += 4;
  var jsonData = new Uint8Array(dataView.buffer, chunksStart + dataView.byteOffset, jsonDataLength);
  chunksStart += jsonDataLength;
  var jsonString = decodeJson(jsonData);
  var json;

  try {
    json = JSON.parse(jsonString);
  } catch (err) {
    throw new InvalidCCONError(err);
  }

  var chunks = [];

  while (chunksStart < dataView.byteLength) {
    if (chunksStart % CHUNK_ALIGN_AS !== 0) {
      var padding = CHUNK_ALIGN_AS - chunksStart % CHUNK_ALIGN_AS;
      chunksStart += padding;
    }

    var chunkDataLength = dataView.getUint32(chunksStart, true);
    chunksStart += 4;
    chunks.push(new Uint8Array(dataView.buffer, chunksStart + dataView.byteOffset, chunkDataLength));
    chunksStart += chunkDataLength;
  }

  if (chunksStart !== dataView.byteLength) {
    throw new InvalidCCONError(getError(13102));
  }

  return new CCON(json, chunks);
}

function decodeJson(data) {
  if (typeof TextDecoder !== 'undefined') {
    return new TextDecoder().decode(data);
  } else if ('Buffer' in globalThis) {
    var _ref2 = globalThis,
        _Buffer2 = _ref2.Buffer;
    return _Buffer2.from(data.buffer, data.byteOffset, data.byteLength).toString();
  } else {
    throw new Error(getError(13104));
  }
}

var InvalidCCONError = function (_Error) {
  _inheritsLoose(InvalidCCONError, _Error);

  function InvalidCCONError() {
    return _Error.apply(this, arguments) || this;
  }

  return InvalidCCONError;
}(_wrapNativeSuper(Error));
var BufferBuilder = function () {
  function BufferBuilder() {
    this._viewOrPaddings = [];
    this._length = 0;
  }

  var _proto = BufferBuilder.prototype;

  _proto.alignAs = function alignAs(align) {
    if (align !== 0) {
      var remainder = this._length % align;

      if (remainder !== 0) {
        var padding = align - remainder;

        this._viewOrPaddings.push(padding);

        this._length += padding;
        return padding;
      }
    }

    return 0;
  };

  _proto.append = function append(view) {
    var result = this._length;

    this._viewOrPaddings.push(view);

    this._length += view.byteLength;
    return result;
  };

  _proto.get = function get() {
    var result = new Uint8Array(this._length);
    var counter = 0;

    this._viewOrPaddings.forEach(function (viewOrPadding) {
      if (typeof viewOrPadding === 'number') {
        counter += viewOrPadding;
      } else {
        result.set(new Uint8Array(viewOrPadding.buffer, viewOrPadding.byteOffset, viewOrPadding.byteLength), counter);
        counter += viewOrPadding.byteLength;
      }
    });

    return result;
  };

  _createClass(BufferBuilder, [{
    key: "byteLength",
    get: function get() {
      return this._length;
    }
  }]);

  return BufferBuilder;
}();
legacyCC.internal.parseCCONJson = parseCCONJson;
legacyCC.internal.decodeCCONBinary = decodeCCONBinary;
legacyCC.internal.CCON = CCON;

function compileObjectTypeJit(sources, defaultValue, accessorToSet, propNameLiteralToSet, assumeHavePropIfIsValue) {
  if (defaultValue instanceof legacyCC.ValueType) {
    if (!assumeHavePropIfIsValue) {
      sources.push('if(prop){');
    }

    var ctorCode = getClassName(defaultValue);
    sources.push("s._deserializeFastDefinedObject(o" + accessorToSet + ",prop," + ctorCode + ");");

    if (!assumeHavePropIfIsValue) {
      sources.push("}else o" + accessorToSet + "=null;");
    }
  } else {
    sources.push("\nif (prop) {\n    s._deserializeAndAssignField(o, prop, " + propNameLiteralToSet + ");\n} else {\n    o" + accessorToSet + "=null;\n}\n");
  }
}

var compileDeserialize =  compileDeserializeJIT ;
var DELIMITER = DELIMETER;
var POSTFIX_TYPE = DELIMITER + "type";
var POSTFIX_DEFAULT = DELIMITER + "default";
var POSTFIX_FORMERLY_SERIALIZED_AS = DELIMITER + "formerlySerializedAs";

function compileDeserializeJIT(self, klass) {
  var attrs = getClassAttrs(klass);
  var props = klass.__values__;
  var sources = ['var prop;'];
  var fastMode = BUILTIN_CLASSID_RE.test(_getClassId(klass));

  for (var p = 0; p < props.length; p++) {
    var propName = props[p];

    var accessorToSet = void 0;
    var propNameLiteralToSet = void 0;

    if (CCClass.IDENTIFIER_RE.test(propName)) {
      propNameLiteralToSet = "\"" + propName + "\"";
      accessorToSet = "." + propName;
    } else {
      propNameLiteralToSet = CCClass.escapeForJS(propName);
      accessorToSet = "[" + propNameLiteralToSet + "]";
    }

    var accessorToGet = accessorToSet;

    if (attrs[propName + POSTFIX_FORMERLY_SERIALIZED_AS]) {
      var propNameToRead = attrs[propName + POSTFIX_FORMERLY_SERIALIZED_AS];

      if (CCClass.IDENTIFIER_RE.test(propNameToRead)) {
        accessorToGet = "." + propNameToRead;
      } else {
        accessorToGet = "[" + CCClass.escapeForJS(propNameToRead) + "]";
      }
    }

    sources.push("prop=d" + accessorToGet + ";");
    sources.push("if(typeof " + ( 'prop') + "!==\"undefined\"){");
    var defaultValue = CCClass.getDefault(attrs[propName + POSTFIX_DEFAULT]);

    if (fastMode) {
      var isPrimitiveType = void 0;
      var userType = attrs[propName + POSTFIX_TYPE];

      if (defaultValue === undefined && userType) {
        isPrimitiveType = userType instanceof PrimitiveType;
      } else {
        var defaultType = typeof defaultValue;
        isPrimitiveType = defaultType === 'string' || defaultType === 'number' || defaultType === 'boolean';
      }

      if (isPrimitiveType) {
        sources.push("o" + accessorToSet + "=prop;");
      } else {
        compileObjectTypeJit(sources, defaultValue, accessorToSet, propNameLiteralToSet, true);
      }
    } else {
      sources.push("" + ("if(typeof " + ( 'prop') + "!==\"object\"){" + 'o') + accessorToSet + "=prop;" + "}else{");
      compileObjectTypeJit(sources, defaultValue, accessorToSet, propNameLiteralToSet, false);
      sources.push('}');
    }

    sources.push('}');
  }

  if (legacyCC.js.isChildClassOf(klass, legacyCC._BaseNode) || legacyCC.js.isChildClassOf(klass, legacyCC.Component)) {
    {
      sources.push('d._id&&(o._id=d._id);');
    }
  }

  if (props[props.length - 1] === '_$erialized') {
    sources.push('o._$erialized=JSON.parse(JSON.stringify(d));');
    sources.push('s._fillPlainObject(o._$erialized,d);');
  }

  return Function('s', 'o', 'd', 'k', sources.join(''));
}

var DeserializerPool = function (_js$Pool) {
  _inheritsLoose(DeserializerPool, _js$Pool);

  function DeserializerPool() {
    return _js$Pool.call(this, function (deserializer) {
      deserializer.clear();
    }, 1) || this;
  }

  var _proto = DeserializerPool.prototype;

  _proto.get = function get(details, classFinder, reportMissingClass, customEnv, ignoreEditorOnly) {
    var cache = this._get();

    if (cache) {
      cache.reset(details, classFinder, reportMissingClass, customEnv, ignoreEditorOnly);
      return cache;
    } else {
      return new _Deserializer(details, classFinder, reportMissingClass, customEnv, ignoreEditorOnly);
    }
  };

  return DeserializerPool;
}(Pool$1);

var _Deserializer = function () {
  function _Deserializer(result, classFinder, reportMissingClass, customEnv, ignoreEditorOnly) {
    this.deserializedList = void 0;
    this.deserializedData = void 0;
    this._ignoreEditorOnly = void 0;
    this.result = result;
    this.customEnv = customEnv;
    this.deserializedList = [];
    this.deserializedData = null;
    this._classFinder = classFinder;
    this._reportMissingClass = reportMissingClass;
    this._onDereferenced = classFinder === null || classFinder === void 0 ? void 0 : classFinder.onDereferenced;
  }

  var _proto2 = _Deserializer.prototype;

  _proto2.reset = function reset(result, classFinder, reportMissingClass, customEnv, ignoreEditorOnly) {
    this.result = result;
    this.customEnv = customEnv;
    this._classFinder = classFinder;
    this._reportMissingClass = reportMissingClass;
    this._onDereferenced = classFinder === null || classFinder === void 0 ? void 0 : classFinder.onDereferenced;
  };

  _proto2.clear = function clear() {
    this.result = null;
    this.customEnv = null;
    this.deserializedList.length = 0;
    this.deserializedData = null;
    this._classFinder = null;
    this._reportMissingClass = null;
    this._onDereferenced = null;
  };

  _proto2.deserialize = function deserialize(serializedData) {
    var fromCCON = false;
    var jsonObj;

    if (serializedData instanceof CCON) {
      fromCCON = true;
      jsonObj = serializedData.document;

      if (serializedData.chunks.length > 0) {
        assertIsTrue(serializedData.chunks.length === 1);
        this._mainBinChunk = serializedData.chunks[0];
      }
    } else {
      jsonObj = serializedData;
    }

    this._serializedData = jsonObj;
    this._context = {
      fromCCON: fromCCON
    };
    var serializedRootObject = Array.isArray(jsonObj) ? jsonObj[0] : jsonObj;

    {
      this.deserializedData = this._deserializeObject(serializedRootObject, 0);
    }

    this._serializedData = undefined;
    this._mainBinChunk = undefined;
    this._context = undefined;
    return this.deserializedData;
  };

  _proto2._deserializeObject = function _deserializeObject(serialized, globalIndex, owner, propName) {
    switch (serialized.__type__) {
      case 'TypedArray':
        return this._deserializeTypedArrayView(serialized);

      case 'TypedArrayRef':
        return this._deserializeTypedArrayViewRef(serialized);

      default:
        if (serialized.__type__) {
          return this._deserializeTypeTaggedObject(serialized, globalIndex, owner, propName);
        } else if (!Array.isArray(serialized)) {
          return this._deserializePlainObject(serialized);
        } else {
          return this._deserializeArray(serialized);
        }

    }
  };

  _proto2._deserializeTypedArrayView = function _deserializeTypedArrayView(value) {
    return globalThis[value.ctor].from(value.array);
  };

  _proto2._deserializeTypedArrayViewRef = function _deserializeTypedArrayViewRef(value) {
    var offset = value.offset,
        length = value.length,
        constructorName = value.ctor;
    var obj = new globalThis[constructorName](this._mainBinChunk.buffer, this._mainBinChunk.byteOffset + offset, length);
    return obj;
  };

  _proto2._deserializeArray = function _deserializeArray(value) {
    var obj = new Array(value.length);
    var prop;

    for (var i = 0; i < value.length; i++) {
      prop = value[i];

      if (typeof prop === 'object' && prop) {
        var isAssetType = this._deserializeAndAssignField(obj, prop, "" + i);

        if (isAssetType) {
          obj[i] = null;
        }
      } else {
        obj[i] = prop;
      }
    }

    return obj;
  };

  _proto2._deserializePlainObject = function _deserializePlainObject(value) {
    var obj = {};

    this._fillPlainObject(obj, value);

    return obj;
  };

  _proto2._deserializeTypeTaggedObject = function _deserializeTypeTaggedObject(value, globalIndex, owner, propName) {
    var _this = this;

    var type = value.__type__;

    var klass = this._classFinder(type, value, owner, propName);

    if (!klass) {
      var notReported = this._classFinder === _getClassById;

      if (notReported) {
        this._reportMissingClass(type);
      }

      return null;
    }

    var createObject = function createObject(constructor) {
      var obj = new constructor();

      if (globalIndex >= 0) {
        _this.deserializedList[globalIndex] = obj;
      }

      return obj;
    };

    {
      var obj = createObject(klass);

      this._deserializeInto(value, obj, klass);

      return obj;
    }
  };

  _proto2._deserializeInto = function _deserializeInto(value, object, constructor, skipCustomized) {
    if (skipCustomized === void 0) {
      skipCustomized = false;
    }

    if (!skipCustomized && object[deserializeTag]) {
      this._runCustomizedDeserialize(value, object, constructor);

      return;
    }

    if (object._deserialize) {
      object._deserialize(value.content, this);

      return;
    }

    if (legacyCC.Class._isCCClass(constructor)) {
      this._deserializeFireClass(object, value, constructor);
    } else {
      this._deserializeFastDefinedObject(object, value, constructor);
    }
  };

  _proto2._runCustomizedDeserialize = function _runCustomizedDeserialize(value, object, constructor) {
    var _this2 = this;

    var serializationInput = {
      readProperty: function readProperty(name) {
        var serializedField = value[name];

        if (typeof serializedField !== 'object' || !serializedField) {
          return serializedField;
        } else {
          return _this2._deserializeObjectField(serializedField);
        }
      },
      readThis: function readThis() {
        _this2._deserializeInto(value, object, constructor, true);
      },
      readSuper: function readSuper() {
        var superConstructor = getSuper(constructor);

        if (superConstructor) {
          _this2._deserializeInto(value, object, superConstructor);
        }
      }
    };
    object[deserializeTag](serializationInput, this._context);
  };

  _proto2._deserializeFireClass = function _deserializeFireClass(obj, serialized, klass) {
    var deserialize;

    if (klass.hasOwnProperty('__deserialize__')) {
      deserialize = klass.__deserialize__;
    } else {
      deserialize = compileDeserialize(this, klass);
      value(klass, '__deserialize__', deserialize, true);
    }

    deserialize(this, obj, serialized, klass);
  };

  _proto2._deserializeAndAssignField = function _deserializeAndAssignField(obj, serializedField, propName) {
    var id = serializedField.__id__;

    if (typeof id === 'number') {
      var field = this.deserializedList[id];

      if (field) {
        obj[propName] = field;
      } else {
        var _this$_onDereferenced;

        var source = this._serializedData[id];

        {
          obj[propName] = this._deserializeObject(source, id, undefined, propName);
        }

        (_this$_onDereferenced = this._onDereferenced) === null || _this$_onDereferenced === void 0 ? void 0 : _this$_onDereferenced.call(this, this.deserializedList, id, obj, propName);
      }
    } else {
      var uuid = serializedField.__uuid__;

      if (uuid) {
        var expectedType = serializedField.__expectedType__;
        this.result.push(obj, propName, uuid, expectedType);
      } else {
        obj[propName] = this._deserializeObject(serializedField, -1);
      }
    }

    return false;
  };

  _proto2._deserializeObjectField = function _deserializeObjectField(serializedField) {
    var id = serializedField.__id__;

    if (typeof id === 'number') {
      var field = this.deserializedList[id];

      if (field) {
        return field;
      } else {
        var source = this._serializedData[id];

        var _field = this._deserializeObject(source, id, undefined, undefined);

        return _field;
      }
    } else {
      var uuid = serializedField.__uuid__;

      if (uuid) {
        var _expectedType = serializedField.__expectedType__;
        throw new Error("Asset reference field serialization is currently not supported in custom serialization.");
      } else {
        return this._deserializeObject(serializedField, -1);
      }
    }
  };

  _proto2._fillPlainObject = function _fillPlainObject(instance, serialized) {
    for (var propName in serialized) {
      if (!serialized.hasOwnProperty(propName)) {
        continue;
      }

      var prop = serialized[propName];

      if (typeof prop !== 'object') {
        if (propName !== '__type__') {
            instance[propName] = prop;
          }
      } else if (prop) {
        var isAssetType = this._deserializeAndAssignField(instance, prop, propName);

        if (isAssetType) {
          instance[propName] = null;
        }
      } else {
        instance[propName] = null;
      }
    }
  };

  _proto2._deserializeFastDefinedObject = function _deserializeFastDefinedObject(instance, serialized, klass) {
    if (klass === legacyCC.Vec2) {
      instance.x = serialized.x || 0;
      instance.y = serialized.y || 0;
      return;
    } else if (klass === legacyCC.Vec3) {
      instance.x = serialized.x || 0;
      instance.y = serialized.y || 0;
      instance.z = serialized.z || 0;
      return;
    } else if (klass === legacyCC.Color) {
      instance.r = serialized.r || 0;
      instance.g = serialized.g || 0;
      instance.b = serialized.b || 0;
      var a = serialized.a;
      instance.a = a === undefined ? 255 : a;
      return;
    } else if (klass === legacyCC.Size) {
      instance.width = serialized.width || 0;
      instance.height = serialized.height || 0;
      return;
    }

    var attrs = getClassAttrs(klass);
    var props = klass.__values__;

    for (var i = 0; i < props.length; i++) {
      var propName = props[i];
      var value = serialized[propName];
      var exists = value !== undefined || serialized.hasOwnProperty(propName);

      if (!exists) {
        value = CCClass.getDefault(attrs[propName + POSTFIX_DEFAULT]);
      }

      if (typeof value !== 'object') {
        instance[propName] = value;
      } else if (value) {
        this._deserializeAndAssignField(instance, value, propName);
      } else {
        instance[propName] = null;
      }
    }
  };

  return _Deserializer;
}();

_Deserializer.pool = new DeserializerPool();
function deserializeDynamic(data, details, options) {
  var _options$reportMissin;

  options = options || {};
  var classFinder = options.classFinder || _getClassById;
  var createAssetRefs = options.createAssetRefs || sys.platform === Platform.EDITOR_CORE;
  var customEnv = options.customEnv;
  var ignoreEditorOnly = options.ignoreEditorOnly;
  var reportMissingClass = (_options$reportMissin = options.reportMissingClass) !== null && _options$reportMissin !== void 0 ? _options$reportMissin : legacyCC.deserialize.reportMissingClass;
  details.init();

  var deserializer = _Deserializer.pool.get(details, classFinder, reportMissingClass, customEnv, ignoreEditorOnly);

  legacyCC.game._isCloning = true;
  var res = deserializer.deserialize(data);
  legacyCC.game._isCloning = false;

  _Deserializer.pool.put(deserializer);

  if (createAssetRefs) {
    details.assignAssetsBy(EditorExtends.serialize.asAsset);
  }

  return res;
}

function reportMissingClass(id) {
  {
    warnID(5302, id);
  }
}

var SUPPORT_MIN_FORMAT_VERSION = 1;
var EMPTY_PLACEHOLDER = 0;
var BuiltinValueTypes = [Vec2, Vec3, Vec4, Quat, Color, Size, Rect, Mat4];

function BuiltinValueTypeParsers_xyzw(obj, data) {
  obj.x = data[1];
  obj.y = data[2];
  obj.z = data[3];
  obj.w = data[4];
}

var BuiltinValueTypeSetters = [function (obj, data) {
  obj.x = data[1];
  obj.y = data[2];
}, function (obj, data) {
  obj.x = data[1];
  obj.y = data[2];
  obj.z = data[3];
}, BuiltinValueTypeParsers_xyzw, BuiltinValueTypeParsers_xyzw, function (obj, data) {
  obj._val = data[1];
}, function (obj, data) {
  obj.width = data[1];
  obj.height = data[2];
}, function (obj, data) {
  obj.x = data[1];
  obj.y = data[2];
  obj.width = data[3];
  obj.height = data[4];
}, function (obj, data) {
  Mat4.fromArray(obj, data, 1);
}];

var DataTypeID = {
  SimpleType: 0,
  InstanceRef: 1,
  Array_InstanceRef: 2,
  Array_AssetRefByInnerObj: 3,
  Class: 4,
  ValueTypeCreated: 5,
  AssetRefByInnerObj: 6,
  TRS: 7,
  ValueType: 8,
  Array_Class: 9,
  CustomizedClass: 10,
  Dict: 11,
  Array: 12,
  ARRAY_LENGTH: 13
};
var CLASS_TYPE = 0;
var CLASS_KEYS = 1;
var CLASS_PROP_TYPE_OFFSET = 2;
var MASK_CLASS = 0;
var OBJ_DATA_MASK = 0;
var CUSTOM_OBJ_DATA_CLASS = 0;
var CUSTOM_OBJ_DATA_CONTENT = 1;
var VALUETYPE_SETTER = 0;
var DICT_JSON_LAYOUT = 0;
var ARRAY_ITEM_VALUES = 0;
var Refs = {
  EACH_RECORD_LENGTH: 3,
  OWNER_OFFSET: 0,
  KEY_OFFSET: 1,
  TARGET_OFFSET: 2
};
var File = {
  Version: 0,
  Context: 0,
  SharedUuids: 1,
  SharedStrings: 2,
  SharedClasses: 3,
  SharedMasks: 4,
  Instances: 5,
  InstanceTypes: 6,
  Refs: 7,
  DependObjs: 8,
  DependKeys: 9,
  DependUuidIndices: 10,
  ARRAY_LENGTH: 11
};
var PACKED_SECTIONS = File.Instances;
var Details = function () {
  function Details() {
    this.uuidObjList = null;
    this.uuidPropList = null;
    this.uuidList = null;
    this.uuidTypeList = [];
  }

  var _proto = Details.prototype;

  _proto.init = function init(data) {
    if ( data) {
      this.uuidObjList = data[File.DependObjs];
      this.uuidPropList = data[File.DependKeys];
      this.uuidList = data[File.DependUuidIndices];
    } else {
      var used = this.uuidList;

      if (!used) {
        this.uuidList = [];
        this.uuidObjList = [];
        this.uuidPropList = [];
        this.uuidTypeList = [];
      }
    }
  };

  _proto.reset = function reset() {
    {
      var used = this.uuidList;

      if (used) {
        this.uuidList.length = 0;
        this.uuidObjList.length = 0;
        this.uuidPropList.length = 0;
        this.uuidTypeList.length = 0;
      }
    }
  };

  _proto.push = function push(obj, propName, uuid, type) {
    this.uuidObjList.push(obj);
    this.uuidPropList.push(propName);
    this.uuidList.push(uuid);
    this.uuidTypeList.push(type || '');
  };

  return Details;
}();
Details.pool = new Pool$1(function (obj) {
  obj.reset();
}, 5);

Details.pool.get = function () {
  return this._get() || new Details();
};

function dereference(refs, instances, strings) {
  var dataLength = refs.length - 1;
  var i = 0;
  var instanceOffset = refs[dataLength] * Refs.EACH_RECORD_LENGTH;

  for (; i < instanceOffset; i += Refs.EACH_RECORD_LENGTH) {
    var _owner = refs[i];
    var target = instances[refs[i + Refs.TARGET_OFFSET]];
    var keyIndex = refs[i + Refs.KEY_OFFSET];

    if (keyIndex >= 0) {
      _owner[strings[keyIndex]] = target;
    } else {
      _owner[~keyIndex] = target;
    }
  }

  for (; i < dataLength; i += Refs.EACH_RECORD_LENGTH) {
    var _owner2 = instances[refs[i]];
    var _target = instances[refs[i + Refs.TARGET_OFFSET]];
    var _keyIndex = refs[i + Refs.KEY_OFFSET];

    if (_keyIndex >= 0) {
      _owner2[strings[_keyIndex]] = _target;
    } else {
      _owner2[~_keyIndex] = _target;
    }
  }
}

function deserializeCCObject(data, objectData) {
  var mask = data[File.SharedMasks][objectData[OBJ_DATA_MASK]];
  var clazz = mask[MASK_CLASS];
  var ctor = clazz[CLASS_TYPE];
  var obj = new ctor();
  var keys = clazz[CLASS_KEYS];
  var classTypeOffset = clazz[CLASS_PROP_TYPE_OFFSET];
  var maskTypeOffset = mask[mask.length - 1];
  var i = MASK_CLASS + 1;

  for (; i < maskTypeOffset; ++i) {
    var _key = keys[mask[i]];
    obj[_key] = objectData[i];
  }

  for (; i < objectData.length; ++i) {
    var _key2 = keys[mask[i]];
    var _type2 = clazz[mask[i] + classTypeOffset];
    var op = ASSIGNMENTS[_type2];
    op(data, obj, _key2, objectData[i]);
  }

  return obj;
}

function deserializeCustomCCObject(data, ctor, value) {
  var obj = new ctor();

  if (obj._deserialize) {
    obj._deserialize(value, data[File.Context]);
  } else {
    errorID(5303, getClassName(ctor));
  }

  return obj;
}

function assignSimple(data, owner, key, value) {
  owner[key] = value;
}

function assignInstanceRef(data, owner, key, value) {
  if (value >= 0) {
    owner[key] = data[File.Instances][value];
  } else {
    data[File.Refs][~value * Refs.EACH_RECORD_LENGTH] = owner;
  }
}

function genArrayParser(parser) {
  return function (data, owner, key, value) {
    owner[key] = value;

    for (var i = 0; i < value.length; ++i) {
      parser(data, value, i, value[i]);
    }
  };
}

function parseAssetRefByInnerObj(data, owner, key, value) {
  owner[key] = null;
  data[File.DependObjs][value] = owner;
}

function parseClass(data, owner, key, value) {
  owner[key] = deserializeCCObject(data, value);
}

function parseCustomClass(data, owner, key, value) {
  var ctor = data[File.SharedClasses][value[CUSTOM_OBJ_DATA_CLASS]];
  owner[key] = deserializeCustomCCObject(data, ctor, value[CUSTOM_OBJ_DATA_CONTENT]);
}

function parseValueTypeCreated(data, owner, key, value) {
  BuiltinValueTypeSetters[value[VALUETYPE_SETTER]](owner[key], value);
}

function parseValueType(data, owner, key, value) {
  var val = new BuiltinValueTypes[value[VALUETYPE_SETTER]]();
  BuiltinValueTypeSetters[value[VALUETYPE_SETTER]](val, value);
  owner[key] = val;
}

function parseTRS(data, owner, key, value) {
  var typedArray = owner[key];
  typedArray.set(value);
}

function parseDict(data, owner, key, value) {
  var dict = value[DICT_JSON_LAYOUT];
  owner[key] = dict;

  for (var i = DICT_JSON_LAYOUT + 1; i < value.length; i += 3) {
    var subKey = value[i];
    var subType = value[i + 1];
    var subValue = value[i + 2];
    var op = ASSIGNMENTS[subType];
    op(data, dict, subKey, subValue);
  }
}

function parseArray(data, owner, key, value) {
  var array = value[ARRAY_ITEM_VALUES];
  owner[key] = array;

  for (var i = 0; i < array.length; ++i) {
    var subValue = array[i];
    var _type3 = value[i + 1];

    if (_type3 !== DataTypeID.SimpleType) {
      var op = ASSIGNMENTS[_type3];
      op(data, array, i, subValue);
    }
  }
}

var ASSIGNMENTS = new Array(DataTypeID.ARRAY_LENGTH);
ASSIGNMENTS[DataTypeID.SimpleType] = assignSimple;
ASSIGNMENTS[DataTypeID.InstanceRef] = assignInstanceRef;
ASSIGNMENTS[DataTypeID.Array_InstanceRef] = genArrayParser(assignInstanceRef);
ASSIGNMENTS[DataTypeID.Array_AssetRefByInnerObj] = genArrayParser(parseAssetRefByInnerObj);
ASSIGNMENTS[DataTypeID.Class] = parseClass;
ASSIGNMENTS[DataTypeID.ValueTypeCreated] = parseValueTypeCreated;
ASSIGNMENTS[DataTypeID.AssetRefByInnerObj] = parseAssetRefByInnerObj;
ASSIGNMENTS[DataTypeID.TRS] = parseTRS;
ASSIGNMENTS[DataTypeID.ValueType] = parseValueType;
ASSIGNMENTS[DataTypeID.Array_Class] = genArrayParser(parseClass);
ASSIGNMENTS[DataTypeID.CustomizedClass] = parseCustomClass;
ASSIGNMENTS[DataTypeID.Dict] = parseDict;
ASSIGNMENTS[DataTypeID.Array] = parseArray;

function parseInstances(data) {
  var instances = data[File.Instances];
  var instanceTypes = data[File.InstanceTypes];
  var instanceTypesLen = instanceTypes === EMPTY_PLACEHOLDER ? 0 : instanceTypes.length;
  var rootIndex = instances[instances.length - 1];
  var normalObjectCount = instances.length - instanceTypesLen;

  if (typeof rootIndex !== 'number') {
    rootIndex = 0;
  } else {
    if (rootIndex < 0) {
      rootIndex = ~rootIndex;
    }

    --normalObjectCount;
  }

  var insIndex = 0;

  for (; insIndex < normalObjectCount; ++insIndex) {
    instances[insIndex] = deserializeCCObject(data, instances[insIndex]);
  }

  var classes = data[File.SharedClasses];

  for (var typeIndex = 0; typeIndex < instanceTypesLen; ++typeIndex, ++insIndex) {
    var _type4 = instanceTypes[typeIndex];
    var eachData = instances[insIndex];

    if (_type4 >= 0) {
      var ctor = classes[_type4];
      instances[insIndex] = deserializeCustomCCObject(data, ctor, eachData);
    } else {
      _type4 = ~_type4;
      var op = ASSIGNMENTS[_type4];
      op(data, instances, insIndex, eachData);
    }
  }

  return rootIndex;
}

function getMissingClass(hasCustomFinder, type, reportMissingClass) {
  if (!hasCustomFinder) {
    reportMissingClass(type);
  }

  return Object;
}

function doLookupClass(classFinder, type, container, index, silent, hasCustomFinder, reportMissingClass) {
  var klass = classFinder(type);

  if (!klass) {
    if (silent) {
      container[index] = function (c, i, t) {
        return function proxy() {
          var actualClass = classFinder(t) || getMissingClass(hasCustomFinder, t, reportMissingClass);
          c[i] = actualClass;
          return new actualClass();
        };
      }(container, index, type);

      return;
    } else {
      klass = getMissingClass(hasCustomFinder, type, reportMissingClass);
    }
  }

  container[index] = klass;
}

function lookupClasses(data, silent, customFinder, reportMissingClass) {
  var classFinder = customFinder || _getClassById;
  var classes = data[File.SharedClasses];

  for (var i = 0; i < classes.length; ++i) {
    var klassLayout = classes[i];

    if (typeof klassLayout !== 'string') {

      var _type5 = klassLayout[CLASS_TYPE];
      doLookupClass(classFinder, _type5, klassLayout, CLASS_TYPE, silent, customFinder, reportMissingClass);
    } else {
      doLookupClass(classFinder, klassLayout, classes, i, silent, customFinder, reportMissingClass);
    }
  }
}

function cacheMasks(data) {
  var masks = data[File.SharedMasks];

  if (masks) {
    var classes = data[File.SharedClasses];

    for (var i = 0; i < masks.length; ++i) {
      var mask = masks[i];
      mask[MASK_CLASS] = classes[mask[MASK_CLASS]];
    }
  }
}

function parseResult(data) {
  var instances = data[File.Instances];
  var sharedStrings = data[File.SharedStrings];
  var dependSharedUuids = data[File.SharedUuids];
  var dependObjs = data[File.DependObjs];
  var dependKeys = data[File.DependKeys];
  var dependUuids = data[File.DependUuidIndices];

  for (var i = 0; i < dependObjs.length; ++i) {
    var _obj2 = dependObjs[i];

    if (typeof _obj2 === 'number') {
      dependObjs[i] = instances[_obj2];
    }

    var _key3 = dependKeys[i];

    if (typeof _key3 === 'number') {
      if (_key3 >= 0) {
        _key3 = sharedStrings[_key3];
      } else {
        _key3 = ~_key3;
      }

      dependKeys[i] = _key3;
    }

    var _uuid2 = dependUuids[i];

    if (typeof _uuid2 === 'number') {
      dependUuids[i] = dependSharedUuids[_uuid2];
    }
  }
}

function isCompiledJson(json) {
  if (Array.isArray(json)) {
    var version = json[0];
    return typeof version === 'number' || version instanceof FileInfo;
  } else {
    return false;
  }
}
function deserialize(data, details, options) {
  if (typeof data === 'string') {
    data = JSON.parse(data);
  }

  var borrowDetails = !details;
  details = details || Details.pool.get();
  var res;

  if ( !isCompiledJson(data)) {
    res = deserializeDynamic(data, details, options);
  } else {
    details.init(data);
    options = options || {};
    var version = data[File.Version];
    var preprocessed = false;

    if (typeof version === 'object') {
      preprocessed = version.preprocessed;
      version = version.version;
    }

    if (version < SUPPORT_MIN_FORMAT_VERSION) {
      throw new Error(getError(5304, version));
    }

    options._version = version;
    options.result = details;
    data[File.Context] = options;

    if (!preprocessed) {
      var _options$reportMissin;

      lookupClasses(data, false, options.classFinder, (_options$reportMissin = options.reportMissingClass) !== null && _options$reportMissin !== void 0 ? _options$reportMissin : deserialize.reportMissingClass);
      cacheMasks(data);
    }

    legacyCC.game._isCloning = true;
    var instances = data[File.Instances];
    var rootIndex = parseInstances(data);
    legacyCC.game._isCloning = false;

    if (data[File.Refs]) {
      dereference(data[File.Refs], instances, data[File.SharedStrings]);
    }

    parseResult(data);
    res = instances[rootIndex];
  }

  if (borrowDetails) {
    Details.pool.put(details);
  }

  return res;
}
deserialize.Details = Details;
deserialize.reportMissingClass = reportMissingClass;

var FileInfo = function FileInfo(version) {
  this.preprocessed = true;
  this.version = version;
};

function unpackJSONs(data, classFinder, reportMissingClass) {
  if (data[File.Version] < SUPPORT_MIN_FORMAT_VERSION) {
    throw new Error(getError(5304, data[File.Version]));
  }

  lookupClasses(data, true, classFinder, reportMissingClass !== null && reportMissingClass !== void 0 ? reportMissingClass : deserialize.reportMissingClass);
  cacheMasks(data);
  var version = new FileInfo(data[File.Version]);
  var sharedUuids = data[File.SharedUuids];
  var sharedStrings = data[File.SharedStrings];
  var sharedClasses = data[File.SharedClasses];
  var sharedMasks = data[File.SharedMasks];
  var sections = data[PACKED_SECTIONS];

  for (var i = 0; i < sections.length; ++i) {
    sections[i].unshift(version, sharedUuids, sharedStrings, sharedClasses, sharedMasks);
  }

  return sections;
}
function packCustomObjData(type, data, hasNativeDep) {
  return [SUPPORT_MIN_FORMAT_VERSION, EMPTY_PLACEHOLDER, EMPTY_PLACEHOLDER, [type], EMPTY_PLACEHOLDER, hasNativeDep ? [data, ~0] : [data], [0], EMPTY_PLACEHOLDER, [], [], []];
}
function hasNativeDep(data) {
  var instances = data[File.Instances];
  var rootInfo = instances[instances.length - 1];

  if (typeof rootInfo !== 'number') {
    return false;
  } else {
    return rootInfo < 0;
  }
}

function getDependUuidList(json) {
  var sharedUuids = json[File.SharedUuids];
  return json[File.DependUuidIndices].map(function (index) {
    return sharedUuids[index];
  });
}

function parseUuidDependencies(serialized) {
  {
    return getDependUuidList(serialized);
  }
}

legacyCC.deserialize = deserialize;

var Destroyed$1 = CCObject.Flags.Destroyed;
var PersistentMask$1 = CCObject.Flags.PersistentMask;
var objsToClearTmpVar = [];
function instantiate(original, internalForce) {

  var clone;

  if (original instanceof CCObject) {
    if (original._instantiate) {
      legacyCC.game._isCloning = true;
      clone = original._instantiate(null, true);
      legacyCC.game._isCloning = false;
      return clone;
    } else if (original instanceof legacyCC.Asset) {
      throw new TypeError(getError(6903));
    }
  }

  legacyCC.game._isCloning = true;
  clone = doInstantiate(original);
  legacyCC.game._isCloning = false;
  return clone;
}

function doInstantiate(obj, parent) {

  var clone;

  if (obj._iN$t) {
    clone = obj._iN$t;
  } else if (obj.constructor) {
    var klass = obj.constructor;
    clone = new klass();
  } else {
    clone = Object.create(null);
  }

  enumerateObject(obj, clone, parent);

  for (var i = 0, len = objsToClearTmpVar.length; i < len; ++i) {
    objsToClearTmpVar[i]._iN$t = null;
  }

  objsToClearTmpVar.length = 0;
  return clone;
}

function enumerateCCClass(klass, obj, clone, parent) {
  var props = klass.__values__;

  for (var p = 0; p < props.length; p++) {
    var key = props[p];
    var value = obj[key];

    if (typeof value === 'object' && value) {
      var initValue = clone[key];

      if (initValue instanceof ValueType && initValue.constructor === value.constructor) {
        initValue.set(value);
      } else {
        clone[key] = value._iN$t || instantiateObj(value, parent);
      }
    } else {
      clone[key] = value;
    }
  }
}

function enumerateObject(obj, clone, parent) {
  js.value(obj, '_iN$t', clone, true);
  objsToClearTmpVar.push(obj);
  var klass = obj.constructor;

  if (legacyCC.Class._isCCClass(klass)) {
    enumerateCCClass(klass, obj, clone, parent);
  } else {
    for (var key in obj) {
      if (!obj.hasOwnProperty(key) || key.charCodeAt(0) === 95 && key.charCodeAt(1) === 95 && key !== '__type__') {
        continue;
      }

      var value = obj[key];

      if (typeof value === 'object' && value) {
        if (value === clone) {
          continue;
        }

        clone[key] = value._iN$t || instantiateObj(value, parent);
      } else {
        clone[key] = value;
      }
    }
  }

  if (obj instanceof CCObject) {
    clone._objFlags &= PersistentMask$1;
  }
}

function instantiateObj(obj, parent) {
  if (obj instanceof ValueType) {
    return obj.clone();
  }

  if (obj instanceof legacyCC.Asset) {
    return obj;
  }

  var clone;

  if (ArrayBuffer.isView(obj)) {
    var len = obj.length;
    clone = new obj.constructor(len);
    obj._iN$t = clone;
    objsToClearTmpVar.push(obj);

    for (var i = 0; i < len; ++i) {
      clone[i] = obj[i];
    }

    return clone;
  }

  if (Array.isArray(obj)) {
    var _len = obj.length;
    clone = new Array(_len);
    obj._iN$t = clone;
    objsToClearTmpVar.push(obj);

    for (var _i = 0; _i < _len; ++_i) {
      var value = obj[_i];

      if (typeof value === 'object' && value) {
        clone[_i] = value._iN$t || instantiateObj(value, parent);
      } else {
        clone[_i] = value;
      }
    }

    return clone;
  } else if (obj._objFlags & Destroyed$1) {
    return null;
  }

  var ctor = obj.constructor;

  if (legacyCC.Class._isCCClass(ctor)) {
    if (parent) {
      if (parent instanceof legacyCC.Component) {
        if (obj instanceof legacyCC._BaseNode || obj instanceof legacyCC.Component) {
          return obj;
        }
      } else if (parent instanceof legacyCC._BaseNode) {
        if (obj instanceof legacyCC._BaseNode) {
          if (!obj.isChildOf(parent)) {
            return obj;
          }
        } else if (obj instanceof legacyCC.Component) {
          if (obj.node && !obj.node.isChildOf(parent)) {
            return obj;
          }
        }
      }
    }

    clone = new ctor();
  } else if (ctor === Object) {
    clone = {};
  } else if (!ctor) {
    clone = Object.create(null);
  } else {
    return obj;
  }

  enumerateObject(obj, clone, parent);
  return clone;
}

instantiate._clone = doInstantiate;
legacyCC.instantiate = instantiate;

var _dec$6, _class$6, _class2$5, _descriptor$4, _descriptor2$2, _descriptor3$1, _descriptor4, _class3$2, _temp$4, _BuiltinElementTypeTr;
var StorageUnit;

(function (StorageUnit) {
  StorageUnit[StorageUnit["Uint8"] = 0] = "Uint8";
  StorageUnit[StorageUnit["Uint16"] = 1] = "Uint16";
  StorageUnit[StorageUnit["Uint32"] = 2] = "Uint32";
  StorageUnit[StorageUnit["Int8"] = 3] = "Int8";
  StorageUnit[StorageUnit["Int16"] = 4] = "Int16";
  StorageUnit[StorageUnit["Int32"] = 5] = "Int32";
  StorageUnit[StorageUnit["Float32"] = 6] = "Float32";
  StorageUnit[StorageUnit["Float64"] = 7] = "Float64";
})(StorageUnit || (StorageUnit = {}));

var ElementType;

(function (ElementType) {
  ElementType[ElementType["Scalar"] = 0] = "Scalar";
  ElementType[ElementType["Vec2"] = 1] = "Vec2";
  ElementType[ElementType["Vec3"] = 2] = "Vec3";
  ElementType[ElementType["Vec4"] = 3] = "Vec4";
  ElementType[ElementType["Quat"] = 4] = "Quat";
  ElementType[ElementType["Mat4"] = 5] = "Mat4";
})(ElementType || (ElementType = {}));

var elementTypeBits = 3;
function combineStorageUnitElementType(unit, elementType) {
  return (elementType << elementTypeBits) + unit;
}
function extractStorageUnitElementType(combined) {
  return {
    storageUnit: ~(-1 << elementTypeBits) & combined,
    elementType: combined >> elementTypeBits
  };
}
var CompactValueTypeArray = (_dec$6 = ccclass('cc.CompactValueTypeArray'), _dec$6(_class$6 = (_class2$5 = (_temp$4 = _class3$2 = function () {
  function CompactValueTypeArray() {
    _initializerDefineProperty(this, "_byteOffset", _descriptor$4, this);

    _initializerDefineProperty(this, "_unitCount", _descriptor2$2, this);

    _initializerDefineProperty(this, "_unitElement", _descriptor3$1, this);

    _initializerDefineProperty(this, "_length", _descriptor4, this);
  }

  CompactValueTypeArray.lengthFor = function lengthFor(values, elementType, unit) {
    var elementTraits = getElementTraits(elementType);
    return elementTraits.requiredUnits * values.length * getStorageConstructor(unit).BYTES_PER_ELEMENT;
  };

  CompactValueTypeArray.compress = function compress(values, elementType, unit, arrayBuffer, byteOffset, presumedByteOffset) {
    var elementTraits = getElementTraits(elementType);
    var storageConstructor = getStorageConstructor(unit);
    var unitCount = elementTraits.requiredUnits * values.length;
    var storage = new storageConstructor(arrayBuffer, byteOffset, unitCount);

    for (var i = 0; i < values.length; ++i) {
      elementTraits.compress(storage, i, values[i]);
    }

    var result = new CompactValueTypeArray();
    result._unitElement = combineStorageUnitElementType(unit, elementType);
    result._byteOffset = presumedByteOffset;
    result._unitCount = unitCount;
    result._length = values.length;
    return result;
  };

  var _proto = CompactValueTypeArray.prototype;

  _proto.decompress = function decompress(arrayBuffer) {
    var _extractStorageUnitEl = extractStorageUnitElementType(this._unitElement),
        storageUnit = _extractStorageUnitEl.storageUnit,
        elementType = _extractStorageUnitEl.elementType;

    var elementTraits = getElementTraits(elementType);
    var storageConstructor = getStorageConstructor(storageUnit);
    var storage = new storageConstructor(arrayBuffer, this._byteOffset, this._unitCount);
    var result = new Array(this._length);

    for (var i = 0; i < this._length; ++i) {
      result[i] = elementTraits.decompress(storage, i);
    }

    return result;
  };

  return CompactValueTypeArray;
}(), _class3$2.StorageUnit = StorageUnit, _class3$2.ElementType = ElementType, _temp$4), (_descriptor$4 = _applyDecoratedDescriptor(_class2$5.prototype, "_byteOffset", [serializable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return 0;
  }
}), _descriptor2$2 = _applyDecoratedDescriptor(_class2$5.prototype, "_unitCount", [serializable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return 0;
  }
}), _descriptor3$1 = _applyDecoratedDescriptor(_class2$5.prototype, "_unitElement", [serializable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return combineStorageUnitElementType(StorageUnit.Uint8, ElementType.Scalar);
  }
}), _descriptor4 = _applyDecoratedDescriptor(_class2$5.prototype, "_length", [serializable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return 0;
  }
})), _class2$5)) || _class$6);

function getElementTraits(elementType) {
  return BuiltinElementTypeTraits[elementType];
}

function getStorageConstructor(unit) {
  switch (unit) {
    case StorageUnit.Uint8:
      return Uint8Array;

    case StorageUnit.Uint16:
      return Uint16Array;

    case StorageUnit.Uint32:
      return Uint32Array;

    case StorageUnit.Int8:
      return Int8Array;

    case StorageUnit.Int16:
      return Int16Array;

    case StorageUnit.Int32:
      return Int32Array;

    case StorageUnit.Float32:
      return Float32Array;

    case StorageUnit.Float64:
      return Float64Array;
  }
}

var BuiltinElementTypeTraits = (_BuiltinElementTypeTr = {}, _BuiltinElementTypeTr[ElementType.Scalar] = {
  requiredUnits: 1,
  compress: function compress(storage, index, value) {
    storage[index] = value;
  },
  decompress: function decompress(storage, index) {
    return storage[index];
  }
}, _BuiltinElementTypeTr[ElementType.Vec2] = {
  requiredUnits: 2,
  compress: function compress(storage, index, value) {
    storage[index * 2] = value.x;
    storage[index * 2 + 1] = value.y;
  },
  decompress: function decompress(storage, index) {
    return new Vec3(storage[index * 2], storage[index * 2 + 1]);
  }
}, _BuiltinElementTypeTr[ElementType.Vec3] = {
  requiredUnits: 3,
  compress: function compress(storage, index, value) {
    storage[index * 3] = value.x;
    storage[index * 3 + 1] = value.y;
    storage[index * 3 + 2] = value.z;
  },
  decompress: function decompress(storage, index) {
    return new Vec3(storage[index * 3], storage[index * 3 + 1], storage[index * 3 + 2]);
  }
}, _BuiltinElementTypeTr[ElementType.Vec4] = {
  requiredUnits: 4,
  compress: function compress(storage, index, value) {
    storage[index * 4] = value.x;
    storage[index * 4 + 1] = value.y;
    storage[index * 4 + 2] = value.z;
    storage[index * 4 + 3] = value.w;
  },
  decompress: function decompress(storage, index) {
    return new Vec4(storage[index * 4], storage[index * 4 + 1], storage[index * 4 + 2], storage[index * 4 + 3]);
  }
}, _BuiltinElementTypeTr[ElementType.Quat] = {
  requiredUnits: 4,
  compress: function compress(storage, index, value) {
    storage[index * 4] = value.x;
    storage[index * 4 + 1] = value.y;
    storage[index * 4 + 2] = value.z;
    storage[index * 4 + 3] = value.w;
  },
  decompress: function decompress(storage, index) {
    return new Quat(storage[index * 4], storage[index * 4 + 1], storage[index * 4 + 2], storage[index * 4 + 3]);
  }
}, _BuiltinElementTypeTr[ElementType.Mat4] = {
  requiredUnits: 16,
  compress: function compress(storage, index, value) {
    Mat4.toArray(storage, value, index * 16);
  },
  decompress: function decompress(storage, index) {
    return Mat4.fromArray(new Mat4(), storage, index * 16);
  }
}, _BuiltinElementTypeTr);

legacyCC._decorator = _decorator;

function constant() {
  return 0;
}
function linear(k) {
  return k;
}
function quadIn(k) {
  return k * k;
}
function quadOut(k) {
  return k * (2 - k);
}
function quadInOut(k) {
  k *= 2;

  if (k < 1) {
    return 0.5 * k * k;
  }

  return -0.5 * (--k * (k - 2) - 1);
}
function cubicIn(k) {
  return k * k * k;
}
function cubicOut(k) {
  return --k * k * k + 1;
}
function cubicInOut(k) {
  k *= 2;

  if (k < 1) {
    return 0.5 * k * k * k;
  }

  return 0.5 * ((k -= 2) * k * k + 2);
}
function quartIn(k) {
  return k * k * k * k;
}
function quartOut(k) {
  return 1 - --k * k * k * k;
}
function quartInOut(k) {
  k *= 2;

  if (k < 1) {
    return 0.5 * k * k * k * k;
  }

  return -0.5 * ((k -= 2) * k * k * k - 2);
}
function quintIn(k) {
  return k * k * k * k * k;
}
function quintOut(k) {
  return --k * k * k * k * k + 1;
}
function quintInOut(k) {
  k *= 2;

  if (k < 1) {
    return 0.5 * k * k * k * k * k;
  }

  return 0.5 * ((k -= 2) * k * k * k * k + 2);
}
function sineIn(k) {
  if (k === 1) {
    return 1;
  }

  return 1 - Math.cos(k * Math.PI / 2);
}
function sineOut(k) {
  return Math.sin(k * Math.PI / 2);
}
function sineInOut(k) {
  return 0.5 * (1 - Math.cos(Math.PI * k));
}
function expoIn(k) {
  return k === 0 ? 0 : Math.pow(1024, k - 1);
}
function expoOut(k) {
  return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);
}
function expoInOut(k) {
  if (k === 0) {
    return 0;
  }

  if (k === 1) {
    return 1;
  }

  k *= 2;

  if (k < 1) {
    return 0.5 * Math.pow(1024, k - 1);
  }

  return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);
}
function circIn(k) {
  return 1 - Math.sqrt(1 - k * k);
}
function circOut(k) {
  return Math.sqrt(1 - --k * k);
}
function circInOut(k) {
  k *= 2;

  if (k < 1) {
    return -0.5 * (Math.sqrt(1 - k * k) - 1);
  }

  return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
}
function elasticIn(k) {
  var s;
  var a = 0.1;
  var p = 0.4;

  if (k === 0) {
    return 0;
  }

  if (k === 1) {
    return 1;
  }

  if (!a || a < 1) {
    a = 1;
    s = p / 4;
  } else {
    s = p * Math.asin(1 / a) / (2 * Math.PI);
  }

  return -(a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
}
function elasticOut(k) {
  var s;
  var a = 0.1;
  var p = 0.4;

  if (k === 0) {
    return 0;
  }

  if (k === 1) {
    return 1;
  }

  if (!a || a < 1) {
    a = 1;
    s = p / 4;
  } else {
    s = p * Math.asin(1 / a) / (2 * Math.PI);
  }

  return a * Math.pow(2, -10 * k) * Math.sin((k - s) * (2 * Math.PI) / p) + 1;
}
function elasticInOut(k) {
  var s;
  var a = 0.1;
  var p = 0.4;

  if (k === 0) {
    return 0;
  }

  if (k === 1) {
    return 1;
  }

  if (!a || a < 1) {
    a = 1;
    s = p / 4;
  } else {
    s = p * Math.asin(1 / a) / (2 * Math.PI);
  }

  k *= 2;

  if (k < 1) {
    return -0.5 * (a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
  }

  return a * Math.pow(2, -10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;
}
function backIn(k) {
  if (k === 1) {
    return 1;
  }

  var s = 1.70158;
  return k * k * ((s + 1) * k - s);
}
function backOut(k) {
  if (k === 0) {
    return 0;
  }

  var s = 1.70158;
  return --k * k * ((s + 1) * k + s) + 1;
}
function backInOut(k) {
  var s = 1.70158 * 1.525;
  k *= 2;

  if (k < 1) {
    return 0.5 * (k * k * ((s + 1) * k - s));
  }

  return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);
}
function bounceIn(k) {
  return 1 - bounceOut(1 - k);
}
function bounceOut(k) {
  if (k < 1 / 2.75) {
    return 7.5625 * k * k;
  } else if (k < 2 / 2.75) {
    return 7.5625 * (k -= 1.5 / 2.75) * k + 0.75;
  } else if (k < 2.5 / 2.75) {
    return 7.5625 * (k -= 2.25 / 2.75) * k + 0.9375;
  } else {
    return 7.5625 * (k -= 2.625 / 2.75) * k + 0.984375;
  }
}
function bounceInOut(k) {
  if (k < 0.5) {
    return bounceIn(k * 2) * 0.5;
  }

  return bounceOut(k * 2 - 1) * 0.5 + 0.5;
}
function smooth(k) {
  if (k <= 0) {
    return 0;
  }

  if (k >= 1) {
    return 1;
  }

  return k * k * (3 - 2 * k);
}
function fade(k) {
  if (k <= 0) {
    return 0;
  }

  if (k >= 1) {
    return 1;
  }

  return k * k * k * (k * (k * 6 - 15) + 10);
}
var quadOutIn = _makeOutIn(quadIn, quadOut);
var cubicOutIn = _makeOutIn(cubicIn, cubicOut);
var quartOutIn = _makeOutIn(quartIn, quartOut);
var quintOutIn = _makeOutIn(quintIn, quintOut);
var sineOutIn = _makeOutIn(sineIn, sineOut);
var expoOutIn = _makeOutIn(expoIn, expoOut);
var circOutIn = _makeOutIn(circIn, circOut);
var elasticOutIn = _makeOutIn(elasticIn, elasticOut);
var backOutIn = _makeOutIn(backIn, backOut);
var bounceOutIn = _makeOutIn(bounceIn, bounceOut);

function _makeOutIn(fnIn, fnOut) {
  return function (k) {
    if (k < 0.5) {
      return fnOut(k * 2) / 2;
    }

    return fnIn(2 * k - 1) / 2 + 0.5;
  };
}

var easing = /*#__PURE__*/Object.freeze({
    __proto__: null,
    constant: constant,
    linear: linear,
    quadIn: quadIn,
    quadOut: quadOut,
    quadInOut: quadInOut,
    cubicIn: cubicIn,
    cubicOut: cubicOut,
    cubicInOut: cubicInOut,
    quartIn: quartIn,
    quartOut: quartOut,
    quartInOut: quartInOut,
    quintIn: quintIn,
    quintOut: quintOut,
    quintInOut: quintInOut,
    sineIn: sineIn,
    sineOut: sineOut,
    sineInOut: sineInOut,
    expoIn: expoIn,
    expoOut: expoOut,
    expoInOut: expoInOut,
    circIn: circIn,
    circOut: circOut,
    circInOut: circInOut,
    elasticIn: elasticIn,
    elasticOut: elasticOut,
    elasticInOut: elasticInOut,
    backIn: backIn,
    backOut: backOut,
    backInOut: backInOut,
    bounceIn: bounceIn,
    bounceOut: bounceOut,
    bounceInOut: bounceInOut,
    smooth: smooth,
    fade: fade,
    quadOutIn: quadOutIn,
    cubicOutIn: cubicOutIn,
    quartOutIn: quartOutIn,
    quintOutIn: quintOutIn,
    sineOutIn: sineOutIn,
    expoOutIn: expoOutIn,
    circOutIn: circOutIn,
    elasticOutIn: elasticOutIn,
    backOutIn: backOutIn,
    bounceOutIn: bounceOutIn
});

var _dec$7, _class$7, _class2$6, _descriptor$5, _descriptor2$3, _descriptor3$2, _descriptor4$1, _descriptor5, _descriptor6, _descriptor7, _descriptor8, _temp$5, _dec2$3, _class4, _class5, _descriptor9, _descriptor10, _temp3, _easingMethodFnMap;

(function (EasingMethod) {
  EasingMethod[EasingMethod["LINEAR"] = 0] = "LINEAR";
  EasingMethod[EasingMethod["CONSTANT"] = 1] = "CONSTANT";
  EasingMethod[EasingMethod["QUAD_IN"] = 2] = "QUAD_IN";
  EasingMethod[EasingMethod["QUAD_OUT"] = 3] = "QUAD_OUT";
  EasingMethod[EasingMethod["QUAD_IN_OUT"] = 4] = "QUAD_IN_OUT";
  EasingMethod[EasingMethod["QUAD_OUT_IN"] = 5] = "QUAD_OUT_IN";
  EasingMethod[EasingMethod["CUBIC_IN"] = 6] = "CUBIC_IN";
  EasingMethod[EasingMethod["CUBIC_OUT"] = 7] = "CUBIC_OUT";
  EasingMethod[EasingMethod["CUBIC_IN_OUT"] = 8] = "CUBIC_IN_OUT";
  EasingMethod[EasingMethod["CUBIC_OUT_IN"] = 9] = "CUBIC_OUT_IN";
  EasingMethod[EasingMethod["QUART_IN"] = 10] = "QUART_IN";
  EasingMethod[EasingMethod["QUART_OUT"] = 11] = "QUART_OUT";
  EasingMethod[EasingMethod["QUART_IN_OUT"] = 12] = "QUART_IN_OUT";
  EasingMethod[EasingMethod["QUART_OUT_IN"] = 13] = "QUART_OUT_IN";
  EasingMethod[EasingMethod["QUINT_IN"] = 14] = "QUINT_IN";
  EasingMethod[EasingMethod["QUINT_OUT"] = 15] = "QUINT_OUT";
  EasingMethod[EasingMethod["QUINT_IN_OUT"] = 16] = "QUINT_IN_OUT";
  EasingMethod[EasingMethod["QUINT_OUT_IN"] = 17] = "QUINT_OUT_IN";
  EasingMethod[EasingMethod["SINE_IN"] = 18] = "SINE_IN";
  EasingMethod[EasingMethod["SINE_OUT"] = 19] = "SINE_OUT";
  EasingMethod[EasingMethod["SINE_IN_OUT"] = 20] = "SINE_IN_OUT";
  EasingMethod[EasingMethod["SINE_OUT_IN"] = 21] = "SINE_OUT_IN";
  EasingMethod[EasingMethod["EXPO_IN"] = 22] = "EXPO_IN";
  EasingMethod[EasingMethod["EXPO_OUT"] = 23] = "EXPO_OUT";
  EasingMethod[EasingMethod["EXPO_IN_OUT"] = 24] = "EXPO_IN_OUT";
  EasingMethod[EasingMethod["EXPO_OUT_IN"] = 25] = "EXPO_OUT_IN";
  EasingMethod[EasingMethod["CIRC_IN"] = 26] = "CIRC_IN";
  EasingMethod[EasingMethod["CIRC_OUT"] = 27] = "CIRC_OUT";
  EasingMethod[EasingMethod["CIRC_IN_OUT"] = 28] = "CIRC_IN_OUT";
  EasingMethod[EasingMethod["CIRC_OUT_IN"] = 29] = "CIRC_OUT_IN";
  EasingMethod[EasingMethod["ELASTIC_IN"] = 30] = "ELASTIC_IN";
  EasingMethod[EasingMethod["ELASTIC_OUT"] = 31] = "ELASTIC_OUT";
  EasingMethod[EasingMethod["ELASTIC_IN_OUT"] = 32] = "ELASTIC_IN_OUT";
  EasingMethod[EasingMethod["ELASTIC_OUT_IN"] = 33] = "ELASTIC_OUT_IN";
  EasingMethod[EasingMethod["BACK_IN"] = 34] = "BACK_IN";
  EasingMethod[EasingMethod["BACK_OUT"] = 35] = "BACK_OUT";
  EasingMethod[EasingMethod["BACK_IN_OUT"] = 36] = "BACK_IN_OUT";
  EasingMethod[EasingMethod["BACK_OUT_IN"] = 37] = "BACK_OUT_IN";
  EasingMethod[EasingMethod["BOUNCE_IN"] = 38] = "BOUNCE_IN";
  EasingMethod[EasingMethod["BOUNCE_OUT"] = 39] = "BOUNCE_OUT";
  EasingMethod[EasingMethod["BOUNCE_IN_OUT"] = 40] = "BOUNCE_IN_OUT";
  EasingMethod[EasingMethod["BOUNCE_OUT_IN"] = 41] = "BOUNCE_OUT_IN";
  EasingMethod[EasingMethod["SMOOTH"] = 42] = "SMOOTH";
  EasingMethod[EasingMethod["FADE"] = 43] = "FADE";
})(exports.EasingMethod || (exports.EasingMethod = {}));

var RealKeyframeValue = (_dec$7 = ccclass('cc.RealKeyframeValue'), _dec$7(_class$7 = uniquelyReferenced(_class$7 = (_class2$6 = (_temp$5 = function (_EditorExtendable) {
  _inheritsLoose(RealKeyframeValue, _EditorExtendable);

  function RealKeyframeValue(_temp2) {
    var _this;

    var _ref = _temp2 === void 0 ? {} : _temp2,
        interpolationMode = _ref.interpolationMode,
        tangentWeightMode = _ref.tangentWeightMode,
        value = _ref.value,
        rightTangent = _ref.rightTangent,
        rightTangentWeight = _ref.rightTangentWeight,
        leftTangent = _ref.leftTangent,
        leftTangentWeight = _ref.leftTangentWeight,
        easingMethod = _ref.easingMethod,
        editorExtras = _ref[editorExtrasTag];

    _this = _EditorExtendable.call(this) || this;

    _initializerDefineProperty(_this, "interpolationMode", _descriptor$5, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "tangentWeightMode", _descriptor2$3, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "value", _descriptor3$2, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "rightTangent", _descriptor4$1, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "rightTangentWeight", _descriptor5, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "leftTangent", _descriptor6, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "leftTangentWeight", _descriptor7, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "easingMethod", _descriptor8, _assertThisInitialized(_this));

    _this.value = value !== null && value !== void 0 ? value : _this.value;
    _this.rightTangent = rightTangent !== null && rightTangent !== void 0 ? rightTangent : _this.rightTangent;
    _this.rightTangentWeight = rightTangentWeight !== null && rightTangentWeight !== void 0 ? rightTangentWeight : _this.rightTangentWeight;
    _this.leftTangent = leftTangent !== null && leftTangent !== void 0 ? leftTangent : _this.leftTangent;
    _this.leftTangentWeight = leftTangentWeight !== null && leftTangentWeight !== void 0 ? leftTangentWeight : _this.leftTangentWeight;
    _this.interpolationMode = interpolationMode !== null && interpolationMode !== void 0 ? interpolationMode : _this.interpolationMode;
    _this.tangentWeightMode = tangentWeightMode !== null && tangentWeightMode !== void 0 ? tangentWeightMode : _this.tangentWeightMode;
    _this.easingMethod = easingMethod !== null && easingMethod !== void 0 ? easingMethod : _this.easingMethod;

    if (editorExtras) {
      _this[editorExtrasTag] = editorExtras;
    }

    return _this;
  }

  return RealKeyframeValue;
}(EditorExtendable), _temp$5), (_descriptor$5 = _applyDecoratedDescriptor(_class2$6.prototype, "interpolationMode", [serializable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return exports.RealInterpolationMode.LINEAR;
  }
}), _descriptor2$3 = _applyDecoratedDescriptor(_class2$6.prototype, "tangentWeightMode", [serializable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return exports.TangentWeightMode.NONE;
  }
}), _descriptor3$2 = _applyDecoratedDescriptor(_class2$6.prototype, "value", [serializable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return 0.0;
  }
}), _descriptor4$1 = _applyDecoratedDescriptor(_class2$6.prototype, "rightTangent", [serializable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return 0.0;
  }
}), _descriptor5 = _applyDecoratedDescriptor(_class2$6.prototype, "rightTangentWeight", [serializable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return 0.0;
  }
}), _descriptor6 = _applyDecoratedDescriptor(_class2$6.prototype, "leftTangent", [serializable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return 0.0;
  }
}), _descriptor7 = _applyDecoratedDescriptor(_class2$6.prototype, "leftTangentWeight", [serializable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return 0.0;
  }
}), _descriptor8 = _applyDecoratedDescriptor(_class2$6.prototype, "easingMethod", [serializable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return exports.EasingMethod.LINEAR;
  }
})), _class2$6)) || _class$7) || _class$7);

function createRealKeyframeValue(params) {
  return new RealKeyframeValue(typeof params === 'number' ? {
    value: params
  } : params);
}

var RealCurve = (_dec2$3 = ccclass('cc.RealCurve'), _dec2$3(_class4 = (_class5 = (_temp3 = function (_KeyframeCurve) {
  _inheritsLoose(RealCurve, _KeyframeCurve);

  function RealCurve() {
    var _this2;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this2 = _KeyframeCurve.call.apply(_KeyframeCurve, [this].concat(args)) || this;

    _initializerDefineProperty(_this2, "preExtrapolation", _descriptor9, _assertThisInitialized(_this2));

    _initializerDefineProperty(_this2, "postExtrapolation", _descriptor10, _assertThisInitialized(_this2));

    return _this2;
  }

  var _proto = RealCurve.prototype;

  _proto.evaluate = function evaluate(time) {
    var times = this._times,
        values = this._values;
    var nFrames = times.length;

    if (nFrames === 0) {
      return 0.0;
    }

    var firstTime = times[0];
    var lastTime = times[nFrames - 1];

    if (time < firstTime) {
      var preExtrapolation = this.preExtrapolation;
      var _preValue = values[0];

      if (preExtrapolation === exports.ExtrapolationMode.CLAMP || nFrames < 2) {
        return _preValue.value;
      }

      switch (preExtrapolation) {
        case exports.ExtrapolationMode.LINEAR:
          return linearTrend(firstTime, values[0].value, times[1], values[1].value, time);

        case exports.ExtrapolationMode.LOOP:
          time = wrapRepeat(time, firstTime, lastTime);
          break;

        case exports.ExtrapolationMode.PING_PONG:
          time = wrapPingPong(time, firstTime, lastTime);
          break;

        default:
          return _preValue.value;
      }
    } else if (time > lastTime) {
      var postExtrapolation = this.postExtrapolation;
      var preFrame = values[nFrames - 1];

      if (postExtrapolation === exports.ExtrapolationMode.CLAMP || nFrames < 2) {
        return preFrame.value;
      }

      switch (postExtrapolation) {
        case exports.ExtrapolationMode.LINEAR:
          return linearTrend(lastTime, preFrame.value, times[nFrames - 2], values[nFrames - 2].value, time);

        case exports.ExtrapolationMode.LOOP:
          time = wrapRepeat(time, firstTime, lastTime);
          break;

        case exports.ExtrapolationMode.PING_PONG:
          time = wrapPingPong(time, firstTime, lastTime);
          break;

        default:
          return preFrame.value;
      }
    }

    var index = binarySearchEpsilon(times, time);

    if (index >= 0) {
      return values[index].value;
    }

    var iNext = ~index;
    var iPre = iNext - 1;
    var preTime = times[iPre];
    var preValue = values[iPre];
    var nextTime = times[iNext];
    var nextValue = values[iNext];
    var dt = nextTime - preTime;
    var ratio = (time - preTime) / dt;
    return evalBetweenTwoKeyFrames(preTime, preValue, nextTime, nextValue, ratio);
  };

  _proto.addKeyFrame = function addKeyFrame(time, value) {
    return _KeyframeCurve.prototype.addKeyFrame.call(this, time, createRealKeyframeValue(value));
  };

  _proto.assignSorted = function assignSorted(times, values) {
    if (values !== undefined) {
      this.setKeyframes(times.slice(), values.map(function (value) {
        return createRealKeyframeValue(value);
      }));
    } else {
      var _keyframes = Array.from(times);

      this.setKeyframes(_keyframes.map(function (_ref2) {
        var time = _ref2[0];
        return time;
      }), _keyframes.map(function (_ref3) {
        var value = _ref3[1];
        return createRealKeyframeValue(value);
      }));
    }
  };

  _proto.isConstant = function isConstant(tolerance) {
    if (this._values.length <= 1) {
      return true;
    }

    var firstVal = this._values[0].value;
    return this._values.every(function (frame) {
      return approx(frame.value, firstVal, tolerance);
    });
  };

  _proto[serializeTag] = function (output, context) {
    if (!context.toCCON) {
      output.writeThis();
      return;
    }

    var times = this._times,
        keyframeValues = this._values;
    var nKeyframes = times.length;
    var dataSize = 0 + OVERFLOW_BYTES + OVERFLOW_BYTES + FRAME_COUNT_BYTES + TIME_BYTES * nKeyframes + REAL_KEY_FRAME_VALUE_MAX_SIZE * nKeyframes;
    var dataView = new DataView(new ArrayBuffer(dataSize));
    var currentOffset = 0;
    dataView.setUint8(currentOffset, this.preExtrapolation);
    currentOffset += OVERFLOW_BYTES;
    dataView.setUint8(currentOffset, this.postExtrapolation);
    currentOffset += OVERFLOW_BYTES;
    dataView.setUint32(currentOffset, nKeyframes, true);
    currentOffset += FRAME_COUNT_BYTES;
    times.forEach(function (time, index) {
      return dataView.setFloat32(currentOffset + TIME_BYTES * index, time, true);
    });
    currentOffset += TIME_BYTES * nKeyframes;

    for (var _iterator = _createForOfIteratorHelperLoose(keyframeValues), _step; !(_step = _iterator()).done;) {
      var keyframeValue = _step.value;
      currentOffset = saveRealKeyFrameValue(dataView, keyframeValue, currentOffset);
    }

    var bytes = new Uint8Array(dataView.buffer, 0, currentOffset);
    output.writeProperty('bytes', bytes);
    var keyframeValueEditorExtras = keyframeValues.map(function (keyframeValue) {
      return keyframeValue[editorExtrasTag];
    });

    if (keyframeValueEditorExtras.some(function (extras) {
      return extras !== undefined;
    })) {
      output.writeProperty("keyframeValueEditorExtras", keyframeValueEditorExtras);
    }
  };

  _proto[deserializeTag] = function (input, context) {
    if (!context.fromCCON) {
      input.readThis();
      return;
    }

    var bytes = input.readProperty('bytes');
    var dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
    var currentOffset = 0;
    this.preExtrapolation = dataView.getUint8(currentOffset);
    currentOffset += OVERFLOW_BYTES;
    this.postExtrapolation = dataView.getUint8(currentOffset);
    currentOffset += OVERFLOW_BYTES;
    var nKeyframes = dataView.getUint32(currentOffset, true);
    currentOffset += FRAME_COUNT_BYTES;
    var times = Array.from({
      length: nKeyframes
    }, function (_, index) {
      return dataView.getFloat32(currentOffset + TIME_BYTES * index, true);
    });
    currentOffset += TIME_BYTES * nKeyframes;
    var keyframeValues = new Array(nKeyframes);

    for (var iKeyFrame = 0; iKeyFrame < nKeyframes; ++iKeyFrame) {
      var keyframeValue = createRealKeyframeValue({});
      currentOffset = loadRealKeyFrameValue(dataView, keyframeValue, currentOffset);
      keyframeValues[iKeyFrame] = keyframeValue;
    }

    assertIsTrue(currentOffset === bytes.byteLength);
    var keyframeValueEditorExtras = input.readProperty("keyframeValueEditorExtras");

    if (keyframeValueEditorExtras) {
      assertIsTrue(keyframeValueEditorExtras.length === nKeyframes);
      keyframeValueEditorExtras.forEach(function (extras, index) {
        return keyframeValues[index][editorExtrasTag] = extras;
      });
    }

    this._times = times;
    this._values = keyframeValues;
  };

  return RealCurve;
}(KeyframeCurve), _temp3), (_descriptor9 = _applyDecoratedDescriptor(_class5.prototype, "preExtrapolation", [serializable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return exports.ExtrapolationMode.CLAMP;
  }
}), _descriptor10 = _applyDecoratedDescriptor(_class5.prototype, "postExtrapolation", [serializable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return exports.ExtrapolationMode.CLAMP;
  }
})), _class5)) || _class4);
var FLAGS_EASING_METHOD_BITS_START = 8;
var FLAG_EASING_METHOD_MASK = 0xFF << FLAGS_EASING_METHOD_BITS_START;
var KeyframeValueFlagMask;

(function (KeyframeValueFlagMask) {
  KeyframeValueFlagMask[KeyframeValueFlagMask["VALUE"] = 1] = "VALUE";
  KeyframeValueFlagMask[KeyframeValueFlagMask["INTERPOLATION_MODE"] = 2] = "INTERPOLATION_MODE";
  KeyframeValueFlagMask[KeyframeValueFlagMask["TANGENT_WEIGHT_MODE"] = 4] = "TANGENT_WEIGHT_MODE";
  KeyframeValueFlagMask[KeyframeValueFlagMask["LEFT_TANGENT"] = 8] = "LEFT_TANGENT";
  KeyframeValueFlagMask[KeyframeValueFlagMask["LEFT_TANGENT_WEIGHT"] = 16] = "LEFT_TANGENT_WEIGHT";
  KeyframeValueFlagMask[KeyframeValueFlagMask["RIGHT_TANGENT"] = 32] = "RIGHT_TANGENT";
  KeyframeValueFlagMask[KeyframeValueFlagMask["RIGHT_TANGENT_WEIGHT"] = 64] = "RIGHT_TANGENT_WEIGHT";
})(KeyframeValueFlagMask || (KeyframeValueFlagMask = {}));

var OVERFLOW_BYTES = 1;
var FRAME_COUNT_BYTES = 4;
var TIME_BYTES = 4;
var KEY_FRAME_VALUE_FLAGS_BYTES = 4;
var VALUE_BYTES = 4;
var INTERPOLATION_MODE_BYTES = 1;
var TANGENT_WEIGHT_MODE_BYTES = 1;
var LEFT_TANGENT_BYTES = 4;
var LEFT_TANGENT_WEIGHT_BYTES = 4;
var RIGHT_TANGENT_BYTES = 4;
var RIGHT_TANGENT_WEIGHT_BYTES = 4;

var _createRealKeyframeVa = createRealKeyframeValue({}),
    DEFAULT_INTERPOLATION_MODE = _createRealKeyframeVa.interpolationMode,
    DEFAULT_TANGENT_WEIGHT_MODE = _createRealKeyframeVa.tangentWeightMode,
    DEFAULT_LEFT_TANGENT = _createRealKeyframeVa.leftTangent,
    DEFAULT_LEFT_TANGENT_WEIGHT = _createRealKeyframeVa.leftTangentWeight,
    DEFAULT_RIGHT_TANGENT = _createRealKeyframeVa.rightTangent,
    DEFAULT_RIGHT_TANGENT_WEIGHT = _createRealKeyframeVa.rightTangentWeight;

var REAL_KEY_FRAME_VALUE_MAX_SIZE = KEY_FRAME_VALUE_FLAGS_BYTES + VALUE_BYTES + INTERPOLATION_MODE_BYTES + TANGENT_WEIGHT_MODE_BYTES + LEFT_TANGENT_BYTES + LEFT_TANGENT_WEIGHT_BYTES + RIGHT_TANGENT_BYTES + RIGHT_TANGENT_WEIGHT_BYTES + 0;

function saveRealKeyFrameValue(dataView, keyframeValue, offset) {
  var flags = 0;
  var currentOffset = offset;
  var pFlags = currentOffset;
  currentOffset += KEY_FRAME_VALUE_FLAGS_BYTES;
  var value = keyframeValue.value,
      interpolationMode = keyframeValue.interpolationMode,
      tangentWeightMode = keyframeValue.tangentWeightMode,
      rightTangent = keyframeValue.rightTangent,
      rightTangentWeight = keyframeValue.rightTangentWeight,
      leftTangent = keyframeValue.leftTangent,
      leftTangentWeight = keyframeValue.leftTangentWeight,
      easingMethod = keyframeValue.easingMethod;
  dataView.setFloat32(currentOffset, value, true);
  currentOffset += VALUE_BYTES;

  if (interpolationMode !== DEFAULT_INTERPOLATION_MODE) {
    flags |= KeyframeValueFlagMask.INTERPOLATION_MODE;
    dataView.setUint8(currentOffset, interpolationMode);
    currentOffset += INTERPOLATION_MODE_BYTES;
  }

  if (tangentWeightMode !== DEFAULT_TANGENT_WEIGHT_MODE) {
    flags |= KeyframeValueFlagMask.TANGENT_WEIGHT_MODE;
    dataView.setUint8(currentOffset, tangentWeightMode);
    currentOffset += TANGENT_WEIGHT_MODE_BYTES;
  }

  if (leftTangent !== DEFAULT_LEFT_TANGENT) {
    flags |= KeyframeValueFlagMask.LEFT_TANGENT;
    dataView.setFloat32(currentOffset, leftTangent, true);
    currentOffset += LEFT_TANGENT_BYTES;
  }

  if (leftTangentWeight !== DEFAULT_LEFT_TANGENT_WEIGHT) {
    flags |= KeyframeValueFlagMask.LEFT_TANGENT_WEIGHT;
    dataView.setFloat32(currentOffset, leftTangentWeight, true);
    currentOffset += LEFT_TANGENT_WEIGHT_BYTES;
  }

  if (rightTangent !== DEFAULT_RIGHT_TANGENT) {
    flags |= KeyframeValueFlagMask.RIGHT_TANGENT;
    dataView.setFloat32(currentOffset, rightTangent, true);
    currentOffset += RIGHT_TANGENT_BYTES;
  }

  if (rightTangentWeight !== DEFAULT_RIGHT_TANGENT_WEIGHT) {
    flags |= KeyframeValueFlagMask.RIGHT_TANGENT_WEIGHT;
    dataView.setFloat32(currentOffset, rightTangentWeight, true);
    currentOffset += RIGHT_TANGENT_WEIGHT_BYTES;
  }

  flags |= easingMethod << FLAGS_EASING_METHOD_BITS_START;
  dataView.setUint32(pFlags, flags, true);
  return currentOffset;
}

function loadRealKeyFrameValue(dataView, keyframeValue, offset) {
  var currentOffset = offset;
  var flags = dataView.getUint32(currentOffset, true);
  currentOffset += KEY_FRAME_VALUE_FLAGS_BYTES;
  keyframeValue.value = dataView.getFloat32(currentOffset, true);
  currentOffset += VALUE_BYTES;

  if (flags & KeyframeValueFlagMask.INTERPOLATION_MODE) {
    keyframeValue.interpolationMode = dataView.getUint8(currentOffset);
    currentOffset += INTERPOLATION_MODE_BYTES;
  }

  if (flags & KeyframeValueFlagMask.TANGENT_WEIGHT_MODE) {
    keyframeValue.tangentWeightMode = dataView.getUint8(currentOffset);
    currentOffset += TANGENT_WEIGHT_MODE_BYTES;
  }

  if (flags & KeyframeValueFlagMask.LEFT_TANGENT) {
    keyframeValue.leftTangent = dataView.getFloat32(currentOffset, true);
    currentOffset += LEFT_TANGENT_BYTES;
  }

  if (flags & KeyframeValueFlagMask.LEFT_TANGENT_WEIGHT) {
    keyframeValue.leftTangentWeight = dataView.getFloat32(currentOffset, true);
    currentOffset += LEFT_TANGENT_WEIGHT_BYTES;
  }

  if (flags & KeyframeValueFlagMask.RIGHT_TANGENT) {
    keyframeValue.rightTangent = dataView.getFloat32(currentOffset, true);
    currentOffset += RIGHT_TANGENT_BYTES;
  }

  if (flags & KeyframeValueFlagMask.RIGHT_TANGENT_WEIGHT) {
    keyframeValue.rightTangentWeight = dataView.getFloat32(currentOffset, true);
    currentOffset += RIGHT_TANGENT_WEIGHT_BYTES;
  }

  var easingMethod = (flags & FLAG_EASING_METHOD_MASK) >> FLAGS_EASING_METHOD_BITS_START;
  keyframeValue.easingMethod = easingMethod;
  return currentOffset;
}

function wrapRepeat(time, prevTime, nextTime) {
  return prevTime + repeat(time - prevTime, nextTime - prevTime);
}

function wrapPingPong(time, prevTime, nextTime) {
  return prevTime + pingPong(time - prevTime, nextTime - prevTime);
}

function linearTrend(prevTime, prevValue, nextTime, nextValue, time) {
  var slope = (nextValue - prevValue) / (nextTime - prevTime);
  return prevValue + (time - prevTime) * slope;
}

function evalBetweenTwoKeyFrames(prevTime, prevValue, nextTime, nextValue, ratio) {
  var dt = nextTime - prevTime;

  switch (prevValue.interpolationMode) {
    default:
    case exports.RealInterpolationMode.CONSTANT:
      return prevValue.value;

    case exports.RealInterpolationMode.LINEAR:
      {
        var transformedRatio = prevValue.easingMethod === exports.EasingMethod.LINEAR ? ratio : getEasingFn(prevValue.easingMethod)(ratio);
        return lerp(prevValue.value, nextValue.value, transformedRatio);
      }

    case exports.RealInterpolationMode.CUBIC:
      {
        var ONE_THIRD = 1.0 / 3.0;
        var prevTangent = prevValue.rightTangent,
            prevTangentWeightSpecified = prevValue.rightTangentWeight;
        var prevTangentWeightEnabled = isRightTangentWeightEnabled(prevValue.tangentWeightMode);
        var nextTangent = nextValue.leftTangent,
            nextTangentWeightSpecified = nextValue.leftTangentWeight;
        var nextTangentWeightEnabled = isLeftTangentWeightEnabled(nextValue.tangentWeightMode);

        if (!prevTangentWeightEnabled && !nextTangentWeightEnabled) {
          var p1 = prevValue.value + ONE_THIRD * prevTangent * dt;
          var p2 = nextValue.value - ONE_THIRD * nextTangent * dt;
          return bezierInterpolate(prevValue.value, p1, p2, nextValue.value, ratio);
        } else {
          var prevTangentWeight = 0.0;

          if (prevTangentWeightEnabled) {
            prevTangentWeight = prevTangentWeightSpecified;
          } else {
            var x = dt;

            var _y = dt * prevTangent;

            prevTangentWeight = Math.sqrt(x * x + _y * _y) * ONE_THIRD;
          }

          var angle0 = Math.atan(prevTangent);
          var tx0 = Math.cos(angle0) * prevTangentWeight + prevTime;
          var ty0 = Math.sin(angle0) * prevTangentWeight + prevValue.value;
          var nextTangentWeight = 0.0;

          if (nextTangentWeightEnabled) {
            nextTangentWeight = nextTangentWeightSpecified;
          } else {
            var _x = dt;

            var _y2 = dt * nextTangent;

            nextTangentWeight = Math.sqrt(_x * _x + _y2 * _y2) * ONE_THIRD;
          }

          var angle1 = Math.atan(nextTangent);
          var tx1 = -Math.cos(angle1) * nextTangentWeight + nextTime;
          var ty1 = -Math.sin(angle1) * nextTangentWeight + nextValue.value;
          var dx = dt;
          var u0x = (tx0 - prevTime) / dx;
          var u1x = (tx1 - prevTime) / dx;
          var u0y = ty0;
          var u1y = ty1;
          var coeff0 = 0.0;
          var coeff1 = 3.0 * u0x;
          var coeff2 = 3.0 * u1x - 6.0 * u0x;
          var coeff3 = 3.0 * (u0x - u1x) + 1.0;
          var solutions = [0.0, 0.0, 0.0];
          var nSolutions = solveCubic(coeff0 - ratio, coeff1, coeff2, coeff3, solutions);
          var param = getParamFromCubicSolution(solutions, nSolutions, ratio);
          var y = bezierInterpolate(prevValue.value, u0y, u1y, nextValue.value, param);
          return y;
        }
      }
  }
}

function isLeftTangentWeightEnabled(tangentWeightMode) {
  return (tangentWeightMode & exports.TangentWeightMode.LEFT) !== 0;
}

function isRightTangentWeightEnabled(tangentWeightMode) {
  return (tangentWeightMode & exports.TangentWeightMode.RIGHT) !== 0;
}

function bezierInterpolate(p0, p1, p2, p3, t) {
  var u = 1 - t;
  var coeff0 = u * u * u;
  var coeff1 = 3 * u * u * t;
  var coeff2 = 3 * u * t * t;
  var coeff3 = t * t * t;
  return coeff0 * p0 + coeff1 * p1 + coeff2 * p2 + coeff3 * p3;
}

function getParamFromCubicSolution(solutions, solutionsCount, x) {
  var param = x;

  if (solutionsCount === 1) {
    param = solutions[0];
  } else {
    param = -Infinity;

    for (var iSolution = 0; iSolution < solutionsCount; ++iSolution) {
      var solution = solutions[iSolution];

      if (solution >= 0.0 && solution <= 1.0) {
        if (solution > param) {
          param = solution;
        }
      }
    }

    if (param === -Infinity) {
      param = 0.0;
    }
  }

  return param;
}

var easingMethodFnMap = (_easingMethodFnMap = {}, _easingMethodFnMap[exports.EasingMethod.CONSTANT] = constant, _easingMethodFnMap[exports.EasingMethod.LINEAR] = linear, _easingMethodFnMap[exports.EasingMethod.QUAD_IN] = quadIn, _easingMethodFnMap[exports.EasingMethod.QUAD_OUT] = quadOut, _easingMethodFnMap[exports.EasingMethod.QUAD_IN_OUT] = quadInOut, _easingMethodFnMap[exports.EasingMethod.QUAD_OUT_IN] = quadOutIn, _easingMethodFnMap[exports.EasingMethod.CUBIC_IN] = cubicIn, _easingMethodFnMap[exports.EasingMethod.CUBIC_OUT] = cubicOut, _easingMethodFnMap[exports.EasingMethod.CUBIC_IN_OUT] = cubicInOut, _easingMethodFnMap[exports.EasingMethod.CUBIC_OUT_IN] = cubicOutIn, _easingMethodFnMap[exports.EasingMethod.QUART_IN] = quartIn, _easingMethodFnMap[exports.EasingMethod.QUART_OUT] = quartOut, _easingMethodFnMap[exports.EasingMethod.QUART_IN_OUT] = quartInOut, _easingMethodFnMap[exports.EasingMethod.QUART_OUT_IN] = quartOutIn, _easingMethodFnMap[exports.EasingMethod.QUINT_IN] = quintIn, _easingMethodFnMap[exports.EasingMethod.QUINT_OUT] = quintOut, _easingMethodFnMap[exports.EasingMethod.QUINT_IN_OUT] = quintInOut, _easingMethodFnMap[exports.EasingMethod.QUINT_OUT_IN] = quintOutIn, _easingMethodFnMap[exports.EasingMethod.SINE_IN] = sineIn, _easingMethodFnMap[exports.EasingMethod.SINE_OUT] = sineOut, _easingMethodFnMap[exports.EasingMethod.SINE_IN_OUT] = sineInOut, _easingMethodFnMap[exports.EasingMethod.SINE_OUT_IN] = sineOutIn, _easingMethodFnMap[exports.EasingMethod.EXPO_IN] = expoIn, _easingMethodFnMap[exports.EasingMethod.EXPO_OUT] = expoOut, _easingMethodFnMap[exports.EasingMethod.EXPO_IN_OUT] = expoInOut, _easingMethodFnMap[exports.EasingMethod.EXPO_OUT_IN] = expoOutIn, _easingMethodFnMap[exports.EasingMethod.CIRC_IN] = circIn, _easingMethodFnMap[exports.EasingMethod.CIRC_OUT] = circOut, _easingMethodFnMap[exports.EasingMethod.CIRC_IN_OUT] = circInOut, _easingMethodFnMap[exports.EasingMethod.CIRC_OUT_IN] = circOutIn, _easingMethodFnMap[exports.EasingMethod.ELASTIC_IN] = elasticIn, _easingMethodFnMap[exports.EasingMethod.ELASTIC_OUT] = elasticOut, _easingMethodFnMap[exports.EasingMethod.ELASTIC_IN_OUT] = elasticInOut, _easingMethodFnMap[exports.EasingMethod.ELASTIC_OUT_IN] = elasticOutIn, _easingMethodFnMap[exports.EasingMethod.BACK_IN] = backIn, _easingMethodFnMap[exports.EasingMethod.BACK_OUT] = backOut, _easingMethodFnMap[exports.EasingMethod.BACK_IN_OUT] = backInOut, _easingMethodFnMap[exports.EasingMethod.BACK_OUT_IN] = backOutIn, _easingMethodFnMap[exports.EasingMethod.BOUNCE_IN] = bounceIn, _easingMethodFnMap[exports.EasingMethod.BOUNCE_OUT] = bounceOut, _easingMethodFnMap[exports.EasingMethod.BOUNCE_IN_OUT] = bounceInOut, _easingMethodFnMap[exports.EasingMethod.BOUNCE_OUT_IN] = bounceOutIn, _easingMethodFnMap[exports.EasingMethod.SMOOTH] = smooth, _easingMethodFnMap[exports.EasingMethod.FADE] = fade, _easingMethodFnMap);

function getEasingFn(easingMethod) {
  return easingMethodFnMap[easingMethod];
}

var _dec$8, _class$8, _class2$7, _descriptor$6, _descriptor2$4, _temp$6, _dec2$4, _class4$1, _class5$1, _descriptor3$3, _descriptor4$2, _temp3$1;
var QuatKeyframeValue = (_dec$8 = ccclass('cc.QuatKeyframeValue'), _dec$8(_class$8 = uniquelyReferenced(_class$8 = (_class2$7 = (_temp$6 = function QuatKeyframeValue(_temp2) {
  var _this = this;

  var _ref = _temp2 === void 0 ? {} : _temp2,
      value = _ref.value,
      interpolationMode = _ref.interpolationMode;

  return function () {
    _initializerDefineProperty(_this, "interpolationMode", _descriptor$6, _this);

    _initializerDefineProperty(_this, "value", _descriptor2$4, _this);

    _this.value = value ? Quat.clone(value) : _this.value;
    _this.interpolationMode = interpolationMode !== null && interpolationMode !== void 0 ? interpolationMode : _this.interpolationMode;
  }();
}, _temp$6), (_descriptor$6 = _applyDecoratedDescriptor(_class2$7.prototype, "interpolationMode", [serializable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return exports.QuatInterpolationMode.SLERP;
  }
}), _descriptor2$4 = _applyDecoratedDescriptor(_class2$7.prototype, "value", [serializable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return Quat.clone(Quat.IDENTITY);
  }
})), _class2$7)) || _class$8) || _class$8);

function createQuatKeyframeValue(params) {
  return new QuatKeyframeValue(params);
}

(function (QuatInterpolationMode) {
  QuatInterpolationMode[QuatInterpolationMode["SLERP"] = 0] = "SLERP";
  QuatInterpolationMode[QuatInterpolationMode["CONSTANT"] = 1] = "CONSTANT";
})(exports.QuatInterpolationMode || (exports.QuatInterpolationMode = {}));

var QuatCurve = (_dec2$4 = ccclass('cc.QuatCurve'), _dec2$4(_class4$1 = (_class5$1 = (_temp3$1 = function (_KeyframeCurve) {
  _inheritsLoose(QuatCurve, _KeyframeCurve);

  function QuatCurve() {
    var _this2;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this2 = _KeyframeCurve.call.apply(_KeyframeCurve, [this].concat(args)) || this;

    _initializerDefineProperty(_this2, "preExtrapolation", _descriptor3$3, _assertThisInitialized(_this2));

    _initializerDefineProperty(_this2, "postExtrapolation", _descriptor4$2, _assertThisInitialized(_this2));

    return _this2;
  }

  var _proto = QuatCurve.prototype;

  _proto.evaluate = function evaluate(time, quat) {
    var _quat;

    (_quat = quat) !== null && _quat !== void 0 ? _quat : quat = new Quat();
    var times = this._times,
        values = this._values,
        postExtrapolation = this.postExtrapolation,
        preExtrapolation = this.preExtrapolation;
    var nFrames = times.length;

    if (nFrames === 0) {
      return quat;
    }

    var firstTime = times[0];
    var lastTime = times[nFrames - 1];

    if (time < firstTime) {
      var _preValue = values[0];

      switch (preExtrapolation) {
        case exports.ExtrapolationMode.LOOP:
          time = firstTime + repeat(time - firstTime, lastTime - firstTime);
          break;

        case exports.ExtrapolationMode.PING_PONG:
          time = firstTime + pingPong(time - firstTime, lastTime - firstTime);
          break;

        case exports.ExtrapolationMode.CLAMP:
        default:
          return Quat.copy(quat, _preValue.value);
      }
    } else if (time > lastTime) {
      var _preValue2 = values[nFrames - 1];

      switch (postExtrapolation) {
        case exports.ExtrapolationMode.LOOP:
          time = firstTime + repeat(time - firstTime, lastTime - firstTime);
          break;

        case exports.ExtrapolationMode.PING_PONG:
          time = firstTime + pingPong(time - firstTime, lastTime - firstTime);
          break;

        case exports.ExtrapolationMode.CLAMP:
        default:
          return Quat.copy(quat, _preValue2.value);
      }
    }

    var index = binarySearchEpsilon(times, time);

    if (index >= 0) {
      return Quat.copy(quat, values[index].value);
    }

    var iNext = ~index;
    var iPre = iNext - 1;
    var preTime = times[iPre];
    var preValue = values[iPre];
    var nextTime = times[iNext];
    var nextValue = values[iNext];
    var dt = nextTime - preTime;
    var ratio = (time - preTime) / dt;

    switch (preValue.interpolationMode) {
      default:
      case exports.QuatInterpolationMode.CONSTANT:
        return Quat.copy(quat, preValue.value);

      case exports.QuatInterpolationMode.SLERP:
        return Quat.slerp(quat, preValue.value, nextValue.value, ratio);
    }
  };

  _proto.addKeyFrame = function addKeyFrame(time, value) {
    var keyframeValue = new QuatKeyframeValue(value);
    return _KeyframeCurve.prototype.addKeyFrame.call(this, time, keyframeValue);
  };

  _proto.assignSorted = function assignSorted(times, values) {
    if (values !== undefined) {
      this.setKeyframes(times.slice(), values.map(function (value) {
        return createQuatKeyframeValue(value);
      }));
    } else {
      var _keyframes = Array.from(times);

      this.setKeyframes(_keyframes.map(function (_ref2) {
        var time = _ref2[0];
        return time;
      }), _keyframes.map(function (_ref3) {
        var value = _ref3[1];
        return createQuatKeyframeValue(value);
      }));
    }
  };

  _proto[serializeTag] = function (output, context) {
    if (!context.toCCON) {
      output.writeThis();
      return;
    }

    var times = this._times,
        keyframeValues = this._values;
    var interpolationModeRepeated = true;
    keyframeValues.forEach(function (keyframeValue, _index, _ref4) {
      var firstKeyframeValue = _ref4[0];

      if (interpolationModeRepeated && keyframeValue.interpolationMode !== firstKeyframeValue.interpolationMode) {
        interpolationModeRepeated = false;
      }
    });
    var nKeyframes = times.length;
    var nFrames = nKeyframes;
    var interpolationModesSize = INTERPOLATION_MODE_BYTES$1 * (interpolationModeRepeated ? 1 : nFrames);
    var dataSize = 0;
    dataSize += FLAGS_BYTES + FRAME_COUNT_BYTES$1 + TIME_BYTES$1 * nFrames + VALUE_BYTES$1 * 4 * nFrames + interpolationModesSize + 0;
    var dataView = new DataView(new ArrayBuffer(dataSize));
    var P = 0;
    var flags = 0;

    if (interpolationModeRepeated) {
      flags |= KeyframeValueFlagMask$1.INTERPOLATION_MODE;
    }

    dataView.setUint32(P, flags, true);
    P += FLAGS_BYTES;
    dataView.setUint32(P, nFrames, true);
    P += FRAME_COUNT_BYTES$1;
    times.forEach(function (time, index) {
      return dataView.setFloat32(P + TIME_BYTES$1 * index, time, true);
    });
    P += TIME_BYTES$1 * nFrames;
    keyframeValues.forEach(function (_ref5, index) {
      var _ref5$value = _ref5.value,
          x = _ref5$value.x,
          y = _ref5$value.y,
          z = _ref5$value.z,
          w = _ref5$value.w;
      var pQuat = P + VALUE_BYTES$1 * 4 * index;
      dataView.setFloat32(pQuat + VALUE_BYTES$1 * 0, x, true);
      dataView.setFloat32(pQuat + VALUE_BYTES$1 * 1, y, true);
      dataView.setFloat32(pQuat + VALUE_BYTES$1 * 2, z, true);
      dataView.setFloat32(pQuat + VALUE_BYTES$1 * 3, w, true);
    });
    P += VALUE_BYTES$1 * 4 * nFrames;
    var INTERPOLATION_MODES_START = P;
    P += interpolationModesSize;
    var pInterpolationMode = INTERPOLATION_MODES_START;
    keyframeValues.forEach(function (_ref6) {
      var interpolationMode = _ref6.interpolationMode;
      dataView.setUint8(pInterpolationMode, interpolationMode);

      if (!interpolationModeRepeated) {
        pInterpolationMode += INTERPOLATION_MODE_BYTES$1;
      }
    });
    var bytes = new Uint8Array(dataView.buffer);
    output.writeProperty('bytes', bytes);
  };

  _proto[deserializeTag] = function (input, context) {
    if (!context.fromCCON) {
      input.readThis();
      return;
    }

    var bytes = input.readProperty('bytes');
    var dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
    var P = 0;
    var flags = dataView.getUint32(P, true);
    P += FLAGS_BYTES;
    var interpolationModeRepeated = flags & KeyframeValueFlagMask$1.INTERPOLATION_MODE;
    var nFrames = dataView.getUint32(P, true);
    P += FRAME_COUNT_BYTES$1;
    var times = Array.from({
      length: nFrames
    }, function (_, index) {
      return dataView.getFloat32(P + TIME_BYTES$1 * index, true);
    });
    P += TIME_BYTES$1 * nFrames;
    var P_VALUES = P;
    P += VALUE_BYTES$1 * 4 * nFrames;
    var pInterpolationModes = P;
    var keyframeValues = Array.from({
      length: nFrames
    }, function (_, index) {
      var pQuat = P_VALUES + VALUE_BYTES$1 * 4 * index;
      var x = dataView.getFloat32(pQuat + VALUE_BYTES$1 * 0, true);
      var y = dataView.getFloat32(pQuat + VALUE_BYTES$1 * 1, true);
      var z = dataView.getFloat32(pQuat + VALUE_BYTES$1 * 2, true);
      var w = dataView.getFloat32(pQuat + VALUE_BYTES$1 * 3, true);
      var keyframeValue = createQuatKeyframeValue({
        value: {
          x: x,
          y: y,
          z: z,
          w: w
        },
        interpolationMode: dataView.getUint8(pInterpolationModes)
      });

      if (!interpolationModeRepeated) {
        pInterpolationModes += INTERPOLATION_MODE_BYTES$1;
      }

      return keyframeValue;
    });
    this._times = times;
    this._values = keyframeValues;
  };

  return QuatCurve;
}(KeyframeCurve), _temp3$1), (_descriptor3$3 = _applyDecoratedDescriptor(_class5$1.prototype, "preExtrapolation", [serializable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return exports.ExtrapolationMode.CLAMP;
  }
}), _descriptor4$2 = _applyDecoratedDescriptor(_class5$1.prototype, "postExtrapolation", [serializable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return exports.ExtrapolationMode.CLAMP;
  }
})), _class5$1)) || _class4$1);
var KeyframeValueFlagMask$1;

(function (KeyframeValueFlagMask) {
  KeyframeValueFlagMask[KeyframeValueFlagMask["INTERPOLATION_MODE"] = 1] = "INTERPOLATION_MODE";
})(KeyframeValueFlagMask$1 || (KeyframeValueFlagMask$1 = {}));

var FLAGS_BYTES = 1;
var FRAME_COUNT_BYTES$1 = 4;
var TIME_BYTES$1 = 4;
var VALUE_BYTES$1 = 4;
var INTERPOLATION_MODE_BYTES$1 = 1;

var _dec$9, _class$9;
var ObjectCurve = (_dec$9 = ccclass('cc.ObjectCurve'), _dec$9(_class$9 = function (_KeyframeCurve) {
  _inheritsLoose(ObjectCurve, _KeyframeCurve);

  function ObjectCurve() {
    return _KeyframeCurve.apply(this, arguments) || this;
  }

  var _proto = ObjectCurve.prototype;

  _proto.evaluate = function evaluate(time) {
    var iSearch = this.searchKeyframe(time);

    if (iSearch >= 0) {
      return this._values[iSearch];
    }

    var iPrev = clamp(~iSearch - 1, 0, this._values.length - 1);
    return this._values[iPrev];
  };

  return ObjectCurve;
}(KeyframeCurve)) || _class$9);

var _dec$a, _class$a, _class2$8, _descriptor$7, _class3$3, _temp$7;
var LOOK_FORWARD = 3;
var Keyframe = function Keyframe() {
  this.time = 0;
  this.value = 0;
  this.inTangent = 0;
  this.outTangent = 0;
};
CCClass.fastDefine('cc.Keyframe', Keyframe, {
  time: 0,
  value: 0,
  inTangent: 0,
  outTangent: 0
});
var OptimizedKey = function () {
  function OptimizedKey() {
    this.index = void 0;
    this.time = void 0;
    this.endTime = void 0;
    this.coefficient = void 0;
    this.index = -1;
    this.time = 0;
    this.endTime = 0;
    this.coefficient = new Float32Array(4);
  }

  var _proto = OptimizedKey.prototype;

  _proto.evaluate = function evaluate(T) {
    var t = T - this.time;
    return evalOptCurve(t, this.coefficient);
  };

  return OptimizedKey;
}();
function evalOptCurve(t, coefs) {
  return t * (t * (t * coefs[0] + coefs[1]) + coefs[2]) + coefs[3];
}
var AnimationCurve = (_dec$a = ccclass('cc.AnimationCurve'), _dec$a(_class$a = (_class2$8 = (_temp$7 = _class3$3 = function () {
  _createClass(AnimationCurve, [{
    key: "_internalCurve",
    get: function get() {
      return this._curve;
    }
  }, {
    key: "keyFrames",
    get: function get() {
      return Array.from(this._curve.keyframes()).map(function (_ref) {
        var time = _ref[0],
            value = _ref[1];
        var legacyKeyframe = new Keyframe();
        legacyKeyframe.time = time;
        legacyKeyframe.value = value.value;
        legacyKeyframe.inTangent = value.leftTangent;
        legacyKeyframe.outTangent = value.rightTangent;
        return legacyKeyframe;
      });
    },
    set: function set(value) {
      this._curve.assignSorted(value.map(function (legacyCurve) {
        return [legacyCurve.time, {
          interpolationMode: exports.RealInterpolationMode.CUBIC,
          value: legacyCurve.value,
          leftTangent: legacyCurve.inTangent,
          rightTangent: legacyCurve.outTangent
        }];
      }));
    }
  }, {
    key: "preWrapMode",
    get: function get() {
      return toLegacyWrapMode(this._curve.preExtrapolation);
    },
    set: function set(value) {
      this._curve.preExtrapolation = fromLegacyWrapMode(value);
    }
  }, {
    key: "postWrapMode",
    get: function get() {
      return toLegacyWrapMode(this._curve.postExtrapolation);
    },
    set: function set(value) {
      this._curve.postExtrapolation = fromLegacyWrapMode(value);
    }
  }]);

  function AnimationCurve(keyFrames) {
    if (keyFrames === void 0) {
      keyFrames = null;
    }

    _initializerDefineProperty(this, "_curve", _descriptor$7, this);

    this.cachedKey = void 0;

    if (keyFrames instanceof RealCurve) {
      this._curve = keyFrames;
    } else {
      var curve = new RealCurve();
      this._curve = curve;
      curve.preExtrapolation = exports.ExtrapolationMode.LOOP;
      curve.postExtrapolation = exports.ExtrapolationMode.CLAMP;

      if (!keyFrames) {
        curve.assignSorted([[0.0, {
          interpolationMode: exports.RealInterpolationMode.CUBIC,
          value: 1.0
        }], [1.0, {
          interpolationMode: exports.RealInterpolationMode.CUBIC,
          value: 1.0
        }]]);
      } else {
        curve.assignSorted(keyFrames.map(function (legacyKeyframe) {
          return [legacyKeyframe.time, {
            interpolationMode: exports.RealInterpolationMode.CUBIC,
            value: legacyKeyframe.value,
            leftTangent: legacyKeyframe.inTangent,
            rightTangent: legacyKeyframe.outTangent
          }];
        }));
      }
    }

    this.cachedKey = new OptimizedKey();
  }

  var _proto2 = AnimationCurve.prototype;

  _proto2.addKey = function addKey(keyFrame) {
    if (!keyFrame) {
      this._curve.clear();
    } else {
      this._curve.addKeyFrame(keyFrame.time, {
        interpolationMode: exports.RealInterpolationMode.CUBIC,
        value: keyFrame.value,
        leftTangent: keyFrame.inTangent,
        rightTangent: keyFrame.outTangent
      });
    }
  };

  _proto2.evaluate_slow = function evaluate_slow(time) {
    return this._curve.evaluate(time);
  };

  _proto2.evaluate = function evaluate(time) {
    var cachedKey = this.cachedKey,
        curve = this._curve;
    var nKeyframes = curve.keyFramesCount;
    var lastKeyframeIndex = nKeyframes - 1;
    var wrappedTime = time;
    var extrapolationMode = time < 0 ? curve.preExtrapolation : curve.postExtrapolation;
    var startTime = curve.getKeyframeTime(0);
    var endTime = curve.getKeyframeTime(lastKeyframeIndex);

    switch (extrapolationMode) {
      case exports.ExtrapolationMode.LOOP:
        wrappedTime = repeat(time - startTime, endTime - startTime) + startTime;
        break;

      case exports.ExtrapolationMode.PING_PONG:
        wrappedTime = pingPong(time - startTime, endTime - startTime) + startTime;
        break;

      case exports.ExtrapolationMode.CLAMP:
      default:
        wrappedTime = clamp(time, startTime, endTime);
        break;
    }

    if (wrappedTime >= cachedKey.time && wrappedTime < cachedKey.endTime) {
      return cachedKey.evaluate(wrappedTime);
    }

    var leftIndex = this.findIndex(cachedKey, wrappedTime);
    var rightIndex = Math.min(leftIndex + 1, lastKeyframeIndex);
    this.calcOptimizedKey(cachedKey, leftIndex, rightIndex);
    return cachedKey.evaluate(wrappedTime);
  };

  _proto2.calcOptimizedKey = function calcOptimizedKey(optKey, leftIndex, rightIndex) {
    var lhsTime = this._curve.getKeyframeTime(leftIndex);

    var rhsTime = this._curve.getKeyframeTime(rightIndex);

    var _this$_curve$getKeyfr = this._curve.getKeyframeValue(leftIndex),
        lhsValue = _this$_curve$getKeyfr.value,
        lhsOutTangent = _this$_curve$getKeyfr.leftTangent;

    var _this$_curve$getKeyfr2 = this._curve.getKeyframeValue(rightIndex),
        rhsValue = _this$_curve$getKeyfr2.value,
        rhsInTangent = _this$_curve$getKeyfr2.rightTangent;

    optKey.index = leftIndex;
    optKey.time = lhsTime;
    optKey.endTime = rhsTime;
    var dx = rhsTime - lhsTime;
    var dy = rhsValue - lhsValue;
    var length = 1 / (dx * dx);
    var d1 = lhsOutTangent * dx;
    var d2 = rhsInTangent * dx;
    optKey.coefficient[0] = (d1 + d2 - dy - dy) * length / dx;
    optKey.coefficient[1] = (dy + dy + dy - d1 - d1 - d2) * length;
    optKey.coefficient[2] = lhsOutTangent;
    optKey.coefficient[3] = lhsValue;
  };

  _proto2.findIndex = function findIndex(optKey, t) {
    var curve = this._curve;
    var nKeyframes = curve.keyFramesCount;
    var cachedIndex = optKey.index;

    if (cachedIndex !== -1) {
      var cachedTime = curve.getKeyframeTime(cachedIndex);

      if (t > cachedTime) {
        for (var i = 0; i < LOOK_FORWARD; i++) {
          var currIndex = cachedIndex + i;

          if (currIndex + 1 < nKeyframes && curve.getKeyframeTime(currIndex + 1) > t) {
            return currIndex;
          }
        }
      } else {
        for (var _i = 0; _i < LOOK_FORWARD; _i++) {
          var _currIndex = cachedIndex - _i;

          if (_currIndex >= 0 && curve.getKeyframeTime(_currIndex - 1) <= t) {
            return _currIndex - 1;
          }
        }
      }
    }

    var left = 0;
    var right = nKeyframes;
    var mid;

    while (right - left > 1) {
      mid = Math.floor((left + right) / 2);

      if (curve.getKeyframeTime(mid) >= t) {
        right = mid;
      } else {
        left = mid;
      }
    }

    return left;
  };

  return AnimationCurve;
}(), _class3$3.defaultKF = [{
  time: 0,
  value: 1,
  inTangent: 0,
  outTangent: 0
}, {
  time: 1,
  value: 1,
  inTangent: 0,
  outTangent: 0
}], _temp$7), (_descriptor$7 = _applyDecoratedDescriptor(_class2$8.prototype, "_curve", [serializable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
})), _class2$8)) || _class$a);

function fromLegacyWrapMode(legacyWrapMode) {
  switch (legacyWrapMode) {
    default:
    case exports.WrapModeMask.Default:
    case exports.WrapModeMask.Normal:
    case exports.WrapModeMask.Clamp:
      return exports.ExtrapolationMode.CLAMP;

    case exports.WrapModeMask.PingPong:
      return exports.ExtrapolationMode.PING_PONG;

    case exports.WrapModeMask.Loop:
      return exports.ExtrapolationMode.LOOP;
  }
}

function toLegacyWrapMode(extrapolationMode) {
  switch (extrapolationMode) {
    default:
    case exports.ExtrapolationMode.LINEAR:
    case exports.ExtrapolationMode.CLAMP:
      return exports.WrapModeMask.Clamp;

    case exports.ExtrapolationMode.PING_PONG:
      return exports.WrapModeMask.PingPong;

    case exports.ExtrapolationMode.LOOP:
      return exports.WrapModeMask.Loop;
  }
}

function constructLegacyCurveAndConvert() {
  var curve = new RealCurve();
  curve.assignSorted([[0.0, {
    interpolationMode: exports.RealInterpolationMode.CUBIC,
    value: 1.0
  }], [1.0, {
    interpolationMode: exports.RealInterpolationMode.CUBIC,
    value: 1.0
  }]]);
  return curve;
}

exports.replaceProperty(intersect, 'intersect', [{
  name: 'ray_aabb',
  newName: 'rayAABB'
}, {
  name: 'ray_plane',
  newName: 'rayPlane'
}, {
  name: 'ray_triangle',
  newName: 'rayTriangle'
}, {
  name: 'ray_sphere',
  newName: 'raySphere'
}, {
  name: 'ray_obb',
  newName: 'rayOBB'
}, {
  name: 'ray_capsule',
  newName: 'rayCapsule'
}, {
  name: 'ray_subMesh',
  newName: 'raySubMesh'
}, {
  name: 'ray_mesh',
  newName: 'rayMesh'
}, {
  name: 'ray_model',
  newName: 'rayModel'
}, {
  name: 'line_plane',
  newName: 'linePlane'
}, {
  name: 'line_triangle',
  newName: 'lineTriangle'
}, {
  name: 'line_aabb',
  newName: 'lineAABB'
}, {
  name: 'line_obb',
  newName: 'lineOBB'
}, {
  name: 'line_sphere',
  newName: 'lineSphere'
}, {
  name: 'aabb_aabb',
  newName: 'aabbWithAABB'
}, {
  name: 'aabb_obb',
  newName: 'aabbWithOBB'
}, {
  name: 'aabb_plane',
  newName: 'aabbPlane'
}, {
  name: 'aabb_frustum',
  newName: 'aabbFrustum'
}, {
  name: 'aabbFrustum_accurate',
  newName: 'aabbFrustumAccurate'
}, {
  name: 'obb_point',
  newName: 'obbPoint'
}, {
  name: 'obb_plane',
  newName: 'obbPlane'
}, {
  name: 'obb_frustum',
  newName: 'obbFrustum'
}, {
  name: 'obbFrustum_accurate',
  newName: 'obbFrustumAccurate'
}, {
  name: 'obb_obb',
  newName: 'obbWithOBB'
}, {
  name: 'obb_capsule',
  newName: 'obbCapsule'
}, {
  name: 'sphere_plane',
  newName: 'spherePlane'
}, {
  name: 'sphere_frustum',
  newName: 'sphereFrustum'
}, {
  name: 'sphereFrustum_accurate',
  newName: 'sphereFrustumAccurate'
}, {
  name: 'sphere_sphere',
  newName: 'sphereWithSphere'
}, {
  name: 'sphere_aabb',
  newName: 'sphereAABB'
}, {
  name: 'sphere_obb',
  newName: 'sphereOBB'
}, {
  name: 'sphere_capsule',
  newName: 'sphereCapsule'
}, {
  name: 'capsule_capsule',
  newName: 'capsuleWithCapsule'
}]);

function deprecatedClassMessage(oldClassName, newClassName) {
  console.warn(oldClassName + " is deprecated, please use " + newClassName + " instead.");
}

var line = function (_Line) {
  _inheritsLoose(line, _Line);

  function line() {
    var _this;

    _this = _Line.call(this) || this;
    deprecatedClassMessage('line', 'Line');
    return _this;
  }

  return line;
}(Line);
var plane = function (_Plane) {
  _inheritsLoose(plane, _Plane);

  function plane() {
    var _this2;

    _this2 = _Plane.call(this) || this;
    deprecatedClassMessage('plane', 'Plane');
    return _this2;
  }

  return plane;
}(Plane);
var ray = function (_Ray) {
  _inheritsLoose(ray, _Ray);

  function ray() {
    var _this3;

    _this3 = _Ray.call(this) || this;
    deprecatedClassMessage('ray', 'Ray');
    return _this3;
  }

  return ray;
}(Ray);
var triangle = function (_Triangle) {
  _inheritsLoose(triangle, _Triangle);

  function triangle() {
    var _this4;

    _this4 = _Triangle.call(this) || this;
    deprecatedClassMessage('triangle', 'Triangle');
    return _this4;
  }

  return triangle;
}(Triangle);
var sphere = function (_Sphere) {
  _inheritsLoose(sphere, _Sphere);

  function sphere() {
    var _this5;

    _this5 = _Sphere.call(this) || this;
    deprecatedClassMessage('sphere', 'Sphere');
    return _this5;
  }

  return sphere;
}(Sphere);
var aabb = function (_AABB) {
  _inheritsLoose(aabb, _AABB);

  function aabb() {
    var _this6;

    _this6 = _AABB.call(this) || this;
    deprecatedClassMessage('aabb', 'AABB');
    return _this6;
  }

  return aabb;
}(AABB);
var obb = function (_OBB) {
  _inheritsLoose(obb, _OBB);

  function obb() {
    var _this7;

    _this7 = _OBB.call(this) || this;
    deprecatedClassMessage('obb', 'OBB');
    return _this7;
  }

  return obb;
}(OBB);
var capsule = function (_Capsule) {
  _inheritsLoose(capsule, _Capsule);

  function capsule() {
    var _this8;

    _this8 = _Capsule.call(this) || this;
    deprecatedClassMessage('capsule', 'Capsule');
    return _this8;
  }

  return capsule;
}(Capsule);
var frustum = function (_Frustum) {
  _inheritsLoose(frustum, _Frustum);

  function frustum() {
    var _this9;

    _this9 = _Frustum.call(this) || this;
    deprecatedClassMessage('frustum', 'Frustum');
    return _this9;
  }

  return frustum;
}(Frustum);

var layerList = {
  NONE: 0,
  IGNORE_RAYCAST: 1 << 20,
  GIZMOS: 1 << 21,
  EDITOR: 1 << 22,
  UI_3D: 1 << 23,
  SCENE_GIZMO: 1 << 24,
  UI_2D: 1 << 25,
  PROFILER: 1 << 28,
  DEFAULT: 1 << 30,
  ALL: 0xffffffff
};
var Layers = function () {
  function Layers() {}

  Layers.makeMaskInclude = function makeMaskInclude(includes) {
    var mask = 0;

    for (var _iterator = _createForOfIteratorHelperLoose(includes), _step; !(_step = _iterator()).done;) {
      var inc = _step.value;
      mask |= inc;
    }

    return mask;
  };

  Layers.makeMaskExclude = function makeMaskExclude(excludes) {
    return ~Layers.makeMaskInclude(excludes);
  };

  Layers.addLayer = function addLayer(name, bitNum) {
    if (bitNum === undefined) {
      console.warn('bitNum can\'t be undefined');
      return;
    }

    if (bitNum > 19 || bitNum < 0) {
      console.warn('maximum layers reached.');
      return;
    }

    Layers.Enum[name] = 1 << bitNum;
    Layers.Enum[bitNum] = name;
    Layers.BitMask[name] = 1 << bitNum;
    Layers.BitMask[bitNum] = name;
  };

  Layers.deleteLayer = function deleteLayer(bitNum) {
    if (bitNum > 19 || bitNum < 0) {
      console.warn('do not change buildin layers.');
      return;
    }

    delete Layers.Enum[Layers.Enum[bitNum]];
    delete Layers.Enum[bitNum];
    delete Layers.BitMask[Layers.BitMask[bitNum]];
    delete Layers.BitMask[bitNum];
  };

  Layers.nameToLayer = function nameToLayer(name) {
    if (name === undefined) {
      console.warn('name can\'t be undefined');
      return -1;
    }

    return log2(Layers.Enum[name]);
  };

  Layers.layerToName = function layerToName(bitNum) {
    if (bitNum > 31 || bitNum < 0) {
      console.warn('Unable to access unknown layer.');
      return '';
    }

    return Layers.Enum[bitNum];
  };

  return Layers;
}();
Layers.Enum = Enum(layerList);
Layers.BitMask = BitMask(_extends({}, layerList));
legacyCC.Layers = Layers;

var PIPELINE_FLOW_MAIN = 'MainFlow';
var PIPELINE_FLOW_FORWARD = 'ForwardFlow';
var PIPELINE_FLOW_SHADOW = 'ShadowFlow';
var PIPELINE_FLOW_SMAA = 'SMAAFlow';
var PIPELINE_FLOW_TONEMAP = 'ToneMapFlow';
var RenderPassStage;

(function (RenderPassStage) {
  RenderPassStage[RenderPassStage["DEFAULT"] = 100] = "DEFAULT";
  RenderPassStage[RenderPassStage["UI"] = 200] = "UI";
})(RenderPassStage || (RenderPassStage = {}));

legacyCC.RenderPassStage = RenderPassStage;

(function (RenderPriority) {
  RenderPriority[RenderPriority["MIN"] = 0] = "MIN";
  RenderPriority[RenderPriority["MAX"] = 255] = "MAX";
  RenderPriority[RenderPriority["DEFAULT"] = 128] = "DEFAULT";
})(exports.RenderPriority || (exports.RenderPriority = {}));

var globalDescriptorSetLayout = {
  bindings: [],
  layouts: {}
};
var localDescriptorSetLayout = {
  bindings: [],
  layouts: {}
};

(function (PipelineGlobalBindings) {
  PipelineGlobalBindings[PipelineGlobalBindings["UBO_GLOBAL"] = 0] = "UBO_GLOBAL";
  PipelineGlobalBindings[PipelineGlobalBindings["UBO_CAMERA"] = 1] = "UBO_CAMERA";
  PipelineGlobalBindings[PipelineGlobalBindings["UBO_SHADOW"] = 2] = "UBO_SHADOW";
  PipelineGlobalBindings[PipelineGlobalBindings["SAMPLER_SHADOWMAP"] = 3] = "SAMPLER_SHADOWMAP";
  PipelineGlobalBindings[PipelineGlobalBindings["SAMPLER_ENVIRONMENT"] = 4] = "SAMPLER_ENVIRONMENT";
  PipelineGlobalBindings[PipelineGlobalBindings["SAMPLER_SPOT_LIGHTING_MAP"] = 5] = "SAMPLER_SPOT_LIGHTING_MAP";
  PipelineGlobalBindings[PipelineGlobalBindings["SAMPLER_GBUFFER_ALBEDOMAP"] = 6] = "SAMPLER_GBUFFER_ALBEDOMAP";
  PipelineGlobalBindings[PipelineGlobalBindings["SAMPLER_GBUFFER_POSITIONMAP"] = 7] = "SAMPLER_GBUFFER_POSITIONMAP";
  PipelineGlobalBindings[PipelineGlobalBindings["SAMPLER_GBUFFER_NORMALMAP"] = 8] = "SAMPLER_GBUFFER_NORMALMAP";
  PipelineGlobalBindings[PipelineGlobalBindings["SAMPLER_GBUFFER_EMISSIVEMAP"] = 9] = "SAMPLER_GBUFFER_EMISSIVEMAP";
  PipelineGlobalBindings[PipelineGlobalBindings["SAMPLER_LIGHTING_RESULTMAP"] = 10] = "SAMPLER_LIGHTING_RESULTMAP";
  PipelineGlobalBindings[PipelineGlobalBindings["COUNT"] = 11] = "COUNT";
})(exports.PipelineGlobalBindings || (exports.PipelineGlobalBindings = {}));

var GLOBAL_UBO_COUNT = exports.PipelineGlobalBindings.SAMPLER_SHADOWMAP;
var GLOBAL_SAMPLER_COUNT = exports.PipelineGlobalBindings.COUNT - GLOBAL_UBO_COUNT;

(function (ModelLocalBindings) {
  ModelLocalBindings[ModelLocalBindings["UBO_LOCAL"] = 0] = "UBO_LOCAL";
  ModelLocalBindings[ModelLocalBindings["UBO_FORWARD_LIGHTS"] = 1] = "UBO_FORWARD_LIGHTS";
  ModelLocalBindings[ModelLocalBindings["UBO_SKINNING_ANIMATION"] = 2] = "UBO_SKINNING_ANIMATION";
  ModelLocalBindings[ModelLocalBindings["UBO_SKINNING_TEXTURE"] = 3] = "UBO_SKINNING_TEXTURE";
  ModelLocalBindings[ModelLocalBindings["UBO_MORPH"] = 4] = "UBO_MORPH";
  ModelLocalBindings[ModelLocalBindings["SAMPLER_JOINTS"] = 5] = "SAMPLER_JOINTS";
  ModelLocalBindings[ModelLocalBindings["SAMPLER_MORPH_POSITION"] = 6] = "SAMPLER_MORPH_POSITION";
  ModelLocalBindings[ModelLocalBindings["SAMPLER_MORPH_NORMAL"] = 7] = "SAMPLER_MORPH_NORMAL";
  ModelLocalBindings[ModelLocalBindings["SAMPLER_MORPH_TANGENT"] = 8] = "SAMPLER_MORPH_TANGENT";
  ModelLocalBindings[ModelLocalBindings["SAMPLER_LIGHTMAP"] = 9] = "SAMPLER_LIGHTMAP";
  ModelLocalBindings[ModelLocalBindings["SAMPLER_SPRITE"] = 10] = "SAMPLER_SPRITE";
  ModelLocalBindings[ModelLocalBindings["SAMPLER_REFLECTION"] = 11] = "SAMPLER_REFLECTION";
  ModelLocalBindings[ModelLocalBindings["STORAGE_REFLECTION"] = 12] = "STORAGE_REFLECTION";
  ModelLocalBindings[ModelLocalBindings["COUNT"] = 13] = "COUNT";
})(exports.ModelLocalBindings || (exports.ModelLocalBindings = {}));

var LOCAL_UBO_COUNT = exports.ModelLocalBindings.SAMPLER_JOINTS;
var LOCAL_SAMPLER_COUNT = exports.ModelLocalBindings.COUNT - LOCAL_UBO_COUNT;

(function (SetIndex) {
  SetIndex[SetIndex["GLOBAL"] = 0] = "GLOBAL";
  SetIndex[SetIndex["MATERIAL"] = 1] = "MATERIAL";
  SetIndex[SetIndex["LOCAL"] = 2] = "LOCAL";
})(exports.SetIndex || (exports.SetIndex = {}));

var bindingMappingInfo = new BindingMappingInfo();
bindingMappingInfo.bufferOffsets = [0, GLOBAL_UBO_COUNT + LOCAL_UBO_COUNT, GLOBAL_UBO_COUNT];
bindingMappingInfo.samplerOffsets = [-GLOBAL_UBO_COUNT, GLOBAL_SAMPLER_COUNT + LOCAL_SAMPLER_COUNT, GLOBAL_SAMPLER_COUNT - LOCAL_UBO_COUNT];
bindingMappingInfo.flexibleSet = 1;
var UBOGlobal = function UBOGlobal() {};
UBOGlobal.TIME_OFFSET = 0;
UBOGlobal.NATIVE_SIZE_OFFSET = UBOGlobal.TIME_OFFSET + 4;
UBOGlobal.SCREEN_SIZE_OFFSET = UBOGlobal.NATIVE_SIZE_OFFSET + 4;
UBOGlobal.COUNT = UBOGlobal.SCREEN_SIZE_OFFSET + 4;
UBOGlobal.SIZE = UBOGlobal.COUNT * 4;
UBOGlobal.NAME = 'CCGlobal';
UBOGlobal.BINDING = exports.PipelineGlobalBindings.UBO_GLOBAL;
UBOGlobal.DESCRIPTOR = new DescriptorSetLayoutBinding(UBOGlobal.BINDING, exports.DescriptorType.UNIFORM_BUFFER, 1, exports.ShaderStageFlagBit.ALL);
UBOGlobal.LAYOUT = new UniformBlock(exports.SetIndex.GLOBAL, UBOGlobal.BINDING, UBOGlobal.NAME, [new Uniform('cc_time', exports.Type.FLOAT4, 1), new Uniform('cc_screenSize', exports.Type.FLOAT4, 1), new Uniform('cc_nativeSize', exports.Type.FLOAT4, 1)], 1);
globalDescriptorSetLayout.layouts[UBOGlobal.NAME] = UBOGlobal.LAYOUT;
globalDescriptorSetLayout.bindings[UBOGlobal.BINDING] = UBOGlobal.DESCRIPTOR;
var UBOCamera = function UBOCamera() {};
UBOCamera.MAT_VIEW_OFFSET = 0;
UBOCamera.MAT_VIEW_INV_OFFSET = UBOCamera.MAT_VIEW_OFFSET + 16;
UBOCamera.MAT_PROJ_OFFSET = UBOCamera.MAT_VIEW_INV_OFFSET + 16;
UBOCamera.MAT_PROJ_INV_OFFSET = UBOCamera.MAT_PROJ_OFFSET + 16;
UBOCamera.MAT_VIEW_PROJ_OFFSET = UBOCamera.MAT_PROJ_INV_OFFSET + 16;
UBOCamera.MAT_VIEW_PROJ_INV_OFFSET = UBOCamera.MAT_VIEW_PROJ_OFFSET + 16;
UBOCamera.CAMERA_POS_OFFSET = UBOCamera.MAT_VIEW_PROJ_INV_OFFSET + 16;
UBOCamera.SCREEN_SCALE_OFFSET = UBOCamera.CAMERA_POS_OFFSET + 4;
UBOCamera.EXPOSURE_OFFSET = UBOCamera.SCREEN_SCALE_OFFSET + 4;
UBOCamera.MAIN_LIT_DIR_OFFSET = UBOCamera.EXPOSURE_OFFSET + 4;
UBOCamera.MAIN_LIT_COLOR_OFFSET = UBOCamera.MAIN_LIT_DIR_OFFSET + 4;
UBOCamera.AMBIENT_SKY_OFFSET = UBOCamera.MAIN_LIT_COLOR_OFFSET + 4;
UBOCamera.AMBIENT_GROUND_OFFSET = UBOCamera.AMBIENT_SKY_OFFSET + 4;
UBOCamera.GLOBAL_FOG_COLOR_OFFSET = UBOCamera.AMBIENT_GROUND_OFFSET + 4;
UBOCamera.GLOBAL_FOG_BASE_OFFSET = UBOCamera.GLOBAL_FOG_COLOR_OFFSET + 4;
UBOCamera.GLOBAL_FOG_ADD_OFFSET = UBOCamera.GLOBAL_FOG_BASE_OFFSET + 4;
UBOCamera.COUNT = UBOCamera.GLOBAL_FOG_ADD_OFFSET + 4;
UBOCamera.SIZE = UBOCamera.COUNT * 4;
UBOCamera.NAME = 'CCCamera';
UBOCamera.BINDING = exports.PipelineGlobalBindings.UBO_CAMERA;
UBOCamera.DESCRIPTOR = new DescriptorSetLayoutBinding(UBOCamera.BINDING, exports.DescriptorType.UNIFORM_BUFFER, 1, exports.ShaderStageFlagBit.ALL);
UBOCamera.LAYOUT = new UniformBlock(exports.SetIndex.GLOBAL, UBOCamera.BINDING, UBOCamera.NAME, [new Uniform('cc_matView', exports.Type.MAT4, 1), new Uniform('cc_matViewInv', exports.Type.MAT4, 1), new Uniform('cc_matProj', exports.Type.MAT4, 1), new Uniform('cc_matProjInv', exports.Type.MAT4, 1), new Uniform('cc_matViewProj', exports.Type.MAT4, 1), new Uniform('cc_matViewProjInv', exports.Type.MAT4, 1), new Uniform('cc_cameraPos', exports.Type.FLOAT4, 1), new Uniform('cc_screenScale', exports.Type.FLOAT4, 1), new Uniform('cc_exposure', exports.Type.FLOAT4, 1), new Uniform('cc_mainLitDir', exports.Type.FLOAT4, 1), new Uniform('cc_mainLitColor', exports.Type.FLOAT4, 1), new Uniform('cc_ambientSky', exports.Type.FLOAT4, 1), new Uniform('cc_ambientGround', exports.Type.FLOAT4, 1), new Uniform('cc_fogColor', exports.Type.FLOAT4, 1), new Uniform('cc_fogBase', exports.Type.FLOAT4, 1), new Uniform('cc_fogAdd', exports.Type.FLOAT4, 1)], 1);
globalDescriptorSetLayout.layouts[UBOCamera.NAME] = UBOCamera.LAYOUT;
globalDescriptorSetLayout.bindings[UBOCamera.BINDING] = UBOCamera.DESCRIPTOR;
var UBOShadow = function UBOShadow() {};
UBOShadow.MAT_LIGHT_PLANE_PROJ_OFFSET = 0;
UBOShadow.MAT_LIGHT_VIEW_OFFSET = UBOShadow.MAT_LIGHT_PLANE_PROJ_OFFSET + 16;
UBOShadow.MAT_LIGHT_VIEW_PROJ_OFFSET = UBOShadow.MAT_LIGHT_VIEW_OFFSET + 16;
UBOShadow.SHADOW_NEAR_FAR_LINEAR_SATURATION_INFO_OFFSET = UBOShadow.MAT_LIGHT_VIEW_PROJ_OFFSET + 16;
UBOShadow.SHADOW_WIDTH_HEIGHT_PCF_BIAS_INFO_OFFSET = UBOShadow.SHADOW_NEAR_FAR_LINEAR_SATURATION_INFO_OFFSET + 4;
UBOShadow.SHADOW_LIGHT_PACKING_NBIAS_NULL_INFO_OFFSET = UBOShadow.SHADOW_WIDTH_HEIGHT_PCF_BIAS_INFO_OFFSET + 4;
UBOShadow.SHADOW_COLOR_OFFSET = UBOShadow.SHADOW_LIGHT_PACKING_NBIAS_NULL_INFO_OFFSET + 4;
UBOShadow.COUNT = UBOShadow.SHADOW_COLOR_OFFSET + 4;
UBOShadow.SIZE = UBOShadow.COUNT * 4;
UBOShadow.NAME = 'CCShadow';
UBOShadow.BINDING = exports.PipelineGlobalBindings.UBO_SHADOW;
UBOShadow.DESCRIPTOR = new DescriptorSetLayoutBinding(UBOShadow.BINDING, exports.DescriptorType.UNIFORM_BUFFER, 1, exports.ShaderStageFlagBit.ALL);
UBOShadow.LAYOUT = new UniformBlock(exports.SetIndex.GLOBAL, UBOShadow.BINDING, UBOShadow.NAME, [new Uniform('cc_matLightPlaneProj', exports.Type.MAT4, 1), new Uniform('cc_matLightView', exports.Type.MAT4, 1), new Uniform('cc_matLightViewProj', exports.Type.MAT4, 1), new Uniform('cc_shadowNFLSInfo', exports.Type.FLOAT4, 1), new Uniform('cc_shadowWHPBInfo', exports.Type.FLOAT4, 1), new Uniform('cc_shadowLPNNInfo', exports.Type.FLOAT4, 1), new Uniform('cc_shadowColor', exports.Type.FLOAT4, 1)], 1);
globalDescriptorSetLayout.layouts[UBOShadow.NAME] = UBOShadow.LAYOUT;
globalDescriptorSetLayout.bindings[UBOShadow.BINDING] = UBOShadow.DESCRIPTOR;
var UNIFORM_SHADOWMAP_NAME = 'cc_shadowMap';
var UNIFORM_SHADOWMAP_BINDING = exports.PipelineGlobalBindings.SAMPLER_SHADOWMAP;
var UNIFORM_SHADOWMAP_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_SHADOWMAP_BINDING, exports.DescriptorType.SAMPLER_TEXTURE, 1, exports.ShaderStageFlagBit.FRAGMENT);
var UNIFORM_SHADOWMAP_LAYOUT = new UniformSamplerTexture(exports.SetIndex.GLOBAL, UNIFORM_SHADOWMAP_BINDING, UNIFORM_SHADOWMAP_NAME, exports.Type.SAMPLER2D, 1);
globalDescriptorSetLayout.layouts[UNIFORM_SHADOWMAP_NAME] = UNIFORM_SHADOWMAP_LAYOUT;
globalDescriptorSetLayout.bindings[UNIFORM_SHADOWMAP_BINDING] = UNIFORM_SHADOWMAP_DESCRIPTOR;
var UNIFORM_GBUFFER_ALBEDOMAP_NAME = 'cc_gbuffer_albedoMap';
var UNIFORM_GBUFFER_ALBEDOMAP_BINDING = exports.PipelineGlobalBindings.SAMPLER_GBUFFER_ALBEDOMAP;
var UNIFORM_GBUFFER_ALBEDOMAP_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_GBUFFER_ALBEDOMAP_BINDING, exports.DescriptorType.SAMPLER_TEXTURE, 1, exports.ShaderStageFlagBit.FRAGMENT);
var UNIFORM_GBUFFER_ALBEDOMAP_LAYOUT = new UniformSamplerTexture(exports.SetIndex.GLOBAL, UNIFORM_GBUFFER_ALBEDOMAP_BINDING, UNIFORM_GBUFFER_ALBEDOMAP_NAME, exports.Type.SAMPLER2D, 1);
globalDescriptorSetLayout.layouts[UNIFORM_GBUFFER_ALBEDOMAP_NAME] = UNIFORM_GBUFFER_ALBEDOMAP_LAYOUT;
globalDescriptorSetLayout.bindings[UNIFORM_GBUFFER_ALBEDOMAP_BINDING] = UNIFORM_GBUFFER_ALBEDOMAP_DESCRIPTOR;
var UNIFORM_GBUFFER_POSITIONMAP_NAME = 'cc_gbuffer_positionMap';
var UNIFORM_GBUFFER_POSITIONMAP_BINDING = exports.PipelineGlobalBindings.SAMPLER_GBUFFER_POSITIONMAP;
var UNIFORM_GBUFFER_POSITIONMAP_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_GBUFFER_POSITIONMAP_BINDING, exports.DescriptorType.SAMPLER_TEXTURE, 1, exports.ShaderStageFlagBit.FRAGMENT);
var UNIFORM_GBUFFER_POSITIONMAP_LAYOUT = new UniformSamplerTexture(exports.SetIndex.GLOBAL, UNIFORM_GBUFFER_POSITIONMAP_BINDING, UNIFORM_GBUFFER_POSITIONMAP_NAME, exports.Type.SAMPLER2D, 1);
globalDescriptorSetLayout.layouts[UNIFORM_GBUFFER_POSITIONMAP_NAME] = UNIFORM_GBUFFER_POSITIONMAP_LAYOUT;
globalDescriptorSetLayout.bindings[UNIFORM_GBUFFER_POSITIONMAP_BINDING] = UNIFORM_GBUFFER_POSITIONMAP_DESCRIPTOR;
var UNIFORM_GBUFFER_NORMALMAP_NAME = 'cc_gbuffer_normalMap';
var UNIFORM_GBUFFER_NORMALMAP_BINDING = exports.PipelineGlobalBindings.SAMPLER_GBUFFER_NORMALMAP;
var UNIFORM_GBUFFER_NORMALMAP_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_GBUFFER_NORMALMAP_BINDING, exports.DescriptorType.SAMPLER_TEXTURE, 1, exports.ShaderStageFlagBit.FRAGMENT);
var UNIFORM_GBUFFER_NORMALMAP_LAYOUT = new UniformSamplerTexture(exports.SetIndex.GLOBAL, UNIFORM_GBUFFER_NORMALMAP_BINDING, UNIFORM_GBUFFER_NORMALMAP_NAME, exports.Type.SAMPLER2D, 1);
globalDescriptorSetLayout.layouts[UNIFORM_GBUFFER_NORMALMAP_NAME] = UNIFORM_GBUFFER_NORMALMAP_LAYOUT;
globalDescriptorSetLayout.bindings[UNIFORM_GBUFFER_NORMALMAP_BINDING] = UNIFORM_GBUFFER_NORMALMAP_DESCRIPTOR;
var UNIFORM_LIGHTING_RESULTMAP_NAME = 'cc_lighting_resultMap';
var UNIFORM_LIGHTING_RESULTMAP_BINDING = exports.PipelineGlobalBindings.SAMPLER_LIGHTING_RESULTMAP;
var UNIFORM_LIGHTING_RESULTMAP_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_LIGHTING_RESULTMAP_BINDING, exports.DescriptorType.SAMPLER_TEXTURE, 1, exports.ShaderStageFlagBit.FRAGMENT);
var UNIFORM_LIGHTING_RESULTMAP_LAYOUT = new UniformSamplerTexture(exports.SetIndex.GLOBAL, UNIFORM_LIGHTING_RESULTMAP_BINDING, UNIFORM_LIGHTING_RESULTMAP_NAME, exports.Type.SAMPLER2D, 1);
globalDescriptorSetLayout.layouts[UNIFORM_LIGHTING_RESULTMAP_NAME] = UNIFORM_LIGHTING_RESULTMAP_LAYOUT;
globalDescriptorSetLayout.bindings[UNIFORM_LIGHTING_RESULTMAP_BINDING] = UNIFORM_LIGHTING_RESULTMAP_DESCRIPTOR;
var UNIFORM_GBUFFER_EMISSIVEMAP_NAME = 'cc_gbuffer_emissiveMap';
var UNIFORM_GBUFFER_EMISSIVEMAP_BINDING = exports.PipelineGlobalBindings.SAMPLER_GBUFFER_EMISSIVEMAP;
var UNIFORM_GBUFFER_EMISSIVEMAP_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_GBUFFER_EMISSIVEMAP_BINDING, exports.DescriptorType.SAMPLER_TEXTURE, 1, exports.ShaderStageFlagBit.FRAGMENT);
var UNIFORM_GBUFFER_EMISSIVEMAP_LAYOUT = new UniformSamplerTexture(exports.SetIndex.GLOBAL, UNIFORM_GBUFFER_EMISSIVEMAP_BINDING, UNIFORM_GBUFFER_EMISSIVEMAP_NAME, exports.Type.SAMPLER2D, 1);
globalDescriptorSetLayout.layouts[UNIFORM_GBUFFER_EMISSIVEMAP_NAME] = UNIFORM_GBUFFER_EMISSIVEMAP_LAYOUT;
globalDescriptorSetLayout.bindings[UNIFORM_GBUFFER_EMISSIVEMAP_BINDING] = UNIFORM_GBUFFER_EMISSIVEMAP_DESCRIPTOR;
var UNIFORM_ENVIRONMENT_NAME = 'cc_environment';
var UNIFORM_ENVIRONMENT_BINDING = exports.PipelineGlobalBindings.SAMPLER_ENVIRONMENT;
var UNIFORM_ENVIRONMENT_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_ENVIRONMENT_BINDING, exports.DescriptorType.SAMPLER_TEXTURE, 1, exports.ShaderStageFlagBit.FRAGMENT);
var UNIFORM_ENVIRONMENT_LAYOUT = new UniformSamplerTexture(exports.SetIndex.GLOBAL, UNIFORM_ENVIRONMENT_BINDING, UNIFORM_ENVIRONMENT_NAME, exports.Type.SAMPLER_CUBE, 1);
globalDescriptorSetLayout.layouts[UNIFORM_ENVIRONMENT_NAME] = UNIFORM_ENVIRONMENT_LAYOUT;
globalDescriptorSetLayout.bindings[UNIFORM_ENVIRONMENT_BINDING] = UNIFORM_ENVIRONMENT_DESCRIPTOR;
var UNIFORM_SPOT_LIGHTING_MAP_TEXTURE_NAME = 'cc_spotLightingMap';
var UNIFORM_SPOT_LIGHTING_MAP_TEXTURE_BINDING = exports.PipelineGlobalBindings.SAMPLER_SPOT_LIGHTING_MAP;
var UNIFORM_SPOT_LIGHTING_MAP_TEXTURE_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_SPOT_LIGHTING_MAP_TEXTURE_BINDING, exports.DescriptorType.SAMPLER_TEXTURE, 1, exports.ShaderStageFlagBit.FRAGMENT);
var UNIFORM_SPOT_LIGHTING_MAP_TEXTURE_LAYOUT = new UniformSamplerTexture(exports.SetIndex.GLOBAL, UNIFORM_SPOT_LIGHTING_MAP_TEXTURE_BINDING, UNIFORM_SPOT_LIGHTING_MAP_TEXTURE_NAME, exports.Type.SAMPLER2D, 1);
globalDescriptorSetLayout.layouts[UNIFORM_SPOT_LIGHTING_MAP_TEXTURE_NAME] = UNIFORM_SPOT_LIGHTING_MAP_TEXTURE_LAYOUT;
globalDescriptorSetLayout.bindings[UNIFORM_SPOT_LIGHTING_MAP_TEXTURE_BINDING] = UNIFORM_SPOT_LIGHTING_MAP_TEXTURE_DESCRIPTOR;
var UBOLocal = function UBOLocal() {};
UBOLocal.MAT_WORLD_OFFSET = 0;
UBOLocal.MAT_WORLD_IT_OFFSET = UBOLocal.MAT_WORLD_OFFSET + 16;
UBOLocal.LIGHTINGMAP_UVPARAM = UBOLocal.MAT_WORLD_IT_OFFSET + 16;
UBOLocal.COUNT = UBOLocal.LIGHTINGMAP_UVPARAM + 4;
UBOLocal.SIZE = UBOLocal.COUNT * 4;
UBOLocal.NAME = 'CCLocal';
UBOLocal.BINDING = exports.ModelLocalBindings.UBO_LOCAL;
UBOLocal.DESCRIPTOR = new DescriptorSetLayoutBinding(UBOLocal.BINDING, exports.DescriptorType.UNIFORM_BUFFER, 1, exports.ShaderStageFlagBit.VERTEX | exports.ShaderStageFlagBit.COMPUTE);
UBOLocal.LAYOUT = new UniformBlock(exports.SetIndex.LOCAL, UBOLocal.BINDING, UBOLocal.NAME, [new Uniform('cc_matWorld', exports.Type.MAT4, 1), new Uniform('cc_matWorldIT', exports.Type.MAT4, 1), new Uniform('cc_lightingMapUVParam', exports.Type.FLOAT4, 1)], 1);
localDescriptorSetLayout.layouts[UBOLocal.NAME] = UBOLocal.LAYOUT;
localDescriptorSetLayout.bindings[UBOLocal.BINDING] = UBOLocal.DESCRIPTOR;
var INST_MAT_WORLD = 'a_matWorld0';
var UBOLocalBatched = function UBOLocalBatched() {};
UBOLocalBatched.BATCHING_COUNT = 10;
UBOLocalBatched.MAT_WORLDS_OFFSET = 0;
UBOLocalBatched.COUNT = 16 * UBOLocalBatched.BATCHING_COUNT;
UBOLocalBatched.SIZE = UBOLocalBatched.COUNT * 4;
UBOLocalBatched.NAME = 'CCLocalBatched';
UBOLocalBatched.BINDING = exports.ModelLocalBindings.UBO_LOCAL;
UBOLocalBatched.DESCRIPTOR = new DescriptorSetLayoutBinding(UBOLocalBatched.BINDING, exports.DescriptorType.UNIFORM_BUFFER, 1, exports.ShaderStageFlagBit.VERTEX | exports.ShaderStageFlagBit.COMPUTE);
UBOLocalBatched.LAYOUT = new UniformBlock(exports.SetIndex.LOCAL, UBOLocalBatched.BINDING, UBOLocalBatched.NAME, [new Uniform('cc_matWorlds', exports.Type.MAT4, UBOLocalBatched.BATCHING_COUNT)], 1);
localDescriptorSetLayout.layouts[UBOLocalBatched.NAME] = UBOLocalBatched.LAYOUT;
localDescriptorSetLayout.bindings[UBOLocalBatched.BINDING] = UBOLocalBatched.DESCRIPTOR;
var UBOForwardLight = function UBOForwardLight() {};
UBOForwardLight.LIGHTS_PER_PASS = 1;
UBOForwardLight.LIGHT_POS_OFFSET = 0;
UBOForwardLight.LIGHT_COLOR_OFFSET = UBOForwardLight.LIGHT_POS_OFFSET + UBOForwardLight.LIGHTS_PER_PASS * 4;
UBOForwardLight.LIGHT_SIZE_RANGE_ANGLE_OFFSET = UBOForwardLight.LIGHT_COLOR_OFFSET + UBOForwardLight.LIGHTS_PER_PASS * 4;
UBOForwardLight.LIGHT_DIR_OFFSET = UBOForwardLight.LIGHT_SIZE_RANGE_ANGLE_OFFSET + UBOForwardLight.LIGHTS_PER_PASS * 4;
UBOForwardLight.COUNT = UBOForwardLight.LIGHT_DIR_OFFSET + UBOForwardLight.LIGHTS_PER_PASS * 4;
UBOForwardLight.SIZE = UBOForwardLight.COUNT * 4;
UBOForwardLight.NAME = 'CCForwardLight';
UBOForwardLight.BINDING = exports.ModelLocalBindings.UBO_FORWARD_LIGHTS;
UBOForwardLight.DESCRIPTOR = new DescriptorSetLayoutBinding(UBOForwardLight.BINDING, exports.DescriptorType.DYNAMIC_UNIFORM_BUFFER, 1, exports.ShaderStageFlagBit.FRAGMENT);
UBOForwardLight.LAYOUT = new UniformBlock(exports.SetIndex.LOCAL, UBOForwardLight.BINDING, UBOForwardLight.NAME, [new Uniform('cc_lightPos', exports.Type.FLOAT4, UBOForwardLight.LIGHTS_PER_PASS), new Uniform('cc_lightColor', exports.Type.FLOAT4, UBOForwardLight.LIGHTS_PER_PASS), new Uniform('cc_lightSizeRangeAngle', exports.Type.FLOAT4, UBOForwardLight.LIGHTS_PER_PASS), new Uniform('cc_lightDir', exports.Type.FLOAT4, UBOForwardLight.LIGHTS_PER_PASS)], 1);
localDescriptorSetLayout.layouts[UBOForwardLight.NAME] = UBOForwardLight.LAYOUT;
localDescriptorSetLayout.bindings[UBOForwardLight.BINDING] = UBOForwardLight.DESCRIPTOR;
var UBODeferredLight = function UBODeferredLight() {};
UBODeferredLight.LIGHTS_PER_PASS = 10;
var JOINT_UNIFORM_CAPACITY = 30;
var UBOSkinningTexture = function UBOSkinningTexture() {};
UBOSkinningTexture.JOINTS_TEXTURE_INFO_OFFSET = 0;
UBOSkinningTexture.COUNT = UBOSkinningTexture.JOINTS_TEXTURE_INFO_OFFSET + 4;
UBOSkinningTexture.SIZE = UBOSkinningTexture.COUNT * 4;
UBOSkinningTexture.NAME = 'CCSkinningTexture';
UBOSkinningTexture.BINDING = exports.ModelLocalBindings.UBO_SKINNING_TEXTURE;
UBOSkinningTexture.DESCRIPTOR = new DescriptorSetLayoutBinding(UBOSkinningTexture.BINDING, exports.DescriptorType.UNIFORM_BUFFER, 1, exports.ShaderStageFlagBit.VERTEX);
UBOSkinningTexture.LAYOUT = new UniformBlock(exports.SetIndex.LOCAL, UBOSkinningTexture.BINDING, UBOSkinningTexture.NAME, [new Uniform('cc_jointTextureInfo', exports.Type.FLOAT4, 1)], 1);
localDescriptorSetLayout.layouts[UBOSkinningTexture.NAME] = UBOSkinningTexture.LAYOUT;
localDescriptorSetLayout.bindings[UBOSkinningTexture.BINDING] = UBOSkinningTexture.DESCRIPTOR;
var UBOSkinningAnimation = function UBOSkinningAnimation() {};
UBOSkinningAnimation.JOINTS_ANIM_INFO_OFFSET = 0;
UBOSkinningAnimation.COUNT = UBOSkinningAnimation.JOINTS_ANIM_INFO_OFFSET + 4;
UBOSkinningAnimation.SIZE = UBOSkinningAnimation.COUNT * 4;
UBOSkinningAnimation.NAME = 'CCSkinningAnimation';
UBOSkinningAnimation.BINDING = exports.ModelLocalBindings.UBO_SKINNING_ANIMATION;
UBOSkinningAnimation.DESCRIPTOR = new DescriptorSetLayoutBinding(UBOSkinningAnimation.BINDING, exports.DescriptorType.UNIFORM_BUFFER, 1, exports.ShaderStageFlagBit.VERTEX);
UBOSkinningAnimation.LAYOUT = new UniformBlock(exports.SetIndex.LOCAL, UBOSkinningAnimation.BINDING, UBOSkinningAnimation.NAME, [new Uniform('cc_jointAnimInfo', exports.Type.FLOAT4, 1)], 1);
localDescriptorSetLayout.layouts[UBOSkinningAnimation.NAME] = UBOSkinningAnimation.LAYOUT;
localDescriptorSetLayout.bindings[UBOSkinningAnimation.BINDING] = UBOSkinningAnimation.DESCRIPTOR;
var INST_JOINT_ANIM_INFO = 'a_jointAnimInfo';
var UBOSkinning = function UBOSkinning() {};
UBOSkinning.JOINTS_OFFSET = 0;
UBOSkinning.COUNT = UBOSkinning.JOINTS_OFFSET + JOINT_UNIFORM_CAPACITY * 12;
UBOSkinning.SIZE = UBOSkinning.COUNT * 4;
UBOSkinning.NAME = 'CCSkinning';
UBOSkinning.BINDING = exports.ModelLocalBindings.UBO_SKINNING_TEXTURE;
UBOSkinning.DESCRIPTOR = new DescriptorSetLayoutBinding(UBOSkinning.BINDING, exports.DescriptorType.UNIFORM_BUFFER, 1, exports.ShaderStageFlagBit.VERTEX);
UBOSkinning.LAYOUT = new UniformBlock(exports.SetIndex.LOCAL, UBOSkinning.BINDING, UBOSkinning.NAME, [new Uniform('cc_joints', exports.Type.FLOAT4, JOINT_UNIFORM_CAPACITY * 3)], 1);
localDescriptorSetLayout.layouts[UBOSkinning.NAME] = UBOSkinning.LAYOUT;
localDescriptorSetLayout.bindings[UBOSkinning.BINDING] = UBOSkinning.DESCRIPTOR;
var UBOMorph = function UBOMorph() {};
UBOMorph.MAX_MORPH_TARGET_COUNT = 60;
UBOMorph.OFFSET_OF_WEIGHTS = 0;
UBOMorph.OFFSET_OF_DISPLACEMENT_TEXTURE_WIDTH = 4 * UBOMorph.MAX_MORPH_TARGET_COUNT;
UBOMorph.OFFSET_OF_DISPLACEMENT_TEXTURE_HEIGHT = UBOMorph.OFFSET_OF_DISPLACEMENT_TEXTURE_WIDTH + 4;
UBOMorph.OFFSET_OF_VERTICES_COUNT = UBOMorph.OFFSET_OF_DISPLACEMENT_TEXTURE_HEIGHT + 4;
UBOMorph.COUNT_BASE_4_BYTES = 4 * Math.ceil(UBOMorph.MAX_MORPH_TARGET_COUNT / 4) + 4;
UBOMorph.SIZE = UBOMorph.COUNT_BASE_4_BYTES * 4;
UBOMorph.NAME = 'CCMorph';
UBOMorph.BINDING = exports.ModelLocalBindings.UBO_MORPH;
UBOMorph.DESCRIPTOR = new DescriptorSetLayoutBinding(UBOMorph.BINDING, exports.DescriptorType.UNIFORM_BUFFER, 1, exports.ShaderStageFlagBit.VERTEX);
UBOMorph.LAYOUT = new UniformBlock(exports.SetIndex.LOCAL, UBOMorph.BINDING, UBOMorph.NAME, [new Uniform('cc_displacementWeights', exports.Type.FLOAT4, UBOMorph.MAX_MORPH_TARGET_COUNT / 4), new Uniform('cc_displacementTextureInfo', exports.Type.FLOAT4, 1)], 1);
localDescriptorSetLayout.layouts[UBOMorph.NAME] = UBOMorph.LAYOUT;
localDescriptorSetLayout.bindings[UBOMorph.BINDING] = UBOMorph.DESCRIPTOR;
var UNIFORM_JOINT_TEXTURE_NAME = 'cc_jointTexture';
var UNIFORM_JOINT_TEXTURE_BINDING = exports.ModelLocalBindings.SAMPLER_JOINTS;
var UNIFORM_JOINT_TEXTURE_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_JOINT_TEXTURE_BINDING, exports.DescriptorType.SAMPLER_TEXTURE, 1, exports.ShaderStageFlagBit.VERTEX);
var UNIFORM_JOINT_TEXTURE_LAYOUT = new UniformSamplerTexture(exports.SetIndex.LOCAL, UNIFORM_JOINT_TEXTURE_BINDING, UNIFORM_JOINT_TEXTURE_NAME, exports.Type.SAMPLER2D, 1);
localDescriptorSetLayout.layouts[UNIFORM_JOINT_TEXTURE_NAME] = UNIFORM_JOINT_TEXTURE_LAYOUT;
localDescriptorSetLayout.bindings[UNIFORM_JOINT_TEXTURE_BINDING] = UNIFORM_JOINT_TEXTURE_DESCRIPTOR;
var UNIFORM_POSITION_MORPH_TEXTURE_NAME = 'cc_PositionDisplacements';
var UNIFORM_POSITION_MORPH_TEXTURE_BINDING = exports.ModelLocalBindings.SAMPLER_MORPH_POSITION;
var UNIFORM_POSITION_MORPH_TEXTURE_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_POSITION_MORPH_TEXTURE_BINDING, exports.DescriptorType.SAMPLER_TEXTURE, 1, exports.ShaderStageFlagBit.VERTEX);
var UNIFORM_POSITION_MORPH_TEXTURE_LAYOUT = new UniformSamplerTexture(exports.SetIndex.LOCAL, UNIFORM_POSITION_MORPH_TEXTURE_BINDING, UNIFORM_POSITION_MORPH_TEXTURE_NAME, exports.Type.SAMPLER2D, 1);
localDescriptorSetLayout.layouts[UNIFORM_POSITION_MORPH_TEXTURE_NAME] = UNIFORM_POSITION_MORPH_TEXTURE_LAYOUT;
localDescriptorSetLayout.bindings[UNIFORM_POSITION_MORPH_TEXTURE_BINDING] = UNIFORM_POSITION_MORPH_TEXTURE_DESCRIPTOR;
var UNIFORM_NORMAL_MORPH_TEXTURE_NAME = 'cc_NormalDisplacements';
var UNIFORM_NORMAL_MORPH_TEXTURE_BINDING = exports.ModelLocalBindings.SAMPLER_MORPH_NORMAL;
var UNIFORM_NORMAL_MORPH_TEXTURE_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_NORMAL_MORPH_TEXTURE_BINDING, exports.DescriptorType.SAMPLER_TEXTURE, 1, exports.ShaderStageFlagBit.VERTEX);
var UNIFORM_NORMAL_MORPH_TEXTURE_LAYOUT = new UniformSamplerTexture(exports.SetIndex.LOCAL, UNIFORM_NORMAL_MORPH_TEXTURE_BINDING, UNIFORM_NORMAL_MORPH_TEXTURE_NAME, exports.Type.SAMPLER2D, 1);
localDescriptorSetLayout.layouts[UNIFORM_NORMAL_MORPH_TEXTURE_NAME] = UNIFORM_NORMAL_MORPH_TEXTURE_LAYOUT;
localDescriptorSetLayout.bindings[UNIFORM_NORMAL_MORPH_TEXTURE_BINDING] = UNIFORM_NORMAL_MORPH_TEXTURE_DESCRIPTOR;
var UNIFORM_TANGENT_MORPH_TEXTURE_NAME = 'cc_TangentDisplacements';
var UNIFORM_TANGENT_MORPH_TEXTURE_BINDING = exports.ModelLocalBindings.SAMPLER_MORPH_TANGENT;
var UNIFORM_TANGENT_MORPH_TEXTURE_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_TANGENT_MORPH_TEXTURE_BINDING, exports.DescriptorType.SAMPLER_TEXTURE, 1, exports.ShaderStageFlagBit.VERTEX);
var UNIFORM_TANGENT_MORPH_TEXTURE_LAYOUT = new UniformSamplerTexture(exports.SetIndex.LOCAL, UNIFORM_TANGENT_MORPH_TEXTURE_BINDING, UNIFORM_TANGENT_MORPH_TEXTURE_NAME, exports.Type.SAMPLER2D, 1);
localDescriptorSetLayout.layouts[UNIFORM_TANGENT_MORPH_TEXTURE_NAME] = UNIFORM_TANGENT_MORPH_TEXTURE_LAYOUT;
localDescriptorSetLayout.bindings[UNIFORM_TANGENT_MORPH_TEXTURE_BINDING] = UNIFORM_TANGENT_MORPH_TEXTURE_DESCRIPTOR;
var UNIFORM_LIGHTMAP_TEXTURE_NAME = 'cc_lightingMap';
var UNIFORM_LIGHTMAP_TEXTURE_BINDING = exports.ModelLocalBindings.SAMPLER_LIGHTMAP;
var UNIFORM_LIGHTMAP_TEXTURE_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_LIGHTMAP_TEXTURE_BINDING, exports.DescriptorType.SAMPLER_TEXTURE, 1, exports.ShaderStageFlagBit.FRAGMENT);
var UNIFORM_LIGHTMAP_TEXTURE_LAYOUT = new UniformSamplerTexture(exports.SetIndex.LOCAL, UNIFORM_LIGHTMAP_TEXTURE_BINDING, UNIFORM_LIGHTMAP_TEXTURE_NAME, exports.Type.SAMPLER2D, 1);
localDescriptorSetLayout.layouts[UNIFORM_LIGHTMAP_TEXTURE_NAME] = UNIFORM_LIGHTMAP_TEXTURE_LAYOUT;
localDescriptorSetLayout.bindings[UNIFORM_LIGHTMAP_TEXTURE_BINDING] = UNIFORM_LIGHTMAP_TEXTURE_DESCRIPTOR;
var UNIFORM_SPRITE_TEXTURE_NAME = 'cc_spriteTexture';
var UNIFORM_SPRITE_TEXTURE_BINDING = exports.ModelLocalBindings.SAMPLER_SPRITE;
var UNIFORM_SPRITE_TEXTURE_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_SPRITE_TEXTURE_BINDING, exports.DescriptorType.SAMPLER_TEXTURE, 1, exports.ShaderStageFlagBit.FRAGMENT);
var UNIFORM_SPRITE_TEXTURE_LAYOUT = new UniformSamplerTexture(exports.SetIndex.LOCAL, UNIFORM_SPRITE_TEXTURE_BINDING, UNIFORM_SPRITE_TEXTURE_NAME, exports.Type.SAMPLER2D, 1);
localDescriptorSetLayout.layouts[UNIFORM_SPRITE_TEXTURE_NAME] = UNIFORM_SPRITE_TEXTURE_LAYOUT;
localDescriptorSetLayout.bindings[UNIFORM_SPRITE_TEXTURE_BINDING] = UNIFORM_SPRITE_TEXTURE_DESCRIPTOR;
var UNIFORM_REFLECTION_TEXTURE_NAME = 'cc_reflectionTexture';
var UNIFORM_REFLECTION_TEXTURE_BINDING = exports.ModelLocalBindings.SAMPLER_REFLECTION;
var UNIFORM_REFLECTION_TEXTURE_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_REFLECTION_TEXTURE_BINDING, exports.DescriptorType.SAMPLER_TEXTURE, 1, exports.ShaderStageFlagBit.FRAGMENT);
var UNIFORM_REFLECTION_TEXTURE_LAYOUT = new UniformSamplerTexture(exports.SetIndex.LOCAL, UNIFORM_REFLECTION_TEXTURE_BINDING, UNIFORM_REFLECTION_TEXTURE_NAME, exports.Type.SAMPLER2D, 1);
localDescriptorSetLayout.layouts[UNIFORM_REFLECTION_TEXTURE_NAME] = UNIFORM_REFLECTION_TEXTURE_LAYOUT;
localDescriptorSetLayout.bindings[UNIFORM_REFLECTION_TEXTURE_BINDING] = UNIFORM_REFLECTION_TEXTURE_DESCRIPTOR;
var UNIFORM_REFLECTION_STORAGE_NAME = 'cc_reflectionStorage';
var UNIFORM_REFLECTION_STORAGE_BINDING = exports.ModelLocalBindings.STORAGE_REFLECTION;
var UNIFORM_REFLECTION_STORAGE_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_REFLECTION_STORAGE_BINDING, exports.DescriptorType.STORAGE_IMAGE, 1, exports.ShaderStageFlagBit.COMPUTE);
var UNIFORM_REFLECTION_STORAGE_LAYOUT = new UniformStorageImage(exports.SetIndex.LOCAL, UNIFORM_REFLECTION_STORAGE_BINDING, UNIFORM_REFLECTION_STORAGE_NAME, exports.Type.IMAGE2D, 1);
localDescriptorSetLayout.layouts[UNIFORM_REFLECTION_STORAGE_NAME] = UNIFORM_REFLECTION_STORAGE_LAYOUT;
localDescriptorSetLayout.bindings[UNIFORM_REFLECTION_STORAGE_BINDING] = UNIFORM_REFLECTION_STORAGE_DESCRIPTOR;
var CAMERA_DEFAULT_MASK = Layers.makeMaskExclude([Layers.BitMask.UI_2D, Layers.BitMask.GIZMOS, Layers.BitMask.EDITOR, Layers.BitMask.SCENE_GIZMO, Layers.BitMask.PROFILER]);
var CAMERA_EDITOR_MASK = Layers.makeMaskExclude([Layers.BitMask.UI_2D, Layers.BitMask.PROFILER]);
var MODEL_ALWAYS_MASK = Layers.Enum.ALL;
function supportsHalfFloatTexture(device) {
  return device.hasFeature(exports.Feature.COLOR_HALF_FLOAT) && device.hasFeature(exports.Feature.TEXTURE_HALF_FLOAT) && !(device.gfxAPI === exports.API.WEBGL);
}

var define$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    PIPELINE_FLOW_MAIN: PIPELINE_FLOW_MAIN,
    PIPELINE_FLOW_FORWARD: PIPELINE_FLOW_FORWARD,
    PIPELINE_FLOW_SHADOW: PIPELINE_FLOW_SHADOW,
    PIPELINE_FLOW_SMAA: PIPELINE_FLOW_SMAA,
    PIPELINE_FLOW_TONEMAP: PIPELINE_FLOW_TONEMAP,
    get RenderPassStage () { return RenderPassStage; },
    get RenderPriority () { return exports.RenderPriority; },
    globalDescriptorSetLayout: globalDescriptorSetLayout,
    localDescriptorSetLayout: localDescriptorSetLayout,
    get PipelineGlobalBindings () { return exports.PipelineGlobalBindings; },
    get ModelLocalBindings () { return exports.ModelLocalBindings; },
    get SetIndex () { return exports.SetIndex; },
    bindingMappingInfo: bindingMappingInfo,
    UBOGlobal: UBOGlobal,
    UBOCamera: UBOCamera,
    UBOShadow: UBOShadow,
    UNIFORM_SHADOWMAP_BINDING: UNIFORM_SHADOWMAP_BINDING,
    UNIFORM_GBUFFER_ALBEDOMAP_BINDING: UNIFORM_GBUFFER_ALBEDOMAP_BINDING,
    UNIFORM_GBUFFER_POSITIONMAP_BINDING: UNIFORM_GBUFFER_POSITIONMAP_BINDING,
    UNIFORM_GBUFFER_NORMALMAP_BINDING: UNIFORM_GBUFFER_NORMALMAP_BINDING,
    UNIFORM_LIGHTING_RESULTMAP_BINDING: UNIFORM_LIGHTING_RESULTMAP_BINDING,
    UNIFORM_GBUFFER_EMISSIVEMAP_BINDING: UNIFORM_GBUFFER_EMISSIVEMAP_BINDING,
    UNIFORM_ENVIRONMENT_BINDING: UNIFORM_ENVIRONMENT_BINDING,
    UNIFORM_SPOT_LIGHTING_MAP_TEXTURE_BINDING: UNIFORM_SPOT_LIGHTING_MAP_TEXTURE_BINDING,
    UBOLocal: UBOLocal,
    INST_MAT_WORLD: INST_MAT_WORLD,
    UBOLocalBatched: UBOLocalBatched,
    UBOForwardLight: UBOForwardLight,
    UBODeferredLight: UBODeferredLight,
    JOINT_UNIFORM_CAPACITY: JOINT_UNIFORM_CAPACITY,
    UBOSkinningTexture: UBOSkinningTexture,
    UBOSkinningAnimation: UBOSkinningAnimation,
    INST_JOINT_ANIM_INFO: INST_JOINT_ANIM_INFO,
    UBOSkinning: UBOSkinning,
    UBOMorph: UBOMorph,
    UNIFORM_JOINT_TEXTURE_BINDING: UNIFORM_JOINT_TEXTURE_BINDING,
    UNIFORM_POSITION_MORPH_TEXTURE_BINDING: UNIFORM_POSITION_MORPH_TEXTURE_BINDING,
    UNIFORM_NORMAL_MORPH_TEXTURE_BINDING: UNIFORM_NORMAL_MORPH_TEXTURE_BINDING,
    UNIFORM_TANGENT_MORPH_TEXTURE_BINDING: UNIFORM_TANGENT_MORPH_TEXTURE_BINDING,
    UNIFORM_LIGHTMAP_TEXTURE_BINDING: UNIFORM_LIGHTMAP_TEXTURE_BINDING,
    UNIFORM_SPRITE_TEXTURE_BINDING: UNIFORM_SPRITE_TEXTURE_BINDING,
    UNIFORM_REFLECTION_TEXTURE_BINDING: UNIFORM_REFLECTION_TEXTURE_BINDING,
    UNIFORM_REFLECTION_STORAGE_BINDING: UNIFORM_REFLECTION_STORAGE_BINDING,
    CAMERA_DEFAULT_MASK: CAMERA_DEFAULT_MASK,
    CAMERA_EDITOR_MASK: CAMERA_EDITOR_MASK,
    MODEL_ALWAYS_MASK: MODEL_ALWAYS_MASK,
    supportsHalfFloatTexture: supportsHalfFloatTexture
});

var CUSTOM_PIXEL_FORMAT = 1024;

(function (PixelFormat) {
  PixelFormat[PixelFormat["RGB565"] = exports.Format.R5G6B5] = "RGB565";
  PixelFormat[PixelFormat["RGB5A1"] = exports.Format.RGB5A1] = "RGB5A1";
  PixelFormat[PixelFormat["RGBA4444"] = exports.Format.RGBA4] = "RGBA4444";
  PixelFormat[PixelFormat["RGB888"] = exports.Format.RGB8] = "RGB888";
  PixelFormat[PixelFormat["RGB32F"] = exports.Format.RGB32F] = "RGB32F";
  PixelFormat[PixelFormat["RGBA8888"] = exports.Format.RGBA8] = "RGBA8888";
  PixelFormat[PixelFormat["RGBA32F"] = exports.Format.RGBA32F] = "RGBA32F";
  PixelFormat[PixelFormat["A8"] = exports.Format.A8] = "A8";
  PixelFormat[PixelFormat["I8"] = exports.Format.L8] = "I8";
  PixelFormat[PixelFormat["AI8"] = exports.Format.LA8] = "AI8";
  PixelFormat[PixelFormat["RGB_PVRTC_2BPPV1"] = exports.Format.PVRTC_RGB2] = "RGB_PVRTC_2BPPV1";
  PixelFormat[PixelFormat["RGBA_PVRTC_2BPPV1"] = exports.Format.PVRTC_RGBA2] = "RGBA_PVRTC_2BPPV1";
  PixelFormat[PixelFormat["RGB_A_PVRTC_2BPPV1"] = CUSTOM_PIXEL_FORMAT++] = "RGB_A_PVRTC_2BPPV1";
  PixelFormat[PixelFormat["RGB_PVRTC_4BPPV1"] = exports.Format.PVRTC_RGB4] = "RGB_PVRTC_4BPPV1";
  PixelFormat[PixelFormat["RGBA_PVRTC_4BPPV1"] = exports.Format.PVRTC_RGBA4] = "RGBA_PVRTC_4BPPV1";
  PixelFormat[PixelFormat["RGB_A_PVRTC_4BPPV1"] = CUSTOM_PIXEL_FORMAT++] = "RGB_A_PVRTC_4BPPV1";
  PixelFormat[PixelFormat["RGB_ETC1"] = exports.Format.ETC_RGB8] = "RGB_ETC1";
  PixelFormat[PixelFormat["RGBA_ETC1"] = CUSTOM_PIXEL_FORMAT++] = "RGBA_ETC1";
  PixelFormat[PixelFormat["RGB_ETC2"] = exports.Format.ETC2_RGB8] = "RGB_ETC2";
  PixelFormat[PixelFormat["RGBA_ETC2"] = exports.Format.ETC2_RGBA8] = "RGBA_ETC2";
  PixelFormat[PixelFormat["RGBA_ASTC_4x4"] = exports.Format.ASTC_RGBA_4X4] = "RGBA_ASTC_4x4";
  PixelFormat[PixelFormat["RGBA_ASTC_5x4"] = exports.Format.ASTC_RGBA_5X4] = "RGBA_ASTC_5x4";
  PixelFormat[PixelFormat["RGBA_ASTC_5x5"] = exports.Format.ASTC_RGBA_5X5] = "RGBA_ASTC_5x5";
  PixelFormat[PixelFormat["RGBA_ASTC_6x5"] = exports.Format.ASTC_RGBA_6X5] = "RGBA_ASTC_6x5";
  PixelFormat[PixelFormat["RGBA_ASTC_6x6"] = exports.Format.ASTC_RGBA_6X6] = "RGBA_ASTC_6x6";
  PixelFormat[PixelFormat["RGBA_ASTC_8x5"] = exports.Format.ASTC_RGBA_8X5] = "RGBA_ASTC_8x5";
  PixelFormat[PixelFormat["RGBA_ASTC_8x6"] = exports.Format.ASTC_RGBA_8X6] = "RGBA_ASTC_8x6";
  PixelFormat[PixelFormat["RGBA_ASTC_8x8"] = exports.Format.ASTC_RGBA_8X8] = "RGBA_ASTC_8x8";
  PixelFormat[PixelFormat["RGBA_ASTC_10x5"] = exports.Format.ASTC_RGBA_10X5] = "RGBA_ASTC_10x5";
  PixelFormat[PixelFormat["RGBA_ASTC_10x6"] = exports.Format.ASTC_RGBA_10X6] = "RGBA_ASTC_10x6";
  PixelFormat[PixelFormat["RGBA_ASTC_10x8"] = exports.Format.ASTC_RGBA_10X8] = "RGBA_ASTC_10x8";
  PixelFormat[PixelFormat["RGBA_ASTC_10x10"] = exports.Format.ASTC_RGBA_10X10] = "RGBA_ASTC_10x10";
  PixelFormat[PixelFormat["RGBA_ASTC_12x10"] = exports.Format.ASTC_RGBA_12X10] = "RGBA_ASTC_12x10";
  PixelFormat[PixelFormat["RGBA_ASTC_12x12"] = exports.Format.ASTC_RGBA_12X12] = "RGBA_ASTC_12x12";
})(exports.PixelFormat || (exports.PixelFormat = {}));

(function (WrapMode) {
  WrapMode[WrapMode["REPEAT"] = exports.Address.WRAP] = "REPEAT";
  WrapMode[WrapMode["CLAMP_TO_EDGE"] = exports.Address.CLAMP] = "CLAMP_TO_EDGE";
  WrapMode[WrapMode["MIRRORED_REPEAT"] = exports.Address.MIRROR] = "MIRRORED_REPEAT";
  WrapMode[WrapMode["CLAMP_TO_BORDER"] = exports.Address.BORDER] = "CLAMP_TO_BORDER";
})(exports.WrapMode$1 || (exports.WrapMode$1 = {}));

(function (Filter) {
  Filter[Filter["NONE"] = exports.Filter.NONE] = "NONE";
  Filter[Filter["LINEAR"] = exports.Filter.LINEAR] = "LINEAR";
  Filter[Filter["NEAREST"] = exports.Filter.POINT] = "NEAREST";
})(exports.Filter$1 || (exports.Filter$1 = {}));

var _dec$b, _class$b, _class2$9, _class3$4, _temp$8;

function isImageBitmap(imageSource) {
  return !!(legacyCC.sys.capabilities.imageBitmap && imageSource instanceof ImageBitmap);
}

function isNativeImage(imageSource) {

  return imageSource instanceof HTMLImageElement || imageSource instanceof HTMLCanvasElement || isImageBitmap(imageSource);
}

var ImageAsset = (_dec$b = ccclass('cc.ImageAsset'), _dec$b(_class$b = (_class2$9 = (_temp$8 = _class3$4 = function (_Asset) {
  _inheritsLoose(ImageAsset, _Asset);

  _createClass(ImageAsset, [{
    key: "_nativeAsset",
    get: function get() {
      return this._nativeData;
    },
    set: function set(value) {
      if (!(value instanceof HTMLElement) && !isImageBitmap(value)) {
        value.format = value.format || this._format;
      }

      this.reset(value);
    }
  }, {
    key: "data",
    get: function get() {
      if (this._nativeData && isNativeImage(this._nativeData)) {
        return this._nativeData;
      }

      return this._nativeData && this._nativeData._data;
    }
  }, {
    key: "width",
    get: function get() {
      return this._nativeData.width || this._width;
    }
  }, {
    key: "height",
    get: function get() {
      return this._nativeData.height || this._height;
    }
  }, {
    key: "format",
    get: function get() {
      return this._format;
    }
  }, {
    key: "isCompressed",
    get: function get() {
      return this._format >= exports.PixelFormat.RGB_ETC1 && this._format <= exports.PixelFormat.RGBA_ASTC_12x12 || this._format >= exports.PixelFormat.RGB_A_PVRTC_2BPPV1 && this._format <= exports.PixelFormat.RGBA_ETC1;
    }
  }, {
    key: "url",
    get: function get() {
      return this.nativeUrl;
    }
  }]);

  function ImageAsset(nativeAsset) {
    var _this;

    _this = _Asset.call(this) || this;
    _this._nativeData = void 0;
    _this._exportedExts = undefined;
    _this._format = exports.PixelFormat.RGBA8888;
    _this._width = 0;
    _this._height = 0;
    _this._nativeData = {
      _data: null,
      width: 0,
      height: 0,
      format: 0,
      _compressed: false
    };

    if (nativeAsset !== undefined) {
      _this.reset(nativeAsset);
    }

    return _this;
  }

  var _proto = ImageAsset.prototype;

  _proto.reset = function reset(data) {
    if (isImageBitmap(data)) {
      this._nativeData = data;
    } else if (!(data instanceof HTMLElement)) {
      this._nativeData = data;
      this._format = data.format;
    } else {
      this._nativeData = data;
    }
  };

  _proto.destroy = function destroy() {
    if (this.data && this.data instanceof HTMLImageElement) {
      this.data.src = '';

      this._setRawAsset('');
    } else if (isImageBitmap(this.data)) {
      this.data.close && this.data.close();
    }

    return _Asset.prototype.destroy.call(this);
  };

  _proto._serialize = function _serialize() {
  };

  _proto._deserialize = function _deserialize(data) {
    var fmtStr = '';

    if (typeof data === 'string') {
      fmtStr = data;
    } else {
      this._width = data.w;
      this._height = data.h;
      fmtStr = data.fmt;
    }

    var device = _getGlobalDevice();

    var extensionIDs = fmtStr.split('_');
    var defaultExt = '';
    var preferedExtensionIndex = Number.MAX_VALUE;
    var format = this._format;
    var ext = '';
    var SupportTextureFormats = legacyCC.macro.SUPPORT_TEXTURE_FORMATS;

    for (var _iterator2 = _createForOfIteratorHelperLoose(extensionIDs), _step2; !(_step2 = _iterator2()).done;) {
      var extensionID = _step2.value;
      var extFormat = extensionID.split('@');
      var i = parseInt(extFormat[0], undefined);
      var tmpExt = ImageAsset.extnames[i] || extFormat[0];
      var index = SupportTextureFormats.indexOf(tmpExt);

      if (index !== -1 && index < preferedExtensionIndex) {
        var fmt = extFormat[1] ? parseInt(extFormat[1]) : this._format;

        if (tmpExt === '.astc' && (!device || !device.hasFeature(exports.Feature.FORMAT_ASTC))) {
          continue;
        } else if (tmpExt === '.pvr' && (!device || !device.hasFeature(exports.Feature.FORMAT_PVRTC))) {
          continue;
        } else if ((fmt === exports.PixelFormat.RGB_ETC1 || fmt === exports.PixelFormat.RGBA_ETC1) && (!device || !device.hasFeature(exports.Feature.FORMAT_ETC1))) {
          continue;
        } else if ((fmt === exports.PixelFormat.RGB_ETC2 || fmt === exports.PixelFormat.RGBA_ETC2) && (!device || !device.hasFeature(exports.Feature.FORMAT_ETC2))) {
          continue;
        } else if (tmpExt === '.webp' && !legacyCC.sys.capabilities.webp) {
          continue;
        }

        preferedExtensionIndex = index;
        ext = tmpExt;
        format = fmt;
      } else if (!defaultExt) {
        defaultExt = tmpExt;
      }
    }

    if (ext) {
      this._setRawAsset(ext);

      this._format = format;
    } else if (defaultExt) {
      this._setRawAsset(defaultExt);

      warnID(3120, defaultExt, defaultExt);
    } else {
      warnID(3121);
    }
  };

  _proto.initDefault = function initDefault(uuid) {
    _Asset.prototype.initDefault.call(this, uuid);

    if (!ImageAsset._sharedPlaceHolderCanvas) {
      var canvas = document.createElement('canvas');
      var context = canvas.getContext('2d');
      var l = canvas.width = canvas.height = 2;
      context.fillStyle = '#ff00ff';
      context.fillRect(0, 0, l, l);
      this.reset(canvas);
      ImageAsset._sharedPlaceHolderCanvas = canvas;
    } else {
      this.reset(ImageAsset._sharedPlaceHolderCanvas);
    }
  };

  _proto.validate = function validate() {
    return !!this.data;
  };

  return ImageAsset;
}(Asset), _class3$4.extnames = ['.png', '.jpg', '.jpeg', '.bmp', '.webp', '.pvr', '.pkm', '.astc'], _class3$4._sharedPlaceHolderCanvas = null, _temp$8), (_applyDecoratedDescriptor(_class2$9.prototype, "_nativeAsset", [override], Object.getOwnPropertyDescriptor(_class2$9.prototype, "_nativeAsset"), _class2$9.prototype)), _class2$9)) || _class$b);

function _getGlobalDevice() {
  if (legacyCC.director.root) {
    return legacyCC.director.root.device;
  }

  return null;
}

legacyCC.ImageAsset = ImageAsset;

(function (SamplerInfoIndex) {
  SamplerInfoIndex[SamplerInfoIndex["minFilter"] = 0] = "minFilter";
  SamplerInfoIndex[SamplerInfoIndex["magFilter"] = 1] = "magFilter";
  SamplerInfoIndex[SamplerInfoIndex["mipFilter"] = 2] = "mipFilter";
  SamplerInfoIndex[SamplerInfoIndex["addressU"] = 3] = "addressU";
  SamplerInfoIndex[SamplerInfoIndex["addressV"] = 4] = "addressV";
  SamplerInfoIndex[SamplerInfoIndex["addressW"] = 5] = "addressW";
  SamplerInfoIndex[SamplerInfoIndex["maxAnisotropy"] = 6] = "maxAnisotropy";
  SamplerInfoIndex[SamplerInfoIndex["cmpFunc"] = 7] = "cmpFunc";
  SamplerInfoIndex[SamplerInfoIndex["mipLODBias"] = 8] = "mipLODBias";
  SamplerInfoIndex[SamplerInfoIndex["total"] = 9] = "total";
})(exports.SamplerInfoIndex || (exports.SamplerInfoIndex = {}));

var defaultInfo = [exports.Filter.LINEAR, exports.Filter.LINEAR, exports.Filter.NONE, exports.Address.WRAP, exports.Address.WRAP, exports.Address.WRAP, 0, exports.ComparisonFunc.NEVER, 0];
var defaultSamplerHash = genSamplerHash(defaultInfo);
var borderColor = new Color$1();

var _samplerInfo = new SamplerInfo();

function genSamplerHash(info) {
  var value = 0;
  var hash = 0;

  for (var i = 0; i < defaultInfo.length; i++) {
    value = info[i] || defaultInfo[i];

    switch (i) {
      case exports.SamplerInfoIndex.minFilter:
        hash |= value;
        break;

      case exports.SamplerInfoIndex.magFilter:
        hash |= value << 2;
        break;

      case exports.SamplerInfoIndex.mipFilter:
        hash |= value << 4;
        break;

      case exports.SamplerInfoIndex.addressU:
        hash |= value << 6;
        break;

      case exports.SamplerInfoIndex.addressV:
        hash |= value << 8;
        break;

      case exports.SamplerInfoIndex.addressW:
        hash |= value << 10;
        break;

      case exports.SamplerInfoIndex.maxAnisotropy:
        hash |= value << 12;
        break;

      case exports.SamplerInfoIndex.cmpFunc:
        hash |= value << 16;
        break;

      case exports.SamplerInfoIndex.mipLODBias:
        hash |= value << 28;
        break;
    }
  }

  return hash;
}

var SamplerLib = function () {
  function SamplerLib() {
    this._cache = {};
  }

  var _proto = SamplerLib.prototype;

  _proto.getSampler = function getSampler(device, hash) {
    if (!hash) {
      hash = defaultSamplerHash;
    }

    var cache = this._cache[hash];

    if (cache) {
      return cache;
    }

    _samplerInfo.minFilter = hash & 3;
    _samplerInfo.magFilter = hash >> 2 & 3;
    _samplerInfo.mipFilter = hash >> 4 & 3;
    _samplerInfo.addressU = hash >> 6 & 3;
    _samplerInfo.addressV = hash >> 8 & 3;
    _samplerInfo.addressW = hash >> 10 & 3;
    _samplerInfo.maxAnisotropy = hash >> 12 & 15;
    _samplerInfo.cmpFunc = hash >> 16 & 15;
    _samplerInfo.mipLODBias = hash >> 28 & 15;
    _samplerInfo.borderColor = borderColor;
    var sampler = this._cache[hash] = device.createSampler(_samplerInfo);
    return sampler;
  };

  return SamplerLib;
}();

var samplerLib = new SamplerLib();
legacyCC.samplerLib = samplerLib;

var _dec$c, _class$c, _class2$a, _descriptor$8, _descriptor2$5, _descriptor3$4, _descriptor4$3, _descriptor5$1, _descriptor6$1, _descriptor7$1, _descriptor8$1, _class3$5, _temp$9;
var idGenerator$1 = new IDGenerator('Tex');
var TextureBase = (_dec$c = ccclass('cc.TextureBase'), _dec$c(_class$c = (_class2$a = (_temp$9 = _class3$5 = function (_Asset) {
  _inheritsLoose(TextureBase, _Asset);

  _createClass(TextureBase, [{
    key: "isCompressed",
    get: function get() {
      return this._format >= exports.PixelFormat.RGB_ETC1 && this._format <= exports.PixelFormat.RGBA_ASTC_12x12 || this._format >= exports.PixelFormat.RGB_A_PVRTC_2BPPV1 && this._format <= exports.PixelFormat.RGBA_ETC1;
    }
  }, {
    key: "width",
    get: function get() {
      return this._width;
    }
  }, {
    key: "height",
    get: function get() {
      return this._height;
    }
  }]);

  function TextureBase() {
    var _this;

    _this = _Asset.call(this) || this;

    _initializerDefineProperty(_this, "_format", _descriptor$8, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_minFilter", _descriptor2$5, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_magFilter", _descriptor3$4, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_mipFilter", _descriptor4$3, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_wrapS", _descriptor5$1, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_wrapT", _descriptor6$1, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_wrapR", _descriptor7$1, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_anisotropy", _descriptor8$1, _assertThisInitialized(_this));

    _this._width = 1;
    _this._height = 1;
    _this._id = void 0;
    _this._samplerInfo = [];
    _this._samplerHash = 0;
    _this._gfxSampler = null;
    _this._gfxDevice = null;
    _this._textureHash = 0;
    _this._id = idGenerator$1.getNewId();
    _this._gfxDevice = _this._getGFXDevice();
    _this._textureHash = murmurhash2_32_gc(_this._id, 666);
    return _this;
  }

  var _proto = TextureBase.prototype;

  _proto.getId = function getId() {
    return this._id;
  };

  _proto.getPixelFormat = function getPixelFormat() {
    return this._format;
  };

  _proto.getAnisotropy = function getAnisotropy() {
    return this._anisotropy;
  };

  _proto.setWrapMode = function setWrapMode(wrapS, wrapT, wrapR) {
    this._wrapS = wrapS;
    this._samplerInfo[exports.SamplerInfoIndex.addressU] = wrapS;
    this._wrapT = wrapT;
    this._samplerInfo[exports.SamplerInfoIndex.addressV] = wrapT;

    if (wrapR !== undefined) {
      this._wrapR = wrapR;
      this._samplerInfo[exports.SamplerInfoIndex.addressW] = wrapR;
    }

    this._samplerHash = genSamplerHash(this._samplerInfo);

    if (this._gfxDevice) {
      this._gfxSampler = samplerLib.getSampler(this._gfxDevice, this._samplerHash);
    }
  };

  _proto.setFilters = function setFilters(minFilter, magFilter) {
    this._minFilter = minFilter;
    this._samplerInfo[exports.SamplerInfoIndex.minFilter] = minFilter;
    this._magFilter = magFilter;
    this._samplerInfo[exports.SamplerInfoIndex.magFilter] = magFilter;
    this._samplerHash = genSamplerHash(this._samplerInfo);

    if (this._gfxDevice) {
      this._gfxSampler = samplerLib.getSampler(this._gfxDevice, this._samplerHash);
    }
  };

  _proto.setMipFilter = function setMipFilter(mipFilter) {
    this._mipFilter = mipFilter;
    this._samplerInfo[exports.SamplerInfoIndex.mipFilter] = mipFilter;
    this._samplerHash = genSamplerHash(this._samplerInfo);

    if (this._gfxDevice) {
      this._gfxSampler = samplerLib.getSampler(this._gfxDevice, this._samplerHash);
    }
  };

  _proto.setAnisotropy = function setAnisotropy(anisotropy) {
    this._anisotropy = anisotropy;
    this._samplerInfo[exports.SamplerInfoIndex.maxAnisotropy] = anisotropy;
    this._samplerHash = genSamplerHash(this._samplerInfo);

    if (this._gfxDevice) {
      this._gfxSampler = samplerLib.getSampler(this._gfxDevice, this._samplerHash);
    }
  };

  _proto.destroy = function destroy() {
    var _legacyCC$director$ro;

    var destroyed = _Asset.prototype.destroy.call(this);

    if (destroyed && ((_legacyCC$director$ro = legacyCC.director.root) === null || _legacyCC$director$ro === void 0 ? void 0 : _legacyCC$director$ro.batcher2D)) {
      legacyCC.director.root.batcher2D._releaseDescriptorSetCache(this._textureHash);
    }

    return destroyed;
  };

  _proto.getHash = function getHash() {
    return this._textureHash;
  };

  _proto.getGFXTexture = function getGFXTexture() {
    return null;
  };

  _proto.getSamplerHash = function getSamplerHash() {
    return this._samplerHash;
  };

  _proto.getGFXSampler = function getGFXSampler() {
    if (!this._gfxSampler) {
      if (this._gfxDevice) {
        this._gfxSampler = samplerLib.getSampler(this._gfxDevice, this._samplerHash);
      } else {
        errorID(9302);
      }
    }

    return this._gfxSampler;
  };

  _proto._serialize = function _serialize(ctxForExporting) {

    return '';
  };

  _proto._deserialize = function _deserialize(serializedData, handle) {
    var data = serializedData;
    var fields = data.split(',');
    fields.unshift('');

    if (fields.length >= 5) {
      this.setFilters(parseInt(fields[1]), parseInt(fields[2]));
      this.setWrapMode(parseInt(fields[3]), parseInt(fields[4]));
    }

    if (fields.length >= 7) {
      this.setMipFilter(parseInt(fields[5]));
      this.setAnisotropy(parseInt(fields[6]));
    }
  };

  _proto._getGFXDevice = function _getGFXDevice() {
    if (legacyCC.director.root) {
      return legacyCC.director.root.device;
    }

    return null;
  };

  _proto._getGFXFormat = function _getGFXFormat() {
    return this._getGFXPixelFormat(this._format);
  };

  _proto._setGFXFormat = function _setGFXFormat(format) {
    this._format = format === undefined ? exports.PixelFormat.RGBA8888 : format;
  };

  _proto._getGFXPixelFormat = function _getGFXPixelFormat(format) {
    if (format === exports.PixelFormat.RGBA_ETC1) {
      format = exports.PixelFormat.RGB_ETC1;
    } else if (format === exports.PixelFormat.RGB_A_PVRTC_4BPPV1) {
      format = exports.PixelFormat.RGB_PVRTC_4BPPV1;
    } else if (format === exports.PixelFormat.RGB_A_PVRTC_2BPPV1) {
      format = exports.PixelFormat.RGB_PVRTC_2BPPV1;
    }

    return format;
  };

  return TextureBase;
}(Asset), _class3$5.PixelFormat = exports.PixelFormat, _class3$5.WrapMode = exports.WrapMode$1, _class3$5.Filter = exports.Filter$1, _temp$9), (_descriptor$8 = _applyDecoratedDescriptor(_class2$a.prototype, "_format", [serializable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return exports.PixelFormat.RGBA8888;
  }
}), _descriptor2$5 = _applyDecoratedDescriptor(_class2$a.prototype, "_minFilter", [serializable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return exports.Filter$1.LINEAR;
  }
}), _descriptor3$4 = _applyDecoratedDescriptor(_class2$a.prototype, "_magFilter", [serializable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return exports.Filter$1.LINEAR;
  }
}), _descriptor4$3 = _applyDecoratedDescriptor(_class2$a.prototype, "_mipFilter", [serializable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return exports.Filter$1.NONE;
  }
}), _descriptor5$1 = _applyDecoratedDescriptor(_class2$a.prototype, "_wrapS", [serializable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return exports.WrapMode$1.REPEAT;
  }
}), _descriptor6$1 = _applyDecoratedDescriptor(_class2$a.prototype, "_wrapT", [serializable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return exports.WrapMode$1.REPEAT;
  }
}), _descriptor7$1 = _applyDecoratedDescriptor(_class2$a.prototype, "_wrapR", [serializable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return exports.WrapMode$1.REPEAT;
  }
}), _descriptor8$1 = _applyDecoratedDescriptor(_class2$a.prototype, "_anisotropy", [serializable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return 0;
  }
})), _class2$a)) || _class$c);
legacyCC.TextureBase = TextureBase;

var dependMap = new WeakMap();
var nativeDependMap = new WeakSet();
var onLoadedInvokedMap = new WeakSet();

function deserializeAsset(json, options) {
  var classFinder;

  {
    classFinder = MissingScript.safeFindClass;
  }

  var tdInfo = Details.pool.get();
  var asset;

  try {
    asset = deserialize(json, tdInfo, {
      classFinder: classFinder,
      customEnv: options
    });
  } catch (e) {
    error(e);
    Details.pool.put(tdInfo);
    throw e;
  }

  asset._uuid = options.__uuid__ || '';

  var uuidList = tdInfo.uuidList;
  var objList = tdInfo.uuidObjList;
  var propList = tdInfo.uuidPropList;
  var typeList = tdInfo.uuidTypeList || [];
  var depends = [];

  for (var i = 0; i < uuidList.length; i++) {
    var dependUuid = uuidList[i];
    depends[i] = {
      uuid: decodeUuid(dependUuid),
      owner: objList[i],
      prop: propList[i],
      type: js._getClassById(typeList[i])
    };
  }

  dependMap.set(asset, depends);

  if (asset._native) {
    nativeDependMap.add(asset);
  }

  Details.pool.put(tdInfo);
  return asset;
}

var DependUtil = function () {
  function DependUtil() {
    this._depends = new Cache();
  }

  var _proto = DependUtil.prototype;

  _proto.init = function init() {
    this._depends.clear();
  };

  _proto.getNativeDep = function getNativeDep(uuid) {
    var depend = this._depends.get(uuid);

    if (depend && depend.nativeDep) {
      return _extends({}, depend.nativeDep);
    }

    return null;
  };

  _proto.getDeps = function getDeps(uuid) {
    if (this._depends.has(uuid)) {
      return this._depends.get(uuid).deps;
    }

    return [];
  };

  _proto.getDepsRecursively = function getDepsRecursively(uuid) {
    var exclude = Object.create(null);
    var depends = [];

    this._descend(uuid, exclude, depends);

    return depends;
  };

  _proto.remove = function remove(uuid) {
    this._depends.remove(uuid);
  };

  _proto.parse = function parse(uuid, json) {
    var out = null;

    if (Array.isArray(json) || json.__type__) {
      if (this._depends.has(uuid)) {
        return this._depends.get(uuid);
      }

      if (Array.isArray(json) && ( !hasNativeDep(json))) {
        out = {
          deps: this._parseDepsFromJson(json)
        };
      } else {
        try {
          var asset = deserializeAsset(json, {
            __uuid__: uuid
          });
          out = this._parseDepsFromAsset(asset);

          if (out.nativeDep) {
            out.nativeDep.uuid = uuid;
          }

          parsed.add(uuid + "@import", asset);
        } catch (e) {
          files.remove(uuid + "@import");
          out = {
            deps: []
          };
        }
      }
    } else {
      if ( this._depends.has(uuid)) {
        out = this._depends.get(uuid);

        if (out.parsedFromExistAsset) {
          return out;
        }
      }

      out = this._parseDepsFromAsset(json);
    }

    this._depends.add(uuid, out);

    return out;
  };

  _proto._parseDepsFromAsset = function _parseDepsFromAsset(asset) {
    var out = {
      deps: [],
      parsedFromExistAsset: true
    };
    var deps = dependMap.get(asset);

    for (var i = 0, l = deps.length; i < l; i++) {
      out.deps.push(deps[i].uuid);
    }

    if (nativeDependMap.has(asset)) {
      out.nativeDep = asset._nativeDep;
    }

    return out;
  };

  _proto._parseDepsFromJson = function _parseDepsFromJson(json) {
    var depends = parseUuidDependencies(json);
    depends.forEach(function (uuid, index) {
      return depends[index] = decodeUuid(uuid);
    });
    return depends;
  };

  _proto._descend = function _descend(uuid, exclude, depends) {
    var deps = this.getDeps(uuid);

    for (var i = 0; i < deps.length; i++) {
      var depend = deps[i];

      if (!exclude[depend]) {
        exclude[depend] = true;
        depends.push(depend);

        this._descend(depend, exclude, depends);
      }
    }
  };

  return DependUtil;
}();
var dependUtil = new DependUtil();

var _dec$d, _class$d, _temp$a;
var _regions = [new BufferTextureCopy()];

function getMipLevel(width, height) {
  var size = Math.max(width, height);
  var level = 0;

  while (size) {
    size >>= 1;
    level++;
  }

  return level;
}

function isPOT(n) {
  return n && (n & n - 1) === 0;
}

function canGenerateMipmap(device, w, h) {
  var needCheckPOT = device.gfxAPI === exports.API.WEBGL;

  if (needCheckPOT) {
    return isPOT(w) && isPOT(h);
  }

  return true;
}

var SimpleTexture = (_dec$d = ccclass('cc.SimpleTexture'), _dec$d(_class$d = (_temp$a = function (_TextureBase) {
  _inheritsLoose(SimpleTexture, _TextureBase);

  function SimpleTexture() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _TextureBase.call.apply(_TextureBase, [this].concat(args)) || this;
    _this._gfxTexture = null;
    _this._mipmapLevel = 1;
    _this._textureWidth = 0;
    _this._textureHeight = 0;
    return _this;
  }

  var _proto = SimpleTexture.prototype;

  _proto.getGFXTexture = function getGFXTexture() {
    return this._gfxTexture;
  };

  _proto.destroy = function destroy() {
    this._tryDestroyTexture();

    return _TextureBase.prototype.destroy.call(this);
  };

  _proto.updateImage = function updateImage() {
    this.updateMipmaps(0);
  };

  _proto.updateMipmaps = function updateMipmaps(firstLevel, count) {
  };

  _proto.uploadData = function uploadData(source, level, arrayIndex) {
    if (level === void 0) {
      level = 0;
    }

    if (arrayIndex === void 0) {
      arrayIndex = 0;
    }

    if (!this._gfxTexture || this._mipmapLevel <= level) {
      return;
    }

    var gfxDevice = this._getGFXDevice();

    if (!gfxDevice) {
      return;
    }

    var region = _regions[0];
    region.texExtent.width = this._textureWidth >> level;
    region.texExtent.height = this._textureHeight >> level;
    region.texSubres.mipLevel = level;
    region.texSubres.baseArrayLayer = arrayIndex;

    if (ArrayBuffer.isView(source)) {
      gfxDevice.copyBuffersToTexture([source], this._gfxTexture, _regions);
    } else {
      gfxDevice.copyTexImagesToTexture([source], this._gfxTexture, _regions);
    }
  };

  _proto._assignImage = function _assignImage(image, level, arrayIndex) {
    var data = image.data;

    if (!data) {
      return;
    }

    this.uploadData(data, level, arrayIndex);

    this._checkTextureLoaded();

    if (macro.CLEANUP_IMAGE_CACHE) {
      var deps = dependUtil.getDeps(this._uuid);
      var index = deps.indexOf(image._uuid);

      if (index !== -1) {
        fastRemoveAt(deps, index);
        image.decRef();
      }
    }
  };

  _proto._checkTextureLoaded = function _checkTextureLoaded() {
    this._textureReady();
  };

  _proto._textureReady = function _textureReady() {
    this.loaded = true;
    this.emit('load');
  };

  _proto._setMipmapLevel = function _setMipmapLevel(value) {
    this._mipmapLevel = value < 1 ? 1 : value;
  };

  _proto._getGfxTextureCreateInfo = function _getGfxTextureCreateInfo(presumed) {
    return null;
  };

  _proto._tryReset = function _tryReset() {
    this._tryDestroyTexture();

    if (this._mipmapLevel === 0) {
      return;
    }

    var device = this._getGFXDevice();

    if (!device) {
      return;
    }

    this._createTexture(device);
  };

  _proto._createTexture = function _createTexture(device) {
    if (this._width === 0 || this._height === 0) {
      return;
    }

    var flags = exports.TextureFlagBit.NONE;

    if (this._mipFilter !== exports.Filter$1.NONE && canGenerateMipmap(device, this._width, this._height)) {
      this._mipmapLevel = getMipLevel(this._width, this._height);
      flags = exports.TextureFlagBit.GEN_MIPMAP;
    }

    var textureCreateInfo = this._getGfxTextureCreateInfo({
      usage: exports.TextureUsageBit.SAMPLED | exports.TextureUsageBit.TRANSFER_DST,
      format: this._getGFXFormat(),
      levelCount: this._mipmapLevel,
      flags: flags | exports.TextureFlagBit.IMMUTABLE
    });

    if (!textureCreateInfo) {
      return;
    }

    var texture = device.createTexture(textureCreateInfo);
    this._textureWidth = textureCreateInfo.width;
    this._textureHeight = textureCreateInfo.height;
    this._gfxTexture = texture;
  };

  _proto._tryDestroyTexture = function _tryDestroyTexture() {
    if (this._gfxTexture) {
      this._gfxTexture.destroy();

      this._gfxTexture = null;
    }
  };

  _createClass(SimpleTexture, [{
    key: "mipmapLevel",
    get: function get() {
      return this._mipmapLevel;
    }
  }]);

  return SimpleTexture;
}(TextureBase), _temp$a)) || _class$d);
legacyCC.SimpleTexture = SimpleTexture;

var _dec$e, _dec2$5, _class$e, _class2$b, _descriptor$9, _temp$b;
var Texture2D = (_dec$e = ccclass('cc.Texture2D'), _dec2$5 = type([ImageAsset]), _dec$e(_class$e = (_class2$b = (_temp$b = function (_SimpleTexture) {
  _inheritsLoose(Texture2D, _SimpleTexture);

  function Texture2D() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _SimpleTexture.call.apply(_SimpleTexture, [this].concat(args)) || this;

    _initializerDefineProperty(_this, "_mipmaps", _descriptor$9, _assertThisInitialized(_this));

    return _this;
  }

  var _proto = Texture2D.prototype;

  _proto.initialize = function initialize() {
    this.mipmaps = this._mipmaps;
  };

  _proto.onLoaded = function onLoaded() {
    this.initialize();
  };

  _proto.reset = function reset(info) {
    this._width = info.width;
    this._height = info.height;

    this._setGFXFormat(info.format);

    this._setMipmapLevel(info.mipmapLevel || 1);

    this._tryReset();
  };

  _proto.create = function create(width, height, format, mipmapLevel) {
    if (format === void 0) {
      format = exports.PixelFormat.RGBA8888;
    }

    if (mipmapLevel === void 0) {
      mipmapLevel = 1;
    }

    this.reset({
      width: width,
      height: height,
      format: format,
      mipmapLevel: mipmapLevel
    });
  };

  _proto.toString = function toString() {
    return this._mipmaps.length !== 0 ? this._mipmaps[0].url : '';
  };

  _proto.updateMipmaps = function updateMipmaps(firstLevel, count) {
    if (firstLevel === void 0) {
      firstLevel = 0;
    }

    if (firstLevel >= this._mipmaps.length) {
      return;
    }

    var nUpdate = Math.min(count === undefined ? this._mipmaps.length : count, this._mipmaps.length - firstLevel);

    for (var i = 0; i < nUpdate; ++i) {
      var level = firstLevel + i;

      this._assignImage(this._mipmaps[level], level);
    }
  };

  _proto.getHtmlElementObj = function getHtmlElementObj() {
    return this._mipmaps[0] && this._mipmaps[0].data instanceof HTMLElement ? this._mipmaps[0].data : null;
  };

  _proto.destroy = function destroy() {
    this._mipmaps = [];
    return _SimpleTexture.prototype.destroy.call(this);
  };

  _proto.description = function description() {
    var url = this._mipmaps[0] ? this._mipmaps[0].url : '';
    return "<cc.Texture2D | Name = " + url + " | Dimension = " + this.width + " x " + this.height + ">";
  };

  _proto.releaseTexture = function releaseTexture() {
    this.destroy();
  };

  _proto._serialize = function _serialize(ctxForExporting) {

    return null;
  };

  _proto._deserialize = function _deserialize(serializedData, handle) {
    var data = serializedData;

    _SimpleTexture.prototype._deserialize.call(this, data.base, handle);

    this._mipmaps = new Array(data.mipmaps.length);

    for (var i = 0; i < data.mipmaps.length; ++i) {
      this._mipmaps[i] = new ImageAsset();

      if (!data.mipmaps[i]) {
        continue;
      }

      var mipmapUUID = data.mipmaps[i];
      handle.result.push(this._mipmaps, "" + i, mipmapUUID, js._getClassId(ImageAsset));
    }
  };

  _proto._getGfxTextureCreateInfo = function _getGfxTextureCreateInfo(presumed) {
    var texInfo = new TextureInfo(exports.TextureType.TEX2D);
    texInfo.width = this._width;
    texInfo.height = this._height;
    return Object.assign(texInfo, presumed);
  };

  _proto.initDefault = function initDefault(uuid) {
    _SimpleTexture.prototype.initDefault.call(this, uuid);

    var imageAsset = new ImageAsset();
    imageAsset.initDefault();
    this.image = imageAsset;
  };

  _proto.validate = function validate() {
    return this.mipmaps && this.mipmaps.length !== 0;
  };

  _createClass(Texture2D, [{
    key: "mipmaps",
    get: function get() {
      return this._mipmaps;
    },
    set: function set(value) {
      var _this2 = this;

      this._mipmaps = value;

      this._setMipmapLevel(this._mipmaps.length);

      if (this._mipmaps.length > 0) {
        var imageAsset = this._mipmaps[0];
        this.reset({
          width: imageAsset.width,
          height: imageAsset.height,
          format: imageAsset.format,
          mipmapLevel: this._mipmaps.length
        });

        this._mipmaps.forEach(function (mipmap, level) {
          _this2._assignImage(mipmap, level);
        });
      } else {
        this.reset({
          width: 0,
          height: 0,
          mipmapLevel: this._mipmaps.length
        });
      }
    }
  }, {
    key: "image",
    get: function get() {
      return this._mipmaps.length === 0 ? null : this._mipmaps[0];
    },
    set: function set(value) {
      this.mipmaps = value ? [value] : [];
    }
  }]);

  return Texture2D;
}(SimpleTexture), _temp$b), (_descriptor$9 = _applyDecoratedDescriptor(_class2$b.prototype, "_mipmaps", [_dec2$5], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return [];
  }
})), _class2$b)) || _class$e);
legacyCC.Texture2D = Texture2D;

var _dec$f, _class$f, _class2$c, _descriptor$a, _descriptor2$6, _class3$6, _temp$c;
var FaceIndex;

(function (FaceIndex) {
  FaceIndex[FaceIndex["right"] = 0] = "right";
  FaceIndex[FaceIndex["left"] = 1] = "left";
  FaceIndex[FaceIndex["top"] = 2] = "top";
  FaceIndex[FaceIndex["bottom"] = 3] = "bottom";
  FaceIndex[FaceIndex["front"] = 4] = "front";
  FaceIndex[FaceIndex["back"] = 5] = "back";
})(FaceIndex || (FaceIndex = {}));

var TextureCube = (_dec$f = ccclass('cc.TextureCube'), _dec$f(_class$f = (_class2$c = (_temp$c = _class3$6 = function (_SimpleTexture) {
  _inheritsLoose(TextureCube, _SimpleTexture);

  function TextureCube() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _SimpleTexture.call.apply(_SimpleTexture, [this].concat(args)) || this;

    _initializerDefineProperty(_this, "isRGBE", _descriptor$a, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_mipmaps", _descriptor2$6, _assertThisInitialized(_this));

    return _this;
  }

  TextureCube.fromTexture2DArray = function fromTexture2DArray(textures, out) {
    var mipmaps = [];
    var nMipmaps = textures.length / 6;

    for (var i = 0; i < nMipmaps; i++) {
      var x = i * 6;
      mipmaps.push({
        front: textures[x + FaceIndex.front].image,
        back: textures[x + FaceIndex.back].image,
        left: textures[x + FaceIndex.left].image,
        right: textures[x + FaceIndex.right].image,
        top: textures[x + FaceIndex.top].image,
        bottom: textures[x + FaceIndex.bottom].image
      });
    }

    out = out || new TextureCube();
    out.mipmaps = mipmaps;
    return out;
  };

  var _proto = TextureCube.prototype;

  _proto.onLoaded = function onLoaded() {
    this.mipmaps = this._mipmaps;
  };

  _proto.reset = function reset(info) {
    this._width = info.width;
    this._height = info.height;

    this._setGFXFormat(info.format);

    this._setMipmapLevel(info.mipmapLevel || 1);

    this._tryReset();
  };

  _proto.updateMipmaps = function updateMipmaps(firstLevel, count) {
    var _this2 = this;

    if (firstLevel === void 0) {
      firstLevel = 0;
    }

    if (firstLevel >= this._mipmaps.length) {
      return;
    }

    var nUpdate = Math.min(count === undefined ? this._mipmaps.length : count, this._mipmaps.length - firstLevel);

    var _loop = function _loop(i) {
      var level = firstLevel + i;

      _forEachFace(_this2._mipmaps[level], function (face, faceIndex) {
        _this2._assignImage(face, level, faceIndex);
      });
    };

    for (var i = 0; i < nUpdate; ++i) {
      _loop(i);
    }
  };

  _proto.destroy = function destroy() {
    this._mipmaps = [];
    return _SimpleTexture.prototype.destroy.call(this);
  };

  _proto.releaseTexture = function releaseTexture() {
    this.mipmaps = [];
  };

  _proto._serialize = function _serialize(ctxForExporting) {

    return null;
  };

  _proto._deserialize = function _deserialize(serializedData, handle) {
    var data = serializedData;

    _SimpleTexture.prototype._deserialize.call(this, data.base, handle);

    this.isRGBE = data.rgbe;
    this._mipmaps = new Array(data.mipmaps.length);

    for (var i = 0; i < data.mipmaps.length; ++i) {
      this._mipmaps[i] = {
        front: new ImageAsset(),
        back: new ImageAsset(),
        left: new ImageAsset(),
        right: new ImageAsset(),
        top: new ImageAsset(),
        bottom: new ImageAsset()
      };
      var mipmap = data.mipmaps[i];

      var imageAssetClassId = js._getClassId(ImageAsset);

      handle.result.push(this._mipmaps[i], "front", mipmap.front, imageAssetClassId);
      handle.result.push(this._mipmaps[i], "back", mipmap.back, imageAssetClassId);
      handle.result.push(this._mipmaps[i], "left", mipmap.left, imageAssetClassId);
      handle.result.push(this._mipmaps[i], "right", mipmap.right, imageAssetClassId);
      handle.result.push(this._mipmaps[i], "top", mipmap.top, imageAssetClassId);
      handle.result.push(this._mipmaps[i], "bottom", mipmap.bottom, imageAssetClassId);
    }
  };

  _proto._getGfxTextureCreateInfo = function _getGfxTextureCreateInfo(presumed) {
    var texInfo = new TextureInfo(exports.TextureType.CUBE);
    texInfo.width = this._width;
    texInfo.height = this._height;
    texInfo.layerCount = 6;
    Object.assign(texInfo, presumed);
    return texInfo;
  };

  _proto.initDefault = function initDefault(uuid) {
    _SimpleTexture.prototype.initDefault.call(this, uuid);

    var imageAsset = new ImageAsset();
    imageAsset.initDefault();
    this.mipmaps = [{
      front: imageAsset,
      back: imageAsset,
      top: imageAsset,
      bottom: imageAsset,
      left: imageAsset,
      right: imageAsset
    }];
  };

  _proto.validate = function validate() {
    return this._mipmaps.length !== 0 && !this._mipmaps.find(function (x) {
      return !(x.top && x.bottom && x.front && x.back && x.left && x.right);
    });
  };

  _createClass(TextureCube, [{
    key: "mipmaps",
    get: function get() {
      return this._mipmaps;
    },
    set: function set(value) {
      var _this3 = this;

      this._mipmaps = value;

      this._setMipmapLevel(this._mipmaps.length);

      if (this._mipmaps.length > 0) {
        var imageAsset = this._mipmaps[0].front;
        this.reset({
          width: imageAsset.width,
          height: imageAsset.height,
          format: imageAsset.format,
          mipmapLevel: this._mipmaps.length
        });

        this._mipmaps.forEach(function (mipmap, level) {
          _forEachFace(mipmap, function (face, faceIndex) {
            _this3._assignImage(face, level, faceIndex);
          });
        });
      } else {
        this.reset({
          width: 0,
          height: 0,
          mipmapLevel: this._mipmaps.length
        });
      }
    }
  }, {
    key: "image",
    get: function get() {
      return this._mipmaps.length === 0 ? null : this._mipmaps[0];
    },
    set: function set(value) {
      this.mipmaps = value ? [value] : [];
    }
  }]);

  return TextureCube;
}(SimpleTexture), _class3$6.FaceIndex = FaceIndex, _temp$c), (_descriptor$a = _applyDecoratedDescriptor(_class2$c.prototype, "isRGBE", [serializable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return false;
  }
}), _descriptor2$6 = _applyDecoratedDescriptor(_class2$c.prototype, "_mipmaps", [serializable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return [];
  }
})), _class2$c)) || _class$f);
legacyCC.TextureCube = TextureCube;

function _forEachFace(mipmap, callback) {
  callback(mipmap.front, FaceIndex.front);
  callback(mipmap.back, FaceIndex.back);
  callback(mipmap.left, FaceIndex.left);
  callback(mipmap.right, FaceIndex.right);
  callback(mipmap.top, FaceIndex.top);
  callback(mipmap.bottom, FaceIndex.bottom);
}

var effects = [{
  "name": "billboard",
  "techniques": [{
    "name": "add",
    "passes": [{
      "rasterizerState": {
        "cullMode": 0
      },
      "blendState": {
        "targets": [{
          "blend": true,
          "blendSrc": 2,
          "blendDst": 1,
          "blendSrcAlpha": 2,
          "blendDstAlpha": 1
        }]
      },
      "program": "billboard|vert:vs_main|tinted-fs:add",
      "depthStencilState": {
        "depthTest": true,
        "depthWrite": false
      },
      "properties": {
        "mainTexture": {
          "value": "grey",
          "type": 28
        },
        "mainTiling_Offset": {
          "value": [1, 1, 0, 0],
          "type": 16
        },
        "tintColor": {
          "value": [0.5, 0.5, 0.5, 0.5],
          "type": 16
        }
      }
    }]
  }],
  "shaders": [{
    "name": "billboard|vert:vs_main|tinted-fs:add",
    "hash": 308883658,
    "builtins": {
      "statistics": {
        "CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS": 50,
        "CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS": 38
      },
      "globals": {
        "blocks": [{
          "name": "CCGlobal",
          "defines": []
        }, {
          "name": "CCCamera",
          "defines": []
        }],
        "samplerTextures": []
      },
      "locals": {
        "blocks": [{
          "name": "CCLocal",
          "defines": []
        }],
        "samplerTextures": []
      }
    },
    "defines": [{
      "name": "CC_USE_HDR",
      "type": "boolean"
    }],
    "blocks": [{
      "name": "Constants",
      "defines": [],
      "binding": 0,
      "stageFlags": 1,
      "members": [{
        "name": "mainTiling_Offset",
        "type": 16,
        "count": 1
      }, {
        "name": "frameTile_velLenScale",
        "type": 16,
        "count": 1
      }, {
        "name": "scale",
        "type": 16,
        "count": 1
      }]
    }, {
      "name": "builtin",
      "defines": [],
      "binding": 1,
      "stageFlags": 1,
      "members": [{
        "name": "cc_size_rotation",
        "type": 16,
        "count": 1
      }]
    }, {
      "name": "FragConstants",
      "defines": [],
      "binding": 2,
      "stageFlags": 16,
      "members": [{
        "name": "tintColor",
        "type": 16,
        "count": 1
      }]
    }],
    "samplerTextures": [{
      "name": "mainTexture",
      "type": 28,
      "count": 1,
      "defines": [],
      "stageFlags": 16,
      "binding": 3
    }],
    "attributes": [{
      "name": "a_position",
      "type": 15,
      "count": 1,
      "defines": [],
      "stageFlags": 1,
      "format": 32,
      "location": 0
    }, {
      "name": "a_texCoord",
      "type": 14,
      "count": 1,
      "defines": [],
      "stageFlags": 1,
      "format": 21,
      "location": 1
    }, {
      "name": "a_color",
      "type": 16,
      "count": 1,
      "defines": [],
      "stageFlags": 1,
      "format": 44,
      "location": 2
    }]
  }]
}, {
  "name": "clear-stencil",
  "techniques": [{
    "passes": [{
      "blendState": {
        "targets": [{
          "blend": true
        }]
      },
      "rasterizerState": {
        "cullMode": 0
      },
      "program": "clear-stencil|sprite-vs:vert|sprite-fs:frag",
      "depthStencilState": {
        "depthTest": false,
        "depthWrite": false
      }
    }]
  }],
  "shaders": [{
    "name": "clear-stencil|sprite-vs:vert|sprite-fs:frag",
    "hash": 3507038093,
    "builtins": {
      "statistics": {
        "CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS": 0,
        "CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS": 0
      },
      "globals": {
        "blocks": [],
        "samplerTextures": []
      },
      "locals": {
        "blocks": [],
        "samplerTextures": []
      }
    },
    "defines": [],
    "blocks": [],
    "samplerTextures": [],
    "attributes": [{
      "name": "a_position",
      "type": 15,
      "count": 1,
      "defines": [],
      "stageFlags": 1,
      "format": 32,
      "location": 0
    }]
  }]
}, {
  "name": "graphics",
  "techniques": [{
    "passes": [{
      "blendState": {
        "targets": [{
          "blend": true,
          "blendSrc": 1,
          "blendDst": 4,
          "blendSrcAlpha": 1,
          "blendDstAlpha": 4
        }]
      },
      "rasterizerState": {
        "cullMode": 0
      },
      "program": "graphics|vs:vert|fs:frag",
      "depthStencilState": {
        "depthTest": false,
        "depthWrite": false
      }
    }]
  }],
  "shaders": [{
    "name": "graphics|vs:vert|fs:frag",
    "hash": 3113634185,
    "builtins": {
      "statistics": {
        "CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS": 46,
        "CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS": 0
      },
      "globals": {
        "blocks": [{
          "name": "CCGlobal",
          "defines": []
        }, {
          "name": "CCCamera",
          "defines": []
        }],
        "samplerTextures": []
      },
      "locals": {
        "blocks": [{
          "name": "CCLocal",
          "defines": []
        }],
        "samplerTextures": []
      }
    },
    "defines": [],
    "blocks": [],
    "samplerTextures": [],
    "attributes": [{
      "name": "a_position",
      "type": 15,
      "count": 1,
      "defines": [],
      "stageFlags": 1,
      "format": 32,
      "location": 0
    }, {
      "name": "a_color",
      "type": 16,
      "count": 1,
      "defines": [],
      "stageFlags": 1,
      "format": 44,
      "location": 1
    }, {
      "name": "a_dist",
      "type": 13,
      "count": 1,
      "defines": [],
      "stageFlags": 1,
      "format": 11,
      "location": 2
    }]
  }]
}, {
  "name": "particle-gpu",
  "techniques": [{
    "name": "add",
    "passes": [{
      "rasterizerState": {
        "cullMode": 0
      },
      "blendState": {
        "targets": [{
          "blend": true,
          "blendSrc": 2,
          "blendDst": 1,
          "blendSrcAlpha": 2,
          "blendDstAlpha": 1
        }]
      },
      "program": "particle-gpu|particle-vs-gpu:gpvs_main|tinted-fs:add",
      "depthStencilState": {
        "depthTest": true,
        "depthWrite": false
      },
      "properties": {
        "mainTexture": {
          "value": "grey",
          "type": 28
        },
        "mainTiling_Offset": {
          "value": [1, 1, 0, 0],
          "type": 16
        },
        "tintColor": {
          "value": [0.5, 0.5, 0.5, 0.5],
          "type": 16
        }
      }
    }]
  }],
  "shaders": [{
    "name": "particle-gpu|particle-vs-gpu:gpvs_main|tinted-fs:add",
    "hash": 3001336778,
    "builtins": {
      "statistics": {
        "CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS": 60,
        "CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS": 38
      },
      "globals": {
        "blocks": [{
          "name": "CCGlobal",
          "defines": []
        }, {
          "name": "CCCamera",
          "defines": []
        }],
        "samplerTextures": []
      },
      "locals": {
        "blocks": [{
          "name": "CCLocal",
          "defines": []
        }],
        "samplerTextures": []
      }
    },
    "defines": [{
      "name": "CC_RENDER_MODE",
      "type": "number",
      "range": [0, 4]
    }, {
      "name": "COLOR_OVER_TIME_MODULE_ENABLE",
      "type": "boolean"
    }, {
      "name": "ROTATION_OVER_TIME_MODULE_ENABLE",
      "type": "boolean"
    }, {
      "name": "SIZE_OVER_TIME_MODULE_ENABLE",
      "type": "boolean"
    }, {
      "name": "FORCE_OVER_TIME_MODULE_ENABLE",
      "type": "boolean"
    }, {
      "name": "VELOCITY_OVER_TIME_MODULE_ENABLE",
      "type": "boolean"
    }, {
      "name": "TEXTURE_ANIMATION_MODULE_ENABLE",
      "type": "boolean"
    }, {
      "name": "CC_USE_WORLD_SPACE",
      "type": "boolean"
    }, {
      "name": "CC_USE_HDR",
      "type": "boolean"
    }],
    "blocks": [{
      "name": "Constants",
      "defines": [],
      "binding": 0,
      "stageFlags": 1,
      "members": [{
        "name": "mainTiling_Offset",
        "type": 16,
        "count": 1
      }, {
        "name": "frameTile_velLenScale",
        "type": 16,
        "count": 1
      }, {
        "name": "scale",
        "type": 16,
        "count": 1
      }]
    }, {
      "name": "SampleConstants",
      "defines": [],
      "binding": 1,
      "stageFlags": 1,
      "members": [{
        "name": "u_sampleInfo",
        "type": 16,
        "count": 1
      }]
    }, {
      "name": "TickConstants",
      "defines": [],
      "binding": 2,
      "stageFlags": 1,
      "members": [{
        "name": "u_worldRot",
        "type": 16,
        "count": 1
      }, {
        "name": "u_timeDelta",
        "type": 16,
        "count": 1
      }]
    }, {
      "name": "ColorConstant",
      "defines": ["COLOR_OVER_TIME_MODULE_ENABLE"],
      "binding": 3,
      "stageFlags": 1,
      "members": [{
        "name": "u_color_mode",
        "type": 5,
        "count": 1
      }]
    }, {
      "name": "RotationConstant",
      "defines": ["ROTATION_OVER_TIME_MODULE_ENABLE"],
      "binding": 4,
      "stageFlags": 1,
      "members": [{
        "name": "u_rotation_mode",
        "type": 5,
        "count": 1
      }]
    }, {
      "name": "SizeConstant",
      "defines": ["SIZE_OVER_TIME_MODULE_ENABLE"],
      "binding": 5,
      "stageFlags": 1,
      "members": [{
        "name": "u_size_mode",
        "type": 5,
        "count": 1
      }]
    }, {
      "name": "ForceConstant",
      "defines": ["FORCE_OVER_TIME_MODULE_ENABLE"],
      "binding": 6,
      "stageFlags": 1,
      "members": [{
        "name": "u_force_mode",
        "type": 5,
        "count": 1
      }, {
        "name": "u_force_space",
        "type": 5,
        "count": 1
      }]
    }, {
      "name": "VelocityConstant",
      "defines": ["VELOCITY_OVER_TIME_MODULE_ENABLE"],
      "binding": 7,
      "stageFlags": 1,
      "members": [{
        "name": "u_velocity_mode",
        "type": 5,
        "count": 1
      }, {
        "name": "u_velocity_space",
        "type": 5,
        "count": 1
      }]
    }, {
      "name": "AnimationConstant",
      "defines": ["TEXTURE_ANIMATION_MODULE_ENABLE"],
      "binding": 8,
      "stageFlags": 1,
      "members": [{
        "name": "u_anim_info",
        "type": 16,
        "count": 1
      }]
    }, {
      "name": "FragConstants",
      "defines": [],
      "binding": 9,
      "stageFlags": 16,
      "members": [{
        "name": "tintColor",
        "type": 16,
        "count": 1
      }]
    }],
    "samplerTextures": [{
      "name": "color_over_time_tex0",
      "type": 28,
      "count": 1,
      "defines": ["COLOR_OVER_TIME_MODULE_ENABLE"],
      "stageFlags": 1,
      "binding": 10
    }, {
      "name": "rotation_over_time_tex0",
      "type": 28,
      "count": 1,
      "defines": ["ROTATION_OVER_TIME_MODULE_ENABLE"],
      "stageFlags": 1,
      "binding": 11
    }, {
      "name": "size_over_time_tex0",
      "type": 28,
      "count": 1,
      "defines": ["SIZE_OVER_TIME_MODULE_ENABLE"],
      "stageFlags": 1,
      "binding": 12
    }, {
      "name": "force_over_time_tex0",
      "type": 28,
      "count": 1,
      "defines": ["FORCE_OVER_TIME_MODULE_ENABLE"],
      "stageFlags": 1,
      "binding": 13
    }, {
      "name": "velocity_over_time_tex0",
      "type": 28,
      "count": 1,
      "defines": ["VELOCITY_OVER_TIME_MODULE_ENABLE"],
      "stageFlags": 1,
      "binding": 14
    }, {
      "name": "texture_animation_tex0",
      "type": 28,
      "count": 1,
      "defines": ["TEXTURE_ANIMATION_MODULE_ENABLE"],
      "stageFlags": 1,
      "binding": 15
    }, {
      "name": "mainTexture",
      "type": 28,
      "count": 1,
      "defines": [],
      "stageFlags": 16,
      "binding": 16
    }],
    "attributes": [{
      "name": "a_position_starttime",
      "type": 16,
      "count": 1,
      "defines": [],
      "stageFlags": 1,
      "format": 44,
      "location": 0
    }, {
      "name": "a_size_uv",
      "type": 16,
      "count": 1,
      "defines": [],
      "stageFlags": 1,
      "format": 44,
      "location": 1
    }, {
      "name": "a_rotation_uv",
      "type": 16,
      "count": 1,
      "defines": [],
      "stageFlags": 1,
      "format": 44,
      "location": 2
    }, {
      "name": "a_color",
      "type": 16,
      "count": 1,
      "defines": [],
      "stageFlags": 1,
      "format": 44,
      "location": 3
    }, {
      "name": "a_dir_life",
      "type": 16,
      "count": 1,
      "defines": [],
      "stageFlags": 1,
      "format": 44,
      "location": 4
    }, {
      "name": "a_rndSeed",
      "type": 13,
      "count": 1,
      "defines": [],
      "stageFlags": 1,
      "format": 11,
      "location": 5
    }, {
      "name": "a_texCoord",
      "type": 15,
      "count": 1,
      "defines": ["CC_RENDER_MODE"],
      "stageFlags": 1,
      "format": 32,
      "location": 6
    }, {
      "name": "a_texCoord3",
      "type": 15,
      "count": 1,
      "defines": ["CC_RENDER_MODE"],
      "stageFlags": 1,
      "format": 32,
      "location": 7
    }, {
      "name": "a_normal",
      "type": 15,
      "count": 1,
      "defines": ["CC_RENDER_MODE"],
      "stageFlags": 1,
      "format": 32,
      "location": 8
    }, {
      "name": "a_color1",
      "type": 16,
      "count": 1,
      "defines": ["CC_RENDER_MODE"],
      "stageFlags": 1,
      "format": 44,
      "location": 9
    }]
  }]
}, {
  "name": "particle-trail",
  "techniques": [{
    "name": "add",
    "passes": [{
      "rasterizerState": {
        "cullMode": 0
      },
      "blendState": {
        "targets": [{
          "blend": true,
          "blendSrc": 2,
          "blendDst": 1,
          "blendSrcAlpha": 2,
          "blendDstAlpha": 1
        }]
      },
      "program": "particle-trail|particle-trail:vs_main|tinted-fs:add",
      "depthStencilState": {
        "depthTest": true,
        "depthWrite": false
      },
      "properties": {
        "mainTexture": {
          "value": "grey",
          "type": 28
        },
        "mainTiling_Offset": {
          "value": [1, 1, 0, 0],
          "type": 16
        },
        "frameTile_velLenScale": {
          "value": [1, 1, 0, 0],
          "type": 16
        },
        "tintColor": {
          "value": [0.5, 0.5, 0.5, 0.5],
          "type": 16
        }
      }
    }]
  }],
  "shaders": [{
    "name": "particle-trail|particle-trail:vs_main|tinted-fs:add",
    "hash": 2637621064,
    "builtins": {
      "statistics": {
        "CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS": 49,
        "CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS": 38
      },
      "globals": {
        "blocks": [{
          "name": "CCGlobal",
          "defines": []
        }, {
          "name": "CCCamera",
          "defines": []
        }],
        "samplerTextures": []
      },
      "locals": {
        "blocks": [{
          "name": "CCLocal",
          "defines": []
        }],
        "samplerTextures": []
      }
    },
    "defines": [{
      "name": "CC_RENDER_MODE",
      "type": "number",
      "range": [0, 4]
    }, {
      "name": "CC_DRAW_WIRE_FRAME",
      "type": "boolean"
    }, {
      "name": "CC_USE_WORLD_SPACE",
      "type": "boolean"
    }, {
      "name": "CC_USE_HDR",
      "type": "boolean"
    }],
    "blocks": [{
      "name": "Constants",
      "defines": [],
      "binding": 0,
      "stageFlags": 1,
      "members": [{
        "name": "mainTiling_Offset",
        "type": 16,
        "count": 1
      }, {
        "name": "frameTile_velLenScale",
        "type": 16,
        "count": 1
      }, {
        "name": "scale",
        "type": 16,
        "count": 1
      }]
    }, {
      "name": "FragConstants",
      "defines": [],
      "binding": 1,
      "stageFlags": 16,
      "members": [{
        "name": "tintColor",
        "type": 16,
        "count": 1
      }]
    }],
    "samplerTextures": [{
      "name": "mainTexture",
      "type": 28,
      "count": 1,
      "defines": [],
      "stageFlags": 16,
      "binding": 2
    }],
    "attributes": [{
      "name": "a_position",
      "type": 15,
      "count": 1,
      "defines": [],
      "stageFlags": 1,
      "format": 32,
      "location": 0
    }, {
      "name": "a_texCoord",
      "type": 16,
      "count": 1,
      "defines": [],
      "stageFlags": 1,
      "format": 44,
      "location": 1
    }, {
      "name": "a_texCoord1",
      "type": 15,
      "count": 1,
      "defines": [],
      "stageFlags": 1,
      "format": 32,
      "location": 2
    }, {
      "name": "a_texCoord2",
      "type": 15,
      "count": 1,
      "defines": [],
      "stageFlags": 1,
      "format": 32,
      "location": 3
    }, {
      "name": "a_color",
      "type": 16,
      "count": 1,
      "defines": [],
      "stageFlags": 1,
      "format": 44,
      "location": 4
    }]
  }]
}, {
  "name": "particle",
  "techniques": [{
    "name": "add",
    "passes": [{
      "rasterizerState": {
        "cullMode": 0
      },
      "blendState": {
        "targets": [{
          "blend": true,
          "blendSrc": 2,
          "blendDst": 1,
          "blendSrcAlpha": 2,
          "blendDstAlpha": 1
        }]
      },
      "program": "particle|particle-vs-legacy:lpvs_main|tinted-fs:add",
      "depthStencilState": {
        "depthTest": true,
        "depthWrite": false
      },
      "properties": {
        "mainTexture": {
          "value": "grey",
          "type": 28
        },
        "mainTiling_Offset": {
          "value": [1, 1, 0, 0],
          "type": 16
        },
        "tintColor": {
          "value": [0.5, 0.5, 0.5, 0.5],
          "type": 16
        }
      }
    }]
  }],
  "shaders": [{
    "name": "particle|particle-vs-legacy:lpvs_main|tinted-fs:add",
    "hash": 1675533382,
    "builtins": {
      "statistics": {
        "CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS": 49,
        "CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS": 38
      },
      "globals": {
        "blocks": [{
          "name": "CCGlobal",
          "defines": []
        }, {
          "name": "CCCamera",
          "defines": []
        }],
        "samplerTextures": []
      },
      "locals": {
        "blocks": [{
          "name": "CCLocal",
          "defines": []
        }],
        "samplerTextures": []
      }
    },
    "defines": [{
      "name": "CC_RENDER_MODE",
      "type": "number",
      "range": [0, 4]
    }, {
      "name": "CC_USE_WORLD_SPACE",
      "type": "boolean"
    }, {
      "name": "CC_USE_HDR",
      "type": "boolean"
    }],
    "blocks": [{
      "name": "Constants",
      "defines": [],
      "binding": 0,
      "stageFlags": 1,
      "members": [{
        "name": "mainTiling_Offset",
        "type": 16,
        "count": 1
      }, {
        "name": "frameTile_velLenScale",
        "type": 16,
        "count": 1
      }, {
        "name": "scale",
        "type": 16,
        "count": 1
      }]
    }, {
      "name": "FragConstants",
      "defines": [],
      "binding": 1,
      "stageFlags": 16,
      "members": [{
        "name": "tintColor",
        "type": 16,
        "count": 1
      }]
    }],
    "samplerTextures": [{
      "name": "mainTexture",
      "type": 28,
      "count": 1,
      "defines": [],
      "stageFlags": 16,
      "binding": 2
    }],
    "attributes": [{
      "name": "a_position",
      "type": 15,
      "count": 1,
      "defines": [],
      "stageFlags": 1,
      "format": 32,
      "location": 0
    }, {
      "name": "a_texCoord",
      "type": 15,
      "count": 1,
      "defines": [],
      "stageFlags": 1,
      "format": 32,
      "location": 1
    }, {
      "name": "a_texCoord1",
      "type": 15,
      "count": 1,
      "defines": [],
      "stageFlags": 1,
      "format": 32,
      "location": 2
    }, {
      "name": "a_texCoord2",
      "type": 15,
      "count": 1,
      "defines": [],
      "stageFlags": 1,
      "format": 32,
      "location": 3
    }, {
      "name": "a_color",
      "type": 16,
      "count": 1,
      "defines": [],
      "stageFlags": 1,
      "format": 44,
      "location": 4
    }, {
      "name": "a_color1",
      "type": 15,
      "count": 1,
      "defines": ["CC_RENDER_MODE"],
      "stageFlags": 1,
      "format": 32,
      "location": 8
    }, {
      "name": "a_texCoord3",
      "type": 15,
      "count": 1,
      "defines": ["CC_RENDER_MODE"],
      "stageFlags": 1,
      "format": 32,
      "location": 6
    }, {
      "name": "a_normal",
      "type": 15,
      "count": 1,
      "defines": ["CC_RENDER_MODE"],
      "stageFlags": 1,
      "format": 32,
      "location": 7
    }]
  }]
}, {
  "name": "spine",
  "techniques": [{
    "passes": [{
      "blendState": {
        "targets": [{
          "blend": true,
          "blendSrc": 2,
          "blendDst": 4,
          "blendDstAlpha": 4
        }]
      },
      "rasterizerState": {
        "cullMode": 0
      },
      "program": "spine|sprite-vs:vert|sprite-fs:frag",
      "depthStencilState": {
        "depthTest": false,
        "depthWrite": false
      },
      "properties": {
        "alphaThreshold": {
          "value": [0.5],
          "type": 13
        }
      }
    }]
  }],
  "shaders": [{
    "name": "spine|sprite-vs:vert|sprite-fs:frag",
    "hash": 1867464226,
    "builtins": {
      "statistics": {
        "CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS": 46,
        "CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS": 1
      },
      "globals": {
        "blocks": [{
          "name": "CCGlobal",
          "defines": []
        }, {
          "name": "CCCamera",
          "defines": []
        }],
        "samplerTextures": []
      },
      "locals": {
        "blocks": [{
          "name": "CCLocal",
          "defines": ["USE_LOCAL"]
        }],
        "samplerTextures": [{
          "name": "cc_spriteTexture",
          "defines": []
        }]
      }
    },
    "defines": [{
      "name": "USE_LOCAL",
      "type": "boolean"
    }, {
      "name": "TWO_COLORED",
      "type": "boolean"
    }, {
      "name": "USE_ALPHA_TEST",
      "type": "boolean"
    }],
    "blocks": [{
      "name": "ALPHA_TEST_DATA",
      "defines": ["USE_ALPHA_TEST"],
      "binding": 0,
      "stageFlags": 16,
      "members": [{
        "name": "alphaThreshold",
        "type": 13,
        "count": 1
      }]
    }],
    "samplerTextures": [],
    "attributes": [{
      "name": "a_position",
      "type": 15,
      "count": 1,
      "defines": [],
      "stageFlags": 1,
      "format": 32,
      "location": 0
    }, {
      "name": "a_texCoord",
      "type": 14,
      "count": 1,
      "defines": [],
      "stageFlags": 1,
      "format": 21,
      "location": 1
    }, {
      "name": "a_color",
      "type": 16,
      "count": 1,
      "defines": [],
      "stageFlags": 1,
      "format": 44,
      "location": 2
    }, {
      "name": "a_color2",
      "type": 16,
      "count": 1,
      "defines": ["TWO_COLORED"],
      "stageFlags": 1,
      "format": 44,
      "location": 3
    }]
  }]
}, {
  "name": "sprite",
  "techniques": [{
    "passes": [{
      "blendState": {
        "targets": [{
          "blend": true,
          "blendSrc": 2,
          "blendDst": 4,
          "blendDstAlpha": 4
        }]
      },
      "rasterizerState": {
        "cullMode": 0
      },
      "program": "sprite|sprite-vs:vert|sprite-fs:frag",
      "depthStencilState": {
        "depthTest": false,
        "depthWrite": false
      },
      "properties": {
        "alphaThreshold": {
          "value": [0.5],
          "type": 13
        }
      }
    }]
  }],
  "shaders": [{
    "name": "sprite|sprite-vs:vert|sprite-fs:frag",
    "hash": 1559944983,
    "builtins": {
      "statistics": {
        "CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS": 46,
        "CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS": 1
      },
      "globals": {
        "blocks": [{
          "name": "CCGlobal",
          "defines": []
        }, {
          "name": "CCCamera",
          "defines": []
        }],
        "samplerTextures": []
      },
      "locals": {
        "blocks": [{
          "name": "CCLocal",
          "defines": ["USE_LOCAL"]
        }],
        "samplerTextures": [{
          "name": "cc_spriteTexture",
          "defines": ["USE_TEXTURE"]
        }]
      }
    },
    "defines": [{
      "name": "USE_LOCAL",
      "type": "boolean"
    }, {
      "name": "SAMPLE_FROM_RT",
      "type": "boolean"
    }, {
      "name": "USE_PIXEL_ALIGNMENT",
      "type": "boolean"
    }, {
      "name": "CC_USE_EMBEDDED_ALPHA",
      "type": "boolean"
    }, {
      "name": "USE_ALPHA_TEST",
      "type": "boolean"
    }, {
      "name": "USE_TEXTURE",
      "type": "boolean"
    }, {
      "name": "IS_GRAY",
      "type": "boolean"
    }],
    "blocks": [{
      "name": "ALPHA_TEST_DATA",
      "defines": ["USE_ALPHA_TEST"],
      "binding": 0,
      "stageFlags": 16,
      "members": [{
        "name": "alphaThreshold",
        "type": 13,
        "count": 1
      }]
    }],
    "samplerTextures": [],
    "attributes": [{
      "name": "a_position",
      "type": 15,
      "count": 1,
      "defines": [],
      "stageFlags": 1,
      "format": 32,
      "location": 0
    }, {
      "name": "a_texCoord",
      "type": 14,
      "count": 1,
      "defines": [],
      "stageFlags": 1,
      "format": 21,
      "location": 1
    }, {
      "name": "a_color",
      "type": 16,
      "count": 1,
      "defines": [],
      "stageFlags": 1,
      "format": 44,
      "location": 2
    }]
  }]
}, {
  "name": "standard",
  "techniques": [{
    "name": "opaque",
    "passes": [{
      "program": "standard|standard-vs|standard-fs",
      "properties": {
        "tilingOffset": {
          "value": [1, 1, 0, 0],
          "type": 16
        },
        "mainColor": {
          "value": [1, 1, 1, 1],
          "type": 16,
          "handleInfo": ["albedo", 0, 16]
        },
        "albedoScale": {
          "value": [1, 1, 1],
          "type": 15,
          "handleInfo": ["albedoScaleAndCutoff", 0, 15]
        },
        "alphaThreshold": {
          "value": [0.5],
          "type": 13,
          "handleInfo": ["albedoScaleAndCutoff", 3, 13]
        },
        "occlusion": {
          "value": [1],
          "type": 13,
          "handleInfo": ["pbrParams", 0, 13]
        },
        "roughness": {
          "value": [0.8],
          "type": 13,
          "handleInfo": ["pbrParams", 1, 13]
        },
        "metallic": {
          "value": [0.6],
          "type": 13,
          "handleInfo": ["pbrParams", 2, 13]
        },
        "SpecularIntensity": {
          "value": [0.5],
          "type": 13,
          "handleInfo": ["pbrParams", 3, 13]
        },
        "normalStrenth": {
          "value": [1],
          "type": 13,
          "handleInfo": ["miscParams", 0, 13]
        },
        "emissive": {
          "value": [0, 0, 0, 1],
          "type": 16
        },
        "emissiveScale": {
          "value": [1, 1, 1],
          "type": 15,
          "handleInfo": ["emissiveScaleParam", 0, 15]
        },
        "mainTexture": {
          "value": "grey",
          "type": 28,
          "handleInfo": ["albedoMap", 0, 28]
        },
        "normalMap": {
          "value": "normal",
          "type": 28
        },
        "pbrMap": {
          "value": "grey",
          "type": 28
        },
        "metallicRoughnessMap": {
          "value": "grey",
          "type": 28
        },
        "occlusionMap": {
          "value": "white",
          "type": 28
        },
        "emissiveMap": {
          "value": "grey",
          "type": 28
        },
        "albedo": {
          "type": 16,
          "value": [1, 1, 1, 1]
        },
        "albedoScaleAndCutoff": {
          "type": 16,
          "value": [1, 1, 1, 0.5]
        },
        "pbrParams": {
          "type": 16,
          "value": [1, 0.8, 0.6, 0.5]
        },
        "miscParams": {
          "type": 16,
          "value": [1, 0, 0, 0]
        },
        "emissiveScaleParam": {
          "type": 16,
          "value": [1, 1, 1, 0]
        },
        "albedoMap": {
          "type": 28,
          "value": "grey"
        }
      }
    }, {
      "phase": "deferred",
      "propertyIndex": 0,
      "blendState": {
        "targets": [{
          "blend": false
        }, {
          "blend": false
        }, {
          "blend": false
        }, {
          "blend": false
        }]
      },
      "program": "standard|standard-vs|standard-fs",
      "properties": {
        "tilingOffset": {
          "value": [1, 1, 0, 0],
          "type": 16
        },
        "mainColor": {
          "value": [1, 1, 1, 1],
          "type": 16,
          "handleInfo": ["albedo", 0, 16]
        },
        "albedoScale": {
          "value": [1, 1, 1],
          "type": 15,
          "handleInfo": ["albedoScaleAndCutoff", 0, 15]
        },
        "alphaThreshold": {
          "value": [0.5],
          "type": 13,
          "handleInfo": ["albedoScaleAndCutoff", 3, 13]
        },
        "occlusion": {
          "value": [1],
          "type": 13,
          "handleInfo": ["pbrParams", 0, 13]
        },
        "roughness": {
          "value": [0.8],
          "type": 13,
          "handleInfo": ["pbrParams", 1, 13]
        },
        "metallic": {
          "value": [0.6],
          "type": 13,
          "handleInfo": ["pbrParams", 2, 13]
        },
        "SpecularIntensity": {
          "value": [0.5],
          "type": 13,
          "handleInfo": ["pbrParams", 3, 13]
        },
        "normalStrenth": {
          "value": [1],
          "type": 13,
          "handleInfo": ["miscParams", 0, 13]
        },
        "emissive": {
          "value": [0, 0, 0, 1],
          "type": 16
        },
        "emissiveScale": {
          "value": [1, 1, 1],
          "type": 15,
          "handleInfo": ["emissiveScaleParam", 0, 15]
        },
        "mainTexture": {
          "value": "grey",
          "type": 28,
          "handleInfo": ["albedoMap", 0, 28]
        },
        "normalMap": {
          "value": "normal",
          "type": 28
        },
        "pbrMap": {
          "value": "grey",
          "type": 28
        },
        "metallicRoughnessMap": {
          "value": "grey",
          "type": 28
        },
        "occlusionMap": {
          "value": "white",
          "type": 28
        },
        "emissiveMap": {
          "value": "grey",
          "type": 28
        },
        "albedo": {
          "type": 16,
          "value": [1, 1, 1, 1]
        },
        "albedoScaleAndCutoff": {
          "type": 16,
          "value": [1, 1, 1, 0.5]
        },
        "pbrParams": {
          "type": 16,
          "value": [1, 0.8, 0.6, 0.5]
        },
        "miscParams": {
          "type": 16,
          "value": [1, 0, 0, 0]
        },
        "emissiveScaleParam": {
          "type": 16,
          "value": [1, 1, 1, 0]
        },
        "albedoMap": {
          "type": 28,
          "value": "grey"
        }
      }
    }, {
      "phase": "forward-add",
      "propertyIndex": 0,
      "embeddedMacros": {
        "CC_FORWARD_ADD": true
      },
      "blendState": {
        "targets": [{
          "blend": true,
          "blendSrc": 1,
          "blendDst": 1,
          "blendSrcAlpha": 0,
          "blendDstAlpha": 1
        }]
      },
      "program": "standard|standard-vs|standard-fs",
      "depthStencilState": {
        "depthFunc": 2,
        "depthTest": true,
        "depthWrite": false
      },
      "properties": {
        "tilingOffset": {
          "value": [1, 1, 0, 0],
          "type": 16
        },
        "mainColor": {
          "value": [1, 1, 1, 1],
          "type": 16,
          "handleInfo": ["albedo", 0, 16]
        },
        "albedoScale": {
          "value": [1, 1, 1],
          "type": 15,
          "handleInfo": ["albedoScaleAndCutoff", 0, 15]
        },
        "alphaThreshold": {
          "value": [0.5],
          "type": 13,
          "handleInfo": ["albedoScaleAndCutoff", 3, 13]
        },
        "occlusion": {
          "value": [1],
          "type": 13,
          "handleInfo": ["pbrParams", 0, 13]
        },
        "roughness": {
          "value": [0.8],
          "type": 13,
          "handleInfo": ["pbrParams", 1, 13]
        },
        "metallic": {
          "value": [0.6],
          "type": 13,
          "handleInfo": ["pbrParams", 2, 13]
        },
        "SpecularIntensity": {
          "value": [0.5],
          "type": 13,
          "handleInfo": ["pbrParams", 3, 13]
        },
        "normalStrenth": {
          "value": [1],
          "type": 13,
          "handleInfo": ["miscParams", 0, 13]
        },
        "emissive": {
          "value": [0, 0, 0, 1],
          "type": 16
        },
        "emissiveScale": {
          "value": [1, 1, 1],
          "type": 15,
          "handleInfo": ["emissiveScaleParam", 0, 15]
        },
        "mainTexture": {
          "value": "grey",
          "type": 28,
          "handleInfo": ["albedoMap", 0, 28]
        },
        "normalMap": {
          "value": "normal",
          "type": 28
        },
        "pbrMap": {
          "value": "grey",
          "type": 28
        },
        "metallicRoughnessMap": {
          "value": "grey",
          "type": 28
        },
        "occlusionMap": {
          "value": "white",
          "type": 28
        },
        "emissiveMap": {
          "value": "grey",
          "type": 28
        },
        "albedo": {
          "type": 16,
          "value": [1, 1, 1, 1]
        },
        "albedoScaleAndCutoff": {
          "type": 16,
          "value": [1, 1, 1, 0.5]
        },
        "pbrParams": {
          "type": 16,
          "value": [1, 0.8, 0.6, 0.5]
        },
        "miscParams": {
          "type": 16,
          "value": [1, 0, 0, 0]
        },
        "emissiveScaleParam": {
          "type": 16,
          "value": [1, 1, 1, 0]
        },
        "albedoMap": {
          "type": 28,
          "value": "grey"
        }
      }
    }, {
      "phase": "shadow-caster",
      "propertyIndex": 0,
      "rasterizerState": {
        "cullMode": 1
      },
      "program": "standard|shadow-caster-vs:vert|shadow-caster-fs:frag",
      "properties": {
        "tilingOffset": {
          "value": [1, 1, 0, 0],
          "type": 16
        },
        "mainColor": {
          "value": [1, 1, 1, 1],
          "type": 16,
          "handleInfo": ["albedo", 0, 16]
        },
        "albedoScale": {
          "value": [1, 1, 1],
          "type": 15,
          "handleInfo": ["albedoScaleAndCutoff", 0, 15]
        },
        "alphaThreshold": {
          "value": [0.5],
          "type": 13,
          "handleInfo": ["albedoScaleAndCutoff", 3, 13]
        },
        "occlusion": {
          "value": [1],
          "type": 13,
          "handleInfo": ["pbrParams", 0, 13]
        },
        "roughness": {
          "value": [0.8],
          "type": 13,
          "handleInfo": ["pbrParams", 1, 13]
        },
        "metallic": {
          "value": [0.6],
          "type": 13,
          "handleInfo": ["pbrParams", 2, 13]
        },
        "normalStrenth": {
          "value": [1],
          "type": 13,
          "handleInfo": ["pbrParams", 3, 13]
        },
        "emissive": {
          "value": [0, 0, 0, 1],
          "type": 16
        },
        "emissiveScale": {
          "value": [1, 1, 1],
          "type": 15,
          "handleInfo": ["emissiveScaleParam", 0, 15]
        },
        "mainTexture": {
          "value": "grey",
          "type": 28,
          "handleInfo": ["albedoMap", 0, 28]
        },
        "albedo": {
          "type": 16,
          "value": [1, 1, 1, 1]
        },
        "albedoScaleAndCutoff": {
          "type": 16,
          "value": [1, 1, 1, 0.5]
        },
        "pbrParams": {
          "type": 16,
          "value": [1, 0.8, 0.6, 1]
        },
        "emissiveScaleParam": {
          "type": 16,
          "value": [1, 1, 1, 0]
        },
        "albedoMap": {
          "type": 28,
          "value": "grey"
        }
      }
    }]
  }],
  "shaders": [{
    "name": "standard|standard-vs|standard-fs",
    "hash": 1413315494,
    "builtins": {
      "statistics": {
        "CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS": 217,
        "CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS": 60
      },
      "globals": {
        "blocks": [{
          "name": "CCGlobal",
          "defines": []
        }, {
          "name": "CCCamera",
          "defines": []
        }, {
          "name": "CCShadow",
          "defines": []
        }],
        "samplerTextures": [{
          "name": "cc_shadowMap",
          "defines": ["CC_RECEIVE_SHADOW"]
        }, {
          "name": "cc_spotLightingMap",
          "defines": ["CC_RECEIVE_SHADOW"]
        }, {
          "name": "cc_environment",
          "defines": ["CC_USE_IBL"]
        }]
      },
      "locals": {
        "blocks": [{
          "name": "CCMorph",
          "defines": ["CC_USE_MORPH"]
        }, {
          "name": "CCSkinningTexture",
          "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
        }, {
          "name": "CCSkinningAnimation",
          "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
        }, {
          "name": "CCSkinning",
          "defines": ["CC_USE_SKINNING", "!CC_USE_BAKED_ANIMATION"]
        }, {
          "name": "CCLocalBatched",
          "defines": ["!USE_INSTANCING", "USE_BATCHING"]
        }, {
          "name": "CCLocal",
          "defines": ["!USE_INSTANCING", "!USE_BATCHING"]
        }, {
          "name": "CCForwardLight",
          "defines": ["CC_FORWARD_ADD"]
        }],
        "samplerTextures": [{
          "name": "cc_PositionDisplacements",
          "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_POSITION"]
        }, {
          "name": "cc_NormalDisplacements",
          "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_NORMAL"]
        }, {
          "name": "cc_TangentDisplacements",
          "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_TANGENT"]
        }, {
          "name": "cc_jointTexture",
          "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
        }, {
          "name": "cc_lightingMap",
          "defines": ["USE_LIGHTMAP", "!USE_BATCHING", "!CC_FORWARD_ADD"]
        }]
      }
    },
    "defines": [{
      "name": "CC_USE_MORPH",
      "type": "boolean"
    }, {
      "name": "CC_MORPH_TARGET_COUNT",
      "type": "number",
      "range": [2, 8]
    }, {
      "name": "CC_MORPH_PRECOMPUTED",
      "type": "boolean"
    }, {
      "name": "CC_MORPH_TARGET_HAS_POSITION",
      "type": "boolean"
    }, {
      "name": "CC_MORPH_TARGET_HAS_NORMAL",
      "type": "boolean"
    }, {
      "name": "CC_MORPH_TARGET_HAS_TANGENT",
      "type": "boolean"
    }, {
      "name": "CC_USE_SKINNING",
      "type": "boolean"
    }, {
      "name": "CC_USE_BAKED_ANIMATION",
      "type": "boolean"
    }, {
      "name": "USE_INSTANCING",
      "type": "boolean"
    }, {
      "name": "USE_BATCHING",
      "type": "boolean"
    }, {
      "name": "USE_LIGHTMAP",
      "type": "boolean"
    }, {
      "name": "CC_USE_FOG",
      "type": "number",
      "range": [0, 4]
    }, {
      "name": "CC_FORWARD_ADD",
      "type": "boolean"
    }, {
      "name": "CC_RECEIVE_SHADOW",
      "type": "boolean"
    }, {
      "name": "USE_VERTEX_COLOR",
      "type": "boolean"
    }, {
      "name": "USE_NORMAL_MAP",
      "type": "boolean"
    }, {
      "name": "HAS_SECOND_UV",
      "type": "boolean"
    }, {
      "name": "SAMPLE_FROM_RT",
      "type": "boolean"
    }, {
      "name": "CC_USE_IBL",
      "type": "number",
      "range": [0, 2]
    }, {
      "name": "CC_USE_HDR",
      "type": "boolean"
    }, {
      "name": "USE_ALBEDO_MAP",
      "type": "boolean"
    }, {
      "name": "ALBEDO_UV",
      "type": "string",
      "options": ["v_uv", "v_uv1"]
    }, {
      "name": "NORMAL_UV",
      "type": "string",
      "options": ["v_uv", "v_uv1"]
    }, {
      "name": "PBR_UV",
      "type": "string",
      "options": ["v_uv", "v_uv1"]
    }, {
      "name": "USE_PBR_MAP",
      "type": "boolean"
    }, {
      "name": "USE_METALLIC_ROUGHNESS_MAP",
      "type": "boolean"
    }, {
      "name": "USE_OCCLUSION_MAP",
      "type": "boolean"
    }, {
      "name": "USE_EMISSIVE_MAP",
      "type": "boolean"
    }, {
      "name": "EMISSIVE_UV",
      "type": "string",
      "options": ["v_uv", "v_uv1"]
    }, {
      "name": "USE_ALPHA_TEST",
      "type": "boolean"
    }, {
      "name": "ALPHA_TEST_CHANNEL",
      "type": "string",
      "options": ["a", "r"]
    }, {
      "name": "CC_PIPELINE_TYPE",
      "type": "number",
      "range": [0, 1]
    }],
    "blocks": [{
      "name": "Constants",
      "defines": [],
      "binding": 0,
      "stageFlags": 17,
      "members": [{
        "name": "tilingOffset",
        "type": 16,
        "count": 1
      }, {
        "name": "albedo",
        "type": 16,
        "count": 1
      }, {
        "name": "albedoScaleAndCutoff",
        "type": 16,
        "count": 1
      }, {
        "name": "pbrParams",
        "type": 16,
        "count": 1
      }, {
        "name": "miscParams",
        "type": 16,
        "count": 1
      }, {
        "name": "emissive",
        "type": 16,
        "count": 1
      }, {
        "name": "emissiveScaleParam",
        "type": 16,
        "count": 1
      }]
    }],
    "samplerTextures": [{
      "name": "albedoMap",
      "type": 28,
      "count": 1,
      "defines": ["USE_ALBEDO_MAP"],
      "stageFlags": 16,
      "binding": 1
    }, {
      "name": "normalMap",
      "type": 28,
      "count": 1,
      "defines": ["USE_NORMAL_MAP"],
      "stageFlags": 16,
      "binding": 2
    }, {
      "name": "pbrMap",
      "type": 28,
      "count": 1,
      "defines": ["USE_PBR_MAP"],
      "stageFlags": 16,
      "binding": 3
    }, {
      "name": "metallicRoughnessMap",
      "type": 28,
      "count": 1,
      "defines": ["USE_METALLIC_ROUGHNESS_MAP"],
      "stageFlags": 16,
      "binding": 4
    }, {
      "name": "occlusionMap",
      "type": 28,
      "count": 1,
      "defines": ["USE_OCCLUSION_MAP"],
      "stageFlags": 16,
      "binding": 5
    }, {
      "name": "emissiveMap",
      "type": 28,
      "count": 1,
      "defines": ["USE_EMISSIVE_MAP"],
      "stageFlags": 16,
      "binding": 6
    }],
    "attributes": [{
      "name": "a_position",
      "type": 15,
      "count": 1,
      "defines": [],
      "stageFlags": 1,
      "format": 32,
      "location": 0
    }, {
      "name": "a_normal",
      "type": 15,
      "count": 1,
      "defines": [],
      "stageFlags": 1,
      "format": 32,
      "location": 1
    }, {
      "name": "a_texCoord",
      "type": 14,
      "count": 1,
      "defines": [],
      "stageFlags": 1,
      "format": 21,
      "location": 2
    }, {
      "name": "a_tangent",
      "type": 16,
      "count": 1,
      "defines": [],
      "stageFlags": 1,
      "format": 44,
      "location": 3
    }, {
      "name": "a_vertexId",
      "type": 13,
      "count": 1,
      "defines": ["CC_USE_MORPH"],
      "stageFlags": 1,
      "format": 11,
      "location": 6
    }, {
      "name": "a_joints",
      "type": "u32vec4",
      "count": 1,
      "defines": ["CC_USE_SKINNING"],
      "stageFlags": 1,
      "location": 4
    }, {
      "name": "a_weights",
      "type": 16,
      "count": 1,
      "defines": ["CC_USE_SKINNING"],
      "stageFlags": 1,
      "format": 44,
      "location": 5
    }, {
      "name": "a_jointAnimInfo",
      "type": 16,
      "count": 1,
      "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION", "USE_INSTANCING"],
      "stageFlags": 1,
      "format": 44,
      "isInstanced": true,
      "location": 7
    }, {
      "name": "a_matWorld0",
      "type": 16,
      "count": 1,
      "defines": ["USE_INSTANCING"],
      "stageFlags": 1,
      "format": 44,
      "isInstanced": true,
      "location": 8
    }, {
      "name": "a_matWorld1",
      "type": 16,
      "count": 1,
      "defines": ["USE_INSTANCING"],
      "stageFlags": 1,
      "format": 44,
      "isInstanced": true,
      "location": 9
    }, {
      "name": "a_matWorld2",
      "type": 16,
      "count": 1,
      "defines": ["USE_INSTANCING"],
      "stageFlags": 1,
      "format": 44,
      "isInstanced": true,
      "location": 10
    }, {
      "name": "a_lightingMapUVParam",
      "type": 16,
      "count": 1,
      "defines": ["USE_INSTANCING", "USE_LIGHTMAP"],
      "stageFlags": 1,
      "format": 44,
      "isInstanced": true,
      "location": 11
    }, {
      "name": "a_dyn_batch_id",
      "type": 13,
      "count": 1,
      "defines": ["!USE_INSTANCING", "USE_BATCHING"],
      "stageFlags": 1,
      "format": 11,
      "location": 12
    }, {
      "name": "a_color",
      "type": 16,
      "count": 1,
      "defines": ["USE_VERTEX_COLOR"],
      "stageFlags": 1,
      "format": 44,
      "location": 13
    }, {
      "name": "a_texCoord1",
      "type": 14,
      "count": 1,
      "defines": [],
      "stageFlags": 1,
      "format": 21,
      "location": 14
    }]
  }, {
    "name": "standard|shadow-caster-vs:vert|shadow-caster-fs:frag",
    "hash": 3621922986,
    "builtins": {
      "statistics": {
        "CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS": 180,
        "CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS": 23
      },
      "globals": {
        "blocks": [{
          "name": "CCShadow",
          "defines": []
        }],
        "samplerTextures": []
      },
      "locals": {
        "blocks": [{
          "name": "CCMorph",
          "defines": ["CC_USE_MORPH"]
        }, {
          "name": "CCSkinningTexture",
          "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
        }, {
          "name": "CCSkinningAnimation",
          "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
        }, {
          "name": "CCSkinning",
          "defines": ["CC_USE_SKINNING", "!CC_USE_BAKED_ANIMATION"]
        }, {
          "name": "CCLocalBatched",
          "defines": ["!USE_INSTANCING", "USE_BATCHING"]
        }, {
          "name": "CCLocal",
          "defines": ["!USE_INSTANCING", "!USE_BATCHING"]
        }],
        "samplerTextures": [{
          "name": "cc_PositionDisplacements",
          "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_POSITION"]
        }, {
          "name": "cc_NormalDisplacements",
          "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_NORMAL"]
        }, {
          "name": "cc_TangentDisplacements",
          "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_TANGENT"]
        }, {
          "name": "cc_jointTexture",
          "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
        }]
      }
    },
    "defines": [{
      "name": "CC_USE_MORPH",
      "type": "boolean"
    }, {
      "name": "CC_MORPH_TARGET_COUNT",
      "type": "number",
      "range": [2, 8]
    }, {
      "name": "CC_MORPH_PRECOMPUTED",
      "type": "boolean"
    }, {
      "name": "CC_MORPH_TARGET_HAS_POSITION",
      "type": "boolean"
    }, {
      "name": "CC_MORPH_TARGET_HAS_NORMAL",
      "type": "boolean"
    }, {
      "name": "CC_MORPH_TARGET_HAS_TANGENT",
      "type": "boolean"
    }, {
      "name": "CC_USE_SKINNING",
      "type": "boolean"
    }, {
      "name": "CC_USE_BAKED_ANIMATION",
      "type": "boolean"
    }, {
      "name": "USE_INSTANCING",
      "type": "boolean"
    }, {
      "name": "USE_BATCHING",
      "type": "boolean"
    }, {
      "name": "USE_LIGHTMAP",
      "type": "boolean"
    }, {
      "name": "HAS_SECOND_UV",
      "type": "boolean"
    }, {
      "name": "USE_ALBEDO_MAP",
      "type": "boolean"
    }, {
      "name": "ALBEDO_UV",
      "type": "string",
      "options": ["v_uv", "v_uv1"]
    }, {
      "name": "USE_ALPHA_TEST",
      "type": "boolean"
    }, {
      "name": "ALPHA_TEST_CHANNEL",
      "type": "string",
      "options": ["a", "r"]
    }],
    "blocks": [{
      "name": "Constants",
      "defines": [],
      "binding": 0,
      "stageFlags": 17,
      "members": [{
        "name": "tilingOffset",
        "type": 16,
        "count": 1
      }, {
        "name": "albedo",
        "type": 16,
        "count": 1
      }, {
        "name": "albedoScaleAndCutoff",
        "type": 16,
        "count": 1
      }, {
        "name": "pbrParams",
        "type": 16,
        "count": 1
      }, {
        "name": "miscParams",
        "type": 16,
        "count": 1
      }, {
        "name": "emissive",
        "type": 16,
        "count": 1
      }, {
        "name": "emissiveScaleParam",
        "type": 16,
        "count": 1
      }]
    }],
    "samplerTextures": [{
      "name": "albedoMap",
      "type": 28,
      "count": 1,
      "defines": ["USE_ALBEDO_MAP"],
      "stageFlags": 16,
      "binding": 1
    }],
    "attributes": [{
      "name": "a_position",
      "type": 15,
      "count": 1,
      "defines": [],
      "stageFlags": 1,
      "format": 32,
      "location": 0
    }, {
      "name": "a_normal",
      "type": 15,
      "count": 1,
      "defines": [],
      "stageFlags": 1,
      "format": 32,
      "location": 1
    }, {
      "name": "a_texCoord",
      "type": 14,
      "count": 1,
      "defines": [],
      "stageFlags": 1,
      "format": 21,
      "location": 2
    }, {
      "name": "a_tangent",
      "type": 16,
      "count": 1,
      "defines": [],
      "stageFlags": 1,
      "format": 44,
      "location": 3
    }, {
      "name": "a_vertexId",
      "type": 13,
      "count": 1,
      "defines": ["CC_USE_MORPH"],
      "stageFlags": 1,
      "format": 11,
      "location": 6
    }, {
      "name": "a_joints",
      "type": "u32vec4",
      "count": 1,
      "defines": ["CC_USE_SKINNING"],
      "stageFlags": 1,
      "location": 4
    }, {
      "name": "a_weights",
      "type": 16,
      "count": 1,
      "defines": ["CC_USE_SKINNING"],
      "stageFlags": 1,
      "format": 44,
      "location": 5
    }, {
      "name": "a_jointAnimInfo",
      "type": 16,
      "count": 1,
      "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION", "USE_INSTANCING"],
      "stageFlags": 1,
      "format": 44,
      "isInstanced": true,
      "location": 7
    }, {
      "name": "a_matWorld0",
      "type": 16,
      "count": 1,
      "defines": ["USE_INSTANCING"],
      "stageFlags": 1,
      "format": 44,
      "isInstanced": true,
      "location": 8
    }, {
      "name": "a_matWorld1",
      "type": 16,
      "count": 1,
      "defines": ["USE_INSTANCING"],
      "stageFlags": 1,
      "format": 44,
      "isInstanced": true,
      "location": 9
    }, {
      "name": "a_matWorld2",
      "type": 16,
      "count": 1,
      "defines": ["USE_INSTANCING"],
      "stageFlags": 1,
      "format": 44,
      "isInstanced": true,
      "location": 10
    }, {
      "name": "a_lightingMapUVParam",
      "type": 16,
      "count": 1,
      "defines": ["USE_INSTANCING", "USE_LIGHTMAP"],
      "stageFlags": 1,
      "format": 44,
      "isInstanced": true,
      "location": 11
    }, {
      "name": "a_dyn_batch_id",
      "type": 13,
      "count": 1,
      "defines": ["!USE_INSTANCING", "USE_BATCHING"],
      "stageFlags": 1,
      "format": 11,
      "location": 12
    }, {
      "name": "a_texCoord1",
      "type": 14,
      "count": 1,
      "defines": [],
      "stageFlags": 1,
      "format": 21,
      "location": 13
    }]
  }]
}, {
  "name": "terrain",
  "techniques": [{
    "name": "opaque",
    "passes": [{
      "program": "terrain|terrain-vs|terrain-fs",
      "properties": {
        "UVScale": {
          "value": [1, 1, 1, 1],
          "type": 16
        },
        "lightMapUVParam": {
          "value": [0, 0, 0, 0],
          "type": 16
        },
        "metallic": {
          "value": [0, 0, 0, 0],
          "type": 16
        },
        "roughness": {
          "value": [1, 1, 1, 1],
          "type": 16
        },
        "weightMap": {
          "value": "black",
          "type": 28
        },
        "detailMap0": {
          "value": "grey",
          "type": 28
        },
        "detailMap1": {
          "value": "grey",
          "type": 28
        },
        "detailMap2": {
          "value": "grey",
          "type": 28
        },
        "detailMap3": {
          "value": "grey",
          "type": 28
        },
        "normalMap0": {
          "value": "normal",
          "type": 28
        },
        "normalMap1": {
          "value": "normal",
          "type": 28
        },
        "normalMap2": {
          "value": "normal",
          "type": 28
        },
        "normalMap3": {
          "value": "normal",
          "type": 28
        },
        "lightMap": {
          "value": "grey",
          "type": 28
        }
      }
    }, {
      "phase": "deferred",
      "propertyIndex": 0,
      "blendState": {
        "targets": [{
          "blend": false
        }, {
          "blend": false
        }, {
          "blend": false
        }, {
          "blend": false
        }]
      },
      "program": "terrain|terrain-vs|terrain-fs",
      "properties": {
        "UVScale": {
          "value": [1, 1, 1, 1],
          "type": 16
        },
        "lightMapUVParam": {
          "value": [0, 0, 0, 0],
          "type": 16
        },
        "metallic": {
          "value": [0, 0, 0, 0],
          "type": 16
        },
        "roughness": {
          "value": [1, 1, 1, 1],
          "type": 16
        },
        "weightMap": {
          "value": "black",
          "type": 28
        },
        "detailMap0": {
          "value": "grey",
          "type": 28
        },
        "detailMap1": {
          "value": "grey",
          "type": 28
        },
        "detailMap2": {
          "value": "grey",
          "type": 28
        },
        "detailMap3": {
          "value": "grey",
          "type": 28
        },
        "normalMap0": {
          "value": "normal",
          "type": 28
        },
        "normalMap1": {
          "value": "normal",
          "type": 28
        },
        "normalMap2": {
          "value": "normal",
          "type": 28
        },
        "normalMap3": {
          "value": "normal",
          "type": 28
        },
        "lightMap": {
          "value": "grey",
          "type": 28
        }
      }
    }, {
      "phase": "forward-add",
      "propertyIndex": 0,
      "embeddedMacros": {
        "CC_FORWARD_ADD": true
      },
      "blendState": {
        "targets": [{
          "blend": true,
          "blendSrc": 1,
          "blendDst": 1,
          "blendSrcAlpha": 0,
          "blendDstAlpha": 1
        }]
      },
      "program": "terrain|terrain-vs|terrain-fs",
      "depthStencilState": {
        "depthFunc": 2,
        "depthTest": true,
        "depthWrite": false
      },
      "properties": {
        "UVScale": {
          "value": [1, 1, 1, 1],
          "type": 16
        },
        "lightMapUVParam": {
          "value": [0, 0, 0, 0],
          "type": 16
        },
        "metallic": {
          "value": [0, 0, 0, 0],
          "type": 16
        },
        "roughness": {
          "value": [1, 1, 1, 1],
          "type": 16
        },
        "weightMap": {
          "value": "black",
          "type": 28
        },
        "detailMap0": {
          "value": "grey",
          "type": 28
        },
        "detailMap1": {
          "value": "grey",
          "type": 28
        },
        "detailMap2": {
          "value": "grey",
          "type": 28
        },
        "detailMap3": {
          "value": "grey",
          "type": 28
        },
        "normalMap0": {
          "value": "normal",
          "type": 28
        },
        "normalMap1": {
          "value": "normal",
          "type": 28
        },
        "normalMap2": {
          "value": "normal",
          "type": 28
        },
        "normalMap3": {
          "value": "normal",
          "type": 28
        },
        "lightMap": {
          "value": "grey",
          "type": 28
        }
      }
    }, {
      "phase": "shadow-add",
      "propertyIndex": 0,
      "rasterizerState": {
        "cullMode": 2
      },
      "program": "terrain|shadow-caster-vs:vert|shadow-caster-fs:frag"
    }]
  }],
  "shaders": [{
    "name": "terrain|terrain-vs|terrain-fs",
    "hash": 3393045613,
    "builtins": {
      "statistics": {
        "CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS": 64,
        "CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS": 55
      },
      "globals": {
        "blocks": [{
          "name": "CCGlobal",
          "defines": []
        }, {
          "name": "CCCamera",
          "defines": []
        }, {
          "name": "CCShadow",
          "defines": []
        }],
        "samplerTextures": [{
          "name": "cc_shadowMap",
          "defines": ["CC_RECEIVE_SHADOW"]
        }, {
          "name": "cc_spotLightingMap",
          "defines": ["CC_RECEIVE_SHADOW"]
        }, {
          "name": "cc_environment",
          "defines": ["CC_USE_IBL"]
        }]
      },
      "locals": {
        "blocks": [{
          "name": "CCLocal",
          "defines": []
        }, {
          "name": "CCForwardLight",
          "defines": ["CC_FORWARD_ADD"]
        }],
        "samplerTextures": [{
          "name": "cc_lightingMap",
          "defines": ["USE_LIGHTMAP", "!USE_BATCHING", "!CC_FORWARD_ADD"]
        }]
      }
    },
    "defines": [{
      "name": "CC_USE_FOG",
      "type": "number",
      "range": [0, 4]
    }, {
      "name": "CC_FORWARD_ADD",
      "type": "boolean"
    }, {
      "name": "CC_RECEIVE_SHADOW",
      "type": "boolean"
    }, {
      "name": "USE_NORMALMAP",
      "type": "boolean"
    }, {
      "name": "USE_LIGHTMAP",
      "type": "boolean"
    }, {
      "name": "CC_USE_IBL",
      "type": "number",
      "range": [0, 2]
    }, {
      "name": "USE_BATCHING",
      "type": "boolean"
    }, {
      "name": "CC_USE_HDR",
      "type": "boolean"
    }, {
      "name": "LAYERS",
      "type": "number",
      "range": [0, 4]
    }, {
      "name": "USE_PBR",
      "type": "boolean"
    }, {
      "name": "CC_PIPELINE_TYPE",
      "type": "number",
      "range": [0, 1]
    }],
    "blocks": [{
      "name": "TexCoords",
      "defines": [],
      "binding": 0,
      "stageFlags": 1,
      "members": [{
        "name": "UVScale",
        "type": 16,
        "count": 1
      }, {
        "name": "lightMapUVParam",
        "type": 16,
        "count": 1
      }]
    }, {
      "name": "PbrParams",
      "defines": [],
      "binding": 1,
      "stageFlags": 16,
      "members": [{
        "name": "metallic",
        "type": 16,
        "count": 1
      }, {
        "name": "roughness",
        "type": 16,
        "count": 1
      }]
    }],
    "samplerTextures": [{
      "name": "weightMap",
      "type": 28,
      "count": 1,
      "defines": [],
      "stageFlags": 16,
      "binding": 2
    }, {
      "name": "detailMap0",
      "type": 28,
      "count": 1,
      "defines": [],
      "stageFlags": 16,
      "binding": 3
    }, {
      "name": "detailMap1",
      "type": 28,
      "count": 1,
      "defines": [],
      "stageFlags": 16,
      "binding": 4
    }, {
      "name": "detailMap2",
      "type": 28,
      "count": 1,
      "defines": [],
      "stageFlags": 16,
      "binding": 5
    }, {
      "name": "detailMap3",
      "type": 28,
      "count": 1,
      "defines": [],
      "stageFlags": 16,
      "binding": 6
    }, {
      "name": "normalMap0",
      "type": 28,
      "count": 1,
      "defines": [],
      "stageFlags": 16,
      "binding": 7
    }, {
      "name": "normalMap1",
      "type": 28,
      "count": 1,
      "defines": [],
      "stageFlags": 16,
      "binding": 8
    }, {
      "name": "normalMap2",
      "type": 28,
      "count": 1,
      "defines": [],
      "stageFlags": 16,
      "binding": 9
    }, {
      "name": "normalMap3",
      "type": 28,
      "count": 1,
      "defines": [],
      "stageFlags": 16,
      "binding": 10
    }, {
      "name": "lightMap",
      "type": 28,
      "count": 1,
      "defines": [],
      "stageFlags": 16,
      "binding": 11
    }],
    "attributes": [{
      "name": "a_position",
      "type": 15,
      "count": 1,
      "defines": [],
      "stageFlags": 1,
      "format": 32,
      "location": 0
    }, {
      "name": "a_normal",
      "type": 15,
      "count": 1,
      "defines": [],
      "stageFlags": 1,
      "format": 32,
      "location": 1
    }, {
      "name": "a_texCoord",
      "type": 14,
      "count": 1,
      "defines": [],
      "stageFlags": 1,
      "format": 21,
      "location": 2
    }]
  }, {
    "name": "terrain|shadow-caster-vs:vert|shadow-caster-fs:frag",
    "hash": 1471860764,
    "builtins": {
      "statistics": {
        "CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS": 62,
        "CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS": 0
      },
      "globals": {
        "blocks": [{
          "name": "CCGlobal",
          "defines": []
        }, {
          "name": "CCCamera",
          "defines": []
        }, {
          "name": "CCShadow",
          "defines": []
        }],
        "samplerTextures": []
      },
      "locals": {
        "blocks": [{
          "name": "CCLocal",
          "defines": []
        }],
        "samplerTextures": []
      }
    },
    "defines": [],
    "blocks": [],
    "samplerTextures": [],
    "attributes": [{
      "name": "a_position",
      "type": 15,
      "count": 1,
      "defines": [],
      "stageFlags": 1,
      "format": 32,
      "location": 0
    }, {
      "name": "a_normal",
      "type": 15,
      "count": 1,
      "defines": [],
      "stageFlags": 1,
      "format": 32,
      "location": 1
    }, {
      "name": "a_texCoord",
      "type": 14,
      "count": 1,
      "defines": [],
      "stageFlags": 1,
      "format": 21,
      "location": 2
    }]
  }]
}, {
  "name": "unlit",
  "techniques": [{
    "name": "opaque",
    "passes": [{
      "program": "unlit|unlit-vs:vert|unlit-fs:frag",
      "properties": {
        "mainTexture": {
          "value": "grey",
          "type": 28
        },
        "tilingOffset": {
          "value": [1, 1, 0, 0],
          "type": 16
        },
        "mainColor": {
          "value": [1, 1, 1, 1],
          "type": 16
        },
        "colorScale": {
          "value": [1, 1, 1],
          "type": 15,
          "handleInfo": ["colorScaleAndCutoff", 0, 15]
        },
        "alphaThreshold": {
          "value": [0.5],
          "type": 13,
          "handleInfo": ["colorScaleAndCutoff", 3, 13]
        },
        "color": {
          "type": 16,
          "handleInfo": ["mainColor", 0, 16]
        },
        "colorScaleAndCutoff": {
          "type": 16,
          "value": [1, 1, 1, 0.5]
        }
      }
    }]
  }],
  "shaders": [{
    "name": "unlit|unlit-vs:vert|unlit-fs:frag",
    "hash": 1017648509,
    "builtins": {
      "statistics": {
        "CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS": 195,
        "CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS": 39
      },
      "globals": {
        "blocks": [{
          "name": "CCGlobal",
          "defines": []
        }, {
          "name": "CCCamera",
          "defines": []
        }],
        "samplerTextures": []
      },
      "locals": {
        "blocks": [{
          "name": "CCMorph",
          "defines": ["CC_USE_MORPH"]
        }, {
          "name": "CCSkinningTexture",
          "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
        }, {
          "name": "CCSkinningAnimation",
          "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
        }, {
          "name": "CCSkinning",
          "defines": ["CC_USE_SKINNING", "!CC_USE_BAKED_ANIMATION"]
        }, {
          "name": "CCLocalBatched",
          "defines": ["!USE_INSTANCING", "USE_BATCHING"]
        }, {
          "name": "CCLocal",
          "defines": ["!USE_INSTANCING", "!USE_BATCHING"]
        }],
        "samplerTextures": [{
          "name": "cc_PositionDisplacements",
          "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_POSITION"]
        }, {
          "name": "cc_NormalDisplacements",
          "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_NORMAL"]
        }, {
          "name": "cc_TangentDisplacements",
          "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_TANGENT"]
        }, {
          "name": "cc_jointTexture",
          "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
        }]
      }
    },
    "defines": [{
      "name": "CC_USE_MORPH",
      "type": "boolean"
    }, {
      "name": "CC_MORPH_TARGET_COUNT",
      "type": "number",
      "range": [2, 8]
    }, {
      "name": "CC_MORPH_PRECOMPUTED",
      "type": "boolean"
    }, {
      "name": "CC_MORPH_TARGET_HAS_POSITION",
      "type": "boolean"
    }, {
      "name": "CC_MORPH_TARGET_HAS_NORMAL",
      "type": "boolean"
    }, {
      "name": "CC_MORPH_TARGET_HAS_TANGENT",
      "type": "boolean"
    }, {
      "name": "CC_USE_SKINNING",
      "type": "boolean"
    }, {
      "name": "CC_USE_BAKED_ANIMATION",
      "type": "boolean"
    }, {
      "name": "USE_INSTANCING",
      "type": "boolean"
    }, {
      "name": "USE_BATCHING",
      "type": "boolean"
    }, {
      "name": "USE_LIGHTMAP",
      "type": "boolean"
    }, {
      "name": "CC_USE_FOG",
      "type": "number",
      "range": [0, 4]
    }, {
      "name": "CC_FORWARD_ADD",
      "type": "boolean"
    }, {
      "name": "USE_VERTEX_COLOR",
      "type": "boolean"
    }, {
      "name": "USE_TEXTURE",
      "type": "boolean"
    }, {
      "name": "SAMPLE_FROM_RT",
      "type": "boolean"
    }, {
      "name": "CC_USE_HDR",
      "type": "boolean"
    }, {
      "name": "USE_ALPHA_TEST",
      "type": "boolean"
    }, {
      "name": "ALPHA_TEST_CHANNEL",
      "type": "string",
      "options": ["a", "r", "g", "b"]
    }],
    "blocks": [{
      "name": "TexCoords",
      "defines": ["USE_TEXTURE"],
      "binding": 0,
      "stageFlags": 1,
      "members": [{
        "name": "tilingOffset",
        "type": 16,
        "count": 1
      }]
    }, {
      "name": "Constant",
      "defines": [],
      "binding": 1,
      "stageFlags": 16,
      "members": [{
        "name": "mainColor",
        "type": 16,
        "count": 1
      }, {
        "name": "colorScaleAndCutoff",
        "type": 16,
        "count": 1
      }]
    }],
    "samplerTextures": [{
      "name": "mainTexture",
      "type": 28,
      "count": 1,
      "defines": ["USE_TEXTURE"],
      "stageFlags": 16,
      "binding": 2
    }],
    "attributes": [{
      "name": "a_position",
      "type": 15,
      "count": 1,
      "defines": [],
      "stageFlags": 1,
      "format": 32,
      "location": 0
    }, {
      "name": "a_normal",
      "type": 15,
      "count": 1,
      "defines": [],
      "stageFlags": 1,
      "format": 32,
      "location": 1
    }, {
      "name": "a_texCoord",
      "type": 14,
      "count": 1,
      "defines": [],
      "stageFlags": 1,
      "format": 21,
      "location": 2
    }, {
      "name": "a_tangent",
      "type": 16,
      "count": 1,
      "defines": [],
      "stageFlags": 1,
      "format": 44,
      "location": 3
    }, {
      "name": "a_vertexId",
      "type": 13,
      "count": 1,
      "defines": ["CC_USE_MORPH"],
      "stageFlags": 1,
      "format": 11,
      "location": 6
    }, {
      "name": "a_joints",
      "type": "u32vec4",
      "count": 1,
      "defines": ["CC_USE_SKINNING"],
      "stageFlags": 1,
      "location": 4
    }, {
      "name": "a_weights",
      "type": 16,
      "count": 1,
      "defines": ["CC_USE_SKINNING"],
      "stageFlags": 1,
      "format": 44,
      "location": 5
    }, {
      "name": "a_jointAnimInfo",
      "type": 16,
      "count": 1,
      "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION", "USE_INSTANCING"],
      "stageFlags": 1,
      "format": 44,
      "isInstanced": true,
      "location": 7
    }, {
      "name": "a_matWorld0",
      "type": 16,
      "count": 1,
      "defines": ["USE_INSTANCING"],
      "stageFlags": 1,
      "format": 44,
      "isInstanced": true,
      "location": 8
    }, {
      "name": "a_matWorld1",
      "type": 16,
      "count": 1,
      "defines": ["USE_INSTANCING"],
      "stageFlags": 1,
      "format": 44,
      "isInstanced": true,
      "location": 9
    }, {
      "name": "a_matWorld2",
      "type": 16,
      "count": 1,
      "defines": ["USE_INSTANCING"],
      "stageFlags": 1,
      "format": 44,
      "isInstanced": true,
      "location": 10
    }, {
      "name": "a_lightingMapUVParam",
      "type": 16,
      "count": 1,
      "defines": ["USE_INSTANCING", "USE_LIGHTMAP"],
      "stageFlags": 1,
      "format": 44,
      "isInstanced": true,
      "location": 11
    }, {
      "name": "a_dyn_batch_id",
      "type": 13,
      "count": 1,
      "defines": ["!USE_INSTANCING", "USE_BATCHING"],
      "stageFlags": 1,
      "format": 11,
      "location": 12
    }, {
      "name": "a_color",
      "type": 16,
      "count": 1,
      "defines": ["USE_VERTEX_COLOR"],
      "stageFlags": 1,
      "format": 44,
      "location": 13
    }]
  }]
}, {
  "name": "deferred-lighting",
  "techniques": [{
    "passes": [{
      "phase": "deferred-lighting",
      "program": "deferred-lighting|lighting-vs|lighting-fs",
      "depthStencilState": {
        "depthFunc": 4,
        "depthTest": true,
        "depthWrite": false
      }
    }]
  }],
  "shaders": [{
    "name": "deferred-lighting|lighting-vs|lighting-fs",
    "hash": 1887156831,
    "builtins": {
      "statistics": {
        "CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS": 37,
        "CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS": 53
      },
      "globals": {
        "blocks": [{
          "name": "CCGlobal",
          "defines": []
        }, {
          "name": "CCCamera",
          "defines": []
        }, {
          "name": "CCShadow",
          "defines": []
        }],
        "samplerTextures": [{
          "name": "cc_shadowMap",
          "defines": ["CC_RECEIVE_SHADOW"]
        }, {
          "name": "cc_spotLightingMap",
          "defines": ["CC_RECEIVE_SHADOW"]
        }, {
          "name": "cc_environment",
          "defines": ["CC_USE_IBL"]
        }, {
          "name": "cc_gbuffer_albedoMap",
          "defines": []
        }, {
          "name": "cc_gbuffer_positionMap",
          "defines": []
        }, {
          "name": "cc_gbuffer_normalMap",
          "defines": []
        }, {
          "name": "cc_gbuffer_emissiveMap",
          "defines": []
        }]
      },
      "locals": {
        "blocks": [{
          "name": "CCForwardLight",
          "defines": []
        }],
        "samplerTextures": []
      }
    },
    "defines": [{
      "name": "CC_RECEIVE_SHADOW",
      "type": "boolean"
    }, {
      "name": "CC_USE_IBL",
      "type": "number",
      "range": [0, 2]
    }, {
      "name": "USE_LIGHTMAP",
      "type": "boolean"
    }, {
      "name": "USE_BATCHING",
      "type": "boolean"
    }, {
      "name": "CC_FORWARD_ADD",
      "type": "boolean"
    }, {
      "name": "CC_USE_HDR",
      "type": "boolean"
    }, {
      "name": "CC_PIPELINE_TYPE",
      "type": "number",
      "range": [0, 1]
    }, {
      "name": "CC_USE_FOG",
      "type": "number",
      "range": [0, 4]
    }],
    "blocks": [],
    "samplerTextures": [],
    "attributes": [{
      "name": "a_position",
      "type": 15,
      "count": 1,
      "defines": [],
      "stageFlags": 1,
      "format": 32,
      "location": 0
    }, {
      "name": "a_normal",
      "type": 15,
      "count": 1,
      "defines": [],
      "stageFlags": 1,
      "format": 32,
      "location": 1
    }, {
      "name": "a_texCoord",
      "type": 14,
      "count": 1,
      "defines": [],
      "stageFlags": 1,
      "format": 21,
      "location": 2
    }, {
      "name": "a_tangent",
      "type": 16,
      "count": 1,
      "defines": [],
      "stageFlags": 1,
      "format": 44,
      "location": 3
    }]
  }]
}, {
  "name": "planar-shadow",
  "techniques": [{
    "passes": [{
      "phase": "planarShadow",
      "blendState": {
        "targets": [{
          "blend": true,
          "blendSrc": 2,
          "blendDst": 4,
          "blendDstAlpha": 4
        }]
      },
      "program": "planar-shadow|planar-shadow-vs:vert|planar-shadow-fs:frag",
      "depthStencilState": {
        "depthTest": true,
        "depthWrite": false,
        "stencilTestFront": true,
        "stencilFuncFront": 5,
        "stencilPassOpFront": 2,
        "stencilRefBack": 128,
        "stencilRefFront": 128,
        "stencilReadMaskBack": 128,
        "stencilReadMaskFront": 128,
        "stencilWriteMaskBack": 128,
        "stencilWriteMaskFront": 128
      }
    }]
  }],
  "shaders": [{
    "name": "planar-shadow|planar-shadow-vs:vert|planar-shadow-fs:frag",
    "hash": 649108546,
    "builtins": {
      "statistics": {
        "CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS": 210,
        "CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS": 53
      },
      "globals": {
        "blocks": [{
          "name": "CCGlobal",
          "defines": []
        }, {
          "name": "CCCamera",
          "defines": []
        }, {
          "name": "CCShadow",
          "defines": []
        }],
        "samplerTextures": []
      },
      "locals": {
        "blocks": [{
          "name": "CCMorph",
          "defines": ["CC_USE_MORPH"]
        }, {
          "name": "CCSkinningTexture",
          "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
        }, {
          "name": "CCSkinningAnimation",
          "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
        }, {
          "name": "CCSkinning",
          "defines": ["CC_USE_SKINNING", "!CC_USE_BAKED_ANIMATION"]
        }, {
          "name": "CCLocalBatched",
          "defines": ["!USE_INSTANCING", "USE_BATCHING"]
        }, {
          "name": "CCLocal",
          "defines": ["!USE_INSTANCING", "!USE_BATCHING"]
        }],
        "samplerTextures": [{
          "name": "cc_PositionDisplacements",
          "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_POSITION"]
        }, {
          "name": "cc_NormalDisplacements",
          "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_NORMAL"]
        }, {
          "name": "cc_TangentDisplacements",
          "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_TANGENT"]
        }, {
          "name": "cc_jointTexture",
          "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
        }]
      }
    },
    "defines": [{
      "name": "CC_USE_MORPH",
      "type": "boolean"
    }, {
      "name": "CC_MORPH_TARGET_COUNT",
      "type": "number",
      "range": [2, 8]
    }, {
      "name": "CC_MORPH_PRECOMPUTED",
      "type": "boolean"
    }, {
      "name": "CC_MORPH_TARGET_HAS_POSITION",
      "type": "boolean"
    }, {
      "name": "CC_MORPH_TARGET_HAS_NORMAL",
      "type": "boolean"
    }, {
      "name": "CC_MORPH_TARGET_HAS_TANGENT",
      "type": "boolean"
    }, {
      "name": "CC_USE_SKINNING",
      "type": "boolean"
    }, {
      "name": "CC_USE_BAKED_ANIMATION",
      "type": "boolean"
    }, {
      "name": "USE_INSTANCING",
      "type": "boolean"
    }, {
      "name": "USE_BATCHING",
      "type": "boolean"
    }, {
      "name": "USE_LIGHTMAP",
      "type": "boolean"
    }, {
      "name": "CC_USE_HDR",
      "type": "boolean"
    }],
    "blocks": [],
    "samplerTextures": [],
    "attributes": [{
      "name": "a_position",
      "type": 15,
      "count": 1,
      "defines": [],
      "stageFlags": 1,
      "format": 32,
      "location": 0
    }, {
      "name": "a_normal",
      "type": 15,
      "count": 1,
      "defines": [],
      "stageFlags": 1,
      "format": 32,
      "location": 1
    }, {
      "name": "a_texCoord",
      "type": 14,
      "count": 1,
      "defines": [],
      "stageFlags": 1,
      "format": 21,
      "location": 2
    }, {
      "name": "a_tangent",
      "type": 16,
      "count": 1,
      "defines": [],
      "stageFlags": 1,
      "format": 44,
      "location": 3
    }, {
      "name": "a_vertexId",
      "type": 13,
      "count": 1,
      "defines": ["CC_USE_MORPH"],
      "stageFlags": 1,
      "format": 11,
      "location": 6
    }, {
      "name": "a_joints",
      "type": "u32vec4",
      "count": 1,
      "defines": ["CC_USE_SKINNING"],
      "stageFlags": 1,
      "location": 4
    }, {
      "name": "a_weights",
      "type": 16,
      "count": 1,
      "defines": ["CC_USE_SKINNING"],
      "stageFlags": 1,
      "format": 44,
      "location": 5
    }, {
      "name": "a_jointAnimInfo",
      "type": 16,
      "count": 1,
      "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION", "USE_INSTANCING"],
      "stageFlags": 1,
      "format": 44,
      "isInstanced": true,
      "location": 7
    }, {
      "name": "a_matWorld0",
      "type": 16,
      "count": 1,
      "defines": ["USE_INSTANCING"],
      "stageFlags": 1,
      "format": 44,
      "isInstanced": true,
      "location": 8
    }, {
      "name": "a_matWorld1",
      "type": 16,
      "count": 1,
      "defines": ["USE_INSTANCING"],
      "stageFlags": 1,
      "format": 44,
      "isInstanced": true,
      "location": 9
    }, {
      "name": "a_matWorld2",
      "type": 16,
      "count": 1,
      "defines": ["USE_INSTANCING"],
      "stageFlags": 1,
      "format": 44,
      "isInstanced": true,
      "location": 10
    }, {
      "name": "a_lightingMapUVParam",
      "type": 16,
      "count": 1,
      "defines": ["USE_INSTANCING", "USE_LIGHTMAP"],
      "stageFlags": 1,
      "format": 44,
      "isInstanced": true,
      "location": 11
    }, {
      "name": "a_dyn_batch_id",
      "type": 13,
      "count": 1,
      "defines": ["!USE_INSTANCING", "USE_BATCHING"],
      "stageFlags": 1,
      "format": 11,
      "location": 12
    }]
  }]
}, {
  "name": "post-process",
  "techniques": [{
    "passes": [{
      "phase": "post-process",
      "blendState": {
        "targets": [{
          "blend": true,
          "blendSrc": 2,
          "blendDst": 4,
          "blendSrcAlpha": 2,
          "blendDstAlpha": 4
        }]
      },
      "program": "post-process|post-process-vs|post-process-fs",
      "depthStencilState": {
        "depthTest": false,
        "depthWrite": false
      }
    }]
  }],
  "shaders": [{
    "name": "post-process|post-process-vs|post-process-fs",
    "hash": 1780456825,
    "builtins": {
      "statistics": {
        "CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS": 145,
        "CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS": 37
      },
      "globals": {
        "blocks": [{
          "name": "CCGlobal",
          "defines": []
        }, {
          "name": "CCCamera",
          "defines": []
        }],
        "samplerTextures": [{
          "name": "cc_lighting_resultMap",
          "defines": []
        }]
      },
      "locals": {
        "blocks": [{
          "name": "CCMorph",
          "defines": ["CC_USE_MORPH"]
        }, {
          "name": "CCSkinningTexture",
          "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
        }, {
          "name": "CCSkinningAnimation",
          "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
        }, {
          "name": "CCSkinning",
          "defines": ["CC_USE_SKINNING", "!CC_USE_BAKED_ANIMATION"]
        }],
        "samplerTextures": [{
          "name": "cc_PositionDisplacements",
          "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_POSITION"]
        }, {
          "name": "cc_NormalDisplacements",
          "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_NORMAL"]
        }, {
          "name": "cc_TangentDisplacements",
          "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_TANGENT"]
        }, {
          "name": "cc_jointTexture",
          "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
        }]
      }
    },
    "defines": [{
      "name": "CC_USE_MORPH",
      "type": "boolean"
    }, {
      "name": "CC_MORPH_TARGET_COUNT",
      "type": "number",
      "range": [2, 8]
    }, {
      "name": "CC_MORPH_PRECOMPUTED",
      "type": "boolean"
    }, {
      "name": "CC_MORPH_TARGET_HAS_POSITION",
      "type": "boolean"
    }, {
      "name": "CC_MORPH_TARGET_HAS_NORMAL",
      "type": "boolean"
    }, {
      "name": "CC_MORPH_TARGET_HAS_TANGENT",
      "type": "boolean"
    }, {
      "name": "CC_USE_SKINNING",
      "type": "boolean"
    }, {
      "name": "CC_USE_BAKED_ANIMATION",
      "type": "boolean"
    }, {
      "name": "USE_INSTANCING",
      "type": "boolean"
    }],
    "blocks": [],
    "samplerTextures": [],
    "attributes": [{
      "name": "a_position",
      "type": 15,
      "count": 1,
      "defines": [],
      "stageFlags": 1,
      "format": 32,
      "location": 0
    }, {
      "name": "a_normal",
      "type": 15,
      "count": 1,
      "defines": [],
      "stageFlags": 1,
      "format": 32,
      "location": 1
    }, {
      "name": "a_texCoord",
      "type": 14,
      "count": 1,
      "defines": [],
      "stageFlags": 1,
      "format": 21,
      "location": 2
    }, {
      "name": "a_tangent",
      "type": 16,
      "count": 1,
      "defines": [],
      "stageFlags": 1,
      "format": 44,
      "location": 3
    }, {
      "name": "a_vertexId",
      "type": 13,
      "count": 1,
      "defines": ["CC_USE_MORPH"],
      "stageFlags": 1,
      "format": 11,
      "location": 6
    }, {
      "name": "a_joints",
      "type": "u32vec4",
      "count": 1,
      "defines": ["CC_USE_SKINNING"],
      "stageFlags": 1,
      "location": 4
    }, {
      "name": "a_weights",
      "type": 16,
      "count": 1,
      "defines": ["CC_USE_SKINNING"],
      "stageFlags": 1,
      "format": 44,
      "location": 5
    }, {
      "name": "a_jointAnimInfo",
      "type": 16,
      "count": 1,
      "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION", "USE_INSTANCING"],
      "stageFlags": 1,
      "format": 44,
      "isInstanced": true,
      "location": 7
    }]
  }]
}, {
  "name": "skybox",
  "techniques": [{
    "passes": [{
      "rasterizerState": {
        "cullMode": 0
      },
      "program": "skybox|sky-vs:vert|sky-fs:frag",
      "priority": 245,
      "depthStencilState": {
        "depthTest": true,
        "depthWrite": false
      }
    }]
  }],
  "shaders": [{
    "name": "skybox|sky-vs:vert|sky-fs:frag",
    "hash": 3169038185,
    "builtins": {
      "statistics": {
        "CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS": 37,
        "CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS": 37
      },
      "globals": {
        "blocks": [{
          "name": "CCGlobal",
          "defines": []
        }, {
          "name": "CCCamera",
          "defines": []
        }],
        "samplerTextures": [{
          "name": "cc_environment",
          "defines": []
        }]
      },
      "locals": {
        "blocks": [],
        "samplerTextures": []
      }
    },
    "defines": [{
      "name": "CC_USE_IBL",
      "type": "number",
      "range": [0, 2]
    }, {
      "name": "CC_USE_HDR",
      "type": "boolean"
    }, {
      "name": "USE_RGBE_CUBEMAP",
      "type": "boolean"
    }],
    "blocks": [],
    "samplerTextures": [],
    "attributes": [{
      "name": "a_position",
      "type": 15,
      "count": 1,
      "defines": [],
      "stageFlags": 1,
      "format": 32,
      "location": 0
    }, {
      "name": "a_normal",
      "type": 15,
      "count": 1,
      "defines": [],
      "stageFlags": 1,
      "format": 32,
      "location": 1
    }, {
      "name": "a_texCoord",
      "type": 14,
      "count": 1,
      "defines": [],
      "stageFlags": 1,
      "format": 21,
      "location": 2
    }, {
      "name": "a_tangent",
      "type": 16,
      "count": 1,
      "defines": [],
      "stageFlags": 1,
      "format": 44,
      "location": 3
    }]
  }]
}, {
  "name": "profiler",
  "techniques": [{
    "passes": [{
      "blendState": {
        "targets": [{
          "blend": true,
          "blendSrc": 2,
          "blendDst": 4,
          "blendDstAlpha": 4
        }]
      },
      "rasterizerState": {
        "cullMode": 0
      },
      "program": "profiler|profiler-vs:vert|profiler-fs:frag",
      "depthStencilState": {
        "depthTest": false,
        "depthWrite": false
      }
    }]
  }],
  "shaders": [{
    "name": "profiler|profiler-vs:vert|profiler-fs:frag",
    "hash": 3552712539,
    "builtins": {
      "statistics": {
        "CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS": 58,
        "CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS": 37
      },
      "globals": {
        "blocks": [{
          "name": "CCGlobal",
          "defines": []
        }, {
          "name": "CCCamera",
          "defines": []
        }],
        "samplerTextures": []
      },
      "locals": {
        "blocks": [],
        "samplerTextures": []
      }
    },
    "defines": [{
      "name": "CC_USE_HDR",
      "type": "boolean"
    }],
    "blocks": [{
      "name": "Constants",
      "defines": [],
      "binding": 0,
      "stageFlags": 1,
      "members": [{
        "name": "offset",
        "type": 16,
        "count": 1
      }]
    }, {
      "name": "PerFrameInfo",
      "defines": [],
      "binding": 1,
      "stageFlags": 1,
      "members": [{
        "name": "digits",
        "type": 16,
        "count": 20
      }]
    }],
    "samplerTextures": [{
      "name": "mainTexture",
      "type": 28,
      "count": 1,
      "defines": [],
      "stageFlags": 16,
      "binding": 2
    }],
    "attributes": [{
      "name": "a_position",
      "type": 15,
      "count": 1,
      "defines": [],
      "stageFlags": 1,
      "format": 32,
      "location": 0
    }, {
      "name": "a_color",
      "type": 16,
      "count": 1,
      "defines": [],
      "stageFlags": 1,
      "format": 44,
      "location": 1
    }]
  }]
}, {
  "name": "splash-screen",
  "techniques": [{
    "name": "default",
    "passes": [{
      "blendState": {
        "targets": [{
          "blend": true,
          "blendSrc": 2,
          "blendDst": 4,
          "blendDstAlpha": 4
        }]
      },
      "rasterizerState": {
        "cullMode": 0
      },
      "program": "splash-screen|splash-screen-vs:vert|splash-screen-fs:frag",
      "depthStencilState": {
        "depthTest": false,
        "depthWrite": false
      },
      "properties": {
        "mainTexture": {
          "value": "grey",
          "type": 28
        },
        "resolution": {
          "value": [640, 960],
          "type": 14,
          "handleInfo": ["u_buffer0", 0, 14]
        },
        "precent": {
          "value": [0.5],
          "type": 13,
          "handleInfo": ["u_buffer0", 2, 13]
        },
        "scale": {
          "value": [200, 500],
          "type": 14,
          "handleInfo": ["u_buffer1", 0, 14]
        },
        "translate": {
          "value": [320, 480],
          "type": 14,
          "handleInfo": ["u_buffer1", 2, 14]
        },
        "u_buffer0": {
          "type": 16,
          "value": [640, 960, 0.5, 0]
        },
        "u_buffer1": {
          "type": 16,
          "value": [200, 500, 320, 480]
        }
      }
    }]
  }],
  "shaders": [{
    "name": "splash-screen|splash-screen-vs:vert|splash-screen-fs:frag",
    "hash": 1349506124,
    "builtins": {
      "statistics": {
        "CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS": 6,
        "CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS": 0
      },
      "globals": {
        "blocks": [],
        "samplerTextures": []
      },
      "locals": {
        "blocks": [],
        "samplerTextures": []
      }
    },
    "defines": [],
    "blocks": [{
      "name": "Constant",
      "defines": [],
      "binding": 0,
      "stageFlags": 1,
      "members": [{
        "name": "u_buffer0",
        "type": 16,
        "count": 1
      }, {
        "name": "u_buffer1",
        "type": 16,
        "count": 1
      }, {
        "name": "u_projection",
        "type": 25,
        "count": 1
      }]
    }],
    "samplerTextures": [{
      "name": "mainTexture",
      "type": 28,
      "count": 1,
      "defines": [],
      "stageFlags": 16,
      "binding": 1
    }],
    "attributes": [{
      "name": "a_position",
      "type": 14,
      "count": 1,
      "defines": [],
      "stageFlags": 1,
      "format": 21,
      "location": 0
    }, {
      "name": "a_texCoord",
      "type": 14,
      "count": 1,
      "defines": [],
      "stageFlags": 1,
      "format": 21,
      "location": 1
    }]
  }]
}];

var _type2reader, _type2writer;
var dtMask = 0xf0000000;
var typeMask = 0x0fc00000;
var setMask = 0x00300000;
var bindingMask = 0x000fc000;
var offsetMask = 0x00003fff;

(function (PropertyType) {
  PropertyType[PropertyType["BUFFER"] = 0] = "BUFFER";
  PropertyType[PropertyType["TEXTURE"] = 1] = "TEXTURE";
})(exports.PropertyType || (exports.PropertyType = {}));

var genHandle = function genHandle(pt, set, binding, type, offset) {
  if (offset === void 0) {
    offset = 0;
  }

  return pt << 28 & dtMask | type << 22 & typeMask | set << 20 & setMask | binding << 14 & bindingMask | offset & offsetMask;
};
var getPropertyTypeFromHandle = function getPropertyTypeFromHandle(handle) {
  return (handle & dtMask) >>> 28;
};
var getTypeFromHandle = function getTypeFromHandle(handle) {
  return (handle & typeMask) >>> 22;
};
var getSetIndexFromHandle = function getSetIndexFromHandle(handle) {
  return (handle & setMask) >>> 20;
};
var getBindingFromHandle = function getBindingFromHandle(handle) {
  return (handle & bindingMask) >>> 14;
};
var getOffsetFromHandle = function getOffsetFromHandle(handle) {
  return handle & offsetMask;
};
var customizeType = function customizeType(handle, type) {
  return handle & ~typeMask | type << 22 & typeMask;
};
var type2reader = (_type2reader = {}, _type2reader[exports.Type.UNKNOWN] = function (a, v, idx) {

  return console.warn('illegal uniform handle');
}, _type2reader[exports.Type.INT] = function (a, v, idx) {
  if (idx === void 0) {
    idx = 0;
  }

  return a[idx];
}, _type2reader[exports.Type.INT2] = function (a, v, idx) {
  if (idx === void 0) {
    idx = 0;
  }

  return Vec2.fromArray(v, a, idx);
}, _type2reader[exports.Type.INT3] = function (a, v, idx) {
  if (idx === void 0) {
    idx = 0;
  }

  return Vec3.fromArray(v, a, idx);
}, _type2reader[exports.Type.INT4] = function (a, v, idx) {
  if (idx === void 0) {
    idx = 0;
  }

  return Vec4.fromArray(v, a, idx);
}, _type2reader[exports.Type.FLOAT] = function (a, v, idx) {
  if (idx === void 0) {
    idx = 0;
  }

  return a[idx];
}, _type2reader[exports.Type.FLOAT2] = function (a, v, idx) {
  if (idx === void 0) {
    idx = 0;
  }

  return Vec2.fromArray(v, a, idx);
}, _type2reader[exports.Type.FLOAT3] = function (a, v, idx) {
  if (idx === void 0) {
    idx = 0;
  }

  return Vec3.fromArray(v, a, idx);
}, _type2reader[exports.Type.FLOAT4] = function (a, v, idx) {
  if (idx === void 0) {
    idx = 0;
  }

  return Vec4.fromArray(v, a, idx);
}, _type2reader[exports.Type.MAT3] = function (a, v, idx) {
  if (idx === void 0) {
    idx = 0;
  }

  return Mat3.fromArray(v, a, idx);
}, _type2reader[exports.Type.MAT4] = function (a, v, idx) {
  if (idx === void 0) {
    idx = 0;
  }

  return Mat4.fromArray(v, a, idx);
}, _type2reader);
var type2writer = (_type2writer = {}, _type2writer[exports.Type.UNKNOWN] = function (a, v, idx) {

  return console.warn('illegal uniform handle');
}, _type2writer[exports.Type.INT] = function (a, v, idx) {
  if (idx === void 0) {
    idx = 0;
  }

  return a[idx] = v;
}, _type2writer[exports.Type.INT2] = function (a, v, idx) {
  if (idx === void 0) {
    idx = 0;
  }

  return Vec2.toArray(a, v, idx);
}, _type2writer[exports.Type.INT3] = function (a, v, idx) {
  if (idx === void 0) {
    idx = 0;
  }

  return Vec3.toArray(a, v, idx);
}, _type2writer[exports.Type.INT4] = function (a, v, idx) {
  if (idx === void 0) {
    idx = 0;
  }

  return Vec4.toArray(a, v, idx);
}, _type2writer[exports.Type.FLOAT] = function (a, v, idx) {
  if (idx === void 0) {
    idx = 0;
  }

  return a[idx] = v;
}, _type2writer[exports.Type.FLOAT2] = function (a, v, idx) {
  if (idx === void 0) {
    idx = 0;
  }

  return Vec2.toArray(a, v, idx);
}, _type2writer[exports.Type.FLOAT3] = function (a, v, idx) {
  if (idx === void 0) {
    idx = 0;
  }

  return Vec3.toArray(a, v, idx);
}, _type2writer[exports.Type.FLOAT4] = function (a, v, idx) {
  if (idx === void 0) {
    idx = 0;
  }

  return Vec4.toArray(a, v, idx);
}, _type2writer[exports.Type.MAT3] = function (a, v, idx) {
  if (idx === void 0) {
    idx = 0;
  }

  return Mat3.toArray(a, v, idx);
}, _type2writer[exports.Type.MAT4] = function (a, v, idx) {
  if (idx === void 0) {
    idx = 0;
  }

  return Mat4.toArray(a, v, idx);
}, _type2writer);
var defaultValues = [Object.freeze([0]), Object.freeze([0, 0]), Object.freeze([0, 0, 0, 0]), Object.freeze([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1])];
function getDefaultFromType(type) {
  switch (type) {
    case exports.Type.BOOL:
    case exports.Type.INT:
    case exports.Type.UINT:
    case exports.Type.FLOAT:
      return defaultValues[0];

    case exports.Type.BOOL2:
    case exports.Type.INT2:
    case exports.Type.UINT2:
    case exports.Type.FLOAT2:
      return defaultValues[1];

    case exports.Type.BOOL4:
    case exports.Type.INT4:
    case exports.Type.UINT4:
    case exports.Type.FLOAT4:
      return defaultValues[2];

    case exports.Type.MAT4:
      return defaultValues[3];

    case exports.Type.SAMPLER2D:
      return 'default-texture';

    case exports.Type.SAMPLER_CUBE:
      return 'default-cube-texture';
  }

  return defaultValues[0];
}
function overrideMacros(target, source) {
  var entries = Object.entries(source);
  var isDifferent = false;

  for (var i = 0; i < entries.length; i++) {
    if (target[entries[i][0]] !== entries[i][1]) {
      target[entries[i][0]] = entries[i][1];
      isDifferent = true;
    }
  }

  return isDifferent;
}

var _dsLayoutInfo = new DescriptorSetLayoutInfo();

function getBitCount(cnt) {
  return Math.ceil(Math.log2(Math.max(cnt, 2)));
}

function mapDefine(info, def) {
  switch (info.type) {
    case 'boolean':
      return typeof def === 'number' ? def.toString() : def ? '1' : '0';

    case 'string':
      return def !== undefined ? def : info.options[0];

    case 'number':
      return def !== undefined ? def.toString() : info.range[0].toString();

    default:
      console.warn("unknown define type '" + info.type + "'");
      return '-1';
  }
}

function prepareDefines(defs, tDefs) {
  var macros = [];

  for (var i = 0; i < tDefs.length; i++) {
    var tmpl = tDefs[i];
    var name = tmpl.name;
    var v = defs[name];

    var _value = mapDefine(tmpl, v);

    var isDefault = !v || v === '0';
    macros.push({
      name: name,
      value: _value,
      isDefault: isDefault
    });
  }

  return macros;
}

function getShaderInstanceName(name, macros) {
  return name + macros.reduce(function (acc, cur) {
    return cur.isDefault ? acc : acc + "|" + cur.name + cur.value;
  }, '');
}

function insertBuiltinBindings(tmpl, tmplInfo, source, type, outBindings) {
  var target = tmpl.builtins[type];
  var tempBlocks = [];

  var _loop = function _loop(i) {
    var b = target.blocks[i];
    var info = source.layouts[b.name];
    var binding = info && source.bindings.find(function (bd) {
      return bd.binding === info.binding;
    });

    if (!info || !binding || !(binding.descriptorType & DESCRIPTOR_BUFFER_TYPE)) {
      console.warn("builtin UBO '" + b.name + "' not available!");
      return "continue";
    }

    tempBlocks.push(info);
    if (outBindings && !outBindings.includes(binding)) outBindings.push(binding);
  };

  for (var i = 0; i < target.blocks.length; i++) {
    var _ret = _loop(i);

    if (_ret === "continue") continue;
  }

  Array.prototype.unshift.apply(tmplInfo.gfxBlocks, tempBlocks);
  var tempSamplerTextures = [];

  var _loop2 = function _loop2(_i) {
    var s = target.samplerTextures[_i];
    var info = source.layouts[s.name];
    var binding = info && source.bindings.find(function (bd) {
      return bd.binding === info.binding;
    });

    if (!info || !binding || !(binding.descriptorType & DESCRIPTOR_SAMPLER_TYPE)) {
      console.warn("builtin samplerTexture '" + s.name + "' not available!");
      return "continue";
    }

    tempSamplerTextures.push(info);
    if (outBindings && !outBindings.includes(binding)) outBindings.push(binding);
  };

  for (var _i = 0; _i < target.samplerTextures.length; _i++) {
    var _ret2 = _loop2(_i);

    if (_ret2 === "continue") continue;
  }

  Array.prototype.unshift.apply(tmplInfo.gfxSamplerTextures, tempSamplerTextures);
  if (outBindings) outBindings.sort(function (a, b) {
    return a.binding - b.binding;
  });
}

function getSize(block) {
  return block.members.reduce(function (s, m) {
    return s + GetTypeSize(m.type) * m.count;
  }, 0);
}

function genHandles(tmpl) {
  var handleMap = {};

  for (var i = 0; i < tmpl.blocks.length; i++) {
    var block = tmpl.blocks[i];
    var members = block.members;
    var offset = 0;

    for (var j = 0; j < members.length; j++) {
      var uniform = members[j];
      handleMap[uniform.name] = genHandle(exports.PropertyType.BUFFER, exports.SetIndex.MATERIAL, block.binding, uniform.type, offset);
      offset += (GetTypeSize(uniform.type) >> 2) * uniform.count;
    }
  }

  for (var _i2 = 0; _i2 < tmpl.samplerTextures.length; _i2++) {
    var samplerTexture = tmpl.samplerTextures[_i2];
    handleMap[samplerTexture.name] = genHandle(exports.PropertyType.TEXTURE, exports.SetIndex.MATERIAL, samplerTexture.binding, samplerTexture.type);
  }

  return handleMap;
}

function dependencyCheck(dependencies, defines) {
  for (var i = 0; i < dependencies.length; i++) {
    var d = dependencies[i];

    if (d[0] === '!') {
      if (defines[d.slice(1)]) {
        return false;
      }
    } else if (!defines[d]) {
      return false;
    }
  }

  return true;
}

function getActiveAttributes(tmpl, tmplInfo, defines) {
  var out = [];
  var attributes = tmpl.attributes;
  var gfxAttributes = tmplInfo.gfxAttributes;

  for (var i = 0; i < attributes.length; i++) {
    if (!dependencyCheck(attributes[i].defines, defines)) {
      continue;
    }

    out.push(gfxAttributes[i]);
  }

  return out;
}

var ProgramLib = function () {
  function ProgramLib() {
    this._templates = {};
    this._cache = {};
    this._templateInfos = {};
  }

  var _proto = ProgramLib.prototype;

  _proto.register = function register(effect) {
    for (var i = 0; i < effect.shaders.length; i++) {
      var tmpl = this.define(effect.shaders[i]);
      tmpl.effectName = effect.name;
    }
  };

  _proto.define = function define(shader) {
    var curTmpl = this._templates[shader.name];

    if (curTmpl && curTmpl.hash === shader.hash) {
      return curTmpl;
    }

    var tmpl = _extends({}, shader);

    var offset = 0;

    var _loop3 = function _loop3(i) {
      var def = tmpl.defines[i];
      var cnt = 1;

      if (def.type === 'number') {
        var range = def.range;
        cnt = getBitCount(range[1] - range[0] + 1);

        def._map = function (value) {
          return value - range[0];
        };
      } else if (def.type === 'string') {
        cnt = getBitCount(def.options.length);

        def._map = function (value) {
          return Math.max(0, def.options.findIndex(function (s) {
            return s === value;
          }));
        };
      } else if (def.type === 'boolean') {
        def._map = function (value) {
          return value ? 1 : 0;
        };
      }

      def._offset = offset;
      offset += cnt;
    };

    for (var i = 0; i < tmpl.defines.length; i++) {
      _loop3(i);
    }

    if (offset > 31) {
      tmpl.uber = true;
    }

    tmpl.constantMacros = '';

    for (var key in tmpl.builtins.statistics) {
      tmpl.constantMacros += "#define " + key + " " + tmpl.builtins.statistics[key] + "\n";
    }

    this._templates[shader.name] = tmpl;

    if (!this._templateInfos[tmpl.hash]) {
      var tmplInfo = {};
      tmplInfo.samplerStartBinding = tmpl.blocks.length;
      tmplInfo.gfxBlocks = [];
      tmplInfo.gfxSamplerTextures = [];
      tmplInfo.bindings = [];
      tmplInfo.blockSizes = [];

      for (var _i3 = 0; _i3 < tmpl.blocks.length; _i3++) {
        var block = tmpl.blocks[_i3];
        tmplInfo.blockSizes.push(getSize(block));
        tmplInfo.bindings.push(new DescriptorSetLayoutBinding(block.binding, block.descriptorType || exports.DescriptorType.UNIFORM_BUFFER, 1, block.stageFlags));
        tmplInfo.gfxBlocks.push(new UniformBlock(exports.SetIndex.MATERIAL, block.binding, block.name, block.members.map(function (m) {
          return new Uniform(m.name, m.type, m.count);
        }), 1));
      }

      for (var _i4 = 0; _i4 < tmpl.samplerTextures.length; _i4++) {
        var samplerTexture = tmpl.samplerTextures[_i4];
        tmplInfo.bindings.push(new DescriptorSetLayoutBinding(samplerTexture.binding, samplerTexture.descriptorType || exports.DescriptorType.SAMPLER_TEXTURE, samplerTexture.count, samplerTexture.stageFlags));
        tmplInfo.gfxSamplerTextures.push(new UniformSamplerTexture(exports.SetIndex.MATERIAL, samplerTexture.binding, samplerTexture.name, samplerTexture.type, samplerTexture.count));
      }

      tmplInfo.gfxAttributes = [];

      for (var _i5 = 0; _i5 < tmpl.attributes.length; _i5++) {
        var attr = tmpl.attributes[_i5];
        tmplInfo.gfxAttributes.push(new Attribute(attr.name, attr.format, attr.isNormalized, 0, attr.isInstanced, attr.location));
      }

      insertBuiltinBindings(tmpl, tmplInfo, localDescriptorSetLayout, 'locals');
      tmplInfo.gfxStages = [];
      tmplInfo.gfxStages.push(new ShaderStage(exports.ShaderStageFlagBit.VERTEX, ''));
      tmplInfo.gfxStages.push(new ShaderStage(exports.ShaderStageFlagBit.FRAGMENT, ''));
      tmplInfo.handleMap = genHandles(tmpl);
      tmplInfo.setLayouts = [];
      this._templateInfos[tmpl.hash] = tmplInfo;
    }

    return tmpl;
  };

  _proto.getTemplate = function getTemplate(name) {
    return this._templates[name];
  };

  _proto.getTemplateInfo = function getTemplateInfo(name) {
    var hash = this._templates[name].hash;
    return this._templateInfos[hash];
  };

  _proto.getDescriptorSetLayout = function getDescriptorSetLayout(device, name, isLocal) {
    if (isLocal === void 0) {
      isLocal = false;
    }

    var tmpl = this._templates[name];
    var tmplInfo = this._templateInfos[tmpl.hash];

    if (!tmplInfo.setLayouts.length) {
      _dsLayoutInfo.bindings = tmplInfo.bindings;
      tmplInfo.setLayouts[exports.SetIndex.MATERIAL] = device.createDescriptorSetLayout(_dsLayoutInfo);
      _dsLayoutInfo.bindings = localDescriptorSetLayout.bindings;
      tmplInfo.setLayouts[exports.SetIndex.LOCAL] = device.createDescriptorSetLayout(_dsLayoutInfo);
    }

    return tmplInfo.setLayouts[isLocal ? exports.SetIndex.LOCAL : exports.SetIndex.MATERIAL];
  };

  _proto.hasProgram = function hasProgram(name) {
    return this._templates[name] !== undefined;
  };

  _proto.getKey = function getKey(name, defines) {
    var tmpl = this._templates[name];
    var tmplDefs = tmpl.defines;

    if (tmpl.uber) {
      var _key = '';

      for (var i = 0; i < tmplDefs.length; i++) {
        var tmplDef = tmplDefs[i];
        var _value2 = defines[tmplDef.name];

        if (!_value2 || !tmplDef._map) {
          continue;
        }

        var mapped = tmplDef._map(_value2);

        var offset = tmplDef._offset;
        _key += "" + offset + mapped + "|";
      }

      return "" + _key + tmpl.hash;
    }

    var key = 0;

    for (var _i6 = 0; _i6 < tmplDefs.length; _i6++) {
      var _tmplDef = tmplDefs[_i6];
      var _value3 = defines[_tmplDef.name];

      if (!_value3 || !_tmplDef._map) {
        continue;
      }

      var _mapped = _tmplDef._map(_value3);

      var _offset = _tmplDef._offset;
      key |= _mapped << _offset;
    }

    return key.toString(16) + "|" + tmpl.hash;
  };

  _proto.destroyShaderByDefines = function destroyShaderByDefines(defines) {
    var _this = this;

    var names = Object.keys(defines);

    if (!names.length) {
      return;
    }

    var regexes = names.map(function (cur) {
      var val = defines[cur];

      if (typeof val === 'boolean') {
        val = val ? '1' : '0';
      }

      return new RegExp("" + cur + val);
    });
    var keys = Object.keys(this._cache).filter(function (k) {
      return regexes.every(function (re) {
        return re.test(_this._cache[k].name);
      });
    });

    for (var i = 0; i < keys.length; i++) {
      var k = keys[i];
      var prog = this._cache[k];
      debug("destroyed shader " + prog.name);
      prog.destroy();
      delete this._cache[k];
    }
  };

  _proto.getGFXShader = function getGFXShader(device, name, defines, pipeline, key) {
    Object.assign(defines, pipeline.macros);
    if (!key) key = this.getKey(name, defines);
    var res = this._cache[key];

    if (res) {
      return res;
    }

    var tmpl = this._templates[name];
    var tmplInfo = this._templateInfos[tmpl.hash];

    if (!tmplInfo.pipelineLayout) {
      this.getDescriptorSetLayout(device, name);
      insertBuiltinBindings(tmpl, tmplInfo, globalDescriptorSetLayout, 'globals');
      tmplInfo.setLayouts[exports.SetIndex.GLOBAL] = pipeline.descriptorSetLayout;
      tmplInfo.pipelineLayout = device.createPipelineLayout(new PipelineLayoutInfo(tmplInfo.setLayouts));
    }

    var macroArray = prepareDefines(defines, tmpl.defines);
    var prefix = pipeline.constantMacros + tmpl.constantMacros + macroArray.reduce(function (acc, cur) {
      return acc + "#define " + cur.name + " " + cur.value + "\n";
    }, '');
    var src = tmpl.glsl3;
    var deviceShaderVersion = getDeviceShaderVersion(device);

    if (deviceShaderVersion) {
      src = tmpl[deviceShaderVersion];
    } else {
      console.error('Invalid GFX API!');
    }

    tmplInfo.gfxStages[0].source = prefix + src.vert;
    tmplInfo.gfxStages[1].source = prefix + src.frag;
    var attributes = getActiveAttributes(tmpl, tmplInfo, defines);
    var instanceName = getShaderInstanceName(name, macroArray);
    var shaderInfo = new ShaderInfo(instanceName, tmplInfo.gfxStages, attributes, tmplInfo.gfxBlocks);
    shaderInfo.samplerTextures = tmplInfo.gfxSamplerTextures;
    return this._cache[key] = device.createShader(shaderInfo);
  };

  return ProgramLib;
}();

function getDeviceShaderVersion(device) {
  switch (device.gfxAPI) {
    case exports.API.GLES2:
    case exports.API.WEBGL:
      return 'glsl1';

    case exports.API.GLES3:
    case exports.API.WEBGL2:
      return 'glsl3';

    default:
      return 'glsl4';
  }
}
var programLib = new ProgramLib();
legacyCC.programLib = programLib;

var glsl1 = [[{
  "vert": "\nprecision mediump float;\nuniform highp mat4 cc_matView;\nuniform highp mat4 cc_matViewInv;\nuniform highp mat4 cc_matViewProj;\nuniform highp mat4 cc_matWorld;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\nmat3 m = mat3(xAxis,yAxis,zAxis);\nfloat trace = m[0][0] + m[1][1] + m[2][2];\nvec4 quat;\nif (trace > 0.) {\nfloat s = 0.5 / sqrt(trace + 1.0);\nquat.w = 0.25 / s;\nquat.x = (m[2][1] - m[1][2]) * s;\nquat.y = (m[0][2] - m[2][0]) * s;\nquat.z = (m[1][0] - m[0][1]) * s;\n} else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\nfloat s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\nquat.w = (m[2][1] - m[1][2]) / s;\nquat.x = 0.25 * s;\nquat.y = (m[0][1] + m[1][0]) / s;\nquat.z = (m[0][2] + m[2][0]) / s;\n} else if (m[1][1] > m[2][2]) {\nfloat s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\nquat.w = (m[0][2] - m[2][0]) / s;\nquat.x = (m[0][1] + m[1][0]) / s;\nquat.y = 0.25 * s;\nquat.z = (m[1][2] + m[2][1]) / s;\n} else {\nfloat s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\nquat.w = (m[1][0] - m[0][1]) / s;\nquat.x = (m[0][2] + m[2][0]) / s;\nquat.y = (m[1][2] + m[2][1]) / s;\nquat.z = 0.25 * s;\n}\nfloat len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\nif (len > 0.) {\nlen = 1. / sqrt(len);\nquat.x = quat.x * len;\nquat.y = quat.y * len;\nquat.z = quat.z * len;\nquat.w = quat.w * len;\n}\nreturn quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\nfloat x = angle.x / 2.;\nfloat y = angle.y / 2.;\nfloat z = angle.z / 2.;\nfloat sx = sin(x);\nfloat cx = cos(x);\nfloat sy = sin(y);\nfloat cy = cos(y);\nfloat sz = sin(z);\nfloat cz = cos(z);\nvec4 quat = vec4(0);\nquat.x = sx * cy * cz + cx * sy * sz;\nquat.y = cx * sy * cz + sx * cy * sz;\nquat.z = cx * cy * sz - sx * sy * cz;\nquat.w = cx * cy * cz - sx * sy * sz;\nreturn quat;\n}\nvec4 quatMultiply (vec4 a, vec4 b){\nvec4 quat;\nquat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\nquat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\nquat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\nquat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\nreturn quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\nfloat ix = q.w * v.x + q.y * v.z - q.z * v.y;\nfloat iy = q.w * v.y + q.z * v.x - q.x * v.z;\nfloat iz = q.w * v.z + q.x * v.y - q.y * v.x;\nfloat iw = -q.x * v.x - q.y * v.y - q.z * v.z;\nv.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\nv.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\nv.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\nvec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\nvec4 rotQuat = quatMultiply(viewQuat, q);\nrotateVecFromQuat(pos, rotQuat);\nreturn pos;\n}\nvarying mediump vec2 uv;\nvarying mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n, mat4 viewInv\n) {\nvec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\nvec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\nvec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\nvec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\npos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n}\nattribute vec3 a_position;\nattribute vec2 a_texCoord;\nattribute vec4 a_color;\nuniform vec4 cc_size_rotation;\nvec4 vs_main() {\nvec4 pos = vec4(a_position, 1);\npos = cc_matWorld * pos;\nvec2 vertOffset = a_texCoord.xy - 0.5;\ncomputeVertPos(pos, vertOffset, quaternionFromEuler(vec3(0., 0., cc_size_rotation.z)), vec3(cc_size_rotation.xy, 0.), cc_matViewInv);\npos = cc_matViewProj * pos;\nuv = a_texCoord.xy;\ncolor = a_color;\nreturn pos;\n}\nvoid main() { gl_Position = vs_main(); }",
  "frag": "\nprecision mediump float;\nuniform mediump vec4 cc_exposure;\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n#if CC_USE_HDR\ncolor.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n#endif\nreturn color;\n}\nvarying vec2 uv;\nvarying vec4 color;\nuniform sampler2D mainTexture;\nuniform vec4 tintColor;\nvec4 add () {\nvec4 col = 2.0 * color * tintColor * texture2D(mainTexture, uv);\nreturn CCFragOutput(col);\n}\nvoid main() { gl_FragColor = add(); }"
}], [{
  "vert": "\nprecision highp float;\nattribute vec3 a_position;\nvec4 vert () {\nvec4 pos = vec4(a_position, 1);\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",
  "frag": "\nprecision highp float;\nvec4 frag () {\nvec4 o = vec4(1.0);\nreturn o;\n}\nvoid main() { gl_FragColor = frag(); }"
}], [{
  "vert": "\nprecision highp float;\nuniform highp mat4 cc_matViewProj;\nuniform highp mat4 cc_matWorld;\nattribute vec3 a_position;\nattribute vec4 a_color;\nvarying vec4 v_color;\nattribute float a_dist;\nvarying float v_dist;\nvec4 vert () {\nvec4 pos = vec4(a_position, 1);\npos = cc_matViewProj * cc_matWorld * pos;\nv_color = a_color;\nv_dist = a_dist;\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",
  "frag": "\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives: enable\n#endif\nprecision highp float;\nvarying vec4 v_color;\nvarying float v_dist;\nvec4 frag () {\nvec4 o = v_color;\n#ifdef GL_OES_standard_derivatives\nfloat aa = fwidth(v_dist);\n#else\nfloat aa = 0.05;\n#endif\nfloat alpha = 1. - smoothstep(-aa, 0., abs(v_dist) - 1.0);\no.rgb *= o.a;\no *= alpha;\nreturn o;\n}\nvoid main() { gl_FragColor = frag(); }"
}], [{
  "vert": "\nprecision mediump float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\nmat3 m = mat3(xAxis,yAxis,zAxis);\nfloat trace = m[0][0] + m[1][1] + m[2][2];\nvec4 quat;\nif (trace > 0.) {\nfloat s = 0.5 / sqrt(trace + 1.0);\nquat.w = 0.25 / s;\nquat.x = (m[2][1] - m[1][2]) * s;\nquat.y = (m[0][2] - m[2][0]) * s;\nquat.z = (m[1][0] - m[0][1]) * s;\n} else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\nfloat s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\nquat.w = (m[2][1] - m[1][2]) / s;\nquat.x = 0.25 * s;\nquat.y = (m[0][1] + m[1][0]) / s;\nquat.z = (m[0][2] + m[2][0]) / s;\n} else if (m[1][1] > m[2][2]) {\nfloat s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\nquat.w = (m[0][2] - m[2][0]) / s;\nquat.x = (m[0][1] + m[1][0]) / s;\nquat.y = 0.25 * s;\nquat.z = (m[1][2] + m[2][1]) / s;\n} else {\nfloat s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\nquat.w = (m[1][0] - m[0][1]) / s;\nquat.x = (m[0][2] + m[2][0]) / s;\nquat.y = (m[1][2] + m[2][1]) / s;\nquat.z = 0.25 * s;\n}\nfloat len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\nif (len > 0.) {\nlen = 1. / sqrt(len);\nquat.x = quat.x * len;\nquat.y = quat.y * len;\nquat.z = quat.z * len;\nquat.w = quat.w * len;\n}\nreturn quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\nfloat x2 = q.x + q.x;\nfloat y2 = q.y + q.y;\nfloat z2 = q.z + q.z;\nfloat xx = q.x * x2;\nfloat xy = q.x * y2;\nfloat xz = q.x * z2;\nfloat yy = q.y * y2;\nfloat yz = q.y * z2;\nfloat zz = q.z * z2;\nfloat wx = q.w * x2;\nfloat wy = q.w * y2;\nfloat wz = q.w * z2;\nreturn mat4(\n1. - (yy + zz), xy + wz, xz - wy, 0,\nxy - wz, 1. - (xx + zz), yz + wx, 0,\nxz + wy, yz - wx, 1. - (xx + yy), 0,\np.x, p.y, p.z, 1\n);\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\nfloat x = q.x, y = q.y, z = q.z, w = q.w;\nfloat x2 = x + x;\nfloat y2 = y + y;\nfloat z2 = z + z;\nfloat xx = x * x2;\nfloat xy = x * y2;\nfloat xz = x * z2;\nfloat yy = y * y2;\nfloat yz = y * z2;\nfloat zz = z * z2;\nfloat wx = w * x2;\nfloat wy = w * y2;\nfloat wz = w * z2;\nfloat sx = s.x;\nfloat sy = s.y;\nfloat sz = s.z;\nreturn mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n(xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n(xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\nt.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\nvec4 quat;\nquat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\nquat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\nquat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\nquat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\nreturn quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\nfloat ix = q.w * v.x + q.y * v.z - q.z * v.y;\nfloat iy = q.w * v.y + q.z * v.x - q.x * v.z;\nfloat iz = q.w * v.z + q.x * v.y - q.y * v.x;\nfloat iw = -q.x * v.x - q.y * v.y - q.z * v.z;\nv.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\nv.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\nv.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\nvec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\nvec4 rotQuat = quatMultiply(viewQuat, q);\nrotateVecFromQuat(pos, rotQuat);\nreturn pos;\n}\nuniform vec4 mainTiling_Offset;\nuniform vec4 frameTile_velLenScale;\nuniform vec4 scale;\nuniform highp mat4 cc_matView;\nuniform highp mat4 cc_matViewInv;\nuniform highp mat4 cc_matViewProj;\nuniform highp vec4 cc_cameraPos;\nuniform highp mat4 cc_matWorld;\nvarying mediump vec2 uv;\nvarying mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n, mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n, vec3 eye\n, vec4 velocity\n, float velocityScale\n, float lengthScale\n, float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\nvec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\nvec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\nvec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\nvec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\npos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\nvec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\nvec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\npos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\nvec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\nvec3 camX = vec3(1, 0, 0);\nvec3 camY = vec3(0, 0, -1);\npos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\nvec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\nrotateVecFromQuat(viewSpaceVert, q);\nvec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\nvec3 camY = vec3(0, 1, 0);\nvec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\npos.xyz += offset;\n#else\npos.x += vertOffset.x;\npos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\nvec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\naniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\nvertIndex.y = 1. - vertIndex.y;\n#endif\nreturn (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nuniform vec4 u_sampleInfo;\nuniform vec4 u_worldRot;\nuniform vec4 u_timeDelta;\nattribute vec4 a_position_starttime;\nattribute vec4 a_size_uv;\nattribute vec4 a_rotation_uv;\nattribute vec4 a_color;\nattribute vec4 a_dir_life;\nattribute float a_rndSeed;\n#if CC_RENDER_MODE == 4\nattribute vec3 a_texCoord;\nattribute vec3 a_texCoord3;\nattribute vec3 a_normal;\nattribute vec4 a_color1;\n#endif\nvec3 unpackCurveData (sampler2D tex, vec2 coord) {\nvec4 a = texture2D(tex, coord);\nvec4 b = texture2D(tex, coord + u_sampleInfo.y);\nfloat c = fract(coord.x * u_sampleInfo.x);\nreturn mix(a.xyz, b.xyz, c);\n}\nvec3 unpackCurveData (sampler2D tex, vec2 coord, out float w) {\nvec4 a = texture2D(tex, coord);\nvec4 b = texture2D(tex, coord + u_sampleInfo.y);\nfloat c = fract(coord.x * u_sampleInfo.x);\nw = mix(a.w, b.w, c);\nreturn mix(a.xyz, b.xyz, c);\n}\nfloat pseudoRandom (float seed) {\nseed = mod(seed, 233280.);\nfloat q = (seed * 9301. + 49297.) / 233280.;\nreturn fract(q);\n}\n#if COLOR_OVER_TIME_MODULE_ENABLE\nuniform sampler2D color_over_time_tex0;\nuniform int u_color_mode;\n#endif\n#if ROTATION_OVER_TIME_MODULE_ENABLE\nuniform sampler2D rotation_over_time_tex0;\nuniform int u_rotation_mode;\n#endif\n#if SIZE_OVER_TIME_MODULE_ENABLE\nuniform sampler2D size_over_time_tex0;\nuniform int u_size_mode;\n#endif\n#if FORCE_OVER_TIME_MODULE_ENABLE\nuniform sampler2D force_over_time_tex0;\nuniform int u_force_mode;\nuniform int u_force_space;\n#endif\n#if VELOCITY_OVER_TIME_MODULE_ENABLE\nuniform sampler2D velocity_over_time_tex0;\nuniform int u_velocity_mode;\nuniform int u_velocity_space;\n#endif\n#if TEXTURE_ANIMATION_MODULE_ENABLE\nuniform sampler2D texture_animation_tex0;\nuniform vec4 u_anim_info;\n#endif\nfloat repeat (float t, float length) {\nreturn t - floor(t / length) * length;\n}\nvec4 rotateQuat (vec4 p, vec4 q) {\nvec3 iv = cross(q.xyz, p.xyz) + q.w * p.xyz;\nvec3 res = p.xyz + 2.0 * cross(q.xyz, iv);\nreturn vec4(res.xyz, p.w);\n}\nvec4 toQuat(vec3 rotation) {\nvec3 rotTmp = rotation;\nfloat mulFactor = 1.0;\nif (rotTmp.x > 10.0 * 0.5) {\nrotTmp.x -= 10.0;\nmulFactor = -1.0;\n}\nvec4 rot = vec4(rotTmp, 0.0);\nrot.w = mulFactor * sqrt(1.0 - rot.x * rot.x - rot.y * rot.y - rot.z * rot.z);\nreturn rot;\n}\nmat3 QuatToMat3(vec4 q) {\nvec3 m0 = vec3(\n1.0 - 2.0 * q.y * q.y - 2.0 * q.z * q.z,\n2.0 * q.x * q.y + 2.0 * q.w * q.z,\n2.0 * q.x * q.z - 2.0 * q.w * q.y);\nvec3 m1 = vec3(\n2.0 * q.x * q.y - 2.0 * q.w * q.z,\n1.0 - 2.0 * q.x * q.x - 2.0 * q.z * q.z,\n2.0 * q.y * q.z + 2.0 * q.w * q.x);\nvec3 m2 = vec3(\n2.0 * q.x * q.z + 2.0 * q.w * q.y,\n2.0 * q.y * q.z - 2.0 * q.w * q.x,\n1.0 - 2.0 * q.x * q.x - 2.0 * q.y * q.y);\nreturn mat3(m0, m1, m2);\n}\nvec4 Mat3ToQuat(mat3 mat) {\nfloat tr = mat[0][0] + mat[1][1] + mat[2][2];\nfloat qw, qx, qy, qz;\nif (tr > 0.0) {\nfloat S = sqrt(tr + 1.0) * 2.0;\nfloat invS = 1.0 / S;\nqw = 0.25 * S;\nqx = (mat[1][2] - mat[2][1]) * invS;\nqy = (mat[2][0] - mat[0][2]) * invS;\nqz = (mat[0][1] - mat[1][0]) * invS;\n} else if ((mat[0][0] > mat[1][1])&&(mat[0][0] > mat[2][2])) {\nfloat S = sqrt(1.0 + mat[0][0] - mat[1][1] - mat[2][2]) * 2.0;\nfloat invS = 1.0 / S;\nqw = (mat[1][2] - mat[2][1]) * invS;\nqx = 0.25 * S;\nqy = (mat[1][0] + mat[0][1]) * invS;\nqz = (mat[2][0] + mat[0][2]) * invS;\n} else if (mat[1][1] > mat[2][2]) {\nfloat S = sqrt(1.0 + mat[1][1] - mat[0][0] - mat[2][2]) * 2.0;\nfloat invS = 1.0 / S;\nqw = (mat[2][0] - mat[0][2]) * invS;\nqx = (mat[1][0] + mat[0][1]) * invS;\nqy = 0.25 * S;\nqz = (mat[2][1] + mat[1][2]) * invS;\n} else {\nfloat S = sqrt(1.0 + mat[2][2] - mat[0][0] - mat[1][1]) * 2.0;\nfloat invS = 1.0 / S;\nqw = (mat[0][1] - mat[1][0]) * invS;\nqx = (mat[2][0] + mat[0][2]) * invS;\nqy = (mat[2][1] + mat[1][2]) * invS;\nqz = 0.25 * S;\n}\nreturn vec4(qx, qy, qz, qw);\n}\nvec4 EulerToQuat(vec3 euler) {\nvec3 er = euler * 0.5;\nfloat x = er.x, y = er.y, z = er.z;\nfloat sx = sin(x);\nfloat cx = cos(x);\nfloat sy = sin(y);\nfloat cy = cos(y);\nfloat sz = sin(z);\nfloat cz = cos(z);\nvec4 quat;\nquat.x = sx * cy * cz + cx * sy * sz;\nquat.y = cx * sy * cz + sx * cy * sz;\nquat.z = cx * cy * sz - sx * sy * cz;\nquat.w = cx * cy * cz - sx * sy * sz;\nreturn quat;\n}\nvec4 gpvs_main () {\nfloat activeTime = u_timeDelta.x - a_position_starttime.w;\nfloat normalizedTime = clamp(activeTime / a_dir_life.w, 0.0, 1.0);\nvec2 timeCoord0 = vec2(normalizedTime, 0.);\nvec2 timeCoord1 = vec2(normalizedTime, 1.);\n#if CC_RENDER_MODE == 4\nvec2 vertIdx = vec2(a_texCoord.x, a_texCoord.y);\n#else\nvec2 vertIdx = vec2(a_size_uv.w, a_rotation_uv.w);\n#endif\nvec4 velocity = vec4(a_dir_life.xyz, 0.);\nvec4 pos = vec4(a_position_starttime.xyz, 1.);\nvec3 size = a_size_uv.xyz;\n#if SIZE_OVER_TIME_MODULE_ENABLE\nif (u_size_mode == 1) {\nsize *= unpackCurveData(size_over_time_tex0, timeCoord0);\n} else {\nvec3 size_0 = unpackCurveData(size_over_time_tex0, timeCoord0);\nvec3 size_1 = unpackCurveData(size_over_time_tex0, timeCoord1);\nfloat factor_s = pseudoRandom(a_rndSeed + 39825.);\nsize *= mix(size_0, size_1, factor_s);\n}\n#endif\nvec3 compScale = scale.xyz * size;\n#if FORCE_OVER_TIME_MODULE_ENABLE\nvec3 forceAnim = vec3(0.);\nif (u_force_mode == 1) {\nforceAnim = unpackCurveData(force_over_time_tex0, timeCoord0);\n} else {\nvec3 force_0 = unpackCurveData(force_over_time_tex0, timeCoord0);\nvec3 force_1 = unpackCurveData(force_over_time_tex0, timeCoord1);\nfloat factor_f =  pseudoRandom(a_rndSeed + 212165.);\nforceAnim = mix(force_0, force_1, factor_f);\n}\nvec4 forceTrack = vec4(forceAnim, 0.);\nif (u_force_space == 0) {\nforceTrack = rotateQuat(forceTrack, u_worldRot);\n}\nvelocity.xyz += forceTrack.xyz;\n#endif\n#if VELOCITY_OVER_TIME_MODULE_ENABLE\nfloat speedModifier0 = 1.;\nfloat speedModifier1 = 1.;\nvec3 velocityAnim = vec3(0.);\nif (u_velocity_mode == 1) {\nvelocityAnim = unpackCurveData(velocity_over_time_tex0, timeCoord0, speedModifier0);\n} else {\nvec3 vectory_0 = unpackCurveData(velocity_over_time_tex0, timeCoord0, speedModifier0);\nvec3 vectory_1 = unpackCurveData(velocity_over_time_tex0, timeCoord1, speedModifier1);\nfloat factor_v = pseudoRandom(a_rndSeed + 197866.);\nvelocityAnim = mix(vectory_0, vectory_1, factor_v);\nspeedModifier0 = mix(speedModifier0, speedModifier1, factor_v);\n}\nvec4 velocityTrack = vec4(velocityAnim, 0.);\nif (u_velocity_space == 0) {\nvelocityTrack = rotateQuat(velocityTrack, u_worldRot);\n}\nvelocity.xyz += velocityTrack.xyz;\nvelocity.xyz *= speedModifier0;\n#endif\npos.xyz += velocity.xyz * normalizedTime * a_dir_life.w;\n#if !CC_USE_WORLD_SPACE\npos = cc_matWorld * pos;\n#if CC_RENDER_MODE == 1\nvelocity = rotateQuat(velocity, u_worldRot);\n#endif\n#endif\nvec3 startRotation = a_rotation_uv.xyz;\nvec4 rot = toQuat(startRotation);\n#if ROTATION_OVER_TIME_MODULE_ENABLE\nif (u_rotation_mode == 1) {\nvec3 euler = unpackCurveData(rotation_over_time_tex0, timeCoord0) * normalizedTime * a_dir_life.w;\nvec4 quat = EulerToQuat(euler);\nmat3 mLocal = QuatToMat3(quat);\nmat3 mStart = QuatToMat3(rot);\nrot = Mat3ToQuat(mStart * mLocal);\n} else {\nvec3 rotation_0 = unpackCurveData(rotation_over_time_tex0, timeCoord0);\nvec3 rotation_1 = unpackCurveData(rotation_over_time_tex0, timeCoord1);\nfloat factor_r = pseudoRandom(a_rndSeed + 125292.);\nvec3 euler = mix(rotation_0, rotation_1, factor_r) * normalizedTime * a_dir_life.w;\n#if CC_RENDER_MODE == 3 || CC_RENDER_MODE == 2\neuler = vec3(0.0, 0.0, euler.z);\n#endif\nvec4 quat = EulerToQuat(euler);\nmat3 mLocal = QuatToMat3(quat);\nmat3 mStart = QuatToMat3(rot);\nrot = Mat3ToQuat(mStart * mLocal);\n}\n#endif\n#if COLOR_OVER_TIME_MODULE_ENABLE\nif (u_color_mode == 1) {\ncolor = a_color * texture2D(color_over_time_tex0, timeCoord0);\n} else {\nvec4 color_0 = texture2D(color_over_time_tex0, timeCoord0);\nvec4 color_1 = texture2D(color_over_time_tex0, timeCoord1);\nfloat factor_c = pseudoRandom(a_rndSeed + 91041.);\ncolor = a_color * mix(color_0, color_1, factor_c);\n}\n#else\ncolor = a_color;\n#endif\n#if CC_RENDER_MODE != 4\nvec2 cornerOffset = vec2((vertIdx - 0.5));\n#if CC_RENDER_MODE == 1\nrot = vec4(0.0, 0.0, 0.0, 1.0);\n#endif\ncomputeVertPos(pos, cornerOffset, rot, compScale\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n, cc_matViewInv\n#endif\n#if CC_RENDER_MODE == 1\n, cc_cameraPos.xyz\n, velocity\n, frameTile_velLenScale.z\n, frameTile_velLenScale.w\n, a_size_uv.w\n#endif\n);\n#else\nmat4 xformNoScale = matrixFromRT(rot, pos.xyz);\nmat4 xform = matFromRTS(rot, pos.xyz, compScale);\npos = xform * vec4(a_texCoord3, 1);\nvec4 normal = xformNoScale * vec4(a_normal, 0);\ncolor *= a_color1;\n#endif\npos = cc_matViewProj * pos;\nfloat frameIndex = 0.;\n#if TEXTURE_ANIMATION_MODULE_ENABLE\nfloat startFrame = 0.;\nvec3 frameInfo = vec3(0.);\nif (int(u_anim_info.x) == 1) {\nframeInfo = unpackCurveData(texture_animation_tex0, timeCoord0);\n} else {\nvec3 frameInfo0 = unpackCurveData(texture_animation_tex0, timeCoord0);\nvec3 frameInfo1 = unpackCurveData(texture_animation_tex0, timeCoord1);\nfloat factor_t = pseudoRandom(a_rndSeed + 90794.);\nframeInfo = mix(frameInfo0, frameInfo1, factor_t);\n}\nstartFrame = frameInfo.x / u_anim_info.y;\nframeIndex = repeat(u_anim_info.z * (frameInfo.y + startFrame), 1.);\n#endif\nuv = computeUV(frameIndex, vertIdx, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\nreturn pos;\n}\nvoid main() { gl_Position = gpvs_main(); }",
  "frag": "\nprecision mediump float;\nuniform mediump vec4 cc_exposure;\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n#if CC_USE_HDR\ncolor.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n#endif\nreturn color;\n}\nvarying vec2 uv;\nvarying vec4 color;\nuniform sampler2D mainTexture;\nuniform vec4 tintColor;\nvec4 add () {\nvec4 col = 2.0 * color * tintColor * texture2D(mainTexture, uv);\nreturn CCFragOutput(col);\n}\nvoid main() { gl_FragColor = add(); }"
}], [{
  "vert": "\nprecision mediump float;\nuniform vec4 mainTiling_Offset;\nuniform highp mat4 cc_matViewProj;\nuniform highp vec4 cc_cameraPos;\nuniform highp mat4 cc_matWorld;\nvarying mediump vec2 uv;\nvarying mediump vec4 color;\nattribute vec3 a_position;\nattribute vec4 a_texCoord;\nattribute vec3 a_texCoord1;\nattribute vec3 a_texCoord2;\nattribute vec4 a_color;\n#if CC_DRAW_WIRE_FRAME\nvarying vec3 vBarycentric;\n#endif\nvec4 vs_main() {\nhighp vec4 pos = vec4(a_position, 1);\nvec4 velocity = vec4(a_texCoord1.xyz, 0);\n#if !CC_USE_WORLD_SPACE\npos = cc_matWorld * pos;\nvelocity = cc_matWorld * velocity;\n#endif\nfloat vertOffset = (a_texCoord.x - 0.5) * a_texCoord.y;\nvec3 camUp = normalize(cross(pos.xyz - cc_cameraPos.xyz, velocity.xyz));\npos.xyz += camUp * vertOffset;\npos = cc_matViewProj * pos;\nuv = a_texCoord.zw * mainTiling_Offset.xy + mainTiling_Offset.zw;;\ncolor = a_color;\n#if CC_DRAW_WIRE_FRAME\nvBarycentric = a_texCoord2;\n#endif\nreturn pos;\n}\nvoid main() { gl_Position = vs_main(); }",
  "frag": "\nprecision mediump float;\nuniform mediump vec4 cc_exposure;\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n#if CC_USE_HDR\ncolor.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n#endif\nreturn color;\n}\nvarying vec2 uv;\nvarying vec4 color;\n#if CC_DRAW_WIRE_FRAME\nvarying vec3 vBarycentric;\n#endif\nuniform sampler2D mainTexture;\nuniform vec4 tintColor;\nvec4 add () {\nvec4 col = 2.0 * color * tintColor * texture2D(mainTexture, uv);\n#if CC_DRAW_WIRE_FRAME\nif (any(lessThan(vBarycentric, vec3(0.02)))) {\ncol = vec4(0., 1., 1., 1.);\n}\n#endif\nreturn CCFragOutput(col);\n}\nvoid main() { gl_FragColor = add(); }"
}], [{
  "vert": "\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\nmat3 m = mat3(xAxis,yAxis,zAxis);\nfloat trace = m[0][0] + m[1][1] + m[2][2];\nvec4 quat;\nif (trace > 0.) {\nfloat s = 0.5 / sqrt(trace + 1.0);\nquat.w = 0.25 / s;\nquat.x = (m[2][1] - m[1][2]) * s;\nquat.y = (m[0][2] - m[2][0]) * s;\nquat.z = (m[1][0] - m[0][1]) * s;\n} else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\nfloat s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\nquat.w = (m[2][1] - m[1][2]) / s;\nquat.x = 0.25 * s;\nquat.y = (m[0][1] + m[1][0]) / s;\nquat.z = (m[0][2] + m[2][0]) / s;\n} else if (m[1][1] > m[2][2]) {\nfloat s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\nquat.w = (m[0][2] - m[2][0]) / s;\nquat.x = (m[0][1] + m[1][0]) / s;\nquat.y = 0.25 * s;\nquat.z = (m[1][2] + m[2][1]) / s;\n} else {\nfloat s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\nquat.w = (m[1][0] - m[0][1]) / s;\nquat.x = (m[0][2] + m[2][0]) / s;\nquat.y = (m[1][2] + m[2][1]) / s;\nquat.z = 0.25 * s;\n}\nfloat len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\nif (len > 0.) {\nlen = 1. / sqrt(len);\nquat.x = quat.x * len;\nquat.y = quat.y * len;\nquat.z = quat.z * len;\nquat.w = quat.w * len;\n}\nreturn quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\nfloat x2 = q.x + q.x;\nfloat y2 = q.y + q.y;\nfloat z2 = q.z + q.z;\nfloat xx = q.x * x2;\nfloat xy = q.x * y2;\nfloat xz = q.x * z2;\nfloat yy = q.y * y2;\nfloat yz = q.y * z2;\nfloat zz = q.z * z2;\nfloat wx = q.w * x2;\nfloat wy = q.w * y2;\nfloat wz = q.w * z2;\nreturn mat4(\n1. - (yy + zz), xy + wz, xz - wy, 0,\nxy - wz, 1. - (xx + zz), yz + wx, 0,\nxz + wy, yz - wx, 1. - (xx + yy), 0,\np.x, p.y, p.z, 1\n);\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\nfloat x = q.x, y = q.y, z = q.z, w = q.w;\nfloat x2 = x + x;\nfloat y2 = y + y;\nfloat z2 = z + z;\nfloat xx = x * x2;\nfloat xy = x * y2;\nfloat xz = x * z2;\nfloat yy = y * y2;\nfloat yz = y * z2;\nfloat zz = z * z2;\nfloat wx = w * x2;\nfloat wy = w * y2;\nfloat wz = w * z2;\nfloat sx = s.x;\nfloat sy = s.y;\nfloat sz = s.z;\nreturn mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n(xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n(xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\nt.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\nvec4 quat;\nquat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\nquat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\nquat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\nquat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\nreturn quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\nfloat ix = q.w * v.x + q.y * v.z - q.z * v.y;\nfloat iy = q.w * v.y + q.z * v.x - q.x * v.z;\nfloat iz = q.w * v.z + q.x * v.y - q.y * v.x;\nfloat iw = -q.x * v.x - q.y * v.y - q.z * v.z;\nv.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\nv.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\nv.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\nvec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\nvec4 rotQuat = quatMultiply(viewQuat, q);\nrotateVecFromQuat(pos, rotQuat);\nreturn pos;\n}\nuniform vec4 mainTiling_Offset;\nuniform vec4 frameTile_velLenScale;\nuniform vec4 scale;\nuniform highp mat4 cc_matView;\nuniform highp mat4 cc_matViewInv;\nuniform highp mat4 cc_matViewProj;\nuniform highp vec4 cc_cameraPos;\nuniform highp mat4 cc_matWorld;\nvarying mediump vec2 uv;\nvarying mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n, mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n, vec3 eye\n, vec4 velocity\n, float velocityScale\n, float lengthScale\n, float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\nvec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\nvec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\nvec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\nvec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\npos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\nvec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\nvec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\npos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\nvec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\nvec3 camX = vec3(1, 0, 0);\nvec3 camY = vec3(0, 0, -1);\npos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\nvec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\nrotateVecFromQuat(viewSpaceVert, q);\nvec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\nvec3 camY = vec3(0, 1, 0);\nvec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\npos.xyz += offset;\n#else\npos.x += vertOffset.x;\npos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\nvec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\naniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\nvertIndex.y = 1. - vertIndex.y;\n#endif\nreturn (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nattribute vec3 a_position;\nattribute vec3 a_texCoord;\nattribute vec3 a_texCoord1;\nattribute vec3 a_texCoord2;\nattribute vec4 a_color;\n#if CC_RENDER_MODE == 1\nattribute vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\nattribute vec3 a_texCoord3;\nattribute vec3 a_normal;\nattribute vec4 a_color1;\n#endif\nvec4 lpvs_main () {\nvec3 compScale = scale.xyz * a_texCoord1;\nvec4 pos = vec4(a_position, 1);\n#if CC_RENDER_MODE == 1\nvec4 velocity = vec4(a_color1.xyz, 0);\n#endif\n#if !CC_USE_WORLD_SPACE\npos = cc_matWorld * pos;\n#if CC_RENDER_MODE == 1\nvelocity = cc_matWorld * velocity;\n#endif\n#endif\nvec3 rotTmp = a_texCoord2;\nfloat mulFactor = 1.0;\nif (rotTmp.x > 10.0 * 0.5) {\nrotTmp.x -= 10.0;\nmulFactor = -1.0;\n}\nvec4 rot = vec4(rotTmp, 0.0);\nrot.w = mulFactor * sqrt(1.0 - rot.x * rot.x - rot.y * rot.y - rot.z * rot.z);\n#if CC_RENDER_MODE != 4\nvec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\ncomputeVertPos(pos, cornerOffset, rot, compScale, cc_matViewInv);\n#elif CC_RENDER_MODE == 1\ncomputeVertPos(pos, cornerOffset, rot, compScale, cc_cameraPos.xyz, velocity, frameTile_velLenScale.z, frameTile_velLenScale.w, a_texCoord.x);\n#elif 2\ncomputeVertPos(pos, cornerOffset, rot, compScale);\n#endif\ncolor = a_color;\n#else\nmat4 xformNoScale = matrixFromRT(rot, pos.xyz);\nmat4 xform = matFromRTS(rot, pos.xyz, compScale);\npos = xform * vec4(a_texCoord3, 1);\nvec4 normal = xformNoScale * vec4(a_normal, 0);\ncolor = a_color * a_color1;\n#endif\nuv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\npos = cc_matViewProj * pos;\nreturn pos;\n}\nvoid main() { gl_Position = lpvs_main(); }",
  "frag": "\nprecision mediump float;\nuniform mediump vec4 cc_exposure;\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n#if CC_USE_HDR\ncolor.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n#endif\nreturn color;\n}\nvarying vec2 uv;\nvarying vec4 color;\nuniform sampler2D mainTexture;\nuniform vec4 tintColor;\nvec4 add () {\nvec4 col = 2.0 * color * tintColor * texture2D(mainTexture, uv);\nreturn CCFragOutput(col);\n}\nvoid main() { gl_FragColor = add(); }"
}], [{
  "vert": "\nprecision highp float;\nuniform highp mat4 cc_matViewProj;\n#if USE_LOCAL\nuniform highp mat4 cc_matWorld;\n#endif\nattribute vec3 a_position;\nattribute vec2 a_texCoord;\nattribute vec4 a_color;\nvarying vec4 v_light;\nvarying vec2 uv0;\n#if TWO_COLORED\nattribute vec4 a_color2;\nvarying vec4 v_dark;\n#endif\nvec4 vert () {\nvec4 pos = vec4(a_position, 1);\n#if USE_LOCAL\npos = cc_matWorld * pos;\n#endif\npos = cc_matViewProj * pos;\nuv0 = a_texCoord;\nv_light = a_color;\n#if TWO_COLORED\nv_dark = a_color2;\n#endif\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",
  "frag": "\nprecision highp float;\n#if USE_ALPHA_TEST\nuniform float alphaThreshold;\n#endif\nvoid ALPHA_TEST (in vec4 color) {\n#if USE_ALPHA_TEST\nif (color.a < alphaThreshold) discard;\n#endif\n}\nvoid ALPHA_TEST (in float alpha) {\n#if USE_ALPHA_TEST\nif (alpha < alphaThreshold) discard;\n#endif\n}\nvarying vec4 v_light;\n#if TWO_COLORED\nvarying vec4 v_dark;\n#endif\nvarying vec2 uv0;\nuniform sampler2D cc_spriteTexture;\nvec4 frag () {\nvec4 o = vec4(1, 1, 1, 1);\n#if TWO_COLORED\nvec4 texColor = vec4(1, 1, 1, 1);\ntexColor *= texture2D(cc_spriteTexture, uv0);\no.a = texColor.a * v_light.a;\no.rgb = ((texColor.a - 1.0) * v_dark.a + 1.0 - texColor.rgb) * v_dark.rgb + texColor.rgb * v_light.rgb;\n#else\no *= texture2D(cc_spriteTexture, uv0);\no *= v_light;\n#endif\nALPHA_TEST(o);\nreturn o;\n}\nvoid main() { gl_FragColor = frag(); }"
}], [{
  "vert": "\nprecision highp float;\nuniform highp mat4 cc_matView;\nuniform highp mat4 cc_matProj;\nuniform highp mat4 cc_matViewProj;\nuniform highp vec4 cc_cameraPos;\n#if USE_LOCAL\nuniform highp mat4 cc_matWorld;\n#endif\n#if SAMPLE_FROM_RT\n#endif\nattribute vec3 a_position;\nattribute vec2 a_texCoord;\nattribute vec4 a_color;\nvarying vec4 color;\nvarying vec2 uv0;\nvec4 vert () {\nvec4 pos = vec4(a_position, 1);\n#if USE_LOCAL\npos = cc_matWorld * pos;\n#endif\n#if USE_PIXEL_ALIGNMENT\npos = cc_matView * pos;\npos.xyz = floor(pos.xyz);\npos = cc_matProj * pos;\n#else\npos = cc_matViewProj * pos;\n#endif\nuv0 = a_texCoord;\n#if SAMPLE_FROM_RT\nuv0 = cc_cameraPos.w > 1.0 ? vec2(uv0.x, 1.0 - uv0.y) : uv0;\n#endif\ncolor = a_color;\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",
  "frag": "\nprecision highp float;\nvec4 CCSampleWithAlphaSeparated(sampler2D tex, vec2 uv) {\n#if CC_USE_EMBEDDED_ALPHA\nreturn vec4(texture2D(tex, uv).rgb, texture2D(tex, uv + vec2(0.0, 0.5)).r);\n#else\nreturn texture2D(tex, uv);\n#endif\n}\n#if USE_ALPHA_TEST\nuniform float alphaThreshold;\n#endif\nvoid ALPHA_TEST (in vec4 color) {\n#if USE_ALPHA_TEST\nif (color.a < alphaThreshold) discard;\n#endif\n}\nvoid ALPHA_TEST (in float alpha) {\n#if USE_ALPHA_TEST\nif (alpha < alphaThreshold) discard;\n#endif\n}\nvarying vec4 color;\n#if USE_TEXTURE\nvarying vec2 uv0;\nuniform sampler2D cc_spriteTexture;\n#endif\nvec4 frag () {\nvec4 o = vec4(1, 1, 1, 1);\n#if USE_TEXTURE\no *= CCSampleWithAlphaSeparated(cc_spriteTexture, uv0);\n#if IS_GRAY\nfloat gray  = 0.2126 * o.r + 0.7152 * o.g + 0.0722 * o.b;\no.r = o.g = o.b = gray;\n#endif\n#endif\no *= color;\nALPHA_TEST(o);\nreturn o;\n}\nvoid main() { gl_FragColor = frag(); }"
}], [{
  "vert": "\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\nrgba = rgba * 255.0;\nhighp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\nhighp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\nhighp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\nreturn Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_MORPH\nattribute float a_vertexId;\nint getVertexId() {\nreturn int(a_vertexId);\n}\nuniform vec4 cc_displacementWeights[15];\nuniform vec4 cc_displacementTextureInfo;\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\nfloat pixelIndexF = float(pixelIndex);\nfloat x = mod(pixelIndexF, textureResolution.x);\nfloat y = floor(pixelIndexF / textureResolution.x);\nreturn vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\nreturn (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\nreturn texture2D(tex, uv);\n}\n#else\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex * 4;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\nreturn vec4(\ndecode32(texture2D(tex, x)),\ndecode32(texture2D(tex, y)),\ndecode32(texture2D(tex, z)),\n1.0\n);\n}\n#endif\nfloat getDisplacementWeight(int index) {\nint quot = index / 4;\nint remainder = index - quot * 4;\nif (remainder == 0) {\nreturn cc_displacementWeights[quot].x;\n} else if (remainder == 1) {\nreturn cc_displacementWeights[quot].y;\n} else if (remainder == 2) {\nreturn cc_displacementWeights[quot].z;\n} else {\nreturn cc_displacementWeights[quot].w;\n}\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\nreturn fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\nvec3 result = vec3(0, 0, 0);\nint nVertices = int(cc_displacementTextureInfo.z);\nfor (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\nresult += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n}\nreturn result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\nuniform sampler2D cc_PositionDisplacements;\nvec3 getPositionDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nuniform sampler2D cc_NormalDisplacements;\nvec3 getNormalDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nuniform sampler2D cc_TangentDisplacements;\nvec3 getTangentDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n}\n#endif\nvoid applyMorph (inout StandardVertInput attr) {\nint vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\nattr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nattr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nattr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\nattribute vec4 a_joints;\nattribute vec4 a_weights;\n#if CC_USE_BAKED_ANIMATION\n#if USE_INSTANCING\nattribute highp vec4 a_jointAnimInfo;\n#endif\nuniform highp vec4 cc_jointTextureInfo;\nuniform highp vec4 cc_jointAnimInfo;\nuniform highp sampler2D cc_jointTexture;\n#else\nuniform highp vec4 cc_joints[90];\n#endif\n#if CC_USE_BAKED_ANIMATION\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nmat4 getJointMatrix (float i) {\n#if USE_INSTANCING\nhighp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n#else\nhighp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n#endif\nhighp float invSize = cc_jointTextureInfo.w;\nhighp float y = floor(j * invSize);\nhighp float x = floor(j - y * cc_jointTextureInfo.x);\ny = (y + 0.5) * invSize;\nvec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\nvec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\nvec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#else\nmat4 getJointMatrix (float i) {\n#if USE_INSTANCING\nhighp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n#else\nhighp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n#endif\nhighp float invSize = cc_jointTextureInfo.w;\nhighp float y = floor(j * invSize);\nhighp float x = floor(j - y * cc_jointTextureInfo.x);\ny = (y + 0.5) * invSize;\nvec4 v1 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n);\nvec4 v2 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n);\nvec4 v3 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n);\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\n#else\nmat4 getJointMatrix (float i) {\nint idx = int(i);\nvec4 v1 = cc_joints[idx * 3];\nvec4 v2 = cc_joints[idx * 3 + 1];\nvec4 v3 = cc_joints[idx * 3 + 2];\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\nmat4 skinMatrix () {\nvec4 joints = vec4(a_joints);\nreturn getJointMatrix(joints.x) * a_weights.x\n+ getJointMatrix(joints.y) * a_weights.y\n+ getJointMatrix(joints.z) * a_weights.z\n+ getJointMatrix(joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\nmat4 m = skinMatrix();\nposition = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\nmat4 m = skinMatrix();\nattr.position = m * attr.position;\nattr.normal = (m * vec4(attr.normal, 0.0)).xyz;\nattr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\nuniform highp mat4 cc_matView;\nuniform highp mat4 cc_matProj;\nuniform highp vec4 cc_cameraPos;\nuniform mediump vec4 cc_fogBase;\nuniform mediump vec4 cc_fogAdd;\n#if USE_INSTANCING\nattribute vec4 a_matWorld0;\nattribute vec4 a_matWorld1;\nattribute vec4 a_matWorld2;\n#if USE_LIGHTMAP\nattribute vec4 a_lightingMapUVParam;\n#endif\n#elif USE_BATCHING\nattribute float a_dyn_batch_id;\nuniform highp mat4 cc_matWorlds[10];\n#else\nuniform highp mat4 cc_matWorld;\nuniform highp mat4 cc_matWorldIT;\nuniform highp vec4 cc_lightingMapUVParam;\n#endif\nuniform vec4 tilingOffset;\nfloat LinearFog(vec4 pos) {\nvec4 wPos = pos;\nfloat cam_dis = distance(cc_cameraPos, wPos);\nfloat fogStart = cc_fogBase.x;\nfloat fogEnd = cc_fogBase.y;\nreturn clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\nfloat f = exp(-cam_dis * fogDensity);\nreturn f;\n}\nfloat ExpSquaredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\nfloat f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\nreturn f;\n}\nfloat LayeredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat _FogTop = cc_fogAdd.x;\nfloat _FogRange = cc_fogAdd.y;\nvec3 camWorldProj = cc_cameraPos.xyz;\ncamWorldProj.y = 0.;\nvec3 worldPosProj = wPos.xyz;\nworldPosProj.y = 0.;\nfloat fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\nfloat fDeltaY, fDensityIntegral;\nif (cc_cameraPos.y > _FogTop) {\nif (wPos.y < _FogTop) {\nfDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\nfDensityIntegral = fDeltaY * fDeltaY * 0.5;\n} else {\nfDeltaY = 0.;\nfDensityIntegral = 0.;\n}\n} else {\nif (wPos.y < _FogTop) {\nfloat fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfloat fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\nfDeltaY = abs(fDeltaA - fDeltaB);\nfDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n} else {\nfDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n}\n}\nfloat fDensity;\nif (fDeltaY != 0.) {\nfDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n} else {\nfDensity = 0.;\n}\nfloat f = exp(-fDensity);\nreturn f;\n}\nvarying float v_fog_factor;\nvarying highp vec4 v_shadowPos;\nuniform highp mat4 cc_matLightViewProj;\n#if CC_RECEIVE_SHADOW\nuniform sampler2D cc_shadowMap;\nuniform sampler2D cc_spotLightingMap;\n#endif\n#if USE_VERTEX_COLOR\nattribute vec4 a_color;\nvarying vec4 v_color;\n#endif\nvarying vec3 v_position;\nvarying vec3 v_normal;\nvarying vec2 v_uv;\nvarying vec2 v_uv1;\n#if USE_NORMAL_MAP\nvarying vec3 v_tangent;\nvarying vec3 v_bitangent;\n#endif\n#if HAS_SECOND_UV || USE_LIGHTMAP\nattribute vec2 a_texCoord1;\n#endif\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nvarying vec3 v_luv;\nvoid CCLightingMapCaclUV()\n{\n#if !USE_INSTANCING\nv_luv.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.zw;\nv_luv.z = cc_lightingMapUVParam.z;\n#else\nv_luv.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.zw;\nv_luv.z = a_lightingMapUVParam.z;\n#endif\n}\n#endif\nvoid main () {\nStandardVertInput In;\nIn.position = vec4(a_position, 1.0);\nIn.normal = a_normal;\nIn.tangent = a_tangent;\n#if CC_USE_MORPH\napplyMorph(In);\n#endif\n#if CC_USE_SKINNING\nCCSkin(In);\n#endif\nmat4 matWorld, matWorldIT;\n#if USE_INSTANCING\nmatWorld = mat4(\nvec4(a_matWorld0.xyz, 0.0),\nvec4(a_matWorld1.xyz, 0.0),\nvec4(a_matWorld2.xyz, 0.0),\nvec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n);\nmatWorldIT = matWorld;\n#elif USE_BATCHING\nmatWorld = cc_matWorlds[int(a_dyn_batch_id)];\nmatWorldIT = matWorld;\n#else\nmatWorld = cc_matWorld;\nmatWorldIT = cc_matWorldIT;\n#endif\nvec4 pos = matWorld * In.position;\nv_position = pos.xyz;\nv_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n#if USE_NORMAL_MAP\nv_tangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\nv_bitangent = cross(v_normal, v_tangent) * In.tangent.w;\n#endif\nv_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n#if SAMPLE_FROM_RT\nv_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n#endif\n#if HAS_SECOND_UV\nv_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n#if SAMPLE_FROM_RT\nv_uv1 = cc_cameraPos.w > 1.0 ? vec2(v_uv1.x, 1.0 - v_uv1.y) : v_uv1;\n#endif\n#endif\n#if USE_VERTEX_COLOR\nv_color = a_color;\n#endif\n#if CC_USE_FOG == 0\nv_fog_factor = LinearFog(pos);\n#elif CC_USE_FOG == 1\nv_fog_factor = ExpFog(pos);\n#elif CC_USE_FOG == 2\nv_fog_factor = ExpSquaredFog(pos);\n#elif CC_USE_FOG == 3\nv_fog_factor = LayeredFog(pos);\n#else\nv_fog_factor = 1.0;\n#endif\nv_shadowPos = cc_matLightViewProj * pos;\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nCCLightingMapCaclUV();\n#endif\ngl_Position = cc_matProj * (cc_matView * matWorld) * In.position;\n}",
  "frag": "\n#ifdef GL_EXT_draw_buffers\n#extension GL_EXT_draw_buffers: enable\n#endif\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod: enable\n#endif\nprecision highp float;\nuniform highp vec4 cc_cameraPos;\nuniform mediump vec4 cc_exposure;\nuniform mediump vec4 cc_mainLitDir;\nuniform mediump vec4 cc_mainLitColor;\nuniform mediump vec4 cc_ambientSky;\nuniform mediump vec4 cc_ambientGround;\nuniform mediump vec4 cc_fogColor;\nuniform vec4 albedo;\nuniform vec4 albedoScaleAndCutoff;\nuniform vec4 pbrParams;\nuniform vec4 miscParams;\nuniform vec4 emissive;\nuniform vec4 emissiveScaleParam;\nvarying float v_fog_factor;\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nuniform highp mat4 cc_matLightView;\nuniform lowp vec4 cc_shadowNFLSInfo;\nuniform lowp vec4 cc_shadowWHPBInfo;\nuniform lowp vec4 cc_shadowLPNNInfo;\n#if CC_RECEIVE_SHADOW\nuniform sampler2D cc_shadowMap;\nuniform sampler2D cc_spotLightingMap;\nfloat CCGetLinearDepth (vec3 worldPos) {\nvec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\nfloat dist = length(viewStartPos.xyz);\nreturn cc_shadowNFLSInfo.x + (-dist / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x));\n}\nfloat CCGetShadowFactorHard (vec4 shadowPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat shadow = 0.0;\nfloat closestDepth = 0.0;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nclosestDepth = dot(texture2D(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n} else {\nclosestDepth = texture2D(cc_shadowMap, clipPos.xy).x;\n}\nshadow = step(clipPos.z- cc_shadowWHPBInfo.w, closestDepth);\nreturn shadow;\n}\nfloat CCGetShadowFactorSoft (vec4 shadowPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat offsetDepth = clipPos.z - cc_shadowWHPBInfo.w;\nvec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;\nvec2 clipPos_offset = clipPos.xy + oneTap;\nfloat block0, block1, block2, block3;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nblock0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\n} else {\nblock0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\nblock1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);\nblock2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);\nblock3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n}\nfloat coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block2, block3, coefX);\nfloat coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;\nreturn mix(resultX, resultY, coefY);\n}\nfloat CCGetShadowFactorSoft2X (vec4 shadowPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat bias = cc_shadowWHPBInfo.w;\nfloat offsetDepth = clipPos.z - bias;\nvec2 mapSize = cc_shadowWHPBInfo.xy;\nvec2 oneTap = 1.0 / mapSize;\nfloat clipPos_offset_L = clipPos.x - oneTap.x;\nfloat clipPos_offset_R = clipPos.x + oneTap.x;\nfloat clipPos_offset_U = clipPos.y - oneTap.y;\nfloat clipPos_offset_D = clipPos.y + oneTap.y;\nfloat block0, block1, block2, block3, block4, block5, block6, block7, block8;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nblock0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock4 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock5 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock6 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock7 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock8 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\n} else {\nblock0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\nblock1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);\nblock2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\nblock3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);\nblock4 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\nblock5 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);\nblock6 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\nblock7 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);\nblock8 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n}\nfloat coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\nfloat coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\nfloat shadow = 0.0;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block3, block4, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block1, block2, coefX);\nresultY = mix(block4, block5, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block3, block4, coefX);\nresultY = mix(block6, block7, coefX);\nshadow += mix(resultX, resultY, coefY);\nresultX = mix(block4, block5, coefX);\nresultY = mix(block7, block8, coefX);\nshadow += mix(resultX, resultY, coefY);\nreturn shadow * 0.25;\n}\nfloat CCGetSpotLightShadowFactorHard (vec4 shadowPos, vec3 worldPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat shadow = 0.0;\nfloat closestDepth = 0.0;\nfloat depth = 0.0;\nif (cc_shadowNFLSInfo.z > 0.000001) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nif (cc_shadowLPNNInfo.y > 0.000001) {\nclosestDepth = dot(texture2D(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n} else {\nclosestDepth = texture2D(cc_spotLightingMap, clipPos.xy).x;\n}\nshadow = step(depth - cc_shadowWHPBInfo.w, closestDepth);\nreturn shadow;\n}\nfloat CCGetSpotLightShadowFactorSoft (vec4 shadowPos, vec3 worldPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat offsetx = 1.0 / cc_shadowWHPBInfo.x;\nfloat offsety = 1.0 / cc_shadowWHPBInfo.y;\nfloat shadow = 0.0;\nfloat depth = 0.0;\nif (cc_shadowNFLSInfo.z > 0.000001) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nfloat offsetDepth = depth - cc_shadowWHPBInfo.w;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nfloat closestDepth = dot(texture2D(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = dot(texture2D(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = dot(texture2D(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = dot(texture2D(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(offsetDepth, closestDepth);\n} else {\nfloat closestDepth = texture2D(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y - offsety)).x;\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = texture2D(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y + offsety)).x;\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x;\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = texture2D(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y - offsety)).x;\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = texture2D(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y + offsety)).x;\nshadow += step(offsetDepth, closestDepth);\n}\nreturn shadow / 5.0;\n}\nfloat CCGetSpotLightShadowFactorSoft2X (vec4 shadowPos, vec3 worldPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat offsetx = 1.0 / cc_shadowWHPBInfo.x;\nfloat offsety = 1.0 / cc_shadowWHPBInfo.y;\nfloat shadow = 0.0;\nfloat depth = 0.0;\nif (cc_shadowNFLSInfo.z > 0.000001) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nfloat offsetDepth = depth - cc_shadowWHPBInfo.w;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nfor (int i = -1; i <= 1; i++) {\nfor (int j = -1; j <= 1; j++) {\nfloat closestDepth = dot(texture2D(cc_spotLightingMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(offsetDepth, closestDepth);\n}\n}\n} else {\nfor (int i = -1; i <= 1; i++) {\nfor (int j = -1; j <= 1; j++) {\nfloat closestDepth = texture2D(cc_spotLightingMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)).x;\nshadow += step(offsetDepth, closestDepth);\n}\n}\n}\nreturn shadow / 9.0;\n}\n#endif\n#if CC_USE_IBL\nuniform samplerCube cc_environment;\nvec3 unpackRGBE (vec4 rgbe) {\nreturn rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n}\nvec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n#ifdef GL_EXT_shader_texture_lod\nreturn texture2DLodEXT(tex, coord, lod);\n#else\nreturn texture2D(tex, coord, lod);\n#endif\n}\nvec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n#ifdef GL_EXT_shader_texture_lod\nreturn textureCubeLodEXT(tex, coord, lod);\n#else\nreturn textureCube(tex, coord, lod);\n#endif\n}\n#endif\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\nvec3 NxH = cross(N, H);\nfloat OneMinusNoHSqr = dot(NxH, NxH);\nfloat a = roughness * roughness;\nfloat n = NoH * a;\nfloat p = a / (OneMinusNoHSqr + n * n);\nreturn p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\nreturn (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\nconst vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\nconst vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\nvec4 r = roughness * c0 + c1;\nfloat a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\nvec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\nAB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\nreturn specular * AB.x + AB.y;\n}\nstruct StandardSurface {\nvec4 albedo;\nvec3 position;\nvec3 normal;\nvec3 emissive;\nvec3 lightmap;\nfloat lightmap_test;\nfloat roughness;\nfloat metallic;\nfloat occlusion;\n};\nvec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - s.position);\nfloat NV = max(abs(dot(N, V)), 0.0);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 L = normalize(-cc_mainLitDir.xyz);\nvec3 H = normalize(L + V);\nfloat NH = max(dot(N, H), 0.0);\nfloat NL = max(dot(N, L), 0.0);\nvec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\nvec3 diffuseContrib = diffuse;\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nif (s.lightmap_test > 0.0001) {\nfinalColor = s.lightmap.rgb;\n}\n#else\ndiffuseContrib /= 3.14159265359;\n#endif\nvec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\nvec3 dirlightContrib = (diffuseContrib + specularContrib);\nfloat shadow = 1.0;\n#if CC_RECEIVE_SHADOW\nif (NL > 0.0) {\n{\nfloat pcf = cc_shadowWHPBInfo.z;\nvec3 projWorldPos = shadowPos.xyz + (1.0 - NL) * cc_shadowLPNNInfo.z * N;\nvec4 pos = vec4(projWorldPos.xyz, shadowPos.w);\nif (pcf > 1.9) shadow = CCGetShadowFactorSoft2X(pos);\nelse if (pcf > 0.9) shadow = CCGetShadowFactorSoft(pos);\nelse shadow = CCGetShadowFactorHard(pos);\nshadow = mix(shadow, 1.0, cc_shadowNFLSInfo.w);\n}\n}\n#endif\ndirlightContrib *= shadow;\nfinalColor *= dirlightContrib;\nfloat fAmb = 0.5 - N.y * 0.5;\nvec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb) * cc_ambientSky.w;\nfinalColor += (ambDiff.rgb * diffuse) * s.occlusion;\n#if CC_USE_IBL\nvec3 R = normalize(reflect(-V, N));\nvec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n#if CC_USE_IBL == 2\nvec3 env = unpackRGBE(envmap);\n#else\nvec3 env = SRGBToLinear(envmap.rgb);\n#endif\nfinalColor += env * cc_ambientSky.w * specular * s.occlusion;\n#endif\n#if CC_USE_HDR\ns.emissive *= cc_exposure.w;\n#endif\nfinalColor += s.emissive;\nreturn vec4(finalColor, s.albedo.a);\n}\nvec3 ACESToneMap (vec3 color) {\ncolor = min(color, vec3(8.0));\nconst float A = 2.51;\nconst float B = 0.03;\nconst float C = 2.43;\nconst float D = 0.59;\nconst float E = 0.14;\nreturn (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n#if !CC_USE_HDR\ncolor.rgb = sqrt(ACESToneMap(color.rgb));\n#endif\nreturn color;\n}\nvarying highp vec4 v_shadowPos;\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nvarying vec3 v_luv;\nuniform sampler2D cc_lightingMap;\nvec3 UnpackLightingmap(vec4 color) {\nvec3 c;\nfloat e = 1.0 + color.a * (8.0 - 1.0);\nc.r = color.r * e;\nc.g = color.g * e;\nc.b = color.b * e;\nreturn c;\n}\n#endif\nvarying vec3 v_position;\nvarying vec2 v_uv;\nvarying vec2 v_uv1;\nvarying vec3 v_normal;\n#if USE_VERTEX_COLOR\nvarying vec4 v_color;\n#endif\n#if USE_ALBEDO_MAP\nuniform sampler2D albedoMap;\n#endif\n#if USE_NORMAL_MAP\nvarying vec3 v_tangent;\nvarying vec3 v_bitangent;\nuniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\nuniform sampler2D pbrMap;\n#endif\n#if USE_METALLIC_ROUGHNESS_MAP\nuniform sampler2D metallicRoughnessMap;\n#endif\n#if USE_OCCLUSION_MAP\nuniform sampler2D occlusionMap;\n#endif\n#if USE_EMISSIVE_MAP\nuniform sampler2D emissiveMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvoid surf (out StandardSurface s) {\nvec4 baseColor = albedo;\n#if USE_VERTEX_COLOR\nbaseColor.rgb *= SRGBToLinear(v_color.rgb);\nbaseColor.a *= v_color.a;\n#endif\n#if USE_ALBEDO_MAP\nvec4 texColor = texture2D(albedoMap, ALBEDO_UV);\ntexColor.rgb = SRGBToLinear(texColor.rgb);\nbaseColor *= texColor;\n#endif\ns.albedo = baseColor;\ns.albedo.rgb *= albedoScaleAndCutoff.xyz;\n#if USE_ALPHA_TEST\nif (s.albedo.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n#endif\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nvec4 lightColor = texture2D(cc_lightingMap, v_luv.xy);\ns.lightmap = UnpackLightingmap(lightColor);\ns.lightmap_test = v_luv.z;\n#endif\ns.normal = v_normal;\n#if USE_NORMAL_MAP\nvec3 nmmp = texture2D(normalMap, NORMAL_UV).xyz - vec3(0.5);\ns.normal =\n(nmmp.x * miscParams.x) * normalize(v_tangent) +\n(nmmp.y * miscParams.x) * normalize(v_bitangent) +\nnmmp.z * normalize(s.normal);\n#endif\ns.position = v_position;\nvec4 pbr = pbrParams;\n#if USE_PBR_MAP\nvec4 res = texture2D(pbrMap, PBR_UV);\npbr.x *= res.r;\npbr.y *= res.g;\npbr.z *= res.b;\npbr.w *= res.w;\n#endif\n#if USE_METALLIC_ROUGHNESS_MAP\nvec4 metallicRoughness = texture2D(metallicRoughnessMap, PBR_UV);\npbr.z *= metallicRoughness.b;\npbr.y *= metallicRoughness.g;\n#endif\n#if USE_OCCLUSION_MAP\npbr.x *= texture2D(occlusionMap, PBR_UV).r;\n#endif\ns.occlusion = clamp(pbr.x, 0.0, 0.96);\ns.roughness = clamp(pbr.y, 0.04, 1.0);\ns.metallic = pbr.z;\ns.emissive = emissive.rgb * emissiveScaleParam.xyz;\n#if USE_EMISSIVE_MAP\ns.emissive *= SRGBToLinear(texture2D(emissiveMap, EMISSIVE_UV).rgb);\n#endif\n}\n#if CC_FORWARD_ADD\n#if CC_PIPELINE_TYPE == 0\n# define LIGHTS_PER_PASS 1\n#else\n# define LIGHTS_PER_PASS 10\n#endif\nuniform highp vec4 cc_lightPos[LIGHTS_PER_PASS];\nuniform vec4 cc_lightColor[LIGHTS_PER_PASS];\nuniform vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\nuniform vec4 cc_lightDir[LIGHTS_PER_PASS];\nfloat SmoothDistAtt (float distSqr, float invSqrAttRadius) {\nfloat factor = distSqr * invSqrAttRadius;\nfloat smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\nreturn smoothFactor * smoothFactor;\n}\nfloat GetDistAtt (float distSqr, float invSqrAttRadius) {\nfloat attenuation = 1.0 / max(distSqr, 0.01*0.01);\nattenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\nreturn attenuation;\n}\nfloat GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\nfloat cd = dot(litDir, L);\nfloat attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\nreturn (attenuation * attenuation);\n}\nvec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\nvec3 diffuseContrib = diffuse / 3.14159265359;\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - s.position);\nfloat NV = max(abs(dot(N, V)), 0.001);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 finalColor = vec3(0.0);\nint numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\nfor (int i = 0; i < LIGHTS_PER_PASS; i++) {\nif (i >= numLights) break;\nvec3 SLU = cc_lightPos[i].xyz - s.position;\nvec3 SL = normalize(SLU);\nvec3 SH = normalize(SL + V);\nfloat SNL = max(dot(N, SL), 0.001);\nfloat SNH = max(dot(N, SH), 0.0);\nfloat distSqr = dot(SLU, SLU);\nfloat litRadius = cc_lightSizeRangeAngle[i].x;\nfloat litRadiusSqr = litRadius * litRadius;\nfloat illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\nfloat attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\nattRadiusSqrInv *= attRadiusSqrInv;\nfloat att = GetDistAtt(distSqr, attRadiusSqrInv);\nvec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\nif (cc_lightPos[i].w > 0.0) {\nfloat cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\nfloat cosOuter = cc_lightSizeRangeAngle[i].z;\nfloat litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\nfloat litAngleOffset = -cosOuter * litAngleScale;\natt *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n}\nvec3 lightColor = cc_lightColor[i].rgb;\nfloat shadow = 1.0;\n#if CC_RECEIVE_SHADOW\nif (cc_lightPos[i].w > 0.0) {\n{\nfloat pcf = cc_shadowWHPBInfo.z;\nfloat cosAngle = clamp(1.0 - dot(N, normalize(cc_lightPos[i].xyz - s.position.xyz)), 0.0, 1.0);\nvec3 projWorldPos = shadowPos.xyz + cosAngle * cc_shadowLPNNInfo.z * N;\nvec4 pos = vec4(projWorldPos.xyz, shadowPos.w);\nif (pcf > 1.9) shadow = CCGetSpotLightShadowFactorSoft2X(pos, s.position);\nelse if (pcf > 0.9) shadow = CCGetSpotLightShadowFactorSoft(pos, s.position);\nelse shadow = CCGetSpotLightShadowFactorHard(pos, s.position);\n}\n}\n#endif\nlightColor *= shadow;\nfinalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n}\nreturn vec4(finalColor, 0.0);\n}\nvoid main () {\nStandardSurface s; surf(s);\nvec4 color = CCStandardShadingAdditive(s, v_shadowPos);\ncolor = vec4(mix(CC_FORWARD_ADD > 0 ? vec3(0.0) : cc_fogColor.rgb, color.rgb, v_fog_factor), color.a);\ngl_FragData[0] = CCFragOutput(color);\n}\n#elif CC_PIPELINE_TYPE == 0\nvoid main () {\nStandardSurface s; surf(s);\nvec4 color = CCStandardShadingBase(s, v_shadowPos);\ncolor = vec4(mix(CC_FORWARD_ADD > 0 ? vec3(0.0) : cc_fogColor.rgb, color.rgb, v_fog_factor), color.a);\ngl_FragData[0] = CCFragOutput(color);\n}\n#elif CC_PIPELINE_TYPE == 1\nvoid main () {\nStandardSurface s; surf(s);\ngl_FragData[0] = s.albedo;\ngl_FragData[1] = vec4(s.position, s.roughness);\ngl_FragData[2] = vec4(s.normal, s.metallic);\ngl_FragData[3] = vec4(s.emissive, s.occlusion);\n}\n#endif"
}, {
  "vert": "\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\nrgba = rgba * 255.0;\nhighp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\nhighp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\nhighp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\nreturn Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_MORPH\nattribute float a_vertexId;\nint getVertexId() {\nreturn int(a_vertexId);\n}\nuniform vec4 cc_displacementWeights[15];\nuniform vec4 cc_displacementTextureInfo;\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\nfloat pixelIndexF = float(pixelIndex);\nfloat x = mod(pixelIndexF, textureResolution.x);\nfloat y = floor(pixelIndexF / textureResolution.x);\nreturn vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\nreturn (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\nreturn texture2D(tex, uv);\n}\n#else\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex * 4;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\nreturn vec4(\ndecode32(texture2D(tex, x)),\ndecode32(texture2D(tex, y)),\ndecode32(texture2D(tex, z)),\n1.0\n);\n}\n#endif\nfloat getDisplacementWeight(int index) {\nint quot = index / 4;\nint remainder = index - quot * 4;\nif (remainder == 0) {\nreturn cc_displacementWeights[quot].x;\n} else if (remainder == 1) {\nreturn cc_displacementWeights[quot].y;\n} else if (remainder == 2) {\nreturn cc_displacementWeights[quot].z;\n} else {\nreturn cc_displacementWeights[quot].w;\n}\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\nreturn fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\nvec3 result = vec3(0, 0, 0);\nint nVertices = int(cc_displacementTextureInfo.z);\nfor (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\nresult += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n}\nreturn result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\nuniform sampler2D cc_PositionDisplacements;\nvec3 getPositionDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nuniform sampler2D cc_NormalDisplacements;\nvec3 getNormalDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nuniform sampler2D cc_TangentDisplacements;\nvec3 getTangentDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n}\n#endif\nvoid applyMorph (inout StandardVertInput attr) {\nint vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\nattr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nattr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nattr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\nattribute vec4 a_joints;\nattribute vec4 a_weights;\n#if CC_USE_BAKED_ANIMATION\n#if USE_INSTANCING\nattribute highp vec4 a_jointAnimInfo;\n#endif\nuniform highp vec4 cc_jointTextureInfo;\nuniform highp vec4 cc_jointAnimInfo;\nuniform highp sampler2D cc_jointTexture;\n#else\nuniform highp vec4 cc_joints[90];\n#endif\n#if CC_USE_BAKED_ANIMATION\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nmat4 getJointMatrix (float i) {\n#if USE_INSTANCING\nhighp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n#else\nhighp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n#endif\nhighp float invSize = cc_jointTextureInfo.w;\nhighp float y = floor(j * invSize);\nhighp float x = floor(j - y * cc_jointTextureInfo.x);\ny = (y + 0.5) * invSize;\nvec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\nvec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\nvec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#else\nmat4 getJointMatrix (float i) {\n#if USE_INSTANCING\nhighp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n#else\nhighp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n#endif\nhighp float invSize = cc_jointTextureInfo.w;\nhighp float y = floor(j * invSize);\nhighp float x = floor(j - y * cc_jointTextureInfo.x);\ny = (y + 0.5) * invSize;\nvec4 v1 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n);\nvec4 v2 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n);\nvec4 v3 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n);\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\n#else\nmat4 getJointMatrix (float i) {\nint idx = int(i);\nvec4 v1 = cc_joints[idx * 3];\nvec4 v2 = cc_joints[idx * 3 + 1];\nvec4 v3 = cc_joints[idx * 3 + 2];\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\nmat4 skinMatrix () {\nvec4 joints = vec4(a_joints);\nreturn getJointMatrix(joints.x) * a_weights.x\n+ getJointMatrix(joints.y) * a_weights.y\n+ getJointMatrix(joints.z) * a_weights.z\n+ getJointMatrix(joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\nmat4 m = skinMatrix();\nposition = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\nmat4 m = skinMatrix();\nattr.position = m * attr.position;\nattr.normal = (m * vec4(attr.normal, 0.0)).xyz;\nattr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\n#if USE_INSTANCING\nattribute vec4 a_matWorld0;\nattribute vec4 a_matWorld1;\nattribute vec4 a_matWorld2;\n#if USE_LIGHTMAP\nattribute vec4 a_lightingMapUVParam;\n#endif\n#elif USE_BATCHING\nattribute float a_dyn_batch_id;\nuniform highp mat4 cc_matWorlds[10];\n#else\nuniform highp mat4 cc_matWorld;\nuniform highp mat4 cc_matWorldIT;\n#endif\nuniform vec4 tilingOffset;\nuniform highp mat4 cc_matLightViewProj;\n#if HAS_SECOND_UV || USE_LIGHTMAP\nattribute vec2 a_texCoord1;\n#endif\nvarying vec2 v_uv;\nvarying vec2 v_uv1;\nvarying vec4 v_worldPos;\nvarying float v_clip_depth;\nvec4 vert () {\nStandardVertInput In;\nIn.position = vec4(a_position, 1.0);\nIn.normal = a_normal;\nIn.tangent = a_tangent;\n#if CC_USE_MORPH\napplyMorph(In);\n#endif\n#if CC_USE_SKINNING\nCCSkin(In);\n#endif\nmat4 matWorld, matWorldIT;\n#if USE_INSTANCING\nmatWorld = mat4(\nvec4(a_matWorld0.xyz, 0.0),\nvec4(a_matWorld1.xyz, 0.0),\nvec4(a_matWorld2.xyz, 0.0),\nvec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n);\nmatWorldIT = matWorld;\n#elif USE_BATCHING\nmatWorld = cc_matWorlds[int(a_dyn_batch_id)];\nmatWorldIT = matWorld;\n#else\nmatWorld = cc_matWorld;\nmatWorldIT = cc_matWorldIT;\n#endif\nv_worldPos = matWorld * In.position;\nvec4 clipPos = cc_matLightViewProj * v_worldPos;\nv_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n#if HAS_SECOND_UV\nv_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n#endif\nv_clip_depth = clipPos.z / clipPos.w * 0.5 + 0.5;\nreturn clipPos;\n}\nvoid main() { gl_Position = vert(); }",
  "frag": "\nprecision highp float;\nuniform vec4 albedo;\nuniform vec4 albedoScaleAndCutoff;\nvec4 packDepthToRGBA (float depth) {\nvec4 ret = vec4(1.0, 255.0, 65025.0, 160581375.0) * depth;\nret = fract(ret);\nret -= ret.yzww * vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0);\nreturn ret;\n}\nuniform highp mat4 cc_matLightView;\nuniform lowp vec4 cc_shadowNFLSInfo;\nuniform lowp vec4 cc_shadowLPNNInfo;\nvarying vec2 v_uv;\nvarying vec2 v_uv1;\nvarying vec4 v_worldPos;\nvarying float v_clip_depth;\n#if USE_ALBEDO_MAP\nuniform sampler2D albedoMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvec4 frag () {\nvec4 baseColor = albedo;\n#if USE_ALBEDO_MAP\nbaseColor *= texture2D(albedoMap, ALBEDO_UV);\n#endif\n#if USE_ALPHA_TEST\nif (baseColor.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n#endif\nif(cc_shadowLPNNInfo.x > 0.000001 && cc_shadowLPNNInfo.x < 1.999999) {\nif (cc_shadowNFLSInfo.z > 0.000001) {\nvec4 viewStartPos = cc_matLightView * v_worldPos;\nfloat dist = length(viewStartPos.xyz);\nfloat linearDepth = cc_shadowNFLSInfo.x + (-dist / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x));\nreturn vec4(linearDepth, 1.0, 1.0, 1.0);\n}\n}\nif (cc_shadowLPNNInfo.y > 0.000001) {\nreturn packDepthToRGBA(v_clip_depth);\n}\nreturn vec4(v_clip_depth, 1.0, 1.0, 1.0);\n}\nvoid main() { gl_FragColor = frag(); }"
}], [{
  "vert": "\nprecision mediump float;\nuniform highp mat4 cc_matViewProj;\nuniform highp vec4 cc_cameraPos;\nuniform mediump vec4 cc_fogBase;\nuniform mediump vec4 cc_fogAdd;\nuniform highp mat4 cc_matWorld;\nfloat LinearFog(vec4 pos) {\nvec4 wPos = pos;\nfloat cam_dis = distance(cc_cameraPos, wPos);\nfloat fogStart = cc_fogBase.x;\nfloat fogEnd = cc_fogBase.y;\nreturn clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\nfloat f = exp(-cam_dis * fogDensity);\nreturn f;\n}\nfloat ExpSquaredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\nfloat f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\nreturn f;\n}\nfloat LayeredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat _FogTop = cc_fogAdd.x;\nfloat _FogRange = cc_fogAdd.y;\nvec3 camWorldProj = cc_cameraPos.xyz;\ncamWorldProj.y = 0.;\nvec3 worldPosProj = wPos.xyz;\nworldPosProj.y = 0.;\nfloat fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\nfloat fDeltaY, fDensityIntegral;\nif (cc_cameraPos.y > _FogTop) {\nif (wPos.y < _FogTop) {\nfDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\nfDensityIntegral = fDeltaY * fDeltaY * 0.5;\n} else {\nfDeltaY = 0.;\nfDensityIntegral = 0.;\n}\n} else {\nif (wPos.y < _FogTop) {\nfloat fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfloat fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\nfDeltaY = abs(fDeltaA - fDeltaB);\nfDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n} else {\nfDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n}\n}\nfloat fDensity;\nif (fDeltaY != 0.) {\nfDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n} else {\nfDensity = 0.;\n}\nfloat f = exp(-fDensity);\nreturn f;\n}\nvarying float v_fog_factor;\nvarying highp vec4 v_shadowPos;\nuniform highp mat4 cc_matLightViewProj;\n#if CC_RECEIVE_SHADOW\nuniform sampler2D cc_shadowMap;\nuniform sampler2D cc_spotLightingMap;\n#endif\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nvarying highp vec3 v_position;\nvarying mediump vec3 v_normal;\n#if USE_NORMALMAP\nvarying mediump vec3 v_tangent;\nvarying mediump vec3 v_binormal;\n#endif\nvarying mediump vec2 uvw;\nvarying mediump vec2 uv0;\nvarying mediump vec2 uv1;\nvarying mediump vec2 uv2;\nvarying mediump vec2 uv3;\nvarying mediump vec3 luv;\nvarying mediump vec3 diffuse;\nuniform vec4 UVScale;\nuniform vec4 lightMapUVParam;\nvoid main () {\nvec3 worldPos;\nworldPos.x = cc_matWorld[3][0] + a_position.x;\nworldPos.y = cc_matWorld[3][1] + a_position.y;\nworldPos.z = cc_matWorld[3][2] + a_position.z;\nvec4 pos = vec4(worldPos, 1.0);\npos = cc_matViewProj * pos;\nuvw = a_texCoord;\nuv0 = a_position.xz * UVScale.x;\nuv1 = a_position.xz * UVScale.y;\nuv2 = a_position.xz * UVScale.z;\nuv3 = a_position.xz * UVScale.w;\n#if USE_LIGHTMAP\nluv.xy = lightMapUVParam.xy + a_texCoord * lightMapUVParam.zw;\nluv.z = lightMapUVParam.z;\n#endif\nv_position = worldPos;\nv_normal = a_normal;\n#if CC_USE_FOG == 0\nv_fog_factor = LinearFog(vec4(worldPos, 1.0));\n#elif CC_USE_FOG == 1\nv_fog_factor = ExpFog(vec4(worldPos, 1.0));\n#elif CC_USE_FOG == 2\nv_fog_factor = ExpSquaredFog(vec4(worldPos, 1.0));\n#elif CC_USE_FOG == 3\nv_fog_factor = LayeredFog(vec4(worldPos, 1.0));\n#else\nv_fog_factor = 1.0;\n#endif\n#if USE_NORMALMAP\nv_tangent = vec3(1.0, 0.0, 0.0);\nv_binormal = vec3(0.0, 0.0, 1.0);\nv_binormal = cross(v_tangent, a_normal);\nv_tangent = cross(a_normal, v_binormal);\n#endif\nv_shadowPos = cc_matLightViewProj * vec4(worldPos, 1.0);\ngl_Position = pos;\n}",
  "frag": "\n#ifdef GL_EXT_draw_buffers\n#extension GL_EXT_draw_buffers: enable\n#endif\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod: enable\n#endif\nprecision highp float;\nuniform highp vec4 cc_cameraPos;\nuniform mediump vec4 cc_exposure;\nuniform mediump vec4 cc_mainLitDir;\nuniform mediump vec4 cc_mainLitColor;\nuniform mediump vec4 cc_ambientSky;\nuniform mediump vec4 cc_ambientGround;\nuniform mediump vec4 cc_fogColor;\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nuniform highp mat4 cc_matLightView;\nuniform lowp vec4 cc_shadowNFLSInfo;\nuniform lowp vec4 cc_shadowWHPBInfo;\nuniform lowp vec4 cc_shadowLPNNInfo;\n#if CC_RECEIVE_SHADOW\nuniform sampler2D cc_shadowMap;\nuniform sampler2D cc_spotLightingMap;\nfloat CCGetLinearDepth (vec3 worldPos) {\nvec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\nfloat dist = length(viewStartPos.xyz);\nreturn cc_shadowNFLSInfo.x + (-dist / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x));\n}\nfloat CCGetShadowFactorHard (vec4 shadowPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat shadow = 0.0;\nfloat closestDepth = 0.0;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nclosestDepth = dot(texture2D(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n} else {\nclosestDepth = texture2D(cc_shadowMap, clipPos.xy).x;\n}\nshadow = step(clipPos.z- cc_shadowWHPBInfo.w, closestDepth);\nreturn shadow;\n}\nfloat CCGetShadowFactorSoft (vec4 shadowPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat offsetDepth = clipPos.z - cc_shadowWHPBInfo.w;\nvec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;\nvec2 clipPos_offset = clipPos.xy + oneTap;\nfloat block0, block1, block2, block3;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nblock0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\n} else {\nblock0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\nblock1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);\nblock2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);\nblock3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n}\nfloat coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block2, block3, coefX);\nfloat coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;\nreturn mix(resultX, resultY, coefY);\n}\nfloat CCGetShadowFactorSoft2X (vec4 shadowPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat bias = cc_shadowWHPBInfo.w;\nfloat offsetDepth = clipPos.z - bias;\nvec2 mapSize = cc_shadowWHPBInfo.xy;\nvec2 oneTap = 1.0 / mapSize;\nfloat clipPos_offset_L = clipPos.x - oneTap.x;\nfloat clipPos_offset_R = clipPos.x + oneTap.x;\nfloat clipPos_offset_U = clipPos.y - oneTap.y;\nfloat clipPos_offset_D = clipPos.y + oneTap.y;\nfloat block0, block1, block2, block3, block4, block5, block6, block7, block8;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nblock0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock4 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock5 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock6 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock7 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock8 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\n} else {\nblock0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\nblock1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);\nblock2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\nblock3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);\nblock4 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\nblock5 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);\nblock6 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\nblock7 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);\nblock8 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n}\nfloat coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\nfloat coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\nfloat shadow = 0.0;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block3, block4, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block1, block2, coefX);\nresultY = mix(block4, block5, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block3, block4, coefX);\nresultY = mix(block6, block7, coefX);\nshadow += mix(resultX, resultY, coefY);\nresultX = mix(block4, block5, coefX);\nresultY = mix(block7, block8, coefX);\nshadow += mix(resultX, resultY, coefY);\nreturn shadow * 0.25;\n}\nfloat CCGetSpotLightShadowFactorHard (vec4 shadowPos, vec3 worldPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat shadow = 0.0;\nfloat closestDepth = 0.0;\nfloat depth = 0.0;\nif (cc_shadowNFLSInfo.z > 0.000001) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nif (cc_shadowLPNNInfo.y > 0.000001) {\nclosestDepth = dot(texture2D(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n} else {\nclosestDepth = texture2D(cc_spotLightingMap, clipPos.xy).x;\n}\nshadow = step(depth - cc_shadowWHPBInfo.w, closestDepth);\nreturn shadow;\n}\nfloat CCGetSpotLightShadowFactorSoft (vec4 shadowPos, vec3 worldPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat offsetx = 1.0 / cc_shadowWHPBInfo.x;\nfloat offsety = 1.0 / cc_shadowWHPBInfo.y;\nfloat shadow = 0.0;\nfloat depth = 0.0;\nif (cc_shadowNFLSInfo.z > 0.000001) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nfloat offsetDepth = depth - cc_shadowWHPBInfo.w;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nfloat closestDepth = dot(texture2D(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = dot(texture2D(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = dot(texture2D(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = dot(texture2D(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(offsetDepth, closestDepth);\n} else {\nfloat closestDepth = texture2D(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y - offsety)).x;\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = texture2D(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y + offsety)).x;\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x;\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = texture2D(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y - offsety)).x;\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = texture2D(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y + offsety)).x;\nshadow += step(offsetDepth, closestDepth);\n}\nreturn shadow / 5.0;\n}\nfloat CCGetSpotLightShadowFactorSoft2X (vec4 shadowPos, vec3 worldPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat offsetx = 1.0 / cc_shadowWHPBInfo.x;\nfloat offsety = 1.0 / cc_shadowWHPBInfo.y;\nfloat shadow = 0.0;\nfloat depth = 0.0;\nif (cc_shadowNFLSInfo.z > 0.000001) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nfloat offsetDepth = depth - cc_shadowWHPBInfo.w;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nfor (int i = -1; i <= 1; i++) {\nfor (int j = -1; j <= 1; j++) {\nfloat closestDepth = dot(texture2D(cc_spotLightingMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(offsetDepth, closestDepth);\n}\n}\n} else {\nfor (int i = -1; i <= 1; i++) {\nfor (int j = -1; j <= 1; j++) {\nfloat closestDepth = texture2D(cc_spotLightingMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)).x;\nshadow += step(offsetDepth, closestDepth);\n}\n}\n}\nreturn shadow / 9.0;\n}\n#endif\n#if CC_USE_IBL\nuniform samplerCube cc_environment;\nvec3 unpackRGBE (vec4 rgbe) {\nreturn rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n}\nvec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n#ifdef GL_EXT_shader_texture_lod\nreturn texture2DLodEXT(tex, coord, lod);\n#else\nreturn texture2D(tex, coord, lod);\n#endif\n}\nvec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n#ifdef GL_EXT_shader_texture_lod\nreturn textureCubeLodEXT(tex, coord, lod);\n#else\nreturn textureCube(tex, coord, lod);\n#endif\n}\n#endif\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\nvec3 NxH = cross(N, H);\nfloat OneMinusNoHSqr = dot(NxH, NxH);\nfloat a = roughness * roughness;\nfloat n = NoH * a;\nfloat p = a / (OneMinusNoHSqr + n * n);\nreturn p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\nreturn (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\nconst vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\nconst vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\nvec4 r = roughness * c0 + c1;\nfloat a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\nvec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\nAB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\nreturn specular * AB.x + AB.y;\n}\nstruct StandardSurface {\nvec4 albedo;\nvec3 position;\nvec3 normal;\nvec3 emissive;\nvec3 lightmap;\nfloat lightmap_test;\nfloat roughness;\nfloat metallic;\nfloat occlusion;\n};\nvec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - s.position);\nfloat NV = max(abs(dot(N, V)), 0.0);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 L = normalize(-cc_mainLitDir.xyz);\nvec3 H = normalize(L + V);\nfloat NH = max(dot(N, H), 0.0);\nfloat NL = max(dot(N, L), 0.0);\nvec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\nvec3 diffuseContrib = diffuse;\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nif (s.lightmap_test > 0.0001) {\nfinalColor = s.lightmap.rgb;\n}\n#else\ndiffuseContrib /= 3.14159265359;\n#endif\nvec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\nvec3 dirlightContrib = (diffuseContrib + specularContrib);\nfloat shadow = 1.0;\n#if CC_RECEIVE_SHADOW\nif (NL > 0.0) {\n{\nfloat pcf = cc_shadowWHPBInfo.z;\nvec3 projWorldPos = shadowPos.xyz + (1.0 - NL) * cc_shadowLPNNInfo.z * N;\nvec4 pos = vec4(projWorldPos.xyz, shadowPos.w);\nif (pcf > 1.9) shadow = CCGetShadowFactorSoft2X(pos);\nelse if (pcf > 0.9) shadow = CCGetShadowFactorSoft(pos);\nelse shadow = CCGetShadowFactorHard(pos);\nshadow = mix(shadow, 1.0, cc_shadowNFLSInfo.w);\n}\n}\n#endif\ndirlightContrib *= shadow;\nfinalColor *= dirlightContrib;\nfloat fAmb = 0.5 - N.y * 0.5;\nvec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb) * cc_ambientSky.w;\nfinalColor += (ambDiff.rgb * diffuse) * s.occlusion;\n#if CC_USE_IBL\nvec3 R = normalize(reflect(-V, N));\nvec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n#if CC_USE_IBL == 2\nvec3 env = unpackRGBE(envmap);\n#else\nvec3 env = SRGBToLinear(envmap.rgb);\n#endif\nfinalColor += env * cc_ambientSky.w * specular * s.occlusion;\n#endif\n#if CC_USE_HDR\ns.emissive *= cc_exposure.w;\n#endif\nfinalColor += s.emissive;\nreturn vec4(finalColor, s.albedo.a);\n}\nvec3 ACESToneMap (vec3 color) {\ncolor = min(color, vec3(8.0));\nconst float A = 2.51;\nconst float B = 0.03;\nconst float C = 2.43;\nconst float D = 0.59;\nconst float E = 0.14;\nreturn (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n#if !CC_USE_HDR\ncolor.rgb = sqrt(ACESToneMap(color.rgb));\n#endif\nreturn color;\n}\nvarying float v_fog_factor;\nvarying highp vec4 v_shadowPos;\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nvarying vec3 v_luv;\nuniform sampler2D cc_lightingMap;\nvec3 UnpackLightingmap(vec4 color) {\nvec3 c;\nfloat e = 1.0 + color.a * (8.0 - 1.0);\nc.r = color.r * e;\nc.g = color.g * e;\nc.b = color.b * e;\nreturn c;\n}\n#endif\nvarying highp vec3 v_position;\nvarying mediump vec3 v_normal;\n#if USE_NORMALMAP\nvarying mediump vec3 v_tangent;\nvarying mediump vec3 v_binormal;\n#endif\nvarying mediump vec2 uvw;\nvarying mediump vec2 uv0;\nvarying mediump vec2 uv1;\nvarying mediump vec2 uv2;\nvarying mediump vec2 uv3;\nvarying mediump vec3 diffuse;\nvarying mediump vec3 luv;\nuniform vec4 metallic;\nuniform vec4 roughness;\nuniform sampler2D weightMap;\nuniform sampler2D detailMap0;\nuniform sampler2D detailMap1;\nuniform sampler2D detailMap2;\nuniform sampler2D detailMap3;\nuniform sampler2D normalMap0;\nuniform sampler2D normalMap1;\nuniform sampler2D normalMap2;\nuniform sampler2D normalMap3;\nuniform sampler2D lightMap;\nvoid surf (out StandardSurface s) {\n#if LAYERS > 1\nvec4 w = texture2D(weightMap, uvw);\n#endif\nvec4 baseColor = vec4(0, 0, 0, 0);\n#if LAYERS == 1\nbaseColor = texture2D(detailMap0, uv0);\n#elif LAYERS == 2\nbaseColor += texture2D(detailMap0, uv0) * w.r;\nbaseColor += texture2D(detailMap1, uv1) * w.g;\n#elif LAYERS == 3\nbaseColor += texture2D(detailMap0, uv0) * w.r;\nbaseColor += texture2D(detailMap1, uv1) * w.g;\nbaseColor += texture2D(detailMap2, uv2) * w.b;\n#elif LAYERS == 4\nbaseColor += texture2D(detailMap0, uv0) * w.r;\nbaseColor += texture2D(detailMap1, uv1) * w.g;\nbaseColor += texture2D(detailMap2, uv2) * w.b;\nbaseColor += texture2D(detailMap3, uv3) * w.a;\n#else\nbaseColor = texture2D(detailMap0, uv0);\n#endif\ns.position = v_position;\n#if USE_NORMALMAP\nvec4 baseNormal = vec4(0, 0, 0, 0);\n#if LAYERS == 1\nbaseNormal = texture2D(normalMap0, uv0);\n#elif LAYERS == 2\nbaseNormal += texture2D(normalMap0, uv0) * w.r;\nbaseNormal += texture2D(normalMap1, uv1) * w.g;\n#elif LAYERS == 3\nbaseNormal += texture2D(normalMap0, uv0) * w.r;\nbaseNormal += texture2D(normalMap1, uv1) * w.g;\nbaseNormal += texture2D(normalMap2, uv2) * w.b;\n#elif LAYERS == 4\nbaseNormal += texture2D(normalMap0, uv0) * w.r;\nbaseNormal += texture2D(normalMap1, uv1) * w.g;\nbaseNormal += texture2D(normalMap2, uv2) * w.b;\nbaseNormal += texture2D(normalMap3, uv3) * w.a;\n#else\nbaseNormal = texture2D(normalMap0, uv0);\n#endif\nvec3 nmmp = baseNormal.xyz - vec3(0.5);\ns.normal =\nnmmp.x * normalize(v_tangent) +\nnmmp.y * normalize(v_binormal) +\nnmmp.z * normalize(v_normal);\n#else\ns.normal = v_normal;\n#endif\ns.albedo = vec4(SRGBToLinear(baseColor.rgb), 1.0);\ns.occlusion = 1.0;\n#if USE_PBR\ns.roughness = 0.0;\n#if LAYERS == 1\ns.roughness = roughness.x;\n#elif LAYERS == 2\ns.roughness += roughness.x * w.r;\ns.roughness += roughness.y * w.g;\n#elif LAYERS == 3\ns.roughness += roughness.x * w.r;\ns.roughness += roughness.y * w.g;\ns.roughness += roughness.z * w.b;\n#elif LAYERS == 4\ns.roughness += roughness.x * w.r;\ns.roughness += roughness.y * w.g;\ns.roughness += roughness.z * w.b;\ns.roughness += roughness.w * w.a;\n#else\ns.roughness = 1.0;\n#endif\ns.metallic = 0.0;\n#if LAYERS == 1\ns.metallic = metallic.x;\n#elif LAYERS == 2\ns.metallic += metallic.x * w.r;\ns.metallic += metallic.y * w.g;\n#elif LAYERS == 3\ns.metallic += metallic.x * w.r;\ns.metallic += metallic.y * w.g;\ns.metallic += metallic.z * w.b;\n#elif LAYERS == 4\ns.metallic += metallic.x * w.r;\ns.metallic += metallic.y * w.g;\ns.metallic += metallic.z * w.b;\ns.metallic += metallic.w * w.a;\n#else\ns.metallic = 0.0;\n#endif\n#else\ns.roughness = 1.0;\ns.metallic = 0.0;\n#endif\ns.emissive = vec3(0.0, 0.0, 0.0);\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nvec4 lightColor = texture2D(lightMap, luv.xy);\ns.lightmap = UnpackLightingmap(lightColor);\ns.lightmap_test = luv.z;\n#endif\n}\n#if CC_FORWARD_ADD\n#if CC_PIPELINE_TYPE == 0\n# define LIGHTS_PER_PASS 1\n#else\n# define LIGHTS_PER_PASS 10\n#endif\nuniform highp vec4 cc_lightPos[LIGHTS_PER_PASS];\nuniform vec4 cc_lightColor[LIGHTS_PER_PASS];\nuniform vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\nuniform vec4 cc_lightDir[LIGHTS_PER_PASS];\nfloat SmoothDistAtt (float distSqr, float invSqrAttRadius) {\nfloat factor = distSqr * invSqrAttRadius;\nfloat smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\nreturn smoothFactor * smoothFactor;\n}\nfloat GetDistAtt (float distSqr, float invSqrAttRadius) {\nfloat attenuation = 1.0 / max(distSqr, 0.01*0.01);\nattenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\nreturn attenuation;\n}\nfloat GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\nfloat cd = dot(litDir, L);\nfloat attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\nreturn (attenuation * attenuation);\n}\nvec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\nvec3 diffuseContrib = diffuse / 3.14159265359;\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - s.position);\nfloat NV = max(abs(dot(N, V)), 0.001);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 finalColor = vec3(0.0);\nint numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\nfor (int i = 0; i < LIGHTS_PER_PASS; i++) {\nif (i >= numLights) break;\nvec3 SLU = cc_lightPos[i].xyz - s.position;\nvec3 SL = normalize(SLU);\nvec3 SH = normalize(SL + V);\nfloat SNL = max(dot(N, SL), 0.001);\nfloat SNH = max(dot(N, SH), 0.0);\nfloat distSqr = dot(SLU, SLU);\nfloat litRadius = cc_lightSizeRangeAngle[i].x;\nfloat litRadiusSqr = litRadius * litRadius;\nfloat illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\nfloat attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\nattRadiusSqrInv *= attRadiusSqrInv;\nfloat att = GetDistAtt(distSqr, attRadiusSqrInv);\nvec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\nif (cc_lightPos[i].w > 0.0) {\nfloat cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\nfloat cosOuter = cc_lightSizeRangeAngle[i].z;\nfloat litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\nfloat litAngleOffset = -cosOuter * litAngleScale;\natt *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n}\nvec3 lightColor = cc_lightColor[i].rgb;\nfloat shadow = 1.0;\n#if CC_RECEIVE_SHADOW\nif (cc_lightPos[i].w > 0.0) {\n{\nfloat pcf = cc_shadowWHPBInfo.z;\nfloat cosAngle = clamp(1.0 - dot(N, normalize(cc_lightPos[i].xyz - s.position.xyz)), 0.0, 1.0);\nvec3 projWorldPos = shadowPos.xyz + cosAngle * cc_shadowLPNNInfo.z * N;\nvec4 pos = vec4(projWorldPos.xyz, shadowPos.w);\nif (pcf > 1.9) shadow = CCGetSpotLightShadowFactorSoft2X(pos, s.position);\nelse if (pcf > 0.9) shadow = CCGetSpotLightShadowFactorSoft(pos, s.position);\nelse shadow = CCGetSpotLightShadowFactorHard(pos, s.position);\n}\n}\n#endif\nlightColor *= shadow;\nfinalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n}\nreturn vec4(finalColor, 0.0);\n}\nvoid main () {\nStandardSurface s; surf(s);\nvec4 color = CCStandardShadingAdditive(s, v_shadowPos);\ncolor = vec4(mix(CC_FORWARD_ADD > 0 ? vec3(0.0) : cc_fogColor.rgb, color.rgb, v_fog_factor), color.a);\ngl_FragData[0] = CCFragOutput(color);\n}\n#elif CC_PIPELINE_TYPE == 0\nvoid main () {\nStandardSurface s; surf(s);\nvec4 color = CCStandardShadingBase(s, v_shadowPos);\ncolor = vec4(mix(CC_FORWARD_ADD > 0 ? vec3(0.0) : cc_fogColor.rgb, color.rgb, v_fog_factor), color.a);\ngl_FragData[0] = CCFragOutput(color);\n}\n#elif CC_PIPELINE_TYPE == 1\nvoid main () {\nStandardSurface s; surf(s);\ngl_FragData[0] = s.albedo;\ngl_FragData[1] = vec4(s.position, s.roughness);\ngl_FragData[2] = vec4(s.normal, s.metallic);\ngl_FragData[3] = vec4(s.emissive, s.occlusion);\n}\n#endif"
}, {
  "vert": "\nprecision highp float;\nuniform highp mat4 cc_matWorld;\nuniform highp mat4 cc_matLightViewProj;\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nvarying vec2 v_clip_depth;\nvec4 vert () {\nvec4 worldPos;\nworldPos.x = cc_matWorld[3][0] + a_position.x;\nworldPos.y = cc_matWorld[3][1] + a_position.y;\nworldPos.z = cc_matWorld[3][2] + a_position.z;\nworldPos.w = 1.0;\nvec4 clipPos = cc_matLightViewProj * worldPos;\nv_clip_depth = clipPos.zw;\nreturn clipPos;\n}\nvoid main() { gl_Position = vert(); }",
  "frag": "\nprecision highp float;\nvec4 packDepthToRGBA (float depth) {\nvec4 ret = vec4(1.0, 255.0, 65025.0, 160581375.0) * depth;\nret = fract(ret);\nret -= ret.yzww * vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0);\nreturn ret;\n}\nvarying vec2 v_clip_depth;\nvec4 frag () {\nreturn packDepthToRGBA(v_clip_depth.x / v_clip_depth.y * 0.5 + 0.5);\n}\nvoid main() { gl_FragColor = frag(); }"
}], [{
  "vert": "\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\nrgba = rgba * 255.0;\nhighp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\nhighp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\nhighp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\nreturn Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_MORPH\nattribute float a_vertexId;\nint getVertexId() {\nreturn int(a_vertexId);\n}\nuniform vec4 cc_displacementWeights[15];\nuniform vec4 cc_displacementTextureInfo;\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\nfloat pixelIndexF = float(pixelIndex);\nfloat x = mod(pixelIndexF, textureResolution.x);\nfloat y = floor(pixelIndexF / textureResolution.x);\nreturn vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\nreturn (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\nreturn texture2D(tex, uv);\n}\n#else\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex * 4;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\nreturn vec4(\ndecode32(texture2D(tex, x)),\ndecode32(texture2D(tex, y)),\ndecode32(texture2D(tex, z)),\n1.0\n);\n}\n#endif\nfloat getDisplacementWeight(int index) {\nint quot = index / 4;\nint remainder = index - quot * 4;\nif (remainder == 0) {\nreturn cc_displacementWeights[quot].x;\n} else if (remainder == 1) {\nreturn cc_displacementWeights[quot].y;\n} else if (remainder == 2) {\nreturn cc_displacementWeights[quot].z;\n} else {\nreturn cc_displacementWeights[quot].w;\n}\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\nreturn fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\nvec3 result = vec3(0, 0, 0);\nint nVertices = int(cc_displacementTextureInfo.z);\nfor (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\nresult += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n}\nreturn result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\nuniform sampler2D cc_PositionDisplacements;\nvec3 getPositionDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nuniform sampler2D cc_NormalDisplacements;\nvec3 getNormalDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nuniform sampler2D cc_TangentDisplacements;\nvec3 getTangentDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n}\n#endif\nvoid applyMorph (inout StandardVertInput attr) {\nint vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\nattr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nattr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nattr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\nattribute vec4 a_joints;\nattribute vec4 a_weights;\n#if CC_USE_BAKED_ANIMATION\n#if USE_INSTANCING\nattribute highp vec4 a_jointAnimInfo;\n#endif\nuniform highp vec4 cc_jointTextureInfo;\nuniform highp vec4 cc_jointAnimInfo;\nuniform highp sampler2D cc_jointTexture;\n#else\nuniform highp vec4 cc_joints[90];\n#endif\n#if CC_USE_BAKED_ANIMATION\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nmat4 getJointMatrix (float i) {\n#if USE_INSTANCING\nhighp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n#else\nhighp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n#endif\nhighp float invSize = cc_jointTextureInfo.w;\nhighp float y = floor(j * invSize);\nhighp float x = floor(j - y * cc_jointTextureInfo.x);\ny = (y + 0.5) * invSize;\nvec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\nvec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\nvec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#else\nmat4 getJointMatrix (float i) {\n#if USE_INSTANCING\nhighp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n#else\nhighp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n#endif\nhighp float invSize = cc_jointTextureInfo.w;\nhighp float y = floor(j * invSize);\nhighp float x = floor(j - y * cc_jointTextureInfo.x);\ny = (y + 0.5) * invSize;\nvec4 v1 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n);\nvec4 v2 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n);\nvec4 v3 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n);\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\n#else\nmat4 getJointMatrix (float i) {\nint idx = int(i);\nvec4 v1 = cc_joints[idx * 3];\nvec4 v2 = cc_joints[idx * 3 + 1];\nvec4 v3 = cc_joints[idx * 3 + 2];\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\nmat4 skinMatrix () {\nvec4 joints = vec4(a_joints);\nreturn getJointMatrix(joints.x) * a_weights.x\n+ getJointMatrix(joints.y) * a_weights.y\n+ getJointMatrix(joints.z) * a_weights.z\n+ getJointMatrix(joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\nmat4 m = skinMatrix();\nposition = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\nmat4 m = skinMatrix();\nattr.position = m * attr.position;\nattr.normal = (m * vec4(attr.normal, 0.0)).xyz;\nattr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\nuniform highp mat4 cc_matView;\nuniform highp mat4 cc_matProj;\nuniform highp vec4 cc_cameraPos;\nuniform mediump vec4 cc_fogBase;\nuniform mediump vec4 cc_fogAdd;\n#if USE_INSTANCING\nattribute vec4 a_matWorld0;\nattribute vec4 a_matWorld1;\nattribute vec4 a_matWorld2;\n#if USE_LIGHTMAP\nattribute vec4 a_lightingMapUVParam;\n#endif\n#elif USE_BATCHING\nattribute float a_dyn_batch_id;\nuniform highp mat4 cc_matWorlds[10];\n#else\nuniform highp mat4 cc_matWorld;\n#endif\nfloat LinearFog(vec4 pos) {\nvec4 wPos = pos;\nfloat cam_dis = distance(cc_cameraPos, wPos);\nfloat fogStart = cc_fogBase.x;\nfloat fogEnd = cc_fogBase.y;\nreturn clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\nfloat f = exp(-cam_dis * fogDensity);\nreturn f;\n}\nfloat ExpSquaredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\nfloat f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\nreturn f;\n}\nfloat LayeredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat _FogTop = cc_fogAdd.x;\nfloat _FogRange = cc_fogAdd.y;\nvec3 camWorldProj = cc_cameraPos.xyz;\ncamWorldProj.y = 0.;\nvec3 worldPosProj = wPos.xyz;\nworldPosProj.y = 0.;\nfloat fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\nfloat fDeltaY, fDensityIntegral;\nif (cc_cameraPos.y > _FogTop) {\nif (wPos.y < _FogTop) {\nfDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\nfDensityIntegral = fDeltaY * fDeltaY * 0.5;\n} else {\nfDeltaY = 0.;\nfDensityIntegral = 0.;\n}\n} else {\nif (wPos.y < _FogTop) {\nfloat fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfloat fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\nfDeltaY = abs(fDeltaA - fDeltaB);\nfDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n} else {\nfDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n}\n}\nfloat fDensity;\nif (fDeltaY != 0.) {\nfDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n} else {\nfDensity = 0.;\n}\nfloat f = exp(-fDensity);\nreturn f;\n}\nvarying float v_fog_factor;\n#if USE_VERTEX_COLOR\nattribute lowp vec4 a_color;\nvarying lowp vec4 v_color;\n#endif\n#if USE_TEXTURE\nvarying vec2 v_uv;\nuniform vec4 tilingOffset;\n#endif\nvec4 vert () {\nvec4 position;\nposition = vec4(a_position, 1.0);\n#if CC_USE_MORPH\napplyMorph(position);\n#endif\n#if CC_USE_SKINNING\nCCSkin(position);\n#endif\nmat4 matWorld;\n#if USE_INSTANCING\nmatWorld = mat4(\nvec4(a_matWorld0.xyz, 0.0),\nvec4(a_matWorld1.xyz, 0.0),\nvec4(a_matWorld2.xyz, 0.0),\nvec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n);\n#elif USE_BATCHING\nmatWorld = cc_matWorlds[int(a_dyn_batch_id)];\n#else\nmatWorld = cc_matWorld;\n#endif\n#if USE_TEXTURE\nv_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n#if SAMPLE_FROM_RT\nv_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n#endif\n#endif\n#if USE_VERTEX_COLOR\nv_color = a_color;\n#endif\n#if CC_USE_FOG == 0\nv_fog_factor = LinearFog(matWorld * position);\n#elif CC_USE_FOG == 1\nv_fog_factor = ExpFog(matWorld * position);\n#elif CC_USE_FOG == 2\nv_fog_factor = ExpSquaredFog(matWorld * position);\n#elif CC_USE_FOG == 3\nv_fog_factor = LayeredFog(matWorld * position);\n#else\nv_fog_factor = 1.0;\n#endif\nreturn cc_matProj * (cc_matView * matWorld) * position;\n}\nvoid main() { gl_Position = vert(); }",
  "frag": "\nprecision highp float;\nuniform mediump vec4 cc_exposure;\nuniform mediump vec4 cc_fogColor;\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n#if CC_USE_HDR\ncolor.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n#endif\nreturn color;\n}\nvarying float v_fog_factor;\n#if USE_ALPHA_TEST\n#endif\n#if USE_TEXTURE\nvarying vec2 v_uv;\nuniform sampler2D mainTexture;\n#endif\nuniform vec4 mainColor;\nuniform vec4 colorScaleAndCutoff;\n#if USE_VERTEX_COLOR\nvarying lowp vec4 v_color;\n#endif\nvec4 frag () {\nvec4 o = mainColor;\no.rgb *= colorScaleAndCutoff.xyz;\n#if USE_VERTEX_COLOR\no *= v_color;\n#endif\n#if USE_TEXTURE\no *= texture2D(mainTexture, v_uv);\n#endif\n#if USE_ALPHA_TEST\nif (o.ALPHA_TEST_CHANNEL < colorScaleAndCutoff.w) discard;\n#endif\no = vec4(mix(CC_FORWARD_ADD > 0 ? vec3(0.0) : cc_fogColor.rgb, o.rgb, v_fog_factor), o.a);\nreturn CCFragOutput(o);\n}\nvoid main() { gl_FragColor = frag(); }"
}], [{
  "vert": "\nprecision highp float;\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\nuniform highp vec4 cc_cameraPos;\nvarying vec2 v_uv;\nvoid main () {\nvec4 position;\nposition = vec4(a_position, 1.0);\nposition.xy = cc_cameraPos.w == 0.0 ? vec2(position.xy.x, -position.xy.y) : position.xy;\ngl_Position = vec4(position.x, position.y, 1.0, 1.0);\nv_uv = a_texCoord;\n}",
  "frag": "\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod: enable\n#endif\nprecision highp float;\nuniform highp vec4 cc_cameraPos;\nuniform mediump vec4 cc_exposure;\nuniform mediump vec4 cc_mainLitDir;\nuniform mediump vec4 cc_mainLitColor;\nuniform mediump vec4 cc_ambientSky;\nuniform mediump vec4 cc_ambientGround;\nuniform mediump vec4 cc_fogColor;\nuniform mediump vec4 cc_fogBase;\nuniform mediump vec4 cc_fogAdd;\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nuniform highp mat4 cc_matLightView;\nuniform highp mat4 cc_matLightViewProj;\nuniform lowp vec4 cc_shadowNFLSInfo;\nuniform lowp vec4 cc_shadowWHPBInfo;\nuniform lowp vec4 cc_shadowLPNNInfo;\n#if CC_RECEIVE_SHADOW\nuniform sampler2D cc_shadowMap;\nuniform sampler2D cc_spotLightingMap;\nfloat CCGetLinearDepth (vec3 worldPos) {\nvec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\nfloat dist = length(viewStartPos.xyz);\nreturn cc_shadowNFLSInfo.x + (-dist / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x));\n}\nfloat CCGetShadowFactorHard (vec4 shadowPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat shadow = 0.0;\nfloat closestDepth = 0.0;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nclosestDepth = dot(texture2D(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n} else {\nclosestDepth = texture2D(cc_shadowMap, clipPos.xy).x;\n}\nshadow = step(clipPos.z- cc_shadowWHPBInfo.w, closestDepth);\nreturn shadow;\n}\nfloat CCGetShadowFactorSoft (vec4 shadowPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat offsetDepth = clipPos.z - cc_shadowWHPBInfo.w;\nvec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;\nvec2 clipPos_offset = clipPos.xy + oneTap;\nfloat block0, block1, block2, block3;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nblock0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\n} else {\nblock0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\nblock1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);\nblock2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);\nblock3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n}\nfloat coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block2, block3, coefX);\nfloat coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;\nreturn mix(resultX, resultY, coefY);\n}\nfloat CCGetShadowFactorSoft2X (vec4 shadowPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat bias = cc_shadowWHPBInfo.w;\nfloat offsetDepth = clipPos.z - bias;\nvec2 mapSize = cc_shadowWHPBInfo.xy;\nvec2 oneTap = 1.0 / mapSize;\nfloat clipPos_offset_L = clipPos.x - oneTap.x;\nfloat clipPos_offset_R = clipPos.x + oneTap.x;\nfloat clipPos_offset_U = clipPos.y - oneTap.y;\nfloat clipPos_offset_D = clipPos.y + oneTap.y;\nfloat block0, block1, block2, block3, block4, block5, block6, block7, block8;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nblock0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock4 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock5 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock6 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock7 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock8 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\n} else {\nblock0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\nblock1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);\nblock2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\nblock3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);\nblock4 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\nblock5 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);\nblock6 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\nblock7 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);\nblock8 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n}\nfloat coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\nfloat coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\nfloat shadow = 0.0;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block3, block4, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block1, block2, coefX);\nresultY = mix(block4, block5, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block3, block4, coefX);\nresultY = mix(block6, block7, coefX);\nshadow += mix(resultX, resultY, coefY);\nresultX = mix(block4, block5, coefX);\nresultY = mix(block7, block8, coefX);\nshadow += mix(resultX, resultY, coefY);\nreturn shadow * 0.25;\n}\nfloat CCGetSpotLightShadowFactorHard (vec4 shadowPos, vec3 worldPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat shadow = 0.0;\nfloat closestDepth = 0.0;\nfloat depth = 0.0;\nif (cc_shadowNFLSInfo.z > 0.000001) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nif (cc_shadowLPNNInfo.y > 0.000001) {\nclosestDepth = dot(texture2D(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n} else {\nclosestDepth = texture2D(cc_spotLightingMap, clipPos.xy).x;\n}\nshadow = step(depth - cc_shadowWHPBInfo.w, closestDepth);\nreturn shadow;\n}\nfloat CCGetSpotLightShadowFactorSoft (vec4 shadowPos, vec3 worldPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat offsetx = 1.0 / cc_shadowWHPBInfo.x;\nfloat offsety = 1.0 / cc_shadowWHPBInfo.y;\nfloat shadow = 0.0;\nfloat depth = 0.0;\nif (cc_shadowNFLSInfo.z > 0.000001) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nfloat offsetDepth = depth - cc_shadowWHPBInfo.w;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nfloat closestDepth = dot(texture2D(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = dot(texture2D(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = dot(texture2D(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = dot(texture2D(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(offsetDepth, closestDepth);\n} else {\nfloat closestDepth = texture2D(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y - offsety)).x;\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = texture2D(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y + offsety)).x;\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x;\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = texture2D(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y - offsety)).x;\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = texture2D(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y + offsety)).x;\nshadow += step(offsetDepth, closestDepth);\n}\nreturn shadow / 5.0;\n}\nfloat CCGetSpotLightShadowFactorSoft2X (vec4 shadowPos, vec3 worldPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat offsetx = 1.0 / cc_shadowWHPBInfo.x;\nfloat offsety = 1.0 / cc_shadowWHPBInfo.y;\nfloat shadow = 0.0;\nfloat depth = 0.0;\nif (cc_shadowNFLSInfo.z > 0.000001) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nfloat offsetDepth = depth - cc_shadowWHPBInfo.w;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nfor (int i = -1; i <= 1; i++) {\nfor (int j = -1; j <= 1; j++) {\nfloat closestDepth = dot(texture2D(cc_spotLightingMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(offsetDepth, closestDepth);\n}\n}\n} else {\nfor (int i = -1; i <= 1; i++) {\nfor (int j = -1; j <= 1; j++) {\nfloat closestDepth = texture2D(cc_spotLightingMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)).x;\nshadow += step(offsetDepth, closestDepth);\n}\n}\n}\nreturn shadow / 9.0;\n}\n#endif\n#if CC_USE_IBL\nuniform samplerCube cc_environment;\nvec3 unpackRGBE (vec4 rgbe) {\nreturn rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n}\nvec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n#ifdef GL_EXT_shader_texture_lod\nreturn texture2DLodEXT(tex, coord, lod);\n#else\nreturn texture2D(tex, coord, lod);\n#endif\n}\nvec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n#ifdef GL_EXT_shader_texture_lod\nreturn textureCubeLodEXT(tex, coord, lod);\n#else\nreturn textureCube(tex, coord, lod);\n#endif\n}\n#endif\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\nvec3 NxH = cross(N, H);\nfloat OneMinusNoHSqr = dot(NxH, NxH);\nfloat a = roughness * roughness;\nfloat n = NoH * a;\nfloat p = a / (OneMinusNoHSqr + n * n);\nreturn p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\nreturn (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\nconst vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\nconst vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\nvec4 r = roughness * c0 + c1;\nfloat a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\nvec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\nAB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\nreturn specular * AB.x + AB.y;\n}\nstruct StandardSurface {\nvec4 albedo;\nvec3 position;\nvec3 normal;\nvec3 emissive;\nvec3 lightmap;\nfloat lightmap_test;\nfloat roughness;\nfloat metallic;\nfloat occlusion;\n};\nvec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - s.position);\nfloat NV = max(abs(dot(N, V)), 0.0);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 L = normalize(-cc_mainLitDir.xyz);\nvec3 H = normalize(L + V);\nfloat NH = max(dot(N, H), 0.0);\nfloat NL = max(dot(N, L), 0.0);\nvec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\nvec3 diffuseContrib = diffuse;\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nif (s.lightmap_test > 0.0001) {\nfinalColor = s.lightmap.rgb;\n}\n#else\ndiffuseContrib /= 3.14159265359;\n#endif\nvec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\nvec3 dirlightContrib = (diffuseContrib + specularContrib);\nfloat shadow = 1.0;\n#if CC_RECEIVE_SHADOW\nif (NL > 0.0) {\n{\nfloat pcf = cc_shadowWHPBInfo.z;\nvec3 projWorldPos = shadowPos.xyz + (1.0 - NL) * cc_shadowLPNNInfo.z * N;\nvec4 pos = vec4(projWorldPos.xyz, shadowPos.w);\nif (pcf > 1.9) shadow = CCGetShadowFactorSoft2X(pos);\nelse if (pcf > 0.9) shadow = CCGetShadowFactorSoft(pos);\nelse shadow = CCGetShadowFactorHard(pos);\nshadow = mix(shadow, 1.0, cc_shadowNFLSInfo.w);\n}\n}\n#endif\ndirlightContrib *= shadow;\nfinalColor *= dirlightContrib;\nfloat fAmb = 0.5 - N.y * 0.5;\nvec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb) * cc_ambientSky.w;\nfinalColor += (ambDiff.rgb * diffuse) * s.occlusion;\n#if CC_USE_IBL\nvec3 R = normalize(reflect(-V, N));\nvec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n#if CC_USE_IBL == 2\nvec3 env = unpackRGBE(envmap);\n#else\nvec3 env = SRGBToLinear(envmap.rgb);\n#endif\nfinalColor += env * cc_ambientSky.w * specular * s.occlusion;\n#endif\n#if CC_USE_HDR\ns.emissive *= cc_exposure.w;\n#endif\nfinalColor += s.emissive;\nreturn vec4(finalColor, s.albedo.a);\n}\n#if CC_PIPELINE_TYPE == 0\n# define LIGHTS_PER_PASS 1\n#else\n# define LIGHTS_PER_PASS 10\n#endif\nuniform highp vec4 cc_lightPos[LIGHTS_PER_PASS];\nuniform vec4 cc_lightColor[LIGHTS_PER_PASS];\nuniform vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\nuniform vec4 cc_lightDir[LIGHTS_PER_PASS];\nfloat SmoothDistAtt (float distSqr, float invSqrAttRadius) {\nfloat factor = distSqr * invSqrAttRadius;\nfloat smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\nreturn smoothFactor * smoothFactor;\n}\nfloat GetDistAtt (float distSqr, float invSqrAttRadius) {\nfloat attenuation = 1.0 / max(distSqr, 0.01*0.01);\nattenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\nreturn attenuation;\n}\nfloat GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\nfloat cd = dot(litDir, L);\nfloat attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\nreturn (attenuation * attenuation);\n}\nvec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\nvec3 diffuseContrib = diffuse / 3.14159265359;\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - s.position);\nfloat NV = max(abs(dot(N, V)), 0.001);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 finalColor = vec3(0.0);\nint numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\nfor (int i = 0; i < LIGHTS_PER_PASS; i++) {\nif (i >= numLights) break;\nvec3 SLU = cc_lightPos[i].xyz - s.position;\nvec3 SL = normalize(SLU);\nvec3 SH = normalize(SL + V);\nfloat SNL = max(dot(N, SL), 0.001);\nfloat SNH = max(dot(N, SH), 0.0);\nfloat distSqr = dot(SLU, SLU);\nfloat litRadius = cc_lightSizeRangeAngle[i].x;\nfloat litRadiusSqr = litRadius * litRadius;\nfloat illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\nfloat attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\nattRadiusSqrInv *= attRadiusSqrInv;\nfloat att = GetDistAtt(distSqr, attRadiusSqrInv);\nvec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\nif (cc_lightPos[i].w > 0.0) {\nfloat cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\nfloat cosOuter = cc_lightSizeRangeAngle[i].z;\nfloat litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\nfloat litAngleOffset = -cosOuter * litAngleScale;\natt *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n}\nvec3 lightColor = cc_lightColor[i].rgb;\nfloat shadow = 1.0;\n#if CC_RECEIVE_SHADOW\nif (cc_lightPos[i].w > 0.0) {\n{\nfloat pcf = cc_shadowWHPBInfo.z;\nfloat cosAngle = clamp(1.0 - dot(N, normalize(cc_lightPos[i].xyz - s.position.xyz)), 0.0, 1.0);\nvec3 projWorldPos = shadowPos.xyz + cosAngle * cc_shadowLPNNInfo.z * N;\nvec4 pos = vec4(projWorldPos.xyz, shadowPos.w);\nif (pcf > 1.9) shadow = CCGetSpotLightShadowFactorSoft2X(pos, s.position);\nelse if (pcf > 0.9) shadow = CCGetSpotLightShadowFactorSoft(pos, s.position);\nelse shadow = CCGetSpotLightShadowFactorHard(pos, s.position);\n}\n}\n#endif\nlightColor *= shadow;\nfinalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n}\nreturn vec4(finalColor, 0.0);\n}\nvec3 ACESToneMap (vec3 color) {\ncolor = min(color, vec3(8.0));\nconst float A = 2.51;\nconst float B = 0.03;\nconst float C = 2.43;\nconst float D = 0.59;\nconst float E = 0.14;\nreturn (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n#if !CC_USE_HDR\ncolor.rgb = sqrt(ACESToneMap(color.rgb));\n#endif\nreturn color;\n}\nfloat LinearFog(vec4 pos) {\nvec4 wPos = pos;\nfloat cam_dis = distance(cc_cameraPos, wPos);\nfloat fogStart = cc_fogBase.x;\nfloat fogEnd = cc_fogBase.y;\nreturn clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\nfloat f = exp(-cam_dis * fogDensity);\nreturn f;\n}\nfloat ExpSquaredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\nfloat f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\nreturn f;\n}\nfloat LayeredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat _FogTop = cc_fogAdd.x;\nfloat _FogRange = cc_fogAdd.y;\nvec3 camWorldProj = cc_cameraPos.xyz;\ncamWorldProj.y = 0.;\nvec3 worldPosProj = wPos.xyz;\nworldPosProj.y = 0.;\nfloat fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\nfloat fDeltaY, fDensityIntegral;\nif (cc_cameraPos.y > _FogTop) {\nif (wPos.y < _FogTop) {\nfDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\nfDensityIntegral = fDeltaY * fDeltaY * 0.5;\n} else {\nfDeltaY = 0.;\nfDensityIntegral = 0.;\n}\n} else {\nif (wPos.y < _FogTop) {\nfloat fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfloat fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\nfDeltaY = abs(fDeltaA - fDeltaB);\nfDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n} else {\nfDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n}\n}\nfloat fDensity;\nif (fDeltaY != 0.) {\nfDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n} else {\nfDensity = 0.;\n}\nfloat f = exp(-fDensity);\nreturn f;\n}\nvarying vec2 v_uv;\nuniform sampler2D cc_gbuffer_albedoMap;\nuniform sampler2D cc_gbuffer_positionMap;\nuniform sampler2D cc_gbuffer_normalMap;\nuniform sampler2D cc_gbuffer_emissiveMap;\nvoid main () {\nStandardSurface s;\nvec4 albedoMap = texture2D(cc_gbuffer_albedoMap,v_uv);\nvec4 positionMap = texture2D(cc_gbuffer_positionMap,v_uv);\nvec4 normalMap = texture2D(cc_gbuffer_normalMap,v_uv);\nvec4 emissiveMap = texture2D(cc_gbuffer_emissiveMap,v_uv);\ns.albedo = albedoMap;\ns.position = positionMap.xyz;\ns.roughness = positionMap.w;\ns.normal = normalMap.xyz;\ns.metallic = normalMap.w;\ns.emissive = emissiveMap.xyz;\ns.occlusion = emissiveMap.w;\nfloat fogFactor;\n#if CC_USE_FOG == 0\nfogFactor = LinearFog(vec4(s.position, 1));\n#elif CC_USE_FOG == 1\nfogFactor = ExpFog(vec4(s.position, 1));\n#elif CC_USE_FOG == 2\nfogFactor = ExpSquaredFog(vec4(s.position, 1));\n#elif CC_USE_FOG == 3\nfogFactor = LayeredFog(vec4(s.position, 1));\n#else\nfogFactor = 1.0;\n#endif\nvec4 shadowPos;\nshadowPos = cc_matLightViewProj * vec4(s.position, 1);\nvec4 color = CCStandardShadingBase(s, shadowPos) +\nCCStandardShadingAdditive(s, shadowPos);\ncolor = vec4(mix(CC_FORWARD_ADD > 0 ? vec3(0.0) : cc_fogColor.rgb, color.rgb, fogFactor), color.a);\ngl_FragColor = CCFragOutput(color);\n}"
}], [{
  "vert": "\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\nrgba = rgba * 255.0;\nhighp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\nhighp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\nhighp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\nreturn Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_MORPH\nattribute float a_vertexId;\nint getVertexId() {\nreturn int(a_vertexId);\n}\nuniform vec4 cc_displacementWeights[15];\nuniform vec4 cc_displacementTextureInfo;\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\nfloat pixelIndexF = float(pixelIndex);\nfloat x = mod(pixelIndexF, textureResolution.x);\nfloat y = floor(pixelIndexF / textureResolution.x);\nreturn vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\nreturn (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\nreturn texture2D(tex, uv);\n}\n#else\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex * 4;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\nreturn vec4(\ndecode32(texture2D(tex, x)),\ndecode32(texture2D(tex, y)),\ndecode32(texture2D(tex, z)),\n1.0\n);\n}\n#endif\nfloat getDisplacementWeight(int index) {\nint quot = index / 4;\nint remainder = index - quot * 4;\nif (remainder == 0) {\nreturn cc_displacementWeights[quot].x;\n} else if (remainder == 1) {\nreturn cc_displacementWeights[quot].y;\n} else if (remainder == 2) {\nreturn cc_displacementWeights[quot].z;\n} else {\nreturn cc_displacementWeights[quot].w;\n}\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\nreturn fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\nvec3 result = vec3(0, 0, 0);\nint nVertices = int(cc_displacementTextureInfo.z);\nfor (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\nresult += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n}\nreturn result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\nuniform sampler2D cc_PositionDisplacements;\nvec3 getPositionDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nuniform sampler2D cc_NormalDisplacements;\nvec3 getNormalDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nuniform sampler2D cc_TangentDisplacements;\nvec3 getTangentDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n}\n#endif\nvoid applyMorph (inout StandardVertInput attr) {\nint vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\nattr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nattr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nattr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\nattribute vec4 a_joints;\nattribute vec4 a_weights;\n#if CC_USE_BAKED_ANIMATION\n#if USE_INSTANCING\nattribute highp vec4 a_jointAnimInfo;\n#endif\nuniform highp vec4 cc_jointTextureInfo;\nuniform highp vec4 cc_jointAnimInfo;\nuniform highp sampler2D cc_jointTexture;\n#else\nuniform highp vec4 cc_joints[90];\n#endif\n#if CC_USE_BAKED_ANIMATION\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nmat4 getJointMatrix (float i) {\n#if USE_INSTANCING\nhighp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n#else\nhighp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n#endif\nhighp float invSize = cc_jointTextureInfo.w;\nhighp float y = floor(j * invSize);\nhighp float x = floor(j - y * cc_jointTextureInfo.x);\ny = (y + 0.5) * invSize;\nvec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\nvec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\nvec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#else\nmat4 getJointMatrix (float i) {\n#if USE_INSTANCING\nhighp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n#else\nhighp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n#endif\nhighp float invSize = cc_jointTextureInfo.w;\nhighp float y = floor(j * invSize);\nhighp float x = floor(j - y * cc_jointTextureInfo.x);\ny = (y + 0.5) * invSize;\nvec4 v1 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n);\nvec4 v2 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n);\nvec4 v3 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n);\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\n#else\nmat4 getJointMatrix (float i) {\nint idx = int(i);\nvec4 v1 = cc_joints[idx * 3];\nvec4 v2 = cc_joints[idx * 3 + 1];\nvec4 v3 = cc_joints[idx * 3 + 2];\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\nmat4 skinMatrix () {\nvec4 joints = vec4(a_joints);\nreturn getJointMatrix(joints.x) * a_weights.x\n+ getJointMatrix(joints.y) * a_weights.y\n+ getJointMatrix(joints.z) * a_weights.z\n+ getJointMatrix(joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\nmat4 m = skinMatrix();\nposition = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\nmat4 m = skinMatrix();\nattr.position = m * attr.position;\nattr.normal = (m * vec4(attr.normal, 0.0)).xyz;\nattr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\nuniform highp mat4 cc_matView;\nuniform highp mat4 cc_matProj;\n#if USE_INSTANCING\nattribute vec4 a_matWorld0;\nattribute vec4 a_matWorld1;\nattribute vec4 a_matWorld2;\n#if USE_LIGHTMAP\nattribute vec4 a_lightingMapUVParam;\n#endif\n#elif USE_BATCHING\nattribute float a_dyn_batch_id;\nuniform highp mat4 cc_matWorlds[10];\n#else\nuniform highp mat4 cc_matWorld;\n#endif\nuniform highp mat4 cc_matLightPlaneProj;\nvec4 vert () {\nvec4 position;\nposition = vec4(a_position, 1.0);\n#if CC_USE_MORPH\napplyMorph(position);\n#endif\n#if CC_USE_SKINNING\nCCSkin(position);\n#endif\nmat4 matWorld;\n#if USE_INSTANCING\nmatWorld = mat4(\nvec4(a_matWorld0.xyz, 0.0),\nvec4(a_matWorld1.xyz, 0.0),\nvec4(a_matWorld2.xyz, 0.0),\nvec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n);\n#elif USE_BATCHING\nmatWorld = cc_matWorlds[int(a_dyn_batch_id)];\n#else\nmatWorld = cc_matWorld;\n#endif\nposition = cc_matProj * (cc_matView * cc_matLightPlaneProj * matWorld) * position;\nposition.z -= 0.0001;\nreturn position;\n}\nvoid main() { gl_Position = vert(); }",
  "frag": "\nprecision mediump float;\nuniform lowp vec4 cc_shadowColor;\nuniform mediump vec4 cc_exposure;\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n#if CC_USE_HDR\ncolor.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n#endif\nreturn color;\n}\nvec4 frag () {\nreturn CCFragOutput(cc_shadowColor);\n}\nvoid main() { gl_FragColor = frag(); }"
}], [{
  "vert": "\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\nrgba = rgba * 255.0;\nhighp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\nhighp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\nhighp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\nreturn Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_MORPH\nattribute float a_vertexId;\nint getVertexId() {\nreturn int(a_vertexId);\n}\nuniform vec4 cc_displacementWeights[15];\nuniform vec4 cc_displacementTextureInfo;\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\nfloat pixelIndexF = float(pixelIndex);\nfloat x = mod(pixelIndexF, textureResolution.x);\nfloat y = floor(pixelIndexF / textureResolution.x);\nreturn vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\nreturn (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\nreturn texture2D(tex, uv);\n}\n#else\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex * 4;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\nreturn vec4(\ndecode32(texture2D(tex, x)),\ndecode32(texture2D(tex, y)),\ndecode32(texture2D(tex, z)),\n1.0\n);\n}\n#endif\nfloat getDisplacementWeight(int index) {\nint quot = index / 4;\nint remainder = index - quot * 4;\nif (remainder == 0) {\nreturn cc_displacementWeights[quot].x;\n} else if (remainder == 1) {\nreturn cc_displacementWeights[quot].y;\n} else if (remainder == 2) {\nreturn cc_displacementWeights[quot].z;\n} else {\nreturn cc_displacementWeights[quot].w;\n}\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\nreturn fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\nvec3 result = vec3(0, 0, 0);\nint nVertices = int(cc_displacementTextureInfo.z);\nfor (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\nresult += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n}\nreturn result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\nuniform sampler2D cc_PositionDisplacements;\nvec3 getPositionDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nuniform sampler2D cc_NormalDisplacements;\nvec3 getNormalDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nuniform sampler2D cc_TangentDisplacements;\nvec3 getTangentDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n}\n#endif\nvoid applyMorph (inout StandardVertInput attr) {\nint vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\nattr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nattr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nattr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\nattribute vec4 a_joints;\nattribute vec4 a_weights;\n#if CC_USE_BAKED_ANIMATION\n#if USE_INSTANCING\nattribute highp vec4 a_jointAnimInfo;\n#endif\nuniform highp vec4 cc_jointTextureInfo;\nuniform highp vec4 cc_jointAnimInfo;\nuniform highp sampler2D cc_jointTexture;\n#else\nuniform highp vec4 cc_joints[90];\n#endif\n#if CC_USE_BAKED_ANIMATION\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nmat4 getJointMatrix (float i) {\n#if USE_INSTANCING\nhighp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n#else\nhighp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n#endif\nhighp float invSize = cc_jointTextureInfo.w;\nhighp float y = floor(j * invSize);\nhighp float x = floor(j - y * cc_jointTextureInfo.x);\ny = (y + 0.5) * invSize;\nvec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\nvec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\nvec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#else\nmat4 getJointMatrix (float i) {\n#if USE_INSTANCING\nhighp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n#else\nhighp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n#endif\nhighp float invSize = cc_jointTextureInfo.w;\nhighp float y = floor(j * invSize);\nhighp float x = floor(j - y * cc_jointTextureInfo.x);\ny = (y + 0.5) * invSize;\nvec4 v1 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n);\nvec4 v2 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n);\nvec4 v3 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n);\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\n#else\nmat4 getJointMatrix (float i) {\nint idx = int(i);\nvec4 v1 = cc_joints[idx * 3];\nvec4 v2 = cc_joints[idx * 3 + 1];\nvec4 v3 = cc_joints[idx * 3 + 2];\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\nmat4 skinMatrix () {\nvec4 joints = vec4(a_joints);\nreturn getJointMatrix(joints.x) * a_weights.x\n+ getJointMatrix(joints.y) * a_weights.y\n+ getJointMatrix(joints.z) * a_weights.z\n+ getJointMatrix(joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\nmat4 m = skinMatrix();\nposition = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\nmat4 m = skinMatrix();\nattr.position = m * attr.position;\nattr.normal = (m * vec4(attr.normal, 0.0)).xyz;\nattr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\nuniform highp vec4 cc_cameraPos;\nvarying vec2 v_uv;\nvoid main () {\nStandardVertInput In;\nIn.position = vec4(a_position, 1.0);\nIn.normal = a_normal;\nIn.tangent = a_tangent;\n#if CC_USE_MORPH\napplyMorph(In);\n#endif\n#if CC_USE_SKINNING\nCCSkin(In);\n#endif\nIn.position.xy = cc_cameraPos.w == 0.0 ? vec2(In.position.xy.x, -In.position.xy.y) : In.position.xy;\ngl_Position = In.position;\ngl_Position.y = gl_Position.y;\nv_uv = a_texCoord;\n}",
  "frag": "\nprecision highp float;\nuniform mediump vec4 cc_screenSize;\nvarying vec2 v_uv;\nuniform sampler2D cc_lighting_resultMap;\nvoid texcoords(vec2 fragCoord, vec2 resolution,\nout vec2 v_rgbNW, out vec2 v_rgbNE,\nout vec2 v_rgbSW, out vec2 v_rgbSE,\nout vec2 v_rgbM) {\nvec2 inverseVP = 1.0 / resolution.xy;\nv_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;\nv_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;\nv_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;\nv_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;\nv_rgbM = vec2(fragCoord * inverseVP);\n}\nvec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 resolution,\nvec2 v_rgbNW, vec2 v_rgbNE,\nvec2 v_rgbSW, vec2 v_rgbSE,\nvec2 v_rgbM) {\nvec4 color;\nmediump vec2 inverseVP = vec2(1.0 / resolution.x, 1.0 / resolution.y);\nvec3 rgbNW = texture2D(tex, v_rgbNW).xyz;\nvec3 rgbNE = texture2D(tex, v_rgbNE).xyz;\nvec3 rgbSW = texture2D(tex, v_rgbSW).xyz;\nvec3 rgbSE = texture2D(tex, v_rgbSE).xyz;\nvec4 texColor = texture2D(tex, v_rgbM);\nvec3 rgbM  = texColor.xyz;\nvec3 luma = vec3(0.299, 0.587, 0.114);\nfloat lumaNW = dot(rgbNW, luma);\nfloat lumaNE = dot(rgbNE, luma);\nfloat lumaSW = dot(rgbSW, luma);\nfloat lumaSE = dot(rgbSE, luma);\nfloat lumaM  = dot(rgbM,  luma);\nfloat lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\nfloat lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\nmediump vec2 dir;\ndir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\ndir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\nfloat dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n(0.25 * (1.0 / 8.0)), (1.0/ 128.0));\nfloat rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\ndir = min(vec2(8.0, 8.0),\nmax(vec2(-8.0, -8.0),\ndir * rcpDirMin)) * inverseVP;\nvec3 rgbA = 0.5 * (\ntexture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +\ntexture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);\nvec3 rgbB = rgbA * 0.5 + 0.25 * (\ntexture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +\ntexture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);\nfloat lumaB = dot(rgbB, luma);\nif ((lumaB < lumaMin) || (lumaB > lumaMax))\ncolor = vec4(rgbA, texColor.a);\nelse\ncolor = vec4(rgbB, texColor.a);\nreturn color;\n}\nvoid main () {\nmediump vec2 v_rgbNW;\nmediump vec2 v_rgbNE;\nmediump vec2 v_rgbSW;\nmediump vec2 v_rgbSE;\nmediump vec2 v_rgbM;\nvec2 resolution = cc_screenSize.xy;\nvec2 fragCoord = v_uv * resolution;\ntexcoords(fragCoord, resolution, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\ngl_FragColor = fxaa(cc_lighting_resultMap, fragCoord, resolution, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n}"
}], [{
  "vert": "\nprecision highp float;\nuniform highp mat4 cc_matView;\nuniform highp mat4 cc_matProj;\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\nvarying mediump vec4 viewDir;\nvec4 vert () {\nviewDir = vec4(a_position, 1.0);\nmat4 matViewRotOnly = mat4(mat3(cc_matView));\nmat4 matProj = cc_matProj;\nif (matProj[3].w > 0.0) {\nvec2 scale = vec2(48.0, 24.0);\nmatProj[0].xy *= scale;\nmatProj[1].xy *= scale;\nmatProj[2].zw = vec2(-1.0);\nmatProj[3].zw = vec2(0.0);\n}\nvec4 pos = matProj * matViewRotOnly * viewDir;\npos.z = 0.99999 * pos.w;\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",
  "frag": "\nprecision mediump float;\nuniform mediump vec4 cc_ambientSky;\nuniform samplerCube cc_environment;\nvec3 unpackRGBE (vec4 rgbe) {\nreturn rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n}\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nvec3 ACESToneMap (vec3 color) {\ncolor = min(color, vec3(8.0));\nconst float A = 2.51;\nconst float B = 0.03;\nconst float C = 2.43;\nconst float D = 0.59;\nconst float E = 0.14;\nreturn (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n#if !CC_USE_HDR\ncolor.rgb = sqrt(ACESToneMap(color.rgb));\n#endif\nreturn color;\n}\nvarying mediump vec4 viewDir;\nvec4 frag () {\n#if USE_RGBE_CUBEMAP\nvec3 c = unpackRGBE(textureCube(cc_environment, viewDir.xyz));\n#else\nvec3 c = SRGBToLinear(textureCube(cc_environment, viewDir.xyz).rgb);\n#endif\nreturn CCFragOutput(vec4(c * cc_ambientSky.w, 1.0));\n}\nvoid main() { gl_FragColor = frag(); }"
}], [{
  "vert": "\nprecision mediump float;\nuniform highp mat4 cc_matViewProj;\nattribute vec3 a_position;\nattribute vec4 a_color;\nvarying vec2 v_uv;\nuniform vec4 offset;\nuniform vec4 digits[20];\nfloat getComponent(vec4 v, float i) {\nif (i < 1.0) { return v.x; }\nelse if (i < 2.0) { return v.y; }\nelse if (i < 3.0) { return v.z; }\nelse { return v.w; }\n}\nvec4 vert () {\nvec4 position = cc_matViewProj * vec4(a_position, 1.0);\nposition.xy += offset.xy;\nv_uv = a_color.xy;\nif (a_color.z >= 0.0) {\nfloat n = getComponent(digits[int(a_color.z)], a_color.w);\nv_uv += vec2(offset.z * n, 0.0);\n}\nreturn position;\n}\nvoid main() { gl_Position = vert(); }",
  "frag": "\nprecision mediump float;\nuniform mediump vec4 cc_exposure;\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n#if CC_USE_HDR\ncolor.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n#endif\nreturn color;\n}\nvarying vec2 v_uv;\nuniform sampler2D mainTexture;\nvec4 frag () {\nreturn CCFragOutput(texture2D(mainTexture, v_uv));\n}\nvoid main() { gl_FragColor = frag(); }"
}], [{
  "vert": "\nprecision mediump float;\nattribute vec2 a_position;\nattribute vec2 a_texCoord;\nvarying vec2 v_uv;\nvarying float v_percent;\nuniform vec4 u_buffer0;\nuniform vec4 u_buffer1;\nuniform mat4 u_projection;\nvec4 vert () {\nvec2 worldPos = a_position * u_buffer1.xy + u_buffer1.zw;\nvec2 clipSpace = worldPos / u_buffer0.xy * 2.0 - 1.0;\nvec4 screenPos = u_projection * vec4(clipSpace, 0.0, 1.0);\nv_uv = a_texCoord;\nv_percent = u_buffer0.z;\nreturn screenPos;\n}\nvoid main() { gl_Position = vert(); }",
  "frag": "\nprecision mediump float;\nvarying vec2 v_uv;\nvarying float v_percent;\nuniform sampler2D mainTexture;\nvec4 frag () {\nvec4 color = texture2D(mainTexture, v_uv);\nfloat precent = clamp(v_percent, 0.0, 1.0);\ncolor.xyz *= precent;\nreturn color;\n}\nvoid main() { gl_FragColor = frag(); }"
}]];

var glsl3 = [[{
  "vert": "\nprecision mediump float;\nlayout(std140) uniform Constants {\nvec4 mainTiling_Offset;\nvec4 frameTile_velLenScale;\nvec4 scale;\n};\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\nlayout(std140) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\n};\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\nmat3 m = mat3(xAxis,yAxis,zAxis);\nfloat trace = m[0][0] + m[1][1] + m[2][2];\nvec4 quat;\nif (trace > 0.) {\nfloat s = 0.5 / sqrt(trace + 1.0);\nquat.w = 0.25 / s;\nquat.x = (m[2][1] - m[1][2]) * s;\nquat.y = (m[0][2] - m[2][0]) * s;\nquat.z = (m[1][0] - m[0][1]) * s;\n} else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\nfloat s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\nquat.w = (m[2][1] - m[1][2]) / s;\nquat.x = 0.25 * s;\nquat.y = (m[0][1] + m[1][0]) / s;\nquat.z = (m[0][2] + m[2][0]) / s;\n} else if (m[1][1] > m[2][2]) {\nfloat s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\nquat.w = (m[0][2] - m[2][0]) / s;\nquat.x = (m[0][1] + m[1][0]) / s;\nquat.y = 0.25 * s;\nquat.z = (m[1][2] + m[2][1]) / s;\n} else {\nfloat s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\nquat.w = (m[1][0] - m[0][1]) / s;\nquat.x = (m[0][2] + m[2][0]) / s;\nquat.y = (m[1][2] + m[2][1]) / s;\nquat.z = 0.25 * s;\n}\nfloat len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\nif (len > 0.) {\nlen = 1. / sqrt(len);\nquat.x = quat.x * len;\nquat.y = quat.y * len;\nquat.z = quat.z * len;\nquat.w = quat.w * len;\n}\nreturn quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\nfloat x = angle.x / 2.;\nfloat y = angle.y / 2.;\nfloat z = angle.z / 2.;\nfloat sx = sin(x);\nfloat cx = cos(x);\nfloat sy = sin(y);\nfloat cy = cos(y);\nfloat sz = sin(z);\nfloat cz = cos(z);\nvec4 quat = vec4(0);\nquat.x = sx * cy * cz + cx * sy * sz;\nquat.y = cx * sy * cz + sx * cy * sz;\nquat.z = cx * cy * sz - sx * sy * cz;\nquat.w = cx * cy * cz - sx * sy * sz;\nreturn quat;\n}\nvec4 quatMultiply (vec4 a, vec4 b){\nvec4 quat;\nquat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\nquat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\nquat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\nquat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\nreturn quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\nfloat ix = q.w * v.x + q.y * v.z - q.z * v.y;\nfloat iy = q.w * v.y + q.z * v.x - q.x * v.z;\nfloat iz = q.w * v.z + q.x * v.y - q.y * v.x;\nfloat iw = -q.x * v.x - q.y * v.y - q.z * v.z;\nv.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\nv.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\nv.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\nvec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\nvec4 rotQuat = quatMultiply(viewQuat, q);\nrotateVecFromQuat(pos, rotQuat);\nreturn pos;\n}\nout mediump vec2 uv;\nout mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n, mat4 viewInv\n) {\nvec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\nvec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\nvec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\nvec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\npos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n}\nin vec3 a_position;\nin vec2 a_texCoord;\nin vec4 a_color;\nlayout(std140) uniform builtin {\nvec4 cc_size_rotation;\n};\nvec4 vs_main() {\nvec4 pos = vec4(a_position, 1);\npos = cc_matWorld * pos;\nvec2 vertOffset = a_texCoord.xy - 0.5;\ncomputeVertPos(pos, vertOffset, quaternionFromEuler(vec3(0., 0., cc_size_rotation.z)), vec3(cc_size_rotation.xy, 0.), cc_matViewInv);\npos = cc_matViewProj * pos;\nuv = a_texCoord.xy;\ncolor = a_color;\nreturn pos;\n}\nvoid main() { gl_Position = vs_main(); }",
  "frag": "\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n#if CC_USE_HDR\ncolor.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n#endif\nreturn color;\n}\nin vec2 uv;\nin vec4 color;\nuniform sampler2D mainTexture;\nlayout(std140) uniform FragConstants {\nvec4 tintColor;\n};\nvec4 add () {\nvec4 col = 2.0 * color * tintColor * texture(mainTexture, uv);\nreturn CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = add(); }"
}], [{
  "vert": "\nprecision highp float;\nin vec3 a_position;\nvec4 vert () {\nvec4 pos = vec4(a_position, 1);\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",
  "frag": "\nprecision highp float;\nvec4 frag () {\nvec4 o = vec4(1.0);\nreturn o;\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
}], [{
  "vert": "\nprecision highp float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\nlayout(std140) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\n};\nin vec3 a_position;\nin vec4 a_color;\nout vec4 v_color;\nin float a_dist;\nout float v_dist;\nvec4 vert () {\nvec4 pos = vec4(a_position, 1);\npos = cc_matViewProj * cc_matWorld * pos;\nv_color = a_color;\nv_dist = a_dist;\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",
  "frag": "\nprecision highp float;\nin vec4 v_color;\nin float v_dist;\nvec4 frag () {\nvec4 o = v_color;\nfloat aa = fwidth(v_dist);\nfloat alpha = 1. - smoothstep(-aa, 0., abs(v_dist) - 1.0);\no.rgb *= o.a;\no *= alpha;\nreturn o;\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
}], [{
  "vert": "\nprecision mediump float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\nmat3 m = mat3(xAxis,yAxis,zAxis);\nfloat trace = m[0][0] + m[1][1] + m[2][2];\nvec4 quat;\nif (trace > 0.) {\nfloat s = 0.5 / sqrt(trace + 1.0);\nquat.w = 0.25 / s;\nquat.x = (m[2][1] - m[1][2]) * s;\nquat.y = (m[0][2] - m[2][0]) * s;\nquat.z = (m[1][0] - m[0][1]) * s;\n} else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\nfloat s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\nquat.w = (m[2][1] - m[1][2]) / s;\nquat.x = 0.25 * s;\nquat.y = (m[0][1] + m[1][0]) / s;\nquat.z = (m[0][2] + m[2][0]) / s;\n} else if (m[1][1] > m[2][2]) {\nfloat s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\nquat.w = (m[0][2] - m[2][0]) / s;\nquat.x = (m[0][1] + m[1][0]) / s;\nquat.y = 0.25 * s;\nquat.z = (m[1][2] + m[2][1]) / s;\n} else {\nfloat s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\nquat.w = (m[1][0] - m[0][1]) / s;\nquat.x = (m[0][2] + m[2][0]) / s;\nquat.y = (m[1][2] + m[2][1]) / s;\nquat.z = 0.25 * s;\n}\nfloat len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\nif (len > 0.) {\nlen = 1. / sqrt(len);\nquat.x = quat.x * len;\nquat.y = quat.y * len;\nquat.z = quat.z * len;\nquat.w = quat.w * len;\n}\nreturn quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\nfloat x2 = q.x + q.x;\nfloat y2 = q.y + q.y;\nfloat z2 = q.z + q.z;\nfloat xx = q.x * x2;\nfloat xy = q.x * y2;\nfloat xz = q.x * z2;\nfloat yy = q.y * y2;\nfloat yz = q.y * z2;\nfloat zz = q.z * z2;\nfloat wx = q.w * x2;\nfloat wy = q.w * y2;\nfloat wz = q.w * z2;\nreturn mat4(\n1. - (yy + zz), xy + wz, xz - wy, 0,\nxy - wz, 1. - (xx + zz), yz + wx, 0,\nxz + wy, yz - wx, 1. - (xx + yy), 0,\np.x, p.y, p.z, 1\n);\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\nfloat x = q.x, y = q.y, z = q.z, w = q.w;\nfloat x2 = x + x;\nfloat y2 = y + y;\nfloat z2 = z + z;\nfloat xx = x * x2;\nfloat xy = x * y2;\nfloat xz = x * z2;\nfloat yy = y * y2;\nfloat yz = y * z2;\nfloat zz = z * z2;\nfloat wx = w * x2;\nfloat wy = w * y2;\nfloat wz = w * z2;\nfloat sx = s.x;\nfloat sy = s.y;\nfloat sz = s.z;\nreturn mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n(xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n(xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\nt.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\nvec4 quat;\nquat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\nquat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\nquat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\nquat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\nreturn quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\nfloat ix = q.w * v.x + q.y * v.z - q.z * v.y;\nfloat iy = q.w * v.y + q.z * v.x - q.x * v.z;\nfloat iz = q.w * v.z + q.x * v.y - q.y * v.x;\nfloat iw = -q.x * v.x - q.y * v.y - q.z * v.z;\nv.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\nv.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\nv.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\nvec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\nvec4 rotQuat = quatMultiply(viewQuat, q);\nrotateVecFromQuat(pos, rotQuat);\nreturn pos;\n}\nlayout(std140) uniform Constants {\nvec4 mainTiling_Offset;\nvec4 frameTile_velLenScale;\nvec4 scale;\n};\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\nlayout(std140) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\n};\nout mediump vec2 uv;\nout mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n, mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n, vec3 eye\n, vec4 velocity\n, float velocityScale\n, float lengthScale\n, float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\nvec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\nvec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\nvec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\nvec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\npos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\nvec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\nvec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\npos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\nvec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\nvec3 camX = vec3(1, 0, 0);\nvec3 camY = vec3(0, 0, -1);\npos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\nvec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\nrotateVecFromQuat(viewSpaceVert, q);\nvec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\nvec3 camY = vec3(0, 1, 0);\nvec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\npos.xyz += offset;\n#else\npos.x += vertOffset.x;\npos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\nvec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\naniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\nvertIndex.y = 1. - vertIndex.y;\n#endif\nreturn (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nlayout(std140) uniform SampleConstants {\nvec4 u_sampleInfo;\n};\nlayout(std140) uniform TickConstants {\nvec4 u_worldRot;\nvec4 u_timeDelta;\n};\nin vec4 a_position_starttime;\nin vec4 a_size_uv;\nin vec4 a_rotation_uv;\nin vec4 a_color;\nin vec4 a_dir_life;\nin float a_rndSeed;\n#if CC_RENDER_MODE == 4\nin vec3 a_texCoord;\nin vec3 a_texCoord3;\nin vec3 a_normal;\nin vec4 a_color1;\n#endif\nvec3 unpackCurveData (sampler2D tex, vec2 coord) {\nvec4 a = texture(tex, coord);\nvec4 b = texture(tex, coord + u_sampleInfo.y);\nfloat c = fract(coord.x * u_sampleInfo.x);\nreturn mix(a.xyz, b.xyz, c);\n}\nvec3 unpackCurveData (sampler2D tex, vec2 coord, out float w) {\nvec4 a = texture(tex, coord);\nvec4 b = texture(tex, coord + u_sampleInfo.y);\nfloat c = fract(coord.x * u_sampleInfo.x);\nw = mix(a.w, b.w, c);\nreturn mix(a.xyz, b.xyz, c);\n}\nfloat pseudoRandom (float seed) {\nseed = mod(seed, 233280.);\nfloat q = (seed * 9301. + 49297.) / 233280.;\nreturn fract(q);\n}\n#if COLOR_OVER_TIME_MODULE_ENABLE\nuniform sampler2D color_over_time_tex0;\nlayout(std140) uniform ColorConstant {\nint u_color_mode;\n};\n#endif\n#if ROTATION_OVER_TIME_MODULE_ENABLE\nuniform sampler2D rotation_over_time_tex0;\nlayout(std140) uniform RotationConstant {\nint u_rotation_mode;\n};\n#endif\n#if SIZE_OVER_TIME_MODULE_ENABLE\nuniform sampler2D size_over_time_tex0;\nlayout(std140) uniform SizeConstant {\nint u_size_mode;\n};\n#endif\n#if FORCE_OVER_TIME_MODULE_ENABLE\nuniform sampler2D force_over_time_tex0;\nlayout(std140) uniform ForceConstant {\nint u_force_mode;\nint u_force_space;\n};\n#endif\n#if VELOCITY_OVER_TIME_MODULE_ENABLE\nuniform sampler2D velocity_over_time_tex0;\nlayout(std140) uniform VelocityConstant {\nint u_velocity_mode;\nint u_velocity_space;\n};\n#endif\n#if TEXTURE_ANIMATION_MODULE_ENABLE\nuniform sampler2D texture_animation_tex0;\nlayout(std140) uniform AnimationConstant {\nvec4 u_anim_info;\n};\n#endif\nfloat repeat (float t, float length) {\nreturn t - floor(t / length) * length;\n}\nvec4 rotateQuat (vec4 p, vec4 q) {\nvec3 iv = cross(q.xyz, p.xyz) + q.w * p.xyz;\nvec3 res = p.xyz + 2.0 * cross(q.xyz, iv);\nreturn vec4(res.xyz, p.w);\n}\nvec4 toQuat(vec3 rotation) {\nvec3 rotTmp = rotation;\nfloat mulFactor = 1.0;\nif (rotTmp.x > 10.0 * 0.5) {\nrotTmp.x -= 10.0;\nmulFactor = -1.0;\n}\nvec4 rot = vec4(rotTmp, 0.0);\nrot.w = mulFactor * sqrt(1.0 - rot.x * rot.x - rot.y * rot.y - rot.z * rot.z);\nreturn rot;\n}\nmat3 QuatToMat3(vec4 q) {\nvec3 m0 = vec3(\n1.0 - 2.0 * q.y * q.y - 2.0 * q.z * q.z,\n2.0 * q.x * q.y + 2.0 * q.w * q.z,\n2.0 * q.x * q.z - 2.0 * q.w * q.y);\nvec3 m1 = vec3(\n2.0 * q.x * q.y - 2.0 * q.w * q.z,\n1.0 - 2.0 * q.x * q.x - 2.0 * q.z * q.z,\n2.0 * q.y * q.z + 2.0 * q.w * q.x);\nvec3 m2 = vec3(\n2.0 * q.x * q.z + 2.0 * q.w * q.y,\n2.0 * q.y * q.z - 2.0 * q.w * q.x,\n1.0 - 2.0 * q.x * q.x - 2.0 * q.y * q.y);\nreturn mat3(m0, m1, m2);\n}\nvec4 Mat3ToQuat(mat3 mat) {\nfloat tr = mat[0][0] + mat[1][1] + mat[2][2];\nfloat qw, qx, qy, qz;\nif (tr > 0.0) {\nfloat S = sqrt(tr + 1.0) * 2.0;\nfloat invS = 1.0 / S;\nqw = 0.25 * S;\nqx = (mat[1][2] - mat[2][1]) * invS;\nqy = (mat[2][0] - mat[0][2]) * invS;\nqz = (mat[0][1] - mat[1][0]) * invS;\n} else if ((mat[0][0] > mat[1][1])&&(mat[0][0] > mat[2][2])) {\nfloat S = sqrt(1.0 + mat[0][0] - mat[1][1] - mat[2][2]) * 2.0;\nfloat invS = 1.0 / S;\nqw = (mat[1][2] - mat[2][1]) * invS;\nqx = 0.25 * S;\nqy = (mat[1][0] + mat[0][1]) * invS;\nqz = (mat[2][0] + mat[0][2]) * invS;\n} else if (mat[1][1] > mat[2][2]) {\nfloat S = sqrt(1.0 + mat[1][1] - mat[0][0] - mat[2][2]) * 2.0;\nfloat invS = 1.0 / S;\nqw = (mat[2][0] - mat[0][2]) * invS;\nqx = (mat[1][0] + mat[0][1]) * invS;\nqy = 0.25 * S;\nqz = (mat[2][1] + mat[1][2]) * invS;\n} else {\nfloat S = sqrt(1.0 + mat[2][2] - mat[0][0] - mat[1][1]) * 2.0;\nfloat invS = 1.0 / S;\nqw = (mat[0][1] - mat[1][0]) * invS;\nqx = (mat[2][0] + mat[0][2]) * invS;\nqy = (mat[2][1] + mat[1][2]) * invS;\nqz = 0.25 * S;\n}\nreturn vec4(qx, qy, qz, qw);\n}\nvec4 EulerToQuat(vec3 euler) {\nvec3 er = euler * 0.5;\nfloat x = er.x, y = er.y, z = er.z;\nfloat sx = sin(x);\nfloat cx = cos(x);\nfloat sy = sin(y);\nfloat cy = cos(y);\nfloat sz = sin(z);\nfloat cz = cos(z);\nvec4 quat;\nquat.x = sx * cy * cz + cx * sy * sz;\nquat.y = cx * sy * cz + sx * cy * sz;\nquat.z = cx * cy * sz - sx * sy * cz;\nquat.w = cx * cy * cz - sx * sy * sz;\nreturn quat;\n}\nvec4 gpvs_main () {\nfloat activeTime = u_timeDelta.x - a_position_starttime.w;\nfloat normalizedTime = clamp(activeTime / a_dir_life.w, 0.0, 1.0);\nvec2 timeCoord0 = vec2(normalizedTime, 0.);\nvec2 timeCoord1 = vec2(normalizedTime, 1.);\n#if CC_RENDER_MODE == 4\nvec2 vertIdx = vec2(a_texCoord.x, a_texCoord.y);\n#else\nvec2 vertIdx = vec2(a_size_uv.w, a_rotation_uv.w);\n#endif\nvec4 velocity = vec4(a_dir_life.xyz, 0.);\nvec4 pos = vec4(a_position_starttime.xyz, 1.);\nvec3 size = a_size_uv.xyz;\n#if SIZE_OVER_TIME_MODULE_ENABLE\nif (u_size_mode == 1) {\nsize *= unpackCurveData(size_over_time_tex0, timeCoord0);\n} else {\nvec3 size_0 = unpackCurveData(size_over_time_tex0, timeCoord0);\nvec3 size_1 = unpackCurveData(size_over_time_tex0, timeCoord1);\nfloat factor_s = pseudoRandom(a_rndSeed + 39825.);\nsize *= mix(size_0, size_1, factor_s);\n}\n#endif\nvec3 compScale = scale.xyz * size;\n#if FORCE_OVER_TIME_MODULE_ENABLE\nvec3 forceAnim = vec3(0.);\nif (u_force_mode == 1) {\nforceAnim = unpackCurveData(force_over_time_tex0, timeCoord0);\n} else {\nvec3 force_0 = unpackCurveData(force_over_time_tex0, timeCoord0);\nvec3 force_1 = unpackCurveData(force_over_time_tex0, timeCoord1);\nfloat factor_f =  pseudoRandom(a_rndSeed + 212165.);\nforceAnim = mix(force_0, force_1, factor_f);\n}\nvec4 forceTrack = vec4(forceAnim, 0.);\nif (u_force_space == 0) {\nforceTrack = rotateQuat(forceTrack, u_worldRot);\n}\nvelocity.xyz += forceTrack.xyz;\n#endif\n#if VELOCITY_OVER_TIME_MODULE_ENABLE\nfloat speedModifier0 = 1.;\nfloat speedModifier1 = 1.;\nvec3 velocityAnim = vec3(0.);\nif (u_velocity_mode == 1) {\nvelocityAnim = unpackCurveData(velocity_over_time_tex0, timeCoord0, speedModifier0);\n} else {\nvec3 vectory_0 = unpackCurveData(velocity_over_time_tex0, timeCoord0, speedModifier0);\nvec3 vectory_1 = unpackCurveData(velocity_over_time_tex0, timeCoord1, speedModifier1);\nfloat factor_v = pseudoRandom(a_rndSeed + 197866.);\nvelocityAnim = mix(vectory_0, vectory_1, factor_v);\nspeedModifier0 = mix(speedModifier0, speedModifier1, factor_v);\n}\nvec4 velocityTrack = vec4(velocityAnim, 0.);\nif (u_velocity_space == 0) {\nvelocityTrack = rotateQuat(velocityTrack, u_worldRot);\n}\nvelocity.xyz += velocityTrack.xyz;\nvelocity.xyz *= speedModifier0;\n#endif\npos.xyz += velocity.xyz * normalizedTime * a_dir_life.w;\n#if !CC_USE_WORLD_SPACE\npos = cc_matWorld * pos;\n#if CC_RENDER_MODE == 1\nvelocity = rotateQuat(velocity, u_worldRot);\n#endif\n#endif\nvec3 startRotation = a_rotation_uv.xyz;\nvec4 rot = toQuat(startRotation);\n#if ROTATION_OVER_TIME_MODULE_ENABLE\nif (u_rotation_mode == 1) {\nvec3 euler = unpackCurveData(rotation_over_time_tex0, timeCoord0) * normalizedTime * a_dir_life.w;\nvec4 quat = EulerToQuat(euler);\nmat3 mLocal = QuatToMat3(quat);\nmat3 mStart = QuatToMat3(rot);\nrot = Mat3ToQuat(mStart * mLocal);\n} else {\nvec3 rotation_0 = unpackCurveData(rotation_over_time_tex0, timeCoord0);\nvec3 rotation_1 = unpackCurveData(rotation_over_time_tex0, timeCoord1);\nfloat factor_r = pseudoRandom(a_rndSeed + 125292.);\nvec3 euler = mix(rotation_0, rotation_1, factor_r) * normalizedTime * a_dir_life.w;\n#if CC_RENDER_MODE == 3 || CC_RENDER_MODE == 2\neuler = vec3(0.0, 0.0, euler.z);\n#endif\nvec4 quat = EulerToQuat(euler);\nmat3 mLocal = QuatToMat3(quat);\nmat3 mStart = QuatToMat3(rot);\nrot = Mat3ToQuat(mStart * mLocal);\n}\n#endif\n#if COLOR_OVER_TIME_MODULE_ENABLE\nif (u_color_mode == 1) {\ncolor = a_color * texture(color_over_time_tex0, timeCoord0);\n} else {\nvec4 color_0 = texture(color_over_time_tex0, timeCoord0);\nvec4 color_1 = texture(color_over_time_tex0, timeCoord1);\nfloat factor_c = pseudoRandom(a_rndSeed + 91041.);\ncolor = a_color * mix(color_0, color_1, factor_c);\n}\n#else\ncolor = a_color;\n#endif\n#if CC_RENDER_MODE != 4\nvec2 cornerOffset = vec2((vertIdx - 0.5));\n#if CC_RENDER_MODE == 1\nrot = vec4(0.0, 0.0, 0.0, 1.0);\n#endif\ncomputeVertPos(pos, cornerOffset, rot, compScale\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n, cc_matViewInv\n#endif\n#if CC_RENDER_MODE == 1\n, cc_cameraPos.xyz\n, velocity\n, frameTile_velLenScale.z\n, frameTile_velLenScale.w\n, a_size_uv.w\n#endif\n);\n#else\nmat4 xformNoScale = matrixFromRT(rot, pos.xyz);\nmat4 xform = matFromRTS(rot, pos.xyz, compScale);\npos = xform * vec4(a_texCoord3, 1);\nvec4 normal = xformNoScale * vec4(a_normal, 0);\ncolor *= a_color1;\n#endif\npos = cc_matViewProj * pos;\nfloat frameIndex = 0.;\n#if TEXTURE_ANIMATION_MODULE_ENABLE\nfloat startFrame = 0.;\nvec3 frameInfo = vec3(0.);\nif (int(u_anim_info.x) == 1) {\nframeInfo = unpackCurveData(texture_animation_tex0, timeCoord0);\n} else {\nvec3 frameInfo0 = unpackCurveData(texture_animation_tex0, timeCoord0);\nvec3 frameInfo1 = unpackCurveData(texture_animation_tex0, timeCoord1);\nfloat factor_t = pseudoRandom(a_rndSeed + 90794.);\nframeInfo = mix(frameInfo0, frameInfo1, factor_t);\n}\nstartFrame = frameInfo.x / u_anim_info.y;\nframeIndex = repeat(u_anim_info.z * (frameInfo.y + startFrame), 1.);\n#endif\nuv = computeUV(frameIndex, vertIdx, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\nreturn pos;\n}\nvoid main() { gl_Position = gpvs_main(); }",
  "frag": "\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n#if CC_USE_HDR\ncolor.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n#endif\nreturn color;\n}\nin vec2 uv;\nin vec4 color;\nuniform sampler2D mainTexture;\nlayout(std140) uniform FragConstants {\nvec4 tintColor;\n};\nvec4 add () {\nvec4 col = 2.0 * color * tintColor * texture(mainTexture, uv);\nreturn CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = add(); }"
}], [{
  "vert": "\nprecision mediump float;\nlayout(std140) uniform Constants {\nvec4 mainTiling_Offset;\nvec4 frameTile_velLenScale;\nvec4 scale;\n};\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\nlayout(std140) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\n};\nout mediump vec2 uv;\nout mediump vec4 color;\nin vec3 a_position;\nin vec4 a_texCoord;\nin vec3 a_texCoord1;\nin vec3 a_texCoord2;\nin vec4 a_color;\n#if CC_DRAW_WIRE_FRAME\nout vec3 vBarycentric;\n#endif\nvec4 vs_main() {\nhighp vec4 pos = vec4(a_position, 1);\nvec4 velocity = vec4(a_texCoord1.xyz, 0);\n#if !CC_USE_WORLD_SPACE\npos = cc_matWorld * pos;\nvelocity = cc_matWorld * velocity;\n#endif\nfloat vertOffset = (a_texCoord.x - 0.5) * a_texCoord.y;\nvec3 camUp = normalize(cross(pos.xyz - cc_cameraPos.xyz, velocity.xyz));\npos.xyz += camUp * vertOffset;\npos = cc_matViewProj * pos;\nuv = a_texCoord.zw * mainTiling_Offset.xy + mainTiling_Offset.zw;;\ncolor = a_color;\n#if CC_DRAW_WIRE_FRAME\nvBarycentric = a_texCoord2;\n#endif\nreturn pos;\n}\nvoid main() { gl_Position = vs_main(); }",
  "frag": "\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n#if CC_USE_HDR\ncolor.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n#endif\nreturn color;\n}\nin vec2 uv;\nin vec4 color;\n#if CC_DRAW_WIRE_FRAME\nin vec3 vBarycentric;\n#endif\nuniform sampler2D mainTexture;\nlayout(std140) uniform FragConstants {\nvec4 tintColor;\n};\nvec4 add () {\nvec4 col = 2.0 * color * tintColor * texture(mainTexture, uv);\n#if CC_DRAW_WIRE_FRAME\nif (any(lessThan(vBarycentric, vec3(0.02)))) {\ncol = vec4(0., 1., 1., 1.);\n}\n#endif\nreturn CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = add(); }"
}], [{
  "vert": "\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\nmat3 m = mat3(xAxis,yAxis,zAxis);\nfloat trace = m[0][0] + m[1][1] + m[2][2];\nvec4 quat;\nif (trace > 0.) {\nfloat s = 0.5 / sqrt(trace + 1.0);\nquat.w = 0.25 / s;\nquat.x = (m[2][1] - m[1][2]) * s;\nquat.y = (m[0][2] - m[2][0]) * s;\nquat.z = (m[1][0] - m[0][1]) * s;\n} else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\nfloat s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\nquat.w = (m[2][1] - m[1][2]) / s;\nquat.x = 0.25 * s;\nquat.y = (m[0][1] + m[1][0]) / s;\nquat.z = (m[0][2] + m[2][0]) / s;\n} else if (m[1][1] > m[2][2]) {\nfloat s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\nquat.w = (m[0][2] - m[2][0]) / s;\nquat.x = (m[0][1] + m[1][0]) / s;\nquat.y = 0.25 * s;\nquat.z = (m[1][2] + m[2][1]) / s;\n} else {\nfloat s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\nquat.w = (m[1][0] - m[0][1]) / s;\nquat.x = (m[0][2] + m[2][0]) / s;\nquat.y = (m[1][2] + m[2][1]) / s;\nquat.z = 0.25 * s;\n}\nfloat len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\nif (len > 0.) {\nlen = 1. / sqrt(len);\nquat.x = quat.x * len;\nquat.y = quat.y * len;\nquat.z = quat.z * len;\nquat.w = quat.w * len;\n}\nreturn quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\nfloat x2 = q.x + q.x;\nfloat y2 = q.y + q.y;\nfloat z2 = q.z + q.z;\nfloat xx = q.x * x2;\nfloat xy = q.x * y2;\nfloat xz = q.x * z2;\nfloat yy = q.y * y2;\nfloat yz = q.y * z2;\nfloat zz = q.z * z2;\nfloat wx = q.w * x2;\nfloat wy = q.w * y2;\nfloat wz = q.w * z2;\nreturn mat4(\n1. - (yy + zz), xy + wz, xz - wy, 0,\nxy - wz, 1. - (xx + zz), yz + wx, 0,\nxz + wy, yz - wx, 1. - (xx + yy), 0,\np.x, p.y, p.z, 1\n);\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\nfloat x = q.x, y = q.y, z = q.z, w = q.w;\nfloat x2 = x + x;\nfloat y2 = y + y;\nfloat z2 = z + z;\nfloat xx = x * x2;\nfloat xy = x * y2;\nfloat xz = x * z2;\nfloat yy = y * y2;\nfloat yz = y * z2;\nfloat zz = z * z2;\nfloat wx = w * x2;\nfloat wy = w * y2;\nfloat wz = w * z2;\nfloat sx = s.x;\nfloat sy = s.y;\nfloat sz = s.z;\nreturn mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n(xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n(xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\nt.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\nvec4 quat;\nquat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\nquat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\nquat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\nquat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\nreturn quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\nfloat ix = q.w * v.x + q.y * v.z - q.z * v.y;\nfloat iy = q.w * v.y + q.z * v.x - q.x * v.z;\nfloat iz = q.w * v.z + q.x * v.y - q.y * v.x;\nfloat iw = -q.x * v.x - q.y * v.y - q.z * v.z;\nv.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\nv.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\nv.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\nvec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\nvec4 rotQuat = quatMultiply(viewQuat, q);\nrotateVecFromQuat(pos, rotQuat);\nreturn pos;\n}\nlayout(std140) uniform Constants {\nvec4 mainTiling_Offset;\nvec4 frameTile_velLenScale;\nvec4 scale;\n};\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\nlayout(std140) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\n};\nout mediump vec2 uv;\nout mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n, mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n, vec3 eye\n, vec4 velocity\n, float velocityScale\n, float lengthScale\n, float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\nvec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\nvec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\nvec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\nvec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\npos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\nvec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\nvec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\npos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\nvec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\nvec3 camX = vec3(1, 0, 0);\nvec3 camY = vec3(0, 0, -1);\npos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\nvec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\nrotateVecFromQuat(viewSpaceVert, q);\nvec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\nvec3 camY = vec3(0, 1, 0);\nvec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\npos.xyz += offset;\n#else\npos.x += vertOffset.x;\npos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\nvec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\naniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\nvertIndex.y = 1. - vertIndex.y;\n#endif\nreturn (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nin vec3 a_position;\nin vec3 a_texCoord;\nin vec3 a_texCoord1;\nin vec3 a_texCoord2;\nin vec4 a_color;\n#if CC_RENDER_MODE == 1\nin vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\nin vec3 a_texCoord3;\nin vec3 a_normal;\nin vec4 a_color1;\n#endif\nvec4 lpvs_main () {\nvec3 compScale = scale.xyz * a_texCoord1;\nvec4 pos = vec4(a_position, 1);\n#if CC_RENDER_MODE == 1\nvec4 velocity = vec4(a_color1.xyz, 0);\n#endif\n#if !CC_USE_WORLD_SPACE\npos = cc_matWorld * pos;\n#if CC_RENDER_MODE == 1\nvelocity = cc_matWorld * velocity;\n#endif\n#endif\nvec3 rotTmp = a_texCoord2;\nfloat mulFactor = 1.0;\nif (rotTmp.x > 10.0 * 0.5) {\nrotTmp.x -= 10.0;\nmulFactor = -1.0;\n}\nvec4 rot = vec4(rotTmp, 0.0);\nrot.w = mulFactor * sqrt(1.0 - rot.x * rot.x - rot.y * rot.y - rot.z * rot.z);\n#if CC_RENDER_MODE != 4\nvec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\ncomputeVertPos(pos, cornerOffset, rot, compScale, cc_matViewInv);\n#elif CC_RENDER_MODE == 1\ncomputeVertPos(pos, cornerOffset, rot, compScale, cc_cameraPos.xyz, velocity, frameTile_velLenScale.z, frameTile_velLenScale.w, a_texCoord.x);\n#elif 2\ncomputeVertPos(pos, cornerOffset, rot, compScale);\n#endif\ncolor = a_color;\n#else\nmat4 xformNoScale = matrixFromRT(rot, pos.xyz);\nmat4 xform = matFromRTS(rot, pos.xyz, compScale);\npos = xform * vec4(a_texCoord3, 1);\nvec4 normal = xformNoScale * vec4(a_normal, 0);\ncolor = a_color * a_color1;\n#endif\nuv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\npos = cc_matViewProj * pos;\nreturn pos;\n}\nvoid main() { gl_Position = lpvs_main(); }",
  "frag": "\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n#if CC_USE_HDR\ncolor.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n#endif\nreturn color;\n}\nin vec2 uv;\nin vec4 color;\nuniform sampler2D mainTexture;\nlayout(std140) uniform FragConstants {\nvec4 tintColor;\n};\nvec4 add () {\nvec4 col = 2.0 * color * tintColor * texture(mainTexture, uv);\nreturn CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = add(); }"
}], [{
  "vert": "\nprecision highp float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\n#if USE_LOCAL\nlayout(std140) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\n};\n#endif\nin vec3 a_position;\nin vec2 a_texCoord;\nin vec4 a_color;\nout vec4 v_light;\nout vec2 uv0;\n#if TWO_COLORED\nin vec4 a_color2;\nout vec4 v_dark;\n#endif\nvec4 vert () {\nvec4 pos = vec4(a_position, 1);\n#if USE_LOCAL\npos = cc_matWorld * pos;\n#endif\npos = cc_matViewProj * pos;\nuv0 = a_texCoord;\nv_light = a_color;\n#if TWO_COLORED\nv_dark = a_color2;\n#endif\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",
  "frag": "\nprecision highp float;\n#if USE_ALPHA_TEST\nlayout(std140) uniform ALPHA_TEST_DATA {\nfloat alphaThreshold;\n};\n#endif\nvoid ALPHA_TEST (in vec4 color) {\n#if USE_ALPHA_TEST\nif (color.a < alphaThreshold) discard;\n#endif\n}\nvoid ALPHA_TEST (in float alpha) {\n#if USE_ALPHA_TEST\nif (alpha < alphaThreshold) discard;\n#endif\n}\nin vec4 v_light;\n#if TWO_COLORED\nin vec4 v_dark;\n#endif\nin vec2 uv0;\nuniform sampler2D cc_spriteTexture;\nvec4 frag () {\nvec4 o = vec4(1, 1, 1, 1);\n#if TWO_COLORED\nvec4 texColor = vec4(1, 1, 1, 1);\ntexColor *= texture(cc_spriteTexture, uv0);\no.a = texColor.a * v_light.a;\no.rgb = ((texColor.a - 1.0) * v_dark.a + 1.0 - texColor.rgb) * v_dark.rgb + texColor.rgb * v_light.rgb;\n#else\no *= texture(cc_spriteTexture, uv0);\no *= v_light;\n#endif\nALPHA_TEST(o);\nreturn o;\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
}], [{
  "vert": "\nprecision highp float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\n#if USE_LOCAL\nlayout(std140) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\n};\n#endif\n#if SAMPLE_FROM_RT\n#endif\nin vec3 a_position;\nin vec2 a_texCoord;\nin vec4 a_color;\nout vec4 color;\nout vec2 uv0;\nvec4 vert () {\nvec4 pos = vec4(a_position, 1);\n#if USE_LOCAL\npos = cc_matWorld * pos;\n#endif\n#if USE_PIXEL_ALIGNMENT\npos = cc_matView * pos;\npos.xyz = floor(pos.xyz);\npos = cc_matProj * pos;\n#else\npos = cc_matViewProj * pos;\n#endif\nuv0 = a_texCoord;\n#if SAMPLE_FROM_RT\nuv0 = cc_cameraPos.w > 1.0 ? vec2(uv0.x, 1.0 - uv0.y) : uv0;\n#endif\ncolor = a_color;\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",
  "frag": "\nprecision highp float;\nvec4 CCSampleWithAlphaSeparated(sampler2D tex, vec2 uv) {\n#if CC_USE_EMBEDDED_ALPHA\nreturn vec4(texture(tex, uv).rgb, texture(tex, uv + vec2(0.0, 0.5)).r);\n#else\nreturn texture(tex, uv);\n#endif\n}\n#if USE_ALPHA_TEST\nlayout(std140) uniform ALPHA_TEST_DATA {\nfloat alphaThreshold;\n};\n#endif\nvoid ALPHA_TEST (in vec4 color) {\n#if USE_ALPHA_TEST\nif (color.a < alphaThreshold) discard;\n#endif\n}\nvoid ALPHA_TEST (in float alpha) {\n#if USE_ALPHA_TEST\nif (alpha < alphaThreshold) discard;\n#endif\n}\nin vec4 color;\n#if USE_TEXTURE\nin vec2 uv0;\nuniform sampler2D cc_spriteTexture;\n#endif\nvec4 frag () {\nvec4 o = vec4(1, 1, 1, 1);\n#if USE_TEXTURE\no *= CCSampleWithAlphaSeparated(cc_spriteTexture, uv0);\n#if IS_GRAY\nfloat gray  = 0.2126 * o.r + 0.7152 * o.g + 0.0722 * o.b;\no.r = o.g = o.b = gray;\n#endif\n#endif\no *= color;\nALPHA_TEST(o);\nreturn o;\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
}], [{
  "vert": "\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\nrgba = rgba * 255.0;\nhighp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\nhighp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\nhighp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\nreturn Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_MORPH\nin float a_vertexId;\nint getVertexId() {\nreturn int(a_vertexId);\n}\nlayout(std140) uniform CCMorph {\nvec4 cc_displacementWeights[15];\nvec4 cc_displacementTextureInfo;\n};\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\nfloat pixelIndexF = float(pixelIndex);\nfloat x = mod(pixelIndexF, textureResolution.x);\nfloat y = floor(pixelIndexF / textureResolution.x);\nreturn vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\nreturn (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\nivec2 texSize = textureSize(tex, 0);\nreturn texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n}\n#else\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex * 4;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\nreturn vec4(\ndecode32(texture(tex, x)),\ndecode32(texture(tex, y)),\ndecode32(texture(tex, z)),\n1.0\n);\n}\n#endif\nfloat getDisplacementWeight(int index) {\nint quot = index / 4;\nint remainder = index - quot * 4;\nif (remainder == 0) {\nreturn cc_displacementWeights[quot].x;\n} else if (remainder == 1) {\nreturn cc_displacementWeights[quot].y;\n} else if (remainder == 2) {\nreturn cc_displacementWeights[quot].z;\n} else {\nreturn cc_displacementWeights[quot].w;\n}\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\nreturn fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\nvec3 result = vec3(0, 0, 0);\nint nVertices = int(cc_displacementTextureInfo.z);\nfor (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\nresult += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n}\nreturn result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\nuniform sampler2D cc_PositionDisplacements;\nvec3 getPositionDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nuniform sampler2D cc_NormalDisplacements;\nvec3 getNormalDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nuniform sampler2D cc_TangentDisplacements;\nvec3 getTangentDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n}\n#endif\nvoid applyMorph (inout StandardVertInput attr) {\nint vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\nattr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nattr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nattr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\nin vec4 a_joints;\nin vec4 a_weights;\n#if CC_USE_BAKED_ANIMATION\n#if USE_INSTANCING\nin highp vec4 a_jointAnimInfo;\n#endif\nlayout(std140) uniform CCSkinningTexture {\nhighp vec4 cc_jointTextureInfo;\n};\nlayout(std140) uniform CCSkinningAnimation {\nhighp vec4 cc_jointAnimInfo;\n};\nuniform highp sampler2D cc_jointTexture;\n#else\nlayout(std140) uniform CCSkinning {\nhighp vec4 cc_joints[30 * 3];\n};\n#endif\n#if CC_USE_BAKED_ANIMATION\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nmat4 getJointMatrix (float i) {\n#if USE_INSTANCING\nhighp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n#else\nhighp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n#endif\nhighp float invSize = cc_jointTextureInfo.w;\nhighp float y = floor(j * invSize);\nhighp float x = floor(j - y * cc_jointTextureInfo.x);\ny = (y + 0.5) * invSize;\nvec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\nvec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\nvec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#else\nmat4 getJointMatrix (float i) {\n#if USE_INSTANCING\nhighp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n#else\nhighp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n#endif\nhighp float invSize = cc_jointTextureInfo.w;\nhighp float y = floor(j * invSize);\nhighp float x = floor(j - y * cc_jointTextureInfo.x);\ny = (y + 0.5) * invSize;\nvec4 v1 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n);\nvec4 v2 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n);\nvec4 v3 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n);\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\n#else\nmat4 getJointMatrix (float i) {\nint idx = int(i);\nvec4 v1 = cc_joints[idx * 3];\nvec4 v2 = cc_joints[idx * 3 + 1];\nvec4 v3 = cc_joints[idx * 3 + 2];\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\nmat4 skinMatrix () {\nvec4 joints = vec4(a_joints);\nreturn getJointMatrix(joints.x) * a_weights.x\n+ getJointMatrix(joints.y) * a_weights.y\n+ getJointMatrix(joints.z) * a_weights.z\n+ getJointMatrix(joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\nmat4 m = skinMatrix();\nposition = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\nmat4 m = skinMatrix();\nattr.position = m * attr.position;\nattr.normal = (m * vec4(attr.normal, 0.0)).xyz;\nattr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\n#if USE_INSTANCING\nin vec4 a_matWorld0;\nin vec4 a_matWorld1;\nin vec4 a_matWorld2;\n#if USE_LIGHTMAP\nin vec4 a_lightingMapUVParam;\n#endif\n#elif USE_BATCHING\nin float a_dyn_batch_id;\nlayout(std140) uniform CCLocalBatched {\nhighp mat4 cc_matWorlds[10];\n};\n#else\nlayout(std140) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\n};\n#endif\nlayout(std140) uniform Constants {\nvec4 tilingOffset;\nvec4 albedo;\nvec4 albedoScaleAndCutoff;\nvec4 pbrParams;\nvec4 miscParams;\nvec4 emissive;\nvec4 emissiveScaleParam;\n};\nfloat LinearFog(vec4 pos) {\nvec4 wPos = pos;\nfloat cam_dis = distance(cc_cameraPos, wPos);\nfloat fogStart = cc_fogBase.x;\nfloat fogEnd = cc_fogBase.y;\nreturn clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\nfloat f = exp(-cam_dis * fogDensity);\nreturn f;\n}\nfloat ExpSquaredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\nfloat f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\nreturn f;\n}\nfloat LayeredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat _FogTop = cc_fogAdd.x;\nfloat _FogRange = cc_fogAdd.y;\nvec3 camWorldProj = cc_cameraPos.xyz;\ncamWorldProj.y = 0.;\nvec3 worldPosProj = wPos.xyz;\nworldPosProj.y = 0.;\nfloat fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\nfloat fDeltaY, fDensityIntegral;\nif (cc_cameraPos.y > _FogTop) {\nif (wPos.y < _FogTop) {\nfDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\nfDensityIntegral = fDeltaY * fDeltaY * 0.5;\n} else {\nfDeltaY = 0.;\nfDensityIntegral = 0.;\n}\n} else {\nif (wPos.y < _FogTop) {\nfloat fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfloat fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\nfDeltaY = abs(fDeltaA - fDeltaB);\nfDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n} else {\nfDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n}\n}\nfloat fDensity;\nif (fDeltaY != 0.) {\nfDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n} else {\nfDensity = 0.;\n}\nfloat f = exp(-fDensity);\nreturn f;\n}\nout float v_fog_factor;\nout highp vec4 v_shadowPos;\nlayout(std140) uniform CCShadow {\nhighp mat4 cc_matLightPlaneProj;\nhighp mat4 cc_matLightView;\nhighp mat4 cc_matLightViewProj;\nlowp  vec4 cc_shadowNFLSInfo;\nlowp  vec4 cc_shadowWHPBInfo;\nlowp  vec4 cc_shadowLPNNInfo;\nlowp  vec4 cc_shadowColor;\n};\n#if CC_RECEIVE_SHADOW\nuniform sampler2D cc_shadowMap;\nuniform sampler2D cc_spotLightingMap;\n#endif\n#if USE_VERTEX_COLOR\nin vec4 a_color;\nout vec4 v_color;\n#endif\nout vec3 v_position;\nout vec3 v_normal;\nout vec2 v_uv;\nout vec2 v_uv1;\n#if USE_NORMAL_MAP\nout vec3 v_tangent;\nout vec3 v_bitangent;\n#endif\n#if HAS_SECOND_UV || USE_LIGHTMAP\nin vec2 a_texCoord1;\n#endif\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nout vec3 v_luv;\nvoid CCLightingMapCaclUV()\n{\n#if !USE_INSTANCING\nv_luv.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.zw;\nv_luv.z = cc_lightingMapUVParam.z;\n#else\nv_luv.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.zw;\nv_luv.z = a_lightingMapUVParam.z;\n#endif\n}\n#endif\nvoid main () {\nStandardVertInput In;\nIn.position = vec4(a_position, 1.0);\nIn.normal = a_normal;\nIn.tangent = a_tangent;\n#if CC_USE_MORPH\napplyMorph(In);\n#endif\n#if CC_USE_SKINNING\nCCSkin(In);\n#endif\nmat4 matWorld, matWorldIT;\n#if USE_INSTANCING\nmatWorld = mat4(\nvec4(a_matWorld0.xyz, 0.0),\nvec4(a_matWorld1.xyz, 0.0),\nvec4(a_matWorld2.xyz, 0.0),\nvec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n);\nmatWorldIT = matWorld;\n#elif USE_BATCHING\nmatWorld = cc_matWorlds[int(a_dyn_batch_id)];\nmatWorldIT = matWorld;\n#else\nmatWorld = cc_matWorld;\nmatWorldIT = cc_matWorldIT;\n#endif\nvec4 pos = matWorld * In.position;\nv_position = pos.xyz;\nv_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n#if USE_NORMAL_MAP\nv_tangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\nv_bitangent = cross(v_normal, v_tangent) * In.tangent.w;\n#endif\nv_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n#if SAMPLE_FROM_RT\nv_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n#endif\n#if HAS_SECOND_UV\nv_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n#if SAMPLE_FROM_RT\nv_uv1 = cc_cameraPos.w > 1.0 ? vec2(v_uv1.x, 1.0 - v_uv1.y) : v_uv1;\n#endif\n#endif\n#if USE_VERTEX_COLOR\nv_color = a_color;\n#endif\n#if CC_USE_FOG == 0\nv_fog_factor = LinearFog(pos);\n#elif CC_USE_FOG == 1\nv_fog_factor = ExpFog(pos);\n#elif CC_USE_FOG == 2\nv_fog_factor = ExpSquaredFog(pos);\n#elif CC_USE_FOG == 3\nv_fog_factor = LayeredFog(pos);\n#else\nv_fog_factor = 1.0;\n#endif\nv_shadowPos = cc_matLightViewProj * pos;\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nCCLightingMapCaclUV();\n#endif\ngl_Position = cc_matProj * (cc_matView * matWorld) * In.position;\n}",
  "frag": "\nprecision highp float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\nlayout(std140) uniform Constants {\nvec4 tilingOffset;\nvec4 albedo;\nvec4 albedoScaleAndCutoff;\nvec4 pbrParams;\nvec4 miscParams;\nvec4 emissive;\nvec4 emissiveScaleParam;\n};\nin float v_fog_factor;\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nlayout(std140) uniform CCShadow {\nhighp mat4 cc_matLightPlaneProj;\nhighp mat4 cc_matLightView;\nhighp mat4 cc_matLightViewProj;\nlowp  vec4 cc_shadowNFLSInfo;\nlowp  vec4 cc_shadowWHPBInfo;\nlowp  vec4 cc_shadowLPNNInfo;\nlowp  vec4 cc_shadowColor;\n};\n#if CC_RECEIVE_SHADOW\nuniform sampler2D cc_shadowMap;\nuniform sampler2D cc_spotLightingMap;\nfloat CCGetLinearDepth (vec3 worldPos) {\nvec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\nfloat dist = length(viewStartPos.xyz);\nreturn cc_shadowNFLSInfo.x + (-dist / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x));\n}\nfloat CCGetShadowFactorHard (vec4 shadowPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat shadow = 0.0;\nfloat closestDepth = 0.0;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nclosestDepth = dot(texture(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n} else {\nclosestDepth = texture(cc_shadowMap, clipPos.xy).x;\n}\nshadow = step(clipPos.z- cc_shadowWHPBInfo.w, closestDepth);\nreturn shadow;\n}\nfloat CCGetShadowFactorSoft (vec4 shadowPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat offsetDepth = clipPos.z - cc_shadowWHPBInfo.w;\nvec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;\nvec2 clipPos_offset = clipPos.xy + oneTap;\nfloat block0, block1, block2, block3;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nblock0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\n} else {\nblock0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\nblock1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);\nblock2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);\nblock3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n}\nfloat coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block2, block3, coefX);\nfloat coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;\nreturn mix(resultX, resultY, coefY);\n}\nfloat CCGetShadowFactorSoft2X (vec4 shadowPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat bias = cc_shadowWHPBInfo.w;\nfloat offsetDepth = clipPos.z - bias;\nvec2 mapSize = cc_shadowWHPBInfo.xy;\nvec2 oneTap = 1.0 / mapSize;\nfloat clipPos_offset_L = clipPos.x - oneTap.x;\nfloat clipPos_offset_R = clipPos.x + oneTap.x;\nfloat clipPos_offset_U = clipPos.y - oneTap.y;\nfloat clipPos_offset_D = clipPos.y + oneTap.y;\nfloat block0, block1, block2, block3, block4, block5, block6, block7, block8;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nblock0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock4 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock5 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock6 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock7 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock8 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\n} else {\nblock0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\nblock1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);\nblock2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\nblock3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);\nblock4 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\nblock5 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);\nblock6 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\nblock7 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);\nblock8 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n}\nfloat coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\nfloat coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\nfloat shadow = 0.0;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block3, block4, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block1, block2, coefX);\nresultY = mix(block4, block5, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block3, block4, coefX);\nresultY = mix(block6, block7, coefX);\nshadow += mix(resultX, resultY, coefY);\nresultX = mix(block4, block5, coefX);\nresultY = mix(block7, block8, coefX);\nshadow += mix(resultX, resultY, coefY);\nreturn shadow * 0.25;\n}\nfloat CCGetSpotLightShadowFactorHard (vec4 shadowPos, vec3 worldPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat shadow = 0.0;\nfloat closestDepth = 0.0;\nfloat depth = 0.0;\nif (cc_shadowNFLSInfo.z > 0.000001) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nif (cc_shadowLPNNInfo.y > 0.000001) {\nclosestDepth = dot(texture(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n} else {\nclosestDepth = texture(cc_spotLightingMap, clipPos.xy).x;\n}\nshadow = step(depth - cc_shadowWHPBInfo.w, closestDepth);\nreturn shadow;\n}\nfloat CCGetSpotLightShadowFactorSoft (vec4 shadowPos, vec3 worldPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat offsetx = 1.0 / cc_shadowWHPBInfo.x;\nfloat offsety = 1.0 / cc_shadowWHPBInfo.y;\nfloat shadow = 0.0;\nfloat depth = 0.0;\nif (cc_shadowNFLSInfo.z > 0.000001) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nfloat offsetDepth = depth - cc_shadowWHPBInfo.w;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nfloat closestDepth = dot(texture(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = dot(texture(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = dot(texture(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = dot(texture(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(offsetDepth, closestDepth);\n} else {\nfloat closestDepth = texture(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y - offsety)).x;\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = texture(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y + offsety)).x;\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x;\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = texture(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y - offsety)).x;\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = texture(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y + offsety)).x;\nshadow += step(offsetDepth, closestDepth);\n}\nreturn shadow / 5.0;\n}\nfloat CCGetSpotLightShadowFactorSoft2X (vec4 shadowPos, vec3 worldPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat offsetx = 1.0 / cc_shadowWHPBInfo.x;\nfloat offsety = 1.0 / cc_shadowWHPBInfo.y;\nfloat shadow = 0.0;\nfloat depth = 0.0;\nif (cc_shadowNFLSInfo.z > 0.000001) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nfloat offsetDepth = depth - cc_shadowWHPBInfo.w;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nfor (int i = -1; i <= 1; i++) {\nfor (int j = -1; j <= 1; j++) {\nfloat closestDepth = dot(texture(cc_spotLightingMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(offsetDepth, closestDepth);\n}\n}\n} else {\nfor (int i = -1; i <= 1; i++) {\nfor (int j = -1; j <= 1; j++) {\nfloat closestDepth = texture(cc_spotLightingMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)).x;\nshadow += step(offsetDepth, closestDepth);\n}\n}\n}\nreturn shadow / 9.0;\n}\n#endif\n#if CC_USE_IBL\nuniform samplerCube cc_environment;\nvec3 unpackRGBE (vec4 rgbe) {\nreturn rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n}\nvec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\nreturn textureLod(tex, coord, lod);\n}\nvec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\nreturn textureLod(tex, coord, lod);\n}\n#endif\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\nvec3 NxH = cross(N, H);\nfloat OneMinusNoHSqr = dot(NxH, NxH);\nfloat a = roughness * roughness;\nfloat n = NoH * a;\nfloat p = a / (OneMinusNoHSqr + n * n);\nreturn p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\nreturn (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\nconst vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\nconst vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\nvec4 r = roughness * c0 + c1;\nfloat a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\nvec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\nAB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\nreturn specular * AB.x + AB.y;\n}\nstruct StandardSurface {\nvec4 albedo;\nvec3 position;\nvec3 normal;\nvec3 emissive;\nvec3 lightmap;\nfloat lightmap_test;\nfloat roughness;\nfloat metallic;\nfloat occlusion;\n};\nvec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - s.position);\nfloat NV = max(abs(dot(N, V)), 0.0);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 L = normalize(-cc_mainLitDir.xyz);\nvec3 H = normalize(L + V);\nfloat NH = max(dot(N, H), 0.0);\nfloat NL = max(dot(N, L), 0.0);\nvec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\nvec3 diffuseContrib = diffuse;\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nif (s.lightmap_test > 0.0001) {\nfinalColor = s.lightmap.rgb;\n}\n#else\ndiffuseContrib /= 3.14159265359;\n#endif\nvec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\nvec3 dirlightContrib = (diffuseContrib + specularContrib);\nfloat shadow = 1.0;\n#if CC_RECEIVE_SHADOW\nif (NL > 0.0) {\n{\nfloat pcf = cc_shadowWHPBInfo.z;\nvec3 projWorldPos = shadowPos.xyz + (1.0 - NL) * cc_shadowLPNNInfo.z * N;\nvec4 pos = vec4(projWorldPos.xyz, shadowPos.w);\nif (pcf > 1.9) shadow = CCGetShadowFactorSoft2X(pos);\nelse if (pcf > 0.9) shadow = CCGetShadowFactorSoft(pos);\nelse shadow = CCGetShadowFactorHard(pos);\nshadow = mix(shadow, 1.0, cc_shadowNFLSInfo.w);\n}\n}\n#endif\ndirlightContrib *= shadow;\nfinalColor *= dirlightContrib;\nfloat fAmb = 0.5 - N.y * 0.5;\nvec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb) * cc_ambientSky.w;\nfinalColor += (ambDiff.rgb * diffuse) * s.occlusion;\n#if CC_USE_IBL\nvec3 R = normalize(reflect(-V, N));\nvec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n#if CC_USE_IBL == 2\nvec3 env = unpackRGBE(envmap);\n#else\nvec3 env = SRGBToLinear(envmap.rgb);\n#endif\nfinalColor += env * cc_ambientSky.w * specular * s.occlusion;\n#endif\n#if CC_USE_HDR\ns.emissive *= cc_exposure.w;\n#endif\nfinalColor += s.emissive;\nreturn vec4(finalColor, s.albedo.a);\n}\nvec3 ACESToneMap (vec3 color) {\ncolor = min(color, vec3(8.0));\nconst float A = 2.51;\nconst float B = 0.03;\nconst float C = 2.43;\nconst float D = 0.59;\nconst float E = 0.14;\nreturn (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n#if !CC_USE_HDR\ncolor.rgb = sqrt(ACESToneMap(color.rgb));\n#endif\nreturn color;\n}\nin highp vec4 v_shadowPos;\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nin vec3 v_luv;\nuniform sampler2D cc_lightingMap;\nvec3 UnpackLightingmap(vec4 color) {\nvec3 c;\nfloat e = 1.0 + color.a * (8.0 - 1.0);\nc.r = color.r * e;\nc.g = color.g * e;\nc.b = color.b * e;\nreturn c;\n}\n#endif\nin vec3 v_position;\nin vec2 v_uv;\nin vec2 v_uv1;\nin vec3 v_normal;\n#if USE_VERTEX_COLOR\nin vec4 v_color;\n#endif\n#if USE_ALBEDO_MAP\nuniform sampler2D albedoMap;\n#endif\n#if USE_NORMAL_MAP\nin vec3 v_tangent;\nin vec3 v_bitangent;\nuniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\nuniform sampler2D pbrMap;\n#endif\n#if USE_METALLIC_ROUGHNESS_MAP\nuniform sampler2D metallicRoughnessMap;\n#endif\n#if USE_OCCLUSION_MAP\nuniform sampler2D occlusionMap;\n#endif\n#if USE_EMISSIVE_MAP\nuniform sampler2D emissiveMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvoid surf (out StandardSurface s) {\nvec4 baseColor = albedo;\n#if USE_VERTEX_COLOR\nbaseColor.rgb *= SRGBToLinear(v_color.rgb);\nbaseColor.a *= v_color.a;\n#endif\n#if USE_ALBEDO_MAP\nvec4 texColor = texture(albedoMap, ALBEDO_UV);\ntexColor.rgb = SRGBToLinear(texColor.rgb);\nbaseColor *= texColor;\n#endif\ns.albedo = baseColor;\ns.albedo.rgb *= albedoScaleAndCutoff.xyz;\n#if USE_ALPHA_TEST\nif (s.albedo.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n#endif\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nvec4 lightColor = texture(cc_lightingMap, v_luv.xy);\ns.lightmap = UnpackLightingmap(lightColor);\ns.lightmap_test = v_luv.z;\n#endif\ns.normal = v_normal;\n#if USE_NORMAL_MAP\nvec3 nmmp = texture(normalMap, NORMAL_UV).xyz - vec3(0.5);\ns.normal =\n(nmmp.x * miscParams.x) * normalize(v_tangent) +\n(nmmp.y * miscParams.x) * normalize(v_bitangent) +\nnmmp.z * normalize(s.normal);\n#endif\ns.position = v_position;\nvec4 pbr = pbrParams;\n#if USE_PBR_MAP\nvec4 res = texture(pbrMap, PBR_UV);\npbr.x *= res.r;\npbr.y *= res.g;\npbr.z *= res.b;\npbr.w *= res.w;\n#endif\n#if USE_METALLIC_ROUGHNESS_MAP\nvec4 metallicRoughness = texture(metallicRoughnessMap, PBR_UV);\npbr.z *= metallicRoughness.b;\npbr.y *= metallicRoughness.g;\n#endif\n#if USE_OCCLUSION_MAP\npbr.x *= texture(occlusionMap, PBR_UV).r;\n#endif\ns.occlusion = clamp(pbr.x, 0.0, 0.96);\ns.roughness = clamp(pbr.y, 0.04, 1.0);\ns.metallic = pbr.z;\ns.emissive = emissive.rgb * emissiveScaleParam.xyz;\n#if USE_EMISSIVE_MAP\ns.emissive *= SRGBToLinear(texture(emissiveMap, EMISSIVE_UV).rgb);\n#endif\n}\n#if CC_FORWARD_ADD\n#if CC_PIPELINE_TYPE == 0\n# define LIGHTS_PER_PASS 1\n#else\n# define LIGHTS_PER_PASS 10\n#endif\nlayout(std140) uniform CCForwardLight {\nhighp vec4 cc_lightPos[LIGHTS_PER_PASS];\nvec4 cc_lightColor[LIGHTS_PER_PASS];\nvec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\nvec4 cc_lightDir[LIGHTS_PER_PASS];\n};\nfloat SmoothDistAtt (float distSqr, float invSqrAttRadius) {\nfloat factor = distSqr * invSqrAttRadius;\nfloat smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\nreturn smoothFactor * smoothFactor;\n}\nfloat GetDistAtt (float distSqr, float invSqrAttRadius) {\nfloat attenuation = 1.0 / max(distSqr, 0.01*0.01);\nattenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\nreturn attenuation;\n}\nfloat GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\nfloat cd = dot(litDir, L);\nfloat attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\nreturn (attenuation * attenuation);\n}\nvec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\nvec3 diffuseContrib = diffuse / 3.14159265359;\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - s.position);\nfloat NV = max(abs(dot(N, V)), 0.001);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 finalColor = vec3(0.0);\nint numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\nfor (int i = 0; i < LIGHTS_PER_PASS; i++) {\nif (i >= numLights) break;\nvec3 SLU = cc_lightPos[i].xyz - s.position;\nvec3 SL = normalize(SLU);\nvec3 SH = normalize(SL + V);\nfloat SNL = max(dot(N, SL), 0.001);\nfloat SNH = max(dot(N, SH), 0.0);\nfloat distSqr = dot(SLU, SLU);\nfloat litRadius = cc_lightSizeRangeAngle[i].x;\nfloat litRadiusSqr = litRadius * litRadius;\nfloat illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\nfloat attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\nattRadiusSqrInv *= attRadiusSqrInv;\nfloat att = GetDistAtt(distSqr, attRadiusSqrInv);\nvec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\nif (cc_lightPos[i].w > 0.0) {\nfloat cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\nfloat cosOuter = cc_lightSizeRangeAngle[i].z;\nfloat litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\nfloat litAngleOffset = -cosOuter * litAngleScale;\natt *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n}\nvec3 lightColor = cc_lightColor[i].rgb;\nfloat shadow = 1.0;\n#if CC_RECEIVE_SHADOW\nif (cc_lightPos[i].w > 0.0) {\n{\nfloat pcf = cc_shadowWHPBInfo.z;\nfloat cosAngle = clamp(1.0 - dot(N, normalize(cc_lightPos[i].xyz - s.position.xyz)), 0.0, 1.0);\nvec3 projWorldPos = shadowPos.xyz + cosAngle * cc_shadowLPNNInfo.z * N;\nvec4 pos = vec4(projWorldPos.xyz, shadowPos.w);\nif (pcf > 1.9) shadow = CCGetSpotLightShadowFactorSoft2X(pos, s.position);\nelse if (pcf > 0.9) shadow = CCGetSpotLightShadowFactorSoft(pos, s.position);\nelse shadow = CCGetSpotLightShadowFactorHard(pos, s.position);\n}\n}\n#endif\nlightColor *= shadow;\nfinalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n}\nreturn vec4(finalColor, 0.0);\n}\nlayout(location = 0) out vec4 fragColorX;\nvoid main () {\nStandardSurface s; surf(s);\nvec4 color = CCStandardShadingAdditive(s, v_shadowPos);\ncolor = vec4(mix(CC_FORWARD_ADD > 0 ? vec3(0.0) : cc_fogColor.rgb, color.rgb, v_fog_factor), color.a);\nfragColorX = CCFragOutput(color);\n}\n#elif CC_PIPELINE_TYPE == 0\nlayout(location = 0) out vec4 fragColorX;\nvoid main () {\nStandardSurface s; surf(s);\nvec4 color = CCStandardShadingBase(s, v_shadowPos);\ncolor = vec4(mix(CC_FORWARD_ADD > 0 ? vec3(0.0) : cc_fogColor.rgb, color.rgb, v_fog_factor), color.a);\nfragColorX = CCFragOutput(color);\n}\n#elif CC_PIPELINE_TYPE == 1\nlayout(location = 0) out vec4 fragColor0;\nlayout(location = 1) out vec4 fragColor1;\nlayout(location = 2) out vec4 fragColor2;\nlayout(location = 3) out vec4 fragColor3;\nvoid main () {\nStandardSurface s; surf(s);\nfragColor0 = s.albedo;\nfragColor1 = vec4(s.position, s.roughness);\nfragColor2 = vec4(s.normal, s.metallic);\nfragColor3 = vec4(s.emissive, s.occlusion);\n}\n#endif"
}, {
  "vert": "\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\nrgba = rgba * 255.0;\nhighp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\nhighp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\nhighp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\nreturn Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_MORPH\nin float a_vertexId;\nint getVertexId() {\nreturn int(a_vertexId);\n}\nlayout(std140) uniform CCMorph {\nvec4 cc_displacementWeights[15];\nvec4 cc_displacementTextureInfo;\n};\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\nfloat pixelIndexF = float(pixelIndex);\nfloat x = mod(pixelIndexF, textureResolution.x);\nfloat y = floor(pixelIndexF / textureResolution.x);\nreturn vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\nreturn (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\nivec2 texSize = textureSize(tex, 0);\nreturn texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n}\n#else\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex * 4;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\nreturn vec4(\ndecode32(texture(tex, x)),\ndecode32(texture(tex, y)),\ndecode32(texture(tex, z)),\n1.0\n);\n}\n#endif\nfloat getDisplacementWeight(int index) {\nint quot = index / 4;\nint remainder = index - quot * 4;\nif (remainder == 0) {\nreturn cc_displacementWeights[quot].x;\n} else if (remainder == 1) {\nreturn cc_displacementWeights[quot].y;\n} else if (remainder == 2) {\nreturn cc_displacementWeights[quot].z;\n} else {\nreturn cc_displacementWeights[quot].w;\n}\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\nreturn fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\nvec3 result = vec3(0, 0, 0);\nint nVertices = int(cc_displacementTextureInfo.z);\nfor (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\nresult += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n}\nreturn result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\nuniform sampler2D cc_PositionDisplacements;\nvec3 getPositionDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nuniform sampler2D cc_NormalDisplacements;\nvec3 getNormalDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nuniform sampler2D cc_TangentDisplacements;\nvec3 getTangentDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n}\n#endif\nvoid applyMorph (inout StandardVertInput attr) {\nint vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\nattr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nattr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nattr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\nin vec4 a_joints;\nin vec4 a_weights;\n#if CC_USE_BAKED_ANIMATION\n#if USE_INSTANCING\nin highp vec4 a_jointAnimInfo;\n#endif\nlayout(std140) uniform CCSkinningTexture {\nhighp vec4 cc_jointTextureInfo;\n};\nlayout(std140) uniform CCSkinningAnimation {\nhighp vec4 cc_jointAnimInfo;\n};\nuniform highp sampler2D cc_jointTexture;\n#else\nlayout(std140) uniform CCSkinning {\nhighp vec4 cc_joints[30 * 3];\n};\n#endif\n#if CC_USE_BAKED_ANIMATION\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nmat4 getJointMatrix (float i) {\n#if USE_INSTANCING\nhighp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n#else\nhighp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n#endif\nhighp float invSize = cc_jointTextureInfo.w;\nhighp float y = floor(j * invSize);\nhighp float x = floor(j - y * cc_jointTextureInfo.x);\ny = (y + 0.5) * invSize;\nvec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\nvec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\nvec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#else\nmat4 getJointMatrix (float i) {\n#if USE_INSTANCING\nhighp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n#else\nhighp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n#endif\nhighp float invSize = cc_jointTextureInfo.w;\nhighp float y = floor(j * invSize);\nhighp float x = floor(j - y * cc_jointTextureInfo.x);\ny = (y + 0.5) * invSize;\nvec4 v1 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n);\nvec4 v2 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n);\nvec4 v3 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n);\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\n#else\nmat4 getJointMatrix (float i) {\nint idx = int(i);\nvec4 v1 = cc_joints[idx * 3];\nvec4 v2 = cc_joints[idx * 3 + 1];\nvec4 v3 = cc_joints[idx * 3 + 2];\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\nmat4 skinMatrix () {\nvec4 joints = vec4(a_joints);\nreturn getJointMatrix(joints.x) * a_weights.x\n+ getJointMatrix(joints.y) * a_weights.y\n+ getJointMatrix(joints.z) * a_weights.z\n+ getJointMatrix(joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\nmat4 m = skinMatrix();\nposition = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\nmat4 m = skinMatrix();\nattr.position = m * attr.position;\nattr.normal = (m * vec4(attr.normal, 0.0)).xyz;\nattr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\n#if USE_INSTANCING\nin vec4 a_matWorld0;\nin vec4 a_matWorld1;\nin vec4 a_matWorld2;\n#if USE_LIGHTMAP\nin vec4 a_lightingMapUVParam;\n#endif\n#elif USE_BATCHING\nin float a_dyn_batch_id;\nlayout(std140) uniform CCLocalBatched {\nhighp mat4 cc_matWorlds[10];\n};\n#else\nlayout(std140) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\n};\n#endif\nlayout(std140) uniform Constants {\nvec4 tilingOffset;\nvec4 albedo;\nvec4 albedoScaleAndCutoff;\nvec4 pbrParams;\nvec4 miscParams;\nvec4 emissive;\nvec4 emissiveScaleParam;\n};\nlayout(std140) uniform CCShadow {\nhighp mat4 cc_matLightPlaneProj;\nhighp mat4 cc_matLightView;\nhighp mat4 cc_matLightViewProj;\nlowp  vec4 cc_shadowNFLSInfo;\nlowp  vec4 cc_shadowWHPBInfo;\nlowp  vec4 cc_shadowLPNNInfo;\nlowp  vec4 cc_shadowColor;\n};\n#if HAS_SECOND_UV || USE_LIGHTMAP\nin vec2 a_texCoord1;\n#endif\nout vec2 v_uv;\nout vec2 v_uv1;\nout vec4 v_worldPos;\nout float v_clip_depth;\nvec4 vert () {\nStandardVertInput In;\nIn.position = vec4(a_position, 1.0);\nIn.normal = a_normal;\nIn.tangent = a_tangent;\n#if CC_USE_MORPH\napplyMorph(In);\n#endif\n#if CC_USE_SKINNING\nCCSkin(In);\n#endif\nmat4 matWorld, matWorldIT;\n#if USE_INSTANCING\nmatWorld = mat4(\nvec4(a_matWorld0.xyz, 0.0),\nvec4(a_matWorld1.xyz, 0.0),\nvec4(a_matWorld2.xyz, 0.0),\nvec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n);\nmatWorldIT = matWorld;\n#elif USE_BATCHING\nmatWorld = cc_matWorlds[int(a_dyn_batch_id)];\nmatWorldIT = matWorld;\n#else\nmatWorld = cc_matWorld;\nmatWorldIT = cc_matWorldIT;\n#endif\nv_worldPos = matWorld * In.position;\nvec4 clipPos = cc_matLightViewProj * v_worldPos;\nv_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n#if HAS_SECOND_UV\nv_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n#endif\nv_clip_depth = clipPos.z / clipPos.w * 0.5 + 0.5;\nreturn clipPos;\n}\nvoid main() { gl_Position = vert(); }",
  "frag": "\nprecision highp float;\nlayout(std140) uniform Constants {\nvec4 tilingOffset;\nvec4 albedo;\nvec4 albedoScaleAndCutoff;\nvec4 pbrParams;\nvec4 miscParams;\nvec4 emissive;\nvec4 emissiveScaleParam;\n};\nvec4 packDepthToRGBA (float depth) {\nvec4 ret = vec4(1.0, 255.0, 65025.0, 160581375.0) * depth;\nret = fract(ret);\nret -= ret.yzww * vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0);\nreturn ret;\n}\nlayout(std140) uniform CCShadow {\nhighp mat4 cc_matLightPlaneProj;\nhighp mat4 cc_matLightView;\nhighp mat4 cc_matLightViewProj;\nlowp  vec4 cc_shadowNFLSInfo;\nlowp  vec4 cc_shadowWHPBInfo;\nlowp  vec4 cc_shadowLPNNInfo;\nlowp  vec4 cc_shadowColor;\n};\nin vec2 v_uv;\nin vec2 v_uv1;\nin vec4 v_worldPos;\nin float v_clip_depth;\n#if USE_ALBEDO_MAP\nuniform sampler2D albedoMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvec4 frag () {\nvec4 baseColor = albedo;\n#if USE_ALBEDO_MAP\nbaseColor *= texture(albedoMap, ALBEDO_UV);\n#endif\n#if USE_ALPHA_TEST\nif (baseColor.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n#endif\nif(cc_shadowLPNNInfo.x > 0.000001 && cc_shadowLPNNInfo.x < 1.999999) {\nif (cc_shadowNFLSInfo.z > 0.000001) {\nvec4 viewStartPos = cc_matLightView * v_worldPos;\nfloat dist = length(viewStartPos.xyz);\nfloat linearDepth = cc_shadowNFLSInfo.x + (-dist / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x));\nreturn vec4(linearDepth, 1.0, 1.0, 1.0);\n}\n}\nif (cc_shadowLPNNInfo.y > 0.000001) {\nreturn packDepthToRGBA(v_clip_depth);\n}\nreturn vec4(v_clip_depth, 1.0, 1.0, 1.0);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
}], [{
  "vert": "\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\nlayout(std140) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\n};\nfloat LinearFog(vec4 pos) {\nvec4 wPos = pos;\nfloat cam_dis = distance(cc_cameraPos, wPos);\nfloat fogStart = cc_fogBase.x;\nfloat fogEnd = cc_fogBase.y;\nreturn clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\nfloat f = exp(-cam_dis * fogDensity);\nreturn f;\n}\nfloat ExpSquaredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\nfloat f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\nreturn f;\n}\nfloat LayeredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat _FogTop = cc_fogAdd.x;\nfloat _FogRange = cc_fogAdd.y;\nvec3 camWorldProj = cc_cameraPos.xyz;\ncamWorldProj.y = 0.;\nvec3 worldPosProj = wPos.xyz;\nworldPosProj.y = 0.;\nfloat fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\nfloat fDeltaY, fDensityIntegral;\nif (cc_cameraPos.y > _FogTop) {\nif (wPos.y < _FogTop) {\nfDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\nfDensityIntegral = fDeltaY * fDeltaY * 0.5;\n} else {\nfDeltaY = 0.;\nfDensityIntegral = 0.;\n}\n} else {\nif (wPos.y < _FogTop) {\nfloat fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfloat fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\nfDeltaY = abs(fDeltaA - fDeltaB);\nfDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n} else {\nfDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n}\n}\nfloat fDensity;\nif (fDeltaY != 0.) {\nfDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n} else {\nfDensity = 0.;\n}\nfloat f = exp(-fDensity);\nreturn f;\n}\nout float v_fog_factor;\nout highp vec4 v_shadowPos;\nlayout(std140) uniform CCShadow {\nhighp mat4 cc_matLightPlaneProj;\nhighp mat4 cc_matLightView;\nhighp mat4 cc_matLightViewProj;\nlowp  vec4 cc_shadowNFLSInfo;\nlowp  vec4 cc_shadowWHPBInfo;\nlowp  vec4 cc_shadowLPNNInfo;\nlowp  vec4 cc_shadowColor;\n};\n#if CC_RECEIVE_SHADOW\nuniform sampler2D cc_shadowMap;\nuniform sampler2D cc_spotLightingMap;\n#endif\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nout highp vec3 v_position;\nout mediump vec3 v_normal;\n#if USE_NORMALMAP\nout mediump vec3 v_tangent;\nout mediump vec3 v_binormal;\n#endif\nout mediump vec2 uvw;\nout mediump vec2 uv0;\nout mediump vec2 uv1;\nout mediump vec2 uv2;\nout mediump vec2 uv3;\nout mediump vec3 luv;\nout mediump vec3 diffuse;\nlayout(std140) uniform TexCoords {\nvec4 UVScale;\nvec4 lightMapUVParam;\n};\nvoid main () {\nvec3 worldPos;\nworldPos.x = cc_matWorld[3][0] + a_position.x;\nworldPos.y = cc_matWorld[3][1] + a_position.y;\nworldPos.z = cc_matWorld[3][2] + a_position.z;\nvec4 pos = vec4(worldPos, 1.0);\npos = cc_matViewProj * pos;\nuvw = a_texCoord;\nuv0 = a_position.xz * UVScale.x;\nuv1 = a_position.xz * UVScale.y;\nuv2 = a_position.xz * UVScale.z;\nuv3 = a_position.xz * UVScale.w;\n#if USE_LIGHTMAP\nluv.xy = lightMapUVParam.xy + a_texCoord * lightMapUVParam.zw;\nluv.z = lightMapUVParam.z;\n#endif\nv_position = worldPos;\nv_normal = a_normal;\n#if CC_USE_FOG == 0\nv_fog_factor = LinearFog(vec4(worldPos, 1.0));\n#elif CC_USE_FOG == 1\nv_fog_factor = ExpFog(vec4(worldPos, 1.0));\n#elif CC_USE_FOG == 2\nv_fog_factor = ExpSquaredFog(vec4(worldPos, 1.0));\n#elif CC_USE_FOG == 3\nv_fog_factor = LayeredFog(vec4(worldPos, 1.0));\n#else\nv_fog_factor = 1.0;\n#endif\n#if USE_NORMALMAP\nv_tangent = vec3(1.0, 0.0, 0.0);\nv_binormal = vec3(0.0, 0.0, 1.0);\nv_binormal = cross(v_tangent, a_normal);\nv_tangent = cross(a_normal, v_binormal);\n#endif\nv_shadowPos = cc_matLightViewProj * vec4(worldPos, 1.0);\ngl_Position = pos;\n}",
  "frag": "\nprecision highp float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nlayout(std140) uniform CCShadow {\nhighp mat4 cc_matLightPlaneProj;\nhighp mat4 cc_matLightView;\nhighp mat4 cc_matLightViewProj;\nlowp  vec4 cc_shadowNFLSInfo;\nlowp  vec4 cc_shadowWHPBInfo;\nlowp  vec4 cc_shadowLPNNInfo;\nlowp  vec4 cc_shadowColor;\n};\n#if CC_RECEIVE_SHADOW\nuniform sampler2D cc_shadowMap;\nuniform sampler2D cc_spotLightingMap;\nfloat CCGetLinearDepth (vec3 worldPos) {\nvec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\nfloat dist = length(viewStartPos.xyz);\nreturn cc_shadowNFLSInfo.x + (-dist / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x));\n}\nfloat CCGetShadowFactorHard (vec4 shadowPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat shadow = 0.0;\nfloat closestDepth = 0.0;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nclosestDepth = dot(texture(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n} else {\nclosestDepth = texture(cc_shadowMap, clipPos.xy).x;\n}\nshadow = step(clipPos.z- cc_shadowWHPBInfo.w, closestDepth);\nreturn shadow;\n}\nfloat CCGetShadowFactorSoft (vec4 shadowPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat offsetDepth = clipPos.z - cc_shadowWHPBInfo.w;\nvec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;\nvec2 clipPos_offset = clipPos.xy + oneTap;\nfloat block0, block1, block2, block3;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nblock0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\n} else {\nblock0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\nblock1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);\nblock2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);\nblock3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n}\nfloat coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block2, block3, coefX);\nfloat coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;\nreturn mix(resultX, resultY, coefY);\n}\nfloat CCGetShadowFactorSoft2X (vec4 shadowPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat bias = cc_shadowWHPBInfo.w;\nfloat offsetDepth = clipPos.z - bias;\nvec2 mapSize = cc_shadowWHPBInfo.xy;\nvec2 oneTap = 1.0 / mapSize;\nfloat clipPos_offset_L = clipPos.x - oneTap.x;\nfloat clipPos_offset_R = clipPos.x + oneTap.x;\nfloat clipPos_offset_U = clipPos.y - oneTap.y;\nfloat clipPos_offset_D = clipPos.y + oneTap.y;\nfloat block0, block1, block2, block3, block4, block5, block6, block7, block8;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nblock0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock4 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock5 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock6 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock7 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock8 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\n} else {\nblock0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\nblock1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);\nblock2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\nblock3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);\nblock4 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\nblock5 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);\nblock6 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\nblock7 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);\nblock8 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n}\nfloat coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\nfloat coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\nfloat shadow = 0.0;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block3, block4, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block1, block2, coefX);\nresultY = mix(block4, block5, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block3, block4, coefX);\nresultY = mix(block6, block7, coefX);\nshadow += mix(resultX, resultY, coefY);\nresultX = mix(block4, block5, coefX);\nresultY = mix(block7, block8, coefX);\nshadow += mix(resultX, resultY, coefY);\nreturn shadow * 0.25;\n}\nfloat CCGetSpotLightShadowFactorHard (vec4 shadowPos, vec3 worldPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat shadow = 0.0;\nfloat closestDepth = 0.0;\nfloat depth = 0.0;\nif (cc_shadowNFLSInfo.z > 0.000001) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nif (cc_shadowLPNNInfo.y > 0.000001) {\nclosestDepth = dot(texture(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n} else {\nclosestDepth = texture(cc_spotLightingMap, clipPos.xy).x;\n}\nshadow = step(depth - cc_shadowWHPBInfo.w, closestDepth);\nreturn shadow;\n}\nfloat CCGetSpotLightShadowFactorSoft (vec4 shadowPos, vec3 worldPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat offsetx = 1.0 / cc_shadowWHPBInfo.x;\nfloat offsety = 1.0 / cc_shadowWHPBInfo.y;\nfloat shadow = 0.0;\nfloat depth = 0.0;\nif (cc_shadowNFLSInfo.z > 0.000001) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nfloat offsetDepth = depth - cc_shadowWHPBInfo.w;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nfloat closestDepth = dot(texture(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = dot(texture(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = dot(texture(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = dot(texture(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(offsetDepth, closestDepth);\n} else {\nfloat closestDepth = texture(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y - offsety)).x;\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = texture(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y + offsety)).x;\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x;\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = texture(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y - offsety)).x;\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = texture(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y + offsety)).x;\nshadow += step(offsetDepth, closestDepth);\n}\nreturn shadow / 5.0;\n}\nfloat CCGetSpotLightShadowFactorSoft2X (vec4 shadowPos, vec3 worldPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat offsetx = 1.0 / cc_shadowWHPBInfo.x;\nfloat offsety = 1.0 / cc_shadowWHPBInfo.y;\nfloat shadow = 0.0;\nfloat depth = 0.0;\nif (cc_shadowNFLSInfo.z > 0.000001) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nfloat offsetDepth = depth - cc_shadowWHPBInfo.w;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nfor (int i = -1; i <= 1; i++) {\nfor (int j = -1; j <= 1; j++) {\nfloat closestDepth = dot(texture(cc_spotLightingMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(offsetDepth, closestDepth);\n}\n}\n} else {\nfor (int i = -1; i <= 1; i++) {\nfor (int j = -1; j <= 1; j++) {\nfloat closestDepth = texture(cc_spotLightingMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)).x;\nshadow += step(offsetDepth, closestDepth);\n}\n}\n}\nreturn shadow / 9.0;\n}\n#endif\n#if CC_USE_IBL\nuniform samplerCube cc_environment;\nvec3 unpackRGBE (vec4 rgbe) {\nreturn rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n}\nvec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\nreturn textureLod(tex, coord, lod);\n}\nvec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\nreturn textureLod(tex, coord, lod);\n}\n#endif\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\nvec3 NxH = cross(N, H);\nfloat OneMinusNoHSqr = dot(NxH, NxH);\nfloat a = roughness * roughness;\nfloat n = NoH * a;\nfloat p = a / (OneMinusNoHSqr + n * n);\nreturn p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\nreturn (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\nconst vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\nconst vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\nvec4 r = roughness * c0 + c1;\nfloat a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\nvec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\nAB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\nreturn specular * AB.x + AB.y;\n}\nstruct StandardSurface {\nvec4 albedo;\nvec3 position;\nvec3 normal;\nvec3 emissive;\nvec3 lightmap;\nfloat lightmap_test;\nfloat roughness;\nfloat metallic;\nfloat occlusion;\n};\nvec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - s.position);\nfloat NV = max(abs(dot(N, V)), 0.0);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 L = normalize(-cc_mainLitDir.xyz);\nvec3 H = normalize(L + V);\nfloat NH = max(dot(N, H), 0.0);\nfloat NL = max(dot(N, L), 0.0);\nvec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\nvec3 diffuseContrib = diffuse;\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nif (s.lightmap_test > 0.0001) {\nfinalColor = s.lightmap.rgb;\n}\n#else\ndiffuseContrib /= 3.14159265359;\n#endif\nvec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\nvec3 dirlightContrib = (diffuseContrib + specularContrib);\nfloat shadow = 1.0;\n#if CC_RECEIVE_SHADOW\nif (NL > 0.0) {\n{\nfloat pcf = cc_shadowWHPBInfo.z;\nvec3 projWorldPos = shadowPos.xyz + (1.0 - NL) * cc_shadowLPNNInfo.z * N;\nvec4 pos = vec4(projWorldPos.xyz, shadowPos.w);\nif (pcf > 1.9) shadow = CCGetShadowFactorSoft2X(pos);\nelse if (pcf > 0.9) shadow = CCGetShadowFactorSoft(pos);\nelse shadow = CCGetShadowFactorHard(pos);\nshadow = mix(shadow, 1.0, cc_shadowNFLSInfo.w);\n}\n}\n#endif\ndirlightContrib *= shadow;\nfinalColor *= dirlightContrib;\nfloat fAmb = 0.5 - N.y * 0.5;\nvec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb) * cc_ambientSky.w;\nfinalColor += (ambDiff.rgb * diffuse) * s.occlusion;\n#if CC_USE_IBL\nvec3 R = normalize(reflect(-V, N));\nvec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n#if CC_USE_IBL == 2\nvec3 env = unpackRGBE(envmap);\n#else\nvec3 env = SRGBToLinear(envmap.rgb);\n#endif\nfinalColor += env * cc_ambientSky.w * specular * s.occlusion;\n#endif\n#if CC_USE_HDR\ns.emissive *= cc_exposure.w;\n#endif\nfinalColor += s.emissive;\nreturn vec4(finalColor, s.albedo.a);\n}\nvec3 ACESToneMap (vec3 color) {\ncolor = min(color, vec3(8.0));\nconst float A = 2.51;\nconst float B = 0.03;\nconst float C = 2.43;\nconst float D = 0.59;\nconst float E = 0.14;\nreturn (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n#if !CC_USE_HDR\ncolor.rgb = sqrt(ACESToneMap(color.rgb));\n#endif\nreturn color;\n}\nin float v_fog_factor;\nin highp vec4 v_shadowPos;\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nin vec3 v_luv;\nuniform sampler2D cc_lightingMap;\nvec3 UnpackLightingmap(vec4 color) {\nvec3 c;\nfloat e = 1.0 + color.a * (8.0 - 1.0);\nc.r = color.r * e;\nc.g = color.g * e;\nc.b = color.b * e;\nreturn c;\n}\n#endif\nin highp vec3 v_position;\nin mediump vec3 v_normal;\n#if USE_NORMALMAP\nin mediump vec3 v_tangent;\nin mediump vec3 v_binormal;\n#endif\nin mediump vec2 uvw;\nin mediump vec2 uv0;\nin mediump vec2 uv1;\nin mediump vec2 uv2;\nin mediump vec2 uv3;\nin mediump vec3 diffuse;\nin mediump vec3 luv;\nlayout(std140) uniform PbrParams {\nvec4 metallic;\nvec4 roughness;\n};\nuniform sampler2D weightMap;\nuniform sampler2D detailMap0;\nuniform sampler2D detailMap1;\nuniform sampler2D detailMap2;\nuniform sampler2D detailMap3;\nuniform sampler2D normalMap0;\nuniform sampler2D normalMap1;\nuniform sampler2D normalMap2;\nuniform sampler2D normalMap3;\nuniform sampler2D lightMap;\nvoid surf (out StandardSurface s) {\n#if LAYERS > 1\nvec4 w = texture(weightMap, uvw);\n#endif\nvec4 baseColor = vec4(0, 0, 0, 0);\n#if LAYERS == 1\nbaseColor = texture(detailMap0, uv0);\n#elif LAYERS == 2\nbaseColor += texture(detailMap0, uv0) * w.r;\nbaseColor += texture(detailMap1, uv1) * w.g;\n#elif LAYERS == 3\nbaseColor += texture(detailMap0, uv0) * w.r;\nbaseColor += texture(detailMap1, uv1) * w.g;\nbaseColor += texture(detailMap2, uv2) * w.b;\n#elif LAYERS == 4\nbaseColor += texture(detailMap0, uv0) * w.r;\nbaseColor += texture(detailMap1, uv1) * w.g;\nbaseColor += texture(detailMap2, uv2) * w.b;\nbaseColor += texture(detailMap3, uv3) * w.a;\n#else\nbaseColor = texture(detailMap0, uv0);\n#endif\ns.position = v_position;\n#if USE_NORMALMAP\nvec4 baseNormal = vec4(0, 0, 0, 0);\n#if LAYERS == 1\nbaseNormal = texture(normalMap0, uv0);\n#elif LAYERS == 2\nbaseNormal += texture(normalMap0, uv0) * w.r;\nbaseNormal += texture(normalMap1, uv1) * w.g;\n#elif LAYERS == 3\nbaseNormal += texture(normalMap0, uv0) * w.r;\nbaseNormal += texture(normalMap1, uv1) * w.g;\nbaseNormal += texture(normalMap2, uv2) * w.b;\n#elif LAYERS == 4\nbaseNormal += texture(normalMap0, uv0) * w.r;\nbaseNormal += texture(normalMap1, uv1) * w.g;\nbaseNormal += texture(normalMap2, uv2) * w.b;\nbaseNormal += texture(normalMap3, uv3) * w.a;\n#else\nbaseNormal = texture(normalMap0, uv0);\n#endif\nvec3 nmmp = baseNormal.xyz - vec3(0.5);\ns.normal =\nnmmp.x * normalize(v_tangent) +\nnmmp.y * normalize(v_binormal) +\nnmmp.z * normalize(v_normal);\n#else\ns.normal = v_normal;\n#endif\ns.albedo = vec4(SRGBToLinear(baseColor.rgb), 1.0);\ns.occlusion = 1.0;\n#if USE_PBR\ns.roughness = 0.0;\n#if LAYERS == 1\ns.roughness = roughness.x;\n#elif LAYERS == 2\ns.roughness += roughness.x * w.r;\ns.roughness += roughness.y * w.g;\n#elif LAYERS == 3\ns.roughness += roughness.x * w.r;\ns.roughness += roughness.y * w.g;\ns.roughness += roughness.z * w.b;\n#elif LAYERS == 4\ns.roughness += roughness.x * w.r;\ns.roughness += roughness.y * w.g;\ns.roughness += roughness.z * w.b;\ns.roughness += roughness.w * w.a;\n#else\ns.roughness = 1.0;\n#endif\ns.metallic = 0.0;\n#if LAYERS == 1\ns.metallic = metallic.x;\n#elif LAYERS == 2\ns.metallic += metallic.x * w.r;\ns.metallic += metallic.y * w.g;\n#elif LAYERS == 3\ns.metallic += metallic.x * w.r;\ns.metallic += metallic.y * w.g;\ns.metallic += metallic.z * w.b;\n#elif LAYERS == 4\ns.metallic += metallic.x * w.r;\ns.metallic += metallic.y * w.g;\ns.metallic += metallic.z * w.b;\ns.metallic += metallic.w * w.a;\n#else\ns.metallic = 0.0;\n#endif\n#else\ns.roughness = 1.0;\ns.metallic = 0.0;\n#endif\ns.emissive = vec3(0.0, 0.0, 0.0);\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nvec4 lightColor = texture(lightMap, luv.xy);\ns.lightmap = UnpackLightingmap(lightColor);\ns.lightmap_test = luv.z;\n#endif\n}\n#if CC_FORWARD_ADD\n#if CC_PIPELINE_TYPE == 0\n# define LIGHTS_PER_PASS 1\n#else\n# define LIGHTS_PER_PASS 10\n#endif\nlayout(std140) uniform CCForwardLight {\nhighp vec4 cc_lightPos[LIGHTS_PER_PASS];\nvec4 cc_lightColor[LIGHTS_PER_PASS];\nvec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\nvec4 cc_lightDir[LIGHTS_PER_PASS];\n};\nfloat SmoothDistAtt (float distSqr, float invSqrAttRadius) {\nfloat factor = distSqr * invSqrAttRadius;\nfloat smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\nreturn smoothFactor * smoothFactor;\n}\nfloat GetDistAtt (float distSqr, float invSqrAttRadius) {\nfloat attenuation = 1.0 / max(distSqr, 0.01*0.01);\nattenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\nreturn attenuation;\n}\nfloat GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\nfloat cd = dot(litDir, L);\nfloat attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\nreturn (attenuation * attenuation);\n}\nvec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\nvec3 diffuseContrib = diffuse / 3.14159265359;\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - s.position);\nfloat NV = max(abs(dot(N, V)), 0.001);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 finalColor = vec3(0.0);\nint numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\nfor (int i = 0; i < LIGHTS_PER_PASS; i++) {\nif (i >= numLights) break;\nvec3 SLU = cc_lightPos[i].xyz - s.position;\nvec3 SL = normalize(SLU);\nvec3 SH = normalize(SL + V);\nfloat SNL = max(dot(N, SL), 0.001);\nfloat SNH = max(dot(N, SH), 0.0);\nfloat distSqr = dot(SLU, SLU);\nfloat litRadius = cc_lightSizeRangeAngle[i].x;\nfloat litRadiusSqr = litRadius * litRadius;\nfloat illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\nfloat attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\nattRadiusSqrInv *= attRadiusSqrInv;\nfloat att = GetDistAtt(distSqr, attRadiusSqrInv);\nvec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\nif (cc_lightPos[i].w > 0.0) {\nfloat cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\nfloat cosOuter = cc_lightSizeRangeAngle[i].z;\nfloat litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\nfloat litAngleOffset = -cosOuter * litAngleScale;\natt *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n}\nvec3 lightColor = cc_lightColor[i].rgb;\nfloat shadow = 1.0;\n#if CC_RECEIVE_SHADOW\nif (cc_lightPos[i].w > 0.0) {\n{\nfloat pcf = cc_shadowWHPBInfo.z;\nfloat cosAngle = clamp(1.0 - dot(N, normalize(cc_lightPos[i].xyz - s.position.xyz)), 0.0, 1.0);\nvec3 projWorldPos = shadowPos.xyz + cosAngle * cc_shadowLPNNInfo.z * N;\nvec4 pos = vec4(projWorldPos.xyz, shadowPos.w);\nif (pcf > 1.9) shadow = CCGetSpotLightShadowFactorSoft2X(pos, s.position);\nelse if (pcf > 0.9) shadow = CCGetSpotLightShadowFactorSoft(pos, s.position);\nelse shadow = CCGetSpotLightShadowFactorHard(pos, s.position);\n}\n}\n#endif\nlightColor *= shadow;\nfinalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n}\nreturn vec4(finalColor, 0.0);\n}\nlayout(location = 0) out vec4 fragColorX;\nvoid main () {\nStandardSurface s; surf(s);\nvec4 color = CCStandardShadingAdditive(s, v_shadowPos);\ncolor = vec4(mix(CC_FORWARD_ADD > 0 ? vec3(0.0) : cc_fogColor.rgb, color.rgb, v_fog_factor), color.a);\nfragColorX = CCFragOutput(color);\n}\n#elif CC_PIPELINE_TYPE == 0\nlayout(location = 0) out vec4 fragColorX;\nvoid main () {\nStandardSurface s; surf(s);\nvec4 color = CCStandardShadingBase(s, v_shadowPos);\ncolor = vec4(mix(CC_FORWARD_ADD > 0 ? vec3(0.0) : cc_fogColor.rgb, color.rgb, v_fog_factor), color.a);\nfragColorX = CCFragOutput(color);\n}\n#elif CC_PIPELINE_TYPE == 1\nlayout(location = 0) out vec4 fragColor0;\nlayout(location = 1) out vec4 fragColor1;\nlayout(location = 2) out vec4 fragColor2;\nlayout(location = 3) out vec4 fragColor3;\nvoid main () {\nStandardSurface s; surf(s);\nfragColor0 = s.albedo;\nfragColor1 = vec4(s.position, s.roughness);\nfragColor2 = vec4(s.normal, s.metallic);\nfragColor3 = vec4(s.emissive, s.occlusion);\n}\n#endif"
}, {
  "vert": "\nprecision highp float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\nlayout(std140) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\n};\nlayout(std140) uniform CCShadow {\nhighp mat4 cc_matLightPlaneProj;\nhighp mat4 cc_matLightView;\nhighp mat4 cc_matLightViewProj;\nlowp  vec4 cc_shadowNFLSInfo;\nlowp  vec4 cc_shadowWHPBInfo;\nlowp  vec4 cc_shadowLPNNInfo;\nlowp  vec4 cc_shadowColor;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nout vec2 v_clip_depth;\nvec4 vert () {\nvec4 worldPos;\nworldPos.x = cc_matWorld[3][0] + a_position.x;\nworldPos.y = cc_matWorld[3][1] + a_position.y;\nworldPos.z = cc_matWorld[3][2] + a_position.z;\nworldPos.w = 1.0;\nvec4 clipPos = cc_matLightViewProj * worldPos;\nv_clip_depth = clipPos.zw;\nreturn clipPos;\n}\nvoid main() { gl_Position = vert(); }",
  "frag": "\nprecision highp float;\nvec4 packDepthToRGBA (float depth) {\nvec4 ret = vec4(1.0, 255.0, 65025.0, 160581375.0) * depth;\nret = fract(ret);\nret -= ret.yzww * vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0);\nreturn ret;\n}\nin vec2 v_clip_depth;\nvec4 frag () {\nreturn packDepthToRGBA(v_clip_depth.x / v_clip_depth.y * 0.5 + 0.5);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
}], [{
  "vert": "\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\nrgba = rgba * 255.0;\nhighp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\nhighp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\nhighp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\nreturn Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_MORPH\nin float a_vertexId;\nint getVertexId() {\nreturn int(a_vertexId);\n}\nlayout(std140) uniform CCMorph {\nvec4 cc_displacementWeights[15];\nvec4 cc_displacementTextureInfo;\n};\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\nfloat pixelIndexF = float(pixelIndex);\nfloat x = mod(pixelIndexF, textureResolution.x);\nfloat y = floor(pixelIndexF / textureResolution.x);\nreturn vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\nreturn (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\nivec2 texSize = textureSize(tex, 0);\nreturn texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n}\n#else\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex * 4;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\nreturn vec4(\ndecode32(texture(tex, x)),\ndecode32(texture(tex, y)),\ndecode32(texture(tex, z)),\n1.0\n);\n}\n#endif\nfloat getDisplacementWeight(int index) {\nint quot = index / 4;\nint remainder = index - quot * 4;\nif (remainder == 0) {\nreturn cc_displacementWeights[quot].x;\n} else if (remainder == 1) {\nreturn cc_displacementWeights[quot].y;\n} else if (remainder == 2) {\nreturn cc_displacementWeights[quot].z;\n} else {\nreturn cc_displacementWeights[quot].w;\n}\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\nreturn fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\nvec3 result = vec3(0, 0, 0);\nint nVertices = int(cc_displacementTextureInfo.z);\nfor (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\nresult += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n}\nreturn result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\nuniform sampler2D cc_PositionDisplacements;\nvec3 getPositionDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nuniform sampler2D cc_NormalDisplacements;\nvec3 getNormalDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nuniform sampler2D cc_TangentDisplacements;\nvec3 getTangentDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n}\n#endif\nvoid applyMorph (inout StandardVertInput attr) {\nint vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\nattr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nattr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nattr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\nin vec4 a_joints;\nin vec4 a_weights;\n#if CC_USE_BAKED_ANIMATION\n#if USE_INSTANCING\nin highp vec4 a_jointAnimInfo;\n#endif\nlayout(std140) uniform CCSkinningTexture {\nhighp vec4 cc_jointTextureInfo;\n};\nlayout(std140) uniform CCSkinningAnimation {\nhighp vec4 cc_jointAnimInfo;\n};\nuniform highp sampler2D cc_jointTexture;\n#else\nlayout(std140) uniform CCSkinning {\nhighp vec4 cc_joints[30 * 3];\n};\n#endif\n#if CC_USE_BAKED_ANIMATION\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nmat4 getJointMatrix (float i) {\n#if USE_INSTANCING\nhighp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n#else\nhighp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n#endif\nhighp float invSize = cc_jointTextureInfo.w;\nhighp float y = floor(j * invSize);\nhighp float x = floor(j - y * cc_jointTextureInfo.x);\ny = (y + 0.5) * invSize;\nvec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\nvec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\nvec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#else\nmat4 getJointMatrix (float i) {\n#if USE_INSTANCING\nhighp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n#else\nhighp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n#endif\nhighp float invSize = cc_jointTextureInfo.w;\nhighp float y = floor(j * invSize);\nhighp float x = floor(j - y * cc_jointTextureInfo.x);\ny = (y + 0.5) * invSize;\nvec4 v1 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n);\nvec4 v2 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n);\nvec4 v3 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n);\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\n#else\nmat4 getJointMatrix (float i) {\nint idx = int(i);\nvec4 v1 = cc_joints[idx * 3];\nvec4 v2 = cc_joints[idx * 3 + 1];\nvec4 v3 = cc_joints[idx * 3 + 2];\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\nmat4 skinMatrix () {\nvec4 joints = vec4(a_joints);\nreturn getJointMatrix(joints.x) * a_weights.x\n+ getJointMatrix(joints.y) * a_weights.y\n+ getJointMatrix(joints.z) * a_weights.z\n+ getJointMatrix(joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\nmat4 m = skinMatrix();\nposition = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\nmat4 m = skinMatrix();\nattr.position = m * attr.position;\nattr.normal = (m * vec4(attr.normal, 0.0)).xyz;\nattr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\n#if USE_INSTANCING\nin vec4 a_matWorld0;\nin vec4 a_matWorld1;\nin vec4 a_matWorld2;\n#if USE_LIGHTMAP\nin vec4 a_lightingMapUVParam;\n#endif\n#elif USE_BATCHING\nin float a_dyn_batch_id;\nlayout(std140) uniform CCLocalBatched {\nhighp mat4 cc_matWorlds[10];\n};\n#else\nlayout(std140) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\n};\n#endif\nfloat LinearFog(vec4 pos) {\nvec4 wPos = pos;\nfloat cam_dis = distance(cc_cameraPos, wPos);\nfloat fogStart = cc_fogBase.x;\nfloat fogEnd = cc_fogBase.y;\nreturn clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\nfloat f = exp(-cam_dis * fogDensity);\nreturn f;\n}\nfloat ExpSquaredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\nfloat f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\nreturn f;\n}\nfloat LayeredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat _FogTop = cc_fogAdd.x;\nfloat _FogRange = cc_fogAdd.y;\nvec3 camWorldProj = cc_cameraPos.xyz;\ncamWorldProj.y = 0.;\nvec3 worldPosProj = wPos.xyz;\nworldPosProj.y = 0.;\nfloat fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\nfloat fDeltaY, fDensityIntegral;\nif (cc_cameraPos.y > _FogTop) {\nif (wPos.y < _FogTop) {\nfDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\nfDensityIntegral = fDeltaY * fDeltaY * 0.5;\n} else {\nfDeltaY = 0.;\nfDensityIntegral = 0.;\n}\n} else {\nif (wPos.y < _FogTop) {\nfloat fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfloat fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\nfDeltaY = abs(fDeltaA - fDeltaB);\nfDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n} else {\nfDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n}\n}\nfloat fDensity;\nif (fDeltaY != 0.) {\nfDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n} else {\nfDensity = 0.;\n}\nfloat f = exp(-fDensity);\nreturn f;\n}\nout float v_fog_factor;\n#if USE_VERTEX_COLOR\nin lowp vec4 a_color;\nout lowp vec4 v_color;\n#endif\n#if USE_TEXTURE\nout vec2 v_uv;\nlayout(std140) uniform TexCoords {\nvec4 tilingOffset;\n};\n#endif\nvec4 vert () {\nvec4 position;\nposition = vec4(a_position, 1.0);\n#if CC_USE_MORPH\napplyMorph(position);\n#endif\n#if CC_USE_SKINNING\nCCSkin(position);\n#endif\nmat4 matWorld;\n#if USE_INSTANCING\nmatWorld = mat4(\nvec4(a_matWorld0.xyz, 0.0),\nvec4(a_matWorld1.xyz, 0.0),\nvec4(a_matWorld2.xyz, 0.0),\nvec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n);\n#elif USE_BATCHING\nmatWorld = cc_matWorlds[int(a_dyn_batch_id)];\n#else\nmatWorld = cc_matWorld;\n#endif\n#if USE_TEXTURE\nv_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n#if SAMPLE_FROM_RT\nv_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n#endif\n#endif\n#if USE_VERTEX_COLOR\nv_color = a_color;\n#endif\n#if CC_USE_FOG == 0\nv_fog_factor = LinearFog(matWorld * position);\n#elif CC_USE_FOG == 1\nv_fog_factor = ExpFog(matWorld * position);\n#elif CC_USE_FOG == 2\nv_fog_factor = ExpSquaredFog(matWorld * position);\n#elif CC_USE_FOG == 3\nv_fog_factor = LayeredFog(matWorld * position);\n#else\nv_fog_factor = 1.0;\n#endif\nreturn cc_matProj * (cc_matView * matWorld) * position;\n}\nvoid main() { gl_Position = vert(); }",
  "frag": "\nprecision highp float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n#if CC_USE_HDR\ncolor.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n#endif\nreturn color;\n}\nin float v_fog_factor;\n#if USE_ALPHA_TEST\n#endif\n#if USE_TEXTURE\nin vec2 v_uv;\nuniform sampler2D mainTexture;\n#endif\nlayout(std140) uniform Constant {\nvec4 mainColor;\nvec4 colorScaleAndCutoff;\n};\n#if USE_VERTEX_COLOR\nin lowp vec4 v_color;\n#endif\nvec4 frag () {\nvec4 o = mainColor;\no.rgb *= colorScaleAndCutoff.xyz;\n#if USE_VERTEX_COLOR\no *= v_color;\n#endif\n#if USE_TEXTURE\no *= texture(mainTexture, v_uv);\n#endif\n#if USE_ALPHA_TEST\nif (o.ALPHA_TEST_CHANNEL < colorScaleAndCutoff.w) discard;\n#endif\no = vec4(mix(CC_FORWARD_ADD > 0 ? vec3(0.0) : cc_fogColor.rgb, o.rgb, v_fog_factor), o.a);\nreturn CCFragOutput(o);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
}], [{
  "vert": "\nprecision highp float;\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\nout vec2 v_uv;\nvoid main () {\nvec4 position;\nposition = vec4(a_position, 1.0);\nposition.xy = cc_cameraPos.w == 0.0 ? vec2(position.xy.x, -position.xy.y) : position.xy;\ngl_Position = vec4(position.x, position.y, 1.0, 1.0);\nv_uv = a_texCoord;\n}",
  "frag": "\nprecision highp float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nlayout(std140) uniform CCShadow {\nhighp mat4 cc_matLightPlaneProj;\nhighp mat4 cc_matLightView;\nhighp mat4 cc_matLightViewProj;\nlowp  vec4 cc_shadowNFLSInfo;\nlowp  vec4 cc_shadowWHPBInfo;\nlowp  vec4 cc_shadowLPNNInfo;\nlowp  vec4 cc_shadowColor;\n};\n#if CC_RECEIVE_SHADOW\nuniform sampler2D cc_shadowMap;\nuniform sampler2D cc_spotLightingMap;\nfloat CCGetLinearDepth (vec3 worldPos) {\nvec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\nfloat dist = length(viewStartPos.xyz);\nreturn cc_shadowNFLSInfo.x + (-dist / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x));\n}\nfloat CCGetShadowFactorHard (vec4 shadowPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat shadow = 0.0;\nfloat closestDepth = 0.0;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nclosestDepth = dot(texture(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n} else {\nclosestDepth = texture(cc_shadowMap, clipPos.xy).x;\n}\nshadow = step(clipPos.z- cc_shadowWHPBInfo.w, closestDepth);\nreturn shadow;\n}\nfloat CCGetShadowFactorSoft (vec4 shadowPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat offsetDepth = clipPos.z - cc_shadowWHPBInfo.w;\nvec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;\nvec2 clipPos_offset = clipPos.xy + oneTap;\nfloat block0, block1, block2, block3;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nblock0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\n} else {\nblock0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\nblock1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);\nblock2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);\nblock3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n}\nfloat coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block2, block3, coefX);\nfloat coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;\nreturn mix(resultX, resultY, coefY);\n}\nfloat CCGetShadowFactorSoft2X (vec4 shadowPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat bias = cc_shadowWHPBInfo.w;\nfloat offsetDepth = clipPos.z - bias;\nvec2 mapSize = cc_shadowWHPBInfo.xy;\nvec2 oneTap = 1.0 / mapSize;\nfloat clipPos_offset_L = clipPos.x - oneTap.x;\nfloat clipPos_offset_R = clipPos.x + oneTap.x;\nfloat clipPos_offset_U = clipPos.y - oneTap.y;\nfloat clipPos_offset_D = clipPos.y + oneTap.y;\nfloat block0, block1, block2, block3, block4, block5, block6, block7, block8;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nblock0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock4 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock5 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock6 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock7 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock8 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\n} else {\nblock0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\nblock1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);\nblock2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\nblock3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);\nblock4 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\nblock5 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);\nblock6 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\nblock7 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);\nblock8 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n}\nfloat coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\nfloat coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\nfloat shadow = 0.0;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block3, block4, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block1, block2, coefX);\nresultY = mix(block4, block5, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block3, block4, coefX);\nresultY = mix(block6, block7, coefX);\nshadow += mix(resultX, resultY, coefY);\nresultX = mix(block4, block5, coefX);\nresultY = mix(block7, block8, coefX);\nshadow += mix(resultX, resultY, coefY);\nreturn shadow * 0.25;\n}\nfloat CCGetSpotLightShadowFactorHard (vec4 shadowPos, vec3 worldPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat shadow = 0.0;\nfloat closestDepth = 0.0;\nfloat depth = 0.0;\nif (cc_shadowNFLSInfo.z > 0.000001) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nif (cc_shadowLPNNInfo.y > 0.000001) {\nclosestDepth = dot(texture(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n} else {\nclosestDepth = texture(cc_spotLightingMap, clipPos.xy).x;\n}\nshadow = step(depth - cc_shadowWHPBInfo.w, closestDepth);\nreturn shadow;\n}\nfloat CCGetSpotLightShadowFactorSoft (vec4 shadowPos, vec3 worldPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat offsetx = 1.0 / cc_shadowWHPBInfo.x;\nfloat offsety = 1.0 / cc_shadowWHPBInfo.y;\nfloat shadow = 0.0;\nfloat depth = 0.0;\nif (cc_shadowNFLSInfo.z > 0.000001) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nfloat offsetDepth = depth - cc_shadowWHPBInfo.w;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nfloat closestDepth = dot(texture(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = dot(texture(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = dot(texture(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = dot(texture(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(offsetDepth, closestDepth);\n} else {\nfloat closestDepth = texture(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y - offsety)).x;\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = texture(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y + offsety)).x;\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x;\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = texture(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y - offsety)).x;\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = texture(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y + offsety)).x;\nshadow += step(offsetDepth, closestDepth);\n}\nreturn shadow / 5.0;\n}\nfloat CCGetSpotLightShadowFactorSoft2X (vec4 shadowPos, vec3 worldPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat offsetx = 1.0 / cc_shadowWHPBInfo.x;\nfloat offsety = 1.0 / cc_shadowWHPBInfo.y;\nfloat shadow = 0.0;\nfloat depth = 0.0;\nif (cc_shadowNFLSInfo.z > 0.000001) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nfloat offsetDepth = depth - cc_shadowWHPBInfo.w;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nfor (int i = -1; i <= 1; i++) {\nfor (int j = -1; j <= 1; j++) {\nfloat closestDepth = dot(texture(cc_spotLightingMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(offsetDepth, closestDepth);\n}\n}\n} else {\nfor (int i = -1; i <= 1; i++) {\nfor (int j = -1; j <= 1; j++) {\nfloat closestDepth = texture(cc_spotLightingMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)).x;\nshadow += step(offsetDepth, closestDepth);\n}\n}\n}\nreturn shadow / 9.0;\n}\n#endif\n#if CC_USE_IBL\nuniform samplerCube cc_environment;\nvec3 unpackRGBE (vec4 rgbe) {\nreturn rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n}\nvec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\nreturn textureLod(tex, coord, lod);\n}\nvec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\nreturn textureLod(tex, coord, lod);\n}\n#endif\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\nvec3 NxH = cross(N, H);\nfloat OneMinusNoHSqr = dot(NxH, NxH);\nfloat a = roughness * roughness;\nfloat n = NoH * a;\nfloat p = a / (OneMinusNoHSqr + n * n);\nreturn p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\nreturn (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\nconst vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\nconst vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\nvec4 r = roughness * c0 + c1;\nfloat a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\nvec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\nAB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\nreturn specular * AB.x + AB.y;\n}\nstruct StandardSurface {\nvec4 albedo;\nvec3 position;\nvec3 normal;\nvec3 emissive;\nvec3 lightmap;\nfloat lightmap_test;\nfloat roughness;\nfloat metallic;\nfloat occlusion;\n};\nvec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - s.position);\nfloat NV = max(abs(dot(N, V)), 0.0);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 L = normalize(-cc_mainLitDir.xyz);\nvec3 H = normalize(L + V);\nfloat NH = max(dot(N, H), 0.0);\nfloat NL = max(dot(N, L), 0.0);\nvec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\nvec3 diffuseContrib = diffuse;\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nif (s.lightmap_test > 0.0001) {\nfinalColor = s.lightmap.rgb;\n}\n#else\ndiffuseContrib /= 3.14159265359;\n#endif\nvec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\nvec3 dirlightContrib = (diffuseContrib + specularContrib);\nfloat shadow = 1.0;\n#if CC_RECEIVE_SHADOW\nif (NL > 0.0) {\n{\nfloat pcf = cc_shadowWHPBInfo.z;\nvec3 projWorldPos = shadowPos.xyz + (1.0 - NL) * cc_shadowLPNNInfo.z * N;\nvec4 pos = vec4(projWorldPos.xyz, shadowPos.w);\nif (pcf > 1.9) shadow = CCGetShadowFactorSoft2X(pos);\nelse if (pcf > 0.9) shadow = CCGetShadowFactorSoft(pos);\nelse shadow = CCGetShadowFactorHard(pos);\nshadow = mix(shadow, 1.0, cc_shadowNFLSInfo.w);\n}\n}\n#endif\ndirlightContrib *= shadow;\nfinalColor *= dirlightContrib;\nfloat fAmb = 0.5 - N.y * 0.5;\nvec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb) * cc_ambientSky.w;\nfinalColor += (ambDiff.rgb * diffuse) * s.occlusion;\n#if CC_USE_IBL\nvec3 R = normalize(reflect(-V, N));\nvec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n#if CC_USE_IBL == 2\nvec3 env = unpackRGBE(envmap);\n#else\nvec3 env = SRGBToLinear(envmap.rgb);\n#endif\nfinalColor += env * cc_ambientSky.w * specular * s.occlusion;\n#endif\n#if CC_USE_HDR\ns.emissive *= cc_exposure.w;\n#endif\nfinalColor += s.emissive;\nreturn vec4(finalColor, s.albedo.a);\n}\n#if CC_PIPELINE_TYPE == 0\n# define LIGHTS_PER_PASS 1\n#else\n# define LIGHTS_PER_PASS 10\n#endif\nlayout(std140) uniform CCForwardLight {\nhighp vec4 cc_lightPos[LIGHTS_PER_PASS];\nvec4 cc_lightColor[LIGHTS_PER_PASS];\nvec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\nvec4 cc_lightDir[LIGHTS_PER_PASS];\n};\nfloat SmoothDistAtt (float distSqr, float invSqrAttRadius) {\nfloat factor = distSqr * invSqrAttRadius;\nfloat smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\nreturn smoothFactor * smoothFactor;\n}\nfloat GetDistAtt (float distSqr, float invSqrAttRadius) {\nfloat attenuation = 1.0 / max(distSqr, 0.01*0.01);\nattenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\nreturn attenuation;\n}\nfloat GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\nfloat cd = dot(litDir, L);\nfloat attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\nreturn (attenuation * attenuation);\n}\nvec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\nvec3 diffuseContrib = diffuse / 3.14159265359;\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - s.position);\nfloat NV = max(abs(dot(N, V)), 0.001);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 finalColor = vec3(0.0);\nint numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\nfor (int i = 0; i < LIGHTS_PER_PASS; i++) {\nif (i >= numLights) break;\nvec3 SLU = cc_lightPos[i].xyz - s.position;\nvec3 SL = normalize(SLU);\nvec3 SH = normalize(SL + V);\nfloat SNL = max(dot(N, SL), 0.001);\nfloat SNH = max(dot(N, SH), 0.0);\nfloat distSqr = dot(SLU, SLU);\nfloat litRadius = cc_lightSizeRangeAngle[i].x;\nfloat litRadiusSqr = litRadius * litRadius;\nfloat illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\nfloat attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\nattRadiusSqrInv *= attRadiusSqrInv;\nfloat att = GetDistAtt(distSqr, attRadiusSqrInv);\nvec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\nif (cc_lightPos[i].w > 0.0) {\nfloat cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\nfloat cosOuter = cc_lightSizeRangeAngle[i].z;\nfloat litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\nfloat litAngleOffset = -cosOuter * litAngleScale;\natt *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n}\nvec3 lightColor = cc_lightColor[i].rgb;\nfloat shadow = 1.0;\n#if CC_RECEIVE_SHADOW\nif (cc_lightPos[i].w > 0.0) {\n{\nfloat pcf = cc_shadowWHPBInfo.z;\nfloat cosAngle = clamp(1.0 - dot(N, normalize(cc_lightPos[i].xyz - s.position.xyz)), 0.0, 1.0);\nvec3 projWorldPos = shadowPos.xyz + cosAngle * cc_shadowLPNNInfo.z * N;\nvec4 pos = vec4(projWorldPos.xyz, shadowPos.w);\nif (pcf > 1.9) shadow = CCGetSpotLightShadowFactorSoft2X(pos, s.position);\nelse if (pcf > 0.9) shadow = CCGetSpotLightShadowFactorSoft(pos, s.position);\nelse shadow = CCGetSpotLightShadowFactorHard(pos, s.position);\n}\n}\n#endif\nlightColor *= shadow;\nfinalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n}\nreturn vec4(finalColor, 0.0);\n}\nvec3 ACESToneMap (vec3 color) {\ncolor = min(color, vec3(8.0));\nconst float A = 2.51;\nconst float B = 0.03;\nconst float C = 2.43;\nconst float D = 0.59;\nconst float E = 0.14;\nreturn (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n#if !CC_USE_HDR\ncolor.rgb = sqrt(ACESToneMap(color.rgb));\n#endif\nreturn color;\n}\nfloat LinearFog(vec4 pos) {\nvec4 wPos = pos;\nfloat cam_dis = distance(cc_cameraPos, wPos);\nfloat fogStart = cc_fogBase.x;\nfloat fogEnd = cc_fogBase.y;\nreturn clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\nfloat f = exp(-cam_dis * fogDensity);\nreturn f;\n}\nfloat ExpSquaredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\nfloat f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\nreturn f;\n}\nfloat LayeredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat _FogTop = cc_fogAdd.x;\nfloat _FogRange = cc_fogAdd.y;\nvec3 camWorldProj = cc_cameraPos.xyz;\ncamWorldProj.y = 0.;\nvec3 worldPosProj = wPos.xyz;\nworldPosProj.y = 0.;\nfloat fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\nfloat fDeltaY, fDensityIntegral;\nif (cc_cameraPos.y > _FogTop) {\nif (wPos.y < _FogTop) {\nfDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\nfDensityIntegral = fDeltaY * fDeltaY * 0.5;\n} else {\nfDeltaY = 0.;\nfDensityIntegral = 0.;\n}\n} else {\nif (wPos.y < _FogTop) {\nfloat fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfloat fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\nfDeltaY = abs(fDeltaA - fDeltaB);\nfDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n} else {\nfDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n}\n}\nfloat fDensity;\nif (fDeltaY != 0.) {\nfDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n} else {\nfDensity = 0.;\n}\nfloat f = exp(-fDensity);\nreturn f;\n}\nin vec2 v_uv;\nuniform sampler2D cc_gbuffer_albedoMap;\nuniform sampler2D cc_gbuffer_positionMap;\nuniform sampler2D cc_gbuffer_normalMap;\nuniform sampler2D cc_gbuffer_emissiveMap;\nlayout(location = 0) out vec4 fragColor;\nvoid main () {\nStandardSurface s;\nvec4 albedoMap = texture(cc_gbuffer_albedoMap,v_uv);\nvec4 positionMap = texture(cc_gbuffer_positionMap,v_uv);\nvec4 normalMap = texture(cc_gbuffer_normalMap,v_uv);\nvec4 emissiveMap = texture(cc_gbuffer_emissiveMap,v_uv);\ns.albedo = albedoMap;\ns.position = positionMap.xyz;\ns.roughness = positionMap.w;\ns.normal = normalMap.xyz;\ns.metallic = normalMap.w;\ns.emissive = emissiveMap.xyz;\ns.occlusion = emissiveMap.w;\nfloat fogFactor;\n#if CC_USE_FOG == 0\nfogFactor = LinearFog(vec4(s.position, 1));\n#elif CC_USE_FOG == 1\nfogFactor = ExpFog(vec4(s.position, 1));\n#elif CC_USE_FOG == 2\nfogFactor = ExpSquaredFog(vec4(s.position, 1));\n#elif CC_USE_FOG == 3\nfogFactor = LayeredFog(vec4(s.position, 1));\n#else\nfogFactor = 1.0;\n#endif\nvec4 shadowPos;\nshadowPos = cc_matLightViewProj * vec4(s.position, 1);\nvec4 color = CCStandardShadingBase(s, shadowPos) +\nCCStandardShadingAdditive(s, shadowPos);\ncolor = vec4(mix(CC_FORWARD_ADD > 0 ? vec3(0.0) : cc_fogColor.rgb, color.rgb, fogFactor), color.a);\nfragColor = CCFragOutput(color);\n}"
}], [{
  "vert": "\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\nrgba = rgba * 255.0;\nhighp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\nhighp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\nhighp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\nreturn Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_MORPH\nin float a_vertexId;\nint getVertexId() {\nreturn int(a_vertexId);\n}\nlayout(std140) uniform CCMorph {\nvec4 cc_displacementWeights[15];\nvec4 cc_displacementTextureInfo;\n};\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\nfloat pixelIndexF = float(pixelIndex);\nfloat x = mod(pixelIndexF, textureResolution.x);\nfloat y = floor(pixelIndexF / textureResolution.x);\nreturn vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\nreturn (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\nivec2 texSize = textureSize(tex, 0);\nreturn texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n}\n#else\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex * 4;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\nreturn vec4(\ndecode32(texture(tex, x)),\ndecode32(texture(tex, y)),\ndecode32(texture(tex, z)),\n1.0\n);\n}\n#endif\nfloat getDisplacementWeight(int index) {\nint quot = index / 4;\nint remainder = index - quot * 4;\nif (remainder == 0) {\nreturn cc_displacementWeights[quot].x;\n} else if (remainder == 1) {\nreturn cc_displacementWeights[quot].y;\n} else if (remainder == 2) {\nreturn cc_displacementWeights[quot].z;\n} else {\nreturn cc_displacementWeights[quot].w;\n}\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\nreturn fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\nvec3 result = vec3(0, 0, 0);\nint nVertices = int(cc_displacementTextureInfo.z);\nfor (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\nresult += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n}\nreturn result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\nuniform sampler2D cc_PositionDisplacements;\nvec3 getPositionDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nuniform sampler2D cc_NormalDisplacements;\nvec3 getNormalDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nuniform sampler2D cc_TangentDisplacements;\nvec3 getTangentDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n}\n#endif\nvoid applyMorph (inout StandardVertInput attr) {\nint vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\nattr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nattr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nattr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\nin vec4 a_joints;\nin vec4 a_weights;\n#if CC_USE_BAKED_ANIMATION\n#if USE_INSTANCING\nin highp vec4 a_jointAnimInfo;\n#endif\nlayout(std140) uniform CCSkinningTexture {\nhighp vec4 cc_jointTextureInfo;\n};\nlayout(std140) uniform CCSkinningAnimation {\nhighp vec4 cc_jointAnimInfo;\n};\nuniform highp sampler2D cc_jointTexture;\n#else\nlayout(std140) uniform CCSkinning {\nhighp vec4 cc_joints[30 * 3];\n};\n#endif\n#if CC_USE_BAKED_ANIMATION\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nmat4 getJointMatrix (float i) {\n#if USE_INSTANCING\nhighp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n#else\nhighp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n#endif\nhighp float invSize = cc_jointTextureInfo.w;\nhighp float y = floor(j * invSize);\nhighp float x = floor(j - y * cc_jointTextureInfo.x);\ny = (y + 0.5) * invSize;\nvec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\nvec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\nvec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#else\nmat4 getJointMatrix (float i) {\n#if USE_INSTANCING\nhighp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n#else\nhighp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n#endif\nhighp float invSize = cc_jointTextureInfo.w;\nhighp float y = floor(j * invSize);\nhighp float x = floor(j - y * cc_jointTextureInfo.x);\ny = (y + 0.5) * invSize;\nvec4 v1 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n);\nvec4 v2 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n);\nvec4 v3 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n);\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\n#else\nmat4 getJointMatrix (float i) {\nint idx = int(i);\nvec4 v1 = cc_joints[idx * 3];\nvec4 v2 = cc_joints[idx * 3 + 1];\nvec4 v3 = cc_joints[idx * 3 + 2];\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\nmat4 skinMatrix () {\nvec4 joints = vec4(a_joints);\nreturn getJointMatrix(joints.x) * a_weights.x\n+ getJointMatrix(joints.y) * a_weights.y\n+ getJointMatrix(joints.z) * a_weights.z\n+ getJointMatrix(joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\nmat4 m = skinMatrix();\nposition = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\nmat4 m = skinMatrix();\nattr.position = m * attr.position;\nattr.normal = (m * vec4(attr.normal, 0.0)).xyz;\nattr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\n#if USE_INSTANCING\nin vec4 a_matWorld0;\nin vec4 a_matWorld1;\nin vec4 a_matWorld2;\n#if USE_LIGHTMAP\nin vec4 a_lightingMapUVParam;\n#endif\n#elif USE_BATCHING\nin float a_dyn_batch_id;\nlayout(std140) uniform CCLocalBatched {\nhighp mat4 cc_matWorlds[10];\n};\n#else\nlayout(std140) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\n};\n#endif\nlayout(std140) uniform CCShadow {\nhighp mat4 cc_matLightPlaneProj;\nhighp mat4 cc_matLightView;\nhighp mat4 cc_matLightViewProj;\nlowp  vec4 cc_shadowNFLSInfo;\nlowp  vec4 cc_shadowWHPBInfo;\nlowp  vec4 cc_shadowLPNNInfo;\nlowp  vec4 cc_shadowColor;\n};\nvec4 vert () {\nvec4 position;\nposition = vec4(a_position, 1.0);\n#if CC_USE_MORPH\napplyMorph(position);\n#endif\n#if CC_USE_SKINNING\nCCSkin(position);\n#endif\nmat4 matWorld;\n#if USE_INSTANCING\nmatWorld = mat4(\nvec4(a_matWorld0.xyz, 0.0),\nvec4(a_matWorld1.xyz, 0.0),\nvec4(a_matWorld2.xyz, 0.0),\nvec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n);\n#elif USE_BATCHING\nmatWorld = cc_matWorlds[int(a_dyn_batch_id)];\n#else\nmatWorld = cc_matWorld;\n#endif\nposition = cc_matProj * (cc_matView * cc_matLightPlaneProj * matWorld) * position;\nposition.z -= 0.0001;\nreturn position;\n}\nvoid main() { gl_Position = vert(); }",
  "frag": "\nprecision mediump float;\nlayout(std140) uniform CCShadow {\nhighp mat4 cc_matLightPlaneProj;\nhighp mat4 cc_matLightView;\nhighp mat4 cc_matLightViewProj;\nlowp  vec4 cc_shadowNFLSInfo;\nlowp  vec4 cc_shadowWHPBInfo;\nlowp  vec4 cc_shadowLPNNInfo;\nlowp  vec4 cc_shadowColor;\n};\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n#if CC_USE_HDR\ncolor.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n#endif\nreturn color;\n}\nvec4 frag () {\nreturn CCFragOutput(cc_shadowColor);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
}], [{
  "vert": "\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\nrgba = rgba * 255.0;\nhighp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\nhighp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\nhighp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\nreturn Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_MORPH\nin float a_vertexId;\nint getVertexId() {\nreturn int(a_vertexId);\n}\nlayout(std140) uniform CCMorph {\nvec4 cc_displacementWeights[15];\nvec4 cc_displacementTextureInfo;\n};\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\nfloat pixelIndexF = float(pixelIndex);\nfloat x = mod(pixelIndexF, textureResolution.x);\nfloat y = floor(pixelIndexF / textureResolution.x);\nreturn vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\nreturn (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\nivec2 texSize = textureSize(tex, 0);\nreturn texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n}\n#else\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex * 4;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\nreturn vec4(\ndecode32(texture(tex, x)),\ndecode32(texture(tex, y)),\ndecode32(texture(tex, z)),\n1.0\n);\n}\n#endif\nfloat getDisplacementWeight(int index) {\nint quot = index / 4;\nint remainder = index - quot * 4;\nif (remainder == 0) {\nreturn cc_displacementWeights[quot].x;\n} else if (remainder == 1) {\nreturn cc_displacementWeights[quot].y;\n} else if (remainder == 2) {\nreturn cc_displacementWeights[quot].z;\n} else {\nreturn cc_displacementWeights[quot].w;\n}\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\nreturn fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\nvec3 result = vec3(0, 0, 0);\nint nVertices = int(cc_displacementTextureInfo.z);\nfor (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\nresult += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n}\nreturn result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\nuniform sampler2D cc_PositionDisplacements;\nvec3 getPositionDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nuniform sampler2D cc_NormalDisplacements;\nvec3 getNormalDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nuniform sampler2D cc_TangentDisplacements;\nvec3 getTangentDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n}\n#endif\nvoid applyMorph (inout StandardVertInput attr) {\nint vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\nattr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nattr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nattr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\nin vec4 a_joints;\nin vec4 a_weights;\n#if CC_USE_BAKED_ANIMATION\n#if USE_INSTANCING\nin highp vec4 a_jointAnimInfo;\n#endif\nlayout(std140) uniform CCSkinningTexture {\nhighp vec4 cc_jointTextureInfo;\n};\nlayout(std140) uniform CCSkinningAnimation {\nhighp vec4 cc_jointAnimInfo;\n};\nuniform highp sampler2D cc_jointTexture;\n#else\nlayout(std140) uniform CCSkinning {\nhighp vec4 cc_joints[30 * 3];\n};\n#endif\n#if CC_USE_BAKED_ANIMATION\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nmat4 getJointMatrix (float i) {\n#if USE_INSTANCING\nhighp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n#else\nhighp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n#endif\nhighp float invSize = cc_jointTextureInfo.w;\nhighp float y = floor(j * invSize);\nhighp float x = floor(j - y * cc_jointTextureInfo.x);\ny = (y + 0.5) * invSize;\nvec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\nvec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\nvec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#else\nmat4 getJointMatrix (float i) {\n#if USE_INSTANCING\nhighp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n#else\nhighp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n#endif\nhighp float invSize = cc_jointTextureInfo.w;\nhighp float y = floor(j * invSize);\nhighp float x = floor(j - y * cc_jointTextureInfo.x);\ny = (y + 0.5) * invSize;\nvec4 v1 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n);\nvec4 v2 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n);\nvec4 v3 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n);\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\n#else\nmat4 getJointMatrix (float i) {\nint idx = int(i);\nvec4 v1 = cc_joints[idx * 3];\nvec4 v2 = cc_joints[idx * 3 + 1];\nvec4 v3 = cc_joints[idx * 3 + 2];\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\nmat4 skinMatrix () {\nvec4 joints = vec4(a_joints);\nreturn getJointMatrix(joints.x) * a_weights.x\n+ getJointMatrix(joints.y) * a_weights.y\n+ getJointMatrix(joints.z) * a_weights.z\n+ getJointMatrix(joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\nmat4 m = skinMatrix();\nposition = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\nmat4 m = skinMatrix();\nattr.position = m * attr.position;\nattr.normal = (m * vec4(attr.normal, 0.0)).xyz;\nattr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\nout vec2 v_uv;\nvoid main () {\nStandardVertInput In;\nIn.position = vec4(a_position, 1.0);\nIn.normal = a_normal;\nIn.tangent = a_tangent;\n#if CC_USE_MORPH\napplyMorph(In);\n#endif\n#if CC_USE_SKINNING\nCCSkin(In);\n#endif\nIn.position.xy = cc_cameraPos.w == 0.0 ? vec2(In.position.xy.x, -In.position.xy.y) : In.position.xy;\ngl_Position = In.position;\ngl_Position.y = gl_Position.y;\nv_uv = a_texCoord;\n}",
  "frag": "\nprecision highp float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\nin vec2 v_uv;\nuniform sampler2D cc_lighting_resultMap;\nlayout(location = 0) out vec4 fragColor;\nvoid texcoords(vec2 fragCoord, vec2 resolution,\nout vec2 v_rgbNW, out vec2 v_rgbNE,\nout vec2 v_rgbSW, out vec2 v_rgbSE,\nout vec2 v_rgbM) {\nvec2 inverseVP = 1.0 / resolution.xy;\nv_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;\nv_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;\nv_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;\nv_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;\nv_rgbM = vec2(fragCoord * inverseVP);\n}\nvec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 resolution,\nvec2 v_rgbNW, vec2 v_rgbNE,\nvec2 v_rgbSW, vec2 v_rgbSE,\nvec2 v_rgbM) {\nvec4 color;\nmediump vec2 inverseVP = vec2(1.0 / resolution.x, 1.0 / resolution.y);\nvec3 rgbNW = texture(tex, v_rgbNW).xyz;\nvec3 rgbNE = texture(tex, v_rgbNE).xyz;\nvec3 rgbSW = texture(tex, v_rgbSW).xyz;\nvec3 rgbSE = texture(tex, v_rgbSE).xyz;\nvec4 texColor = texture(tex, v_rgbM);\nvec3 rgbM  = texColor.xyz;\nvec3 luma = vec3(0.299, 0.587, 0.114);\nfloat lumaNW = dot(rgbNW, luma);\nfloat lumaNE = dot(rgbNE, luma);\nfloat lumaSW = dot(rgbSW, luma);\nfloat lumaSE = dot(rgbSE, luma);\nfloat lumaM  = dot(rgbM,  luma);\nfloat lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\nfloat lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\nmediump vec2 dir;\ndir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\ndir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\nfloat dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n(0.25 * (1.0 / 8.0)), (1.0/ 128.0));\nfloat rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\ndir = min(vec2(8.0, 8.0),\nmax(vec2(-8.0, -8.0),\ndir * rcpDirMin)) * inverseVP;\nvec3 rgbA = 0.5 * (\ntexture(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +\ntexture(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);\nvec3 rgbB = rgbA * 0.5 + 0.25 * (\ntexture(tex, fragCoord * inverseVP + dir * -0.5).xyz +\ntexture(tex, fragCoord * inverseVP + dir * 0.5).xyz);\nfloat lumaB = dot(rgbB, luma);\nif ((lumaB < lumaMin) || (lumaB > lumaMax))\ncolor = vec4(rgbA, texColor.a);\nelse\ncolor = vec4(rgbB, texColor.a);\nreturn color;\n}\nvoid main () {\nmediump vec2 v_rgbNW;\nmediump vec2 v_rgbNE;\nmediump vec2 v_rgbSW;\nmediump vec2 v_rgbSE;\nmediump vec2 v_rgbM;\nvec2 resolution = cc_screenSize.xy;\nvec2 fragCoord = v_uv * resolution;\ntexcoords(fragCoord, resolution, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\nfragColor = fxaa(cc_lighting_resultMap, fragCoord, resolution, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n}"
}], [{
  "vert": "\nprecision highp float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\nout mediump vec4 viewDir;\nvec4 vert () {\nviewDir = vec4(a_position, 1.0);\nmat4 matViewRotOnly = mat4(mat3(cc_matView));\nmat4 matProj = cc_matProj;\nif (matProj[3].w > 0.0) {\nvec2 scale = vec2(48.0, 24.0);\nmatProj[0].xy *= scale;\nmatProj[1].xy *= scale;\nmatProj[2].zw = vec2(-1.0);\nmatProj[3].zw = vec2(0.0);\n}\nvec4 pos = matProj * matViewRotOnly * viewDir;\npos.z = 0.99999 * pos.w;\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",
  "frag": "\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\nuniform samplerCube cc_environment;\nvec3 unpackRGBE (vec4 rgbe) {\nreturn rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n}\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nvec3 ACESToneMap (vec3 color) {\ncolor = min(color, vec3(8.0));\nconst float A = 2.51;\nconst float B = 0.03;\nconst float C = 2.43;\nconst float D = 0.59;\nconst float E = 0.14;\nreturn (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n#if !CC_USE_HDR\ncolor.rgb = sqrt(ACESToneMap(color.rgb));\n#endif\nreturn color;\n}\nin mediump vec4 viewDir;\nvec4 frag () {\n#if USE_RGBE_CUBEMAP\nvec3 c = unpackRGBE(texture(cc_environment, viewDir.xyz));\n#else\nvec3 c = SRGBToLinear(texture(cc_environment, viewDir.xyz).rgb);\n#endif\nreturn CCFragOutput(vec4(c * cc_ambientSky.w, 1.0));\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
}], [{
  "vert": "\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\nin vec3 a_position;\nin vec4 a_color;\nout vec2 v_uv;\nlayout(std140) uniform Constants {\nvec4 offset;\n};\nlayout(std140) uniform PerFrameInfo {\nvec4 digits[8 * 10 / 4];\n};\nfloat getComponent(vec4 v, float i) {\nif (i < 1.0) { return v.x; }\nelse if (i < 2.0) { return v.y; }\nelse if (i < 3.0) { return v.z; }\nelse { return v.w; }\n}\nvec4 vert () {\nvec4 position = cc_matViewProj * vec4(a_position, 1.0);\nposition.xy += offset.xy;\nv_uv = a_color.xy;\nif (a_color.z >= 0.0) {\nfloat n = getComponent(digits[int(a_color.z)], a_color.w);\nv_uv += vec2(offset.z * n, 0.0);\n}\nreturn position;\n}\nvoid main() { gl_Position = vert(); }",
  "frag": "\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n#if CC_USE_HDR\ncolor.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n#endif\nreturn color;\n}\nin vec2 v_uv;\nuniform sampler2D mainTexture;\nvec4 frag () {\nreturn CCFragOutput(texture(mainTexture, v_uv));\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
}], [{
  "vert": "\nprecision mediump float;\nin vec2 a_position;\nin vec2 a_texCoord;\nout vec2 v_uv;\nout float v_percent;\nlayout(std140) uniform Constant {\nvec4 u_buffer0;\nvec4 u_buffer1;\nmat4 u_projection;\n};\nvec4 vert () {\nvec2 worldPos = a_position * u_buffer1.xy + u_buffer1.zw;\nvec2 clipSpace = worldPos / u_buffer0.xy * 2.0 - 1.0;\nvec4 screenPos = u_projection * vec4(clipSpace, 0.0, 1.0);\nv_uv = a_texCoord;\nv_percent = u_buffer0.z;\nreturn screenPos;\n}\nvoid main() { gl_Position = vert(); }",
  "frag": "\nprecision mediump float;\nin vec2 v_uv;\nin float v_percent;\nuniform sampler2D mainTexture;\nvec4 frag () {\nvec4 color = texture(mainTexture, v_uv);\nfloat precent = clamp(v_percent, 0.0, 1.0);\ncolor.xyz *= precent;\nreturn color;\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
}]];

var assembly = function () {
  {
    return {
      glsl1: glsl1,
      glsl3: glsl3
    };
  }
}();

var BuiltinResMgr = function () {
  function BuiltinResMgr() {
    this._device = null;
    this._resources = {};
  }

  var _proto = BuiltinResMgr.prototype;

  _proto.initBuiltinRes = function initBuiltinRes(device) {
    var _this = this;

    this._device = device;
    var resources = this._resources;
    var canvas = document.createElement('canvas');
    var context = canvas.getContext('2d');
    var imgAsset = new ImageAsset(canvas);
    var l = canvas.width = canvas.height = 2;
    context.fillStyle = '#000';
    context.fillRect(0, 0, l, l);
    var blackTexture = new Texture2D();
    blackTexture._uuid = 'black-texture';
    blackTexture.image = imgAsset;
    resources[blackTexture._uuid] = blackTexture;
    context.fillStyle = 'rgba(0,0,0,0)';
    context.fillRect(0, 0, l, l);
    var emptyTexture = new Texture2D();
    emptyTexture._uuid = 'empty-texture';
    emptyTexture.image = imgAsset;
    resources[emptyTexture._uuid] = emptyTexture;
    var blackCubeTexture = new TextureCube();
    blackCubeTexture._uuid = 'black-cube-texture';
    blackCubeTexture.setMipFilter(TextureCube.Filter.NEAREST);
    blackCubeTexture.image = {
      front: new ImageAsset(canvas),
      back: new ImageAsset(canvas),
      left: new ImageAsset(canvas),
      right: new ImageAsset(canvas),
      top: new ImageAsset(canvas),
      bottom: new ImageAsset(canvas)
    };
    resources[blackCubeTexture._uuid] = blackCubeTexture;
    context.fillStyle = '#777';
    context.fillRect(0, 0, l, l);
    var greyTexture = new Texture2D();
    greyTexture._uuid = 'grey-texture';
    greyTexture.image = imgAsset;
    resources[greyTexture._uuid] = greyTexture;
    context.fillStyle = '#fff';
    context.fillRect(0, 0, l, l);
    var whiteTexture = new Texture2D();
    whiteTexture._uuid = 'white-texture';
    whiteTexture.image = imgAsset;
    resources[whiteTexture._uuid] = whiteTexture;
    var whiteCubeTexture = new TextureCube();
    whiteCubeTexture._uuid = 'white-cube-texture';
    whiteCubeTexture.setMipFilter(TextureCube.Filter.NEAREST);
    whiteCubeTexture.image = {
      front: new ImageAsset(canvas),
      back: new ImageAsset(canvas),
      left: new ImageAsset(canvas),
      right: new ImageAsset(canvas),
      top: new ImageAsset(canvas),
      bottom: new ImageAsset(canvas)
    };
    resources[whiteCubeTexture._uuid] = whiteCubeTexture;
    context.fillStyle = '#7f7fff';
    context.fillRect(0, 0, l, l);
    var normalTexture = new Texture2D();
    normalTexture._uuid = 'normal-texture';
    normalTexture.image = imgAsset;
    resources[normalTexture._uuid] = normalTexture;
    canvas.width = canvas.height = 16;
    context.fillStyle = '#ddd';
    context.fillRect(0, 0, 16, 16);
    context.fillStyle = '#555';
    context.fillRect(0, 0, 8, 8);
    context.fillStyle = '#555';
    context.fillRect(8, 8, 8, 8);
    var defaultTexture = new Texture2D();
    defaultTexture._uuid = 'default-texture';
    defaultTexture.image = imgAsset;
    resources[defaultTexture._uuid] = defaultTexture;
    var defaultCubeTexture = new TextureCube();
    defaultCubeTexture.setMipFilter(TextureCube.Filter.NEAREST);
    defaultCubeTexture._uuid = 'default-cube-texture';
    defaultCubeTexture.image = {
      front: new ImageAsset(canvas),
      back: new ImageAsset(canvas),
      left: new ImageAsset(canvas),
      right: new ImageAsset(canvas),
      top: new ImageAsset(canvas),
      bottom: new ImageAsset(canvas)
    };
    resources[defaultCubeTexture._uuid] = defaultCubeTexture;

    if (legacyCC.SpriteFrame) {
      var spriteFrame = new legacyCC.SpriteFrame();
      var image = imgAsset;
      var texture = new Texture2D();
      texture.image = image;
      spriteFrame.texture = texture;
      spriteFrame._uuid = 'default-spriteframe';
      resources[spriteFrame._uuid] = spriteFrame;
    }

    var shaderVersionKey = getDeviceShaderVersion(device);

    if (!shaderVersionKey) {
      return Promise.reject(Error('Failed to initialize builtin shaders: unknown device.'));
    }

    var shaderSources = assembly[shaderVersionKey];

    if (!shaderSources) {
      return Promise.reject(Error("Current device is requiring builtin shaders of version " + shaderVersionKey + " " + "but shaders of that version are not assembled in this build."));
    }

    return Promise.resolve().then(function () {
      effects.forEach(function (e, effectIndex) {
        var effect = Object.assign(new legacyCC.EffectAsset(), e);
        effect.shaders.forEach(function (shaderInfo, shaderIndex) {
          var shaderSource = shaderSources[effectIndex][shaderIndex];

          if (shaderSource) {
            shaderInfo[shaderVersionKey] = shaderSource;
          }
        });
        effect.hideInEditor = true;
        effect.onLoaded();
      });

      _this._initMaterials();
    });
  };

  _proto.get = function get(uuid) {
    return this._resources[uuid];
  };

  _proto._initMaterials = function _initMaterials() {
    var resources = this._resources;
    var materialsToBeCompiled = [];
    var standardMtl = new legacyCC.Material();
    standardMtl._uuid = 'standard-material';
    standardMtl.initialize({
      effectName: 'standard'
    });
    resources[standardMtl._uuid] = standardMtl;
    materialsToBeCompiled.push(standardMtl);
    var missingEfxMtl = new legacyCC.Material();
    missingEfxMtl._uuid = 'missing-effect-material';
    missingEfxMtl.initialize({
      effectName: 'unlit',
      defines: {
        USE_COLOR: true
      }
    });
    missingEfxMtl.setProperty('mainColor', legacyCC.color('#ffff00'));
    resources[missingEfxMtl._uuid] = missingEfxMtl;
    materialsToBeCompiled.push(missingEfxMtl);
    var missingMtl = new legacyCC.Material();
    missingMtl._uuid = 'missing-material';
    missingMtl.initialize({
      effectName: 'unlit',
      defines: {
        USE_COLOR: true
      }
    });
    missingMtl.setProperty('mainColor', legacyCC.color('#ff00ff'));
    resources[missingMtl._uuid] = missingMtl;
    materialsToBeCompiled.push(missingMtl);
    var clearStencilMtl = new legacyCC.Material();
    clearStencilMtl._uuid = 'default-clear-stencil';
    clearStencilMtl.initialize({
      defines: {
        USE_TEXTURE: false
      },
      effectName: 'clear-stencil'
    });
    resources[clearStencilMtl._uuid] = clearStencilMtl;
    materialsToBeCompiled.push(clearStencilMtl);
    var spriteMtl = new legacyCC.Material();
    spriteMtl._uuid = 'ui-base-material';
    spriteMtl.initialize({
      defines: {
        USE_TEXTURE: false
      },
      effectName: 'sprite'
    });
    resources[spriteMtl._uuid] = spriteMtl;
    materialsToBeCompiled.push(spriteMtl);
    var spriteColorMtl = new legacyCC.Material();
    spriteColorMtl._uuid = 'ui-sprite-material';
    spriteColorMtl.initialize({
      defines: {
        USE_TEXTURE: true,
        CC_USE_EMBEDDED_ALPHA: false,
        IS_GRAY: false
      },
      effectName: 'sprite'
    });
    resources[spriteColorMtl._uuid] = spriteColorMtl;
    materialsToBeCompiled.push(spriteColorMtl);
    var alphaTestMaskMtl = new legacyCC.Material();
    alphaTestMaskMtl._uuid = 'ui-alpha-test-material';
    alphaTestMaskMtl.initialize({
      defines: {
        USE_TEXTURE: true,
        USE_ALPHA_TEST: true,
        CC_USE_EMBEDDED_ALPHA: false,
        IS_GRAY: false
      },
      effectName: 'sprite'
    });
    resources[alphaTestMaskMtl._uuid] = alphaTestMaskMtl;
    materialsToBeCompiled.push(alphaTestMaskMtl);
    var spriteGrayMtl = new legacyCC.Material();
    spriteGrayMtl._uuid = 'ui-sprite-gray-material';
    spriteGrayMtl.initialize({
      defines: {
        USE_TEXTURE: true,
        CC_USE_EMBEDDED_ALPHA: false,
        IS_GRAY: true
      },
      effectName: 'sprite'
    });
    resources[spriteGrayMtl._uuid] = spriteGrayMtl;
    materialsToBeCompiled.push(spriteGrayMtl);
    var spriteAlphaMtl = new legacyCC.Material();
    spriteAlphaMtl._uuid = 'ui-sprite-alpha-sep-material';
    spriteAlphaMtl.initialize({
      defines: {
        USE_TEXTURE: true,
        CC_USE_EMBEDDED_ALPHA: true,
        IS_GRAY: false
      },
      effectName: 'sprite'
    });
    resources[spriteAlphaMtl._uuid] = spriteAlphaMtl;
    materialsToBeCompiled.push(spriteAlphaMtl);
    var spriteAlphaGrayMtl = new legacyCC.Material();
    spriteAlphaGrayMtl._uuid = 'ui-sprite-gray-alpha-sep-material';
    spriteAlphaGrayMtl.initialize({
      defines: {
        USE_TEXTURE: true,
        CC_USE_EMBEDDED_ALPHA: true,
        IS_GRAY: true
      },
      effectName: 'sprite'
    });
    resources[spriteAlphaGrayMtl._uuid] = spriteAlphaGrayMtl;
    materialsToBeCompiled.push(spriteAlphaGrayMtl);
    var defaultGraphicsMtl = new legacyCC.Material();
    defaultGraphicsMtl._uuid = 'ui-graphics-material';
    defaultGraphicsMtl.initialize({
      effectName: 'graphics'
    });
    resources[defaultGraphicsMtl._uuid] = defaultGraphicsMtl;
    materialsToBeCompiled.push(defaultGraphicsMtl);
    var defaultParticleMtl = new legacyCC.Material();
    defaultParticleMtl._uuid = 'default-particle-material';
    defaultParticleMtl.initialize({
      effectName: 'particle'
    });
    resources[defaultParticleMtl._uuid] = defaultParticleMtl;
    materialsToBeCompiled.push(defaultParticleMtl);
    var defaultParticleGPUMtl = new legacyCC.Material();
    defaultParticleGPUMtl._uuid = 'default-particle-gpu-material';
    defaultParticleGPUMtl.initialize({
      effectName: 'particle-gpu'
    });
    resources[defaultParticleGPUMtl._uuid] = defaultParticleGPUMtl;
    materialsToBeCompiled.push(defaultParticleGPUMtl);
    var defaultTrailMtl = new legacyCC.Material();
    defaultTrailMtl._uuid = 'default-trail-material';
    defaultTrailMtl.initialize({
      effectName: 'particle-trail'
    });
    resources[defaultTrailMtl._uuid] = defaultTrailMtl;
    materialsToBeCompiled.push(defaultTrailMtl);
    var defaultBillboardMtl = new legacyCC.Material();
    defaultBillboardMtl._uuid = 'default-billboard-material';
    defaultBillboardMtl.initialize({
      effectName: 'billboard'
    });
    resources[defaultBillboardMtl._uuid] = defaultBillboardMtl;
    materialsToBeCompiled.push(defaultBillboardMtl);
    var spineTwoColorMtl = new legacyCC.Material();
    spineTwoColorMtl._uuid = 'default-spine-material';
    spineTwoColorMtl.initialize({
      defines: {
        USE_TEXTURE: true,
        CC_USE_EMBEDDED_ALPHA: false,
        IS_GRAY: false
      },
      effectName: 'spine'
    });
    resources[spineTwoColorMtl._uuid] = spineTwoColorMtl;
    materialsToBeCompiled.push(spineTwoColorMtl);
    legacyCC.game.on(legacyCC.Game.EVENT_GAME_INITED, function () {
      for (var i = 0; i < materialsToBeCompiled.length; ++i) {
        var mat = materialsToBeCompiled[i];

        for (var j = 0; j < mat.passes.length; ++j) {
          mat.passes[j].tryCompile();
        }
      }
    });
  };

  return BuiltinResMgr;
}();

var builtinResMgr = legacyCC.builtinResMgr = new BuiltinResMgr();

var getPhaseID = function () {
  var phases = new Map();
  var phaseNum = 0;
  return function (phaseName) {
    if (typeof phaseName === 'number') {
      return phaseName;
    }

    if (!phases.has(phaseName)) {
      phases.set(phaseName, 1 << phaseNum);
      phaseNum++;
    }

    return phases.get(phaseName);
  };
}();

var _bufferInfo = new BufferInfo(exports.BufferUsageBit.UNIFORM | exports.BufferUsageBit.TRANSFER_DST, exports.MemoryUsageBit.HOST | exports.MemoryUsageBit.DEVICE);

var _bufferViewInfo = new BufferViewInfo(null);

var _dsInfo = new DescriptorSetInfo(null);

(function (BatchingSchemes) {
  BatchingSchemes[BatchingSchemes["NONE"] = 0] = "NONE";
  BatchingSchemes[BatchingSchemes["INSTANCING"] = 1] = "INSTANCING";
  BatchingSchemes[BatchingSchemes["VB_MERGING"] = 2] = "VB_MERGING";
})(exports.BatchingSchemes || (exports.BatchingSchemes = {}));

var Pass = function () {
  Pass.fillPipelineInfo = function fillPipelineInfo(pass, info) {
    if (info.priority !== undefined) {
      pass._setPriority(info.priority);
    }

    if (info.primitive !== undefined) {
      pass._setPrimitive(info.primitive);
    }

    if (info.stage !== undefined) {
      pass._setStage(info.stage);
    }

    if (info.dynamicStates !== undefined) {
      pass._setDynamicState(info.dynamicStates);
    }

    if (info.phase !== undefined) {
      pass._setPhase(getPhaseID(info.phase));
    }

    var bs = pass._bs;

    if (info.blendState) {
      var bsInfo = info.blendState;
      var targets = bsInfo.targets;

      if (targets) {
        targets.forEach(function (t, i) {
          bs.setTarget(i, t);
        });
      }

      if (bsInfo.isA2C !== undefined) {
        bs.isA2C = bsInfo.isA2C;
      }

      if (bsInfo.isIndepend !== undefined) {
        bs.isIndepend = bsInfo.isIndepend;
      }

      if (bsInfo.blendColor !== undefined) {
        bs.blendColor = bsInfo.blendColor;
      }
    }

    pass._rs.assign(info.rasterizerState);

    pass._dss.assign(info.depthStencilState);
  };

  Pass.getPassHash = function getPassHash(pass) {
    var shaderKey = programLib.getKey(pass.program, pass.defines);
    var res = shaderKey + "," + pass._primitive + "," + pass._dynamicStates;
    res += serializeBlendState(pass._bs);
    res += serializeDepthStencilState(pass._dss);
    res += serializeRasterizerState(pass._rs);
    return murmurhash2_32_gc(res, 666);
  };

  _createClass(Pass, [{
    key: "native",
    get: function get() {
      return this._nativeObj;
    }
  }]);

  function Pass(root) {
    this._rootBuffer = null;
    this._buffers = [];
    this._descriptorSet = null;
    this._pipelineLayout = null;
    this._passIndex = 0;
    this._propertyIndex = 0;
    this._programName = '';
    this._dynamics = {};
    this._propertyHandleMap = {};
    this._rootBlock = null;
    this._blocks = [];
    this._shaderInfo = null;
    this._defines = {};
    this._properties = {};
    this._shader = null;
    this._bs = new BlendState();
    this._dss = new DepthStencilState();
    this._rs = new RasterizerState();
    this._priority = exports.RenderPriority.DEFAULT;
    this._stage = RenderPassStage.DEFAULT;
    this._phase = getPhaseID('default');
    this._primitive = exports.PrimitiveMode.TRIANGLE_LIST;
    this._batchingScheme = exports.BatchingSchemes.NONE;
    this._dynamicStates = exports.DynamicStateFlagBit.NONE;
    this._hash = 0;
    this._root = void 0;
    this._device = void 0;
    this._passHandle = NULL_HANDLE;
    this._rootBufferDirty = false;
    this._root = root;
    this._device = root.device;
  }

  var _proto = Pass.prototype;

  _proto.initialize = function initialize(info) {
    this._doInit(info);

    this.resetUBOs();
    this.resetTextures();
    this.tryCompile();
  };

  _proto.getHandle = function getHandle(name, offset, targetType) {
    if (offset === void 0) {
      offset = 0;
    }

    if (targetType === void 0) {
      targetType = exports.Type.UNKNOWN;
    }

    var handle = this._propertyHandleMap[name];

    if (!handle) {
      return 0;
    }

    if (targetType) {
      handle = customizeType(handle, targetType);
    } else if (offset) {
      handle = customizeType(handle, getTypeFromHandle(handle) - offset);
    }

    return handle + offset;
  };

  _proto.getBinding = function getBinding(name) {
    var handle = this.getHandle(name);

    if (!handle) {
      return -1;
    }

    return Pass.getBindingFromHandle(handle);
  };

  _proto.setUniform = function setUniform(handle, value) {
    var binding = Pass.getBindingFromHandle(handle);
    var type = Pass.getTypeFromHandle(handle);
    var ofs = Pass.getOffsetFromHandle(handle);
    var block = this._blocks[binding];
    type2writer[type](block, value, ofs);

    this._setRootBufferDirty(true);
  };

  _proto.getUniform = function getUniform(handle, out) {
    var binding = Pass.getBindingFromHandle(handle);
    var type = Pass.getTypeFromHandle(handle);
    var ofs = Pass.getOffsetFromHandle(handle);
    var block = this._blocks[binding];
    return type2reader[type](block, out, ofs);
  };

  _proto.setUniformArray = function setUniformArray(handle, value) {
    var binding = Pass.getBindingFromHandle(handle);
    var type = Pass.getTypeFromHandle(handle);
    var stride = GetTypeSize(type) >> 2;
    var block = this._blocks[binding];
    var ofs = Pass.getOffsetFromHandle(handle);

    for (var i = 0; i < value.length; i++, ofs += stride) {
      if (value[i] === null) {
        continue;
      }

      type2writer[type](block, value[i], ofs);
    }

    this._setRootBufferDirty(true);
  };

  _proto.bindTexture = function bindTexture(binding, value, index) {
    this._descriptorSet.bindTexture(binding, value, index || 0);
  };

  _proto.bindSampler = function bindSampler(binding, value, index) {
    this._descriptorSet.bindSampler(binding, value, index || 0);
  };

  _proto.setDynamicState = function setDynamicState(state, value) {
    var ds = this._dynamics[state];

    if (ds && ds.value === value) {
      return;
    }

    ds.value = value;
    ds.dirty = true;
  };

  _proto.overridePipelineStates = function overridePipelineStates(original, overrides) {
    console.warn('base pass cannot override states, please use pass instance instead.');
  };

  _proto._setRootBufferDirty = function _setRootBufferDirty(val) {
    this._rootBufferDirty = val;
  };

  _proto.update = function update() {
    if (!this._descriptorSet) {
      errorID(12006);
      return;
    }

    if (this._rootBuffer && this._rootBufferDirty) {
      this._rootBuffer.update(this._rootBlock);

      this._setRootBufferDirty(false);
    }

    this._descriptorSet.update();
  };

  _proto._initNative = function _initNative() {
  };

  _proto._destroy = function _destroy() {
  };

  _proto.destroy = function destroy() {
    for (var i = 0; i < this._shaderInfo.blocks.length; i++) {
      var u = this._shaderInfo.blocks[i];

      this._buffers[u.binding].destroy();
    }

    this._buffers = [];

    if (this._rootBuffer) {
      this._rootBuffer.destroy();

      this._rootBuffer = null;
    }

    this._descriptorSet.destroy();

    this._rs.destroy();

    this._dss.destroy();

    this._bs.destroy();

    this._destroy();
  };

  _proto.resetUniform = function resetUniform(name) {
    var handle = this.getHandle(name);

    if (!handle) {
      return;
    }

    var type = Pass.getTypeFromHandle(handle);
    var binding = Pass.getBindingFromHandle(handle);
    var ofs = Pass.getOffsetFromHandle(handle);
    var block = this._blocks[binding];
    var info = this._properties[name];
    var value = info && info.value || getDefaultFromType(type);
    type2writer[type](block, value, ofs);

    this._setRootBufferDirty(true);
  };

  _proto.resetTexture = function resetTexture(name, index) {
    var handle = this.getHandle(name);

    if (!handle) {
      return;
    }

    var type = Pass.getTypeFromHandle(handle);
    var binding = Pass.getBindingFromHandle(handle);
    var info = this._properties[name];
    var value = info && info.value;
    var texName = value ? value + "-texture" : getDefaultFromType(type);
    var textureBase = builtinResMgr.get(texName);
    var texture = textureBase && textureBase.getGFXTexture();
    var samplerHash = info && info.samplerHash !== undefined ? info.samplerHash : textureBase && textureBase.getSamplerHash();
    var sampler = samplerLib.getSampler(this._device, samplerHash);

    this._descriptorSet.bindSampler(binding, sampler, index);

    this._descriptorSet.bindTexture(binding, texture, index);
  };

  _proto.resetUBOs = function resetUBOs() {
    for (var i = 0; i < this._shaderInfo.blocks.length; i++) {
      var u = this._shaderInfo.blocks[i];
      var block = this._blocks[u.binding];
      var ofs = 0;

      for (var j = 0; j < u.members.length; j++) {
        var cur = u.members[j];
        var info = this._properties[cur.name];
        var givenDefault = info && info.value;
        var value = givenDefault || getDefaultFromType(cur.type);
        var size = (GetTypeSize(cur.type) >> 2) * cur.count;

        for (var k = 0; k + value.length <= size; k += value.length) {
          block.set(value, ofs + k);
        }

        ofs += size;
      }
    }

    this._setRootBufferDirty(true);
  };

  _proto.resetTextures = function resetTextures() {
    for (var i = 0; i < this._shaderInfo.samplerTextures.length; i++) {
      var u = this._shaderInfo.samplerTextures[i];

      for (var j = 0; j < u.count; j++) {
        this.resetTexture(u.name, j);
      }
    }
  };

  _proto.tryCompile = function tryCompile() {
    var pipeline = this._root.pipeline;

    if (!pipeline) {
      return false;
    }

    this._syncBatchingScheme();

    var shader = programLib.getGFXShader(this._device, this._programName, this._defines, pipeline);

    if (!shader) {
      console.warn("create shader " + this._programName + " failed");
      return false;
    }

    this._shader = shader;

    this._setPipelineLayout(programLib.getTemplateInfo(this._programName).pipelineLayout);

    this._setHash(Pass.getPassHash(this));

    return true;
  };

  _proto.getShaderVariant = function getShaderVariant(patches) {
    if (patches === void 0) {
      patches = null;
    }

    if (!this._shader && !this.tryCompile()) {
      console.warn('pass resources incomplete');
      return null;
    }

    if (!patches) {
      return this._shader;
    }

    var pipeline = this._root.pipeline;

    for (var _i = 0; _i < patches.length; _i++) {
      var patch = patches[_i];
      this._defines[patch.name] = patch.value;
    }

    var shader = programLib.getGFXShader(this._device, this._programName, this._defines, pipeline);

    for (var _i2 = 0; _i2 < patches.length; _i2++) {
      var _patch = patches[_i2];
      delete this._defines[_patch.name];
    }

    return shader;
  };

  _proto.beginChangeStatesSilently = function beginChangeStatesSilently() {};

  _proto.endChangeStatesSilently = function endChangeStatesSilently() {};

  _proto._setPriority = function _setPriority(val) {
    this._priority = val;
  };

  _proto._setStage = function _setStage(val) {
    this._stage = val;
  };

  _proto._setPhase = function _setPhase(val) {
    this._phase = val;
  };

  _proto._setPrimitive = function _setPrimitive(val) {
    this._primitive = val;
  };

  _proto._setState = function _setState(bs, dss, rs, ds) {
    this._bs = bs;
    this._dss = dss;
    this._rs = rs;
    this._descriptorSet = ds;
  };

  _proto._doInit = function _doInit(info, copyDefines) {
    if (copyDefines === void 0) {
      copyDefines = false;
    }

    this._initNative();

    this._setPriority(exports.RenderPriority.DEFAULT);

    this._setStage(RenderPassStage.DEFAULT);

    this._setPhase(getPhaseID('default'));

    this._setPrimitive(exports.PrimitiveMode.TRIANGLE_LIST);

    this._passIndex = info.passIndex;
    this._propertyIndex = info.propertyIndex !== undefined ? info.propertyIndex : info.passIndex;
    this._programName = info.program;
    this._defines = copyDefines ? _extends({}, info.defines) : info.defines;
    this._shaderInfo = programLib.getTemplate(info.program);
    this._properties = info.properties || this._properties;
    var device = this._device;
    Pass.fillPipelineInfo(this, info);

    if (info.stateOverrides) {
      Pass.fillPipelineInfo(this, info.stateOverrides);
    }

    _dsInfo.layout = programLib.getDescriptorSetLayout(this._device, info.program);
    this._descriptorSet = this._device.createDescriptorSet(_dsInfo);

    this._setState(this._bs, this._dss, this._rs, this._descriptorSet);

    var blocks = this._shaderInfo.blocks;
    var tmplInfo = programLib.getTemplateInfo(info.program);
    var blockSizes = tmplInfo.blockSizes,
        handleMap = tmplInfo.handleMap;
    var alignment = device.capabilities.uboOffsetAlignment;
    var startOffsets = [];
    var lastSize = 0;
    var lastOffset = 0;

    for (var i = 0; i < blocks.length; i++) {
      var size = blockSizes[i];
      startOffsets.push(lastOffset);
      lastOffset += Math.ceil(size / alignment) * alignment;
      lastSize = size;
    }

    var totalSize = startOffsets[startOffsets.length - 1] + lastSize;

    if (totalSize) {
      _bufferInfo.size = Math.ceil(totalSize / 16) * 16;
      this._rootBuffer = device.createBuffer(_bufferInfo);
      this._rootBlock = new ArrayBuffer(totalSize);
    }

    for (var _i3 = 0, count = 0; _i3 < blocks.length; _i3++) {
      var binding = blocks[_i3].binding;
      var _size = blockSizes[_i3];
      _bufferViewInfo.buffer = this._rootBuffer;
      _bufferViewInfo.offset = startOffsets[count++];
      _bufferViewInfo.range = Math.ceil(_size / 16) * 16;
      var bufferView = this._buffers[binding] = device.createBuffer(_bufferViewInfo);
      this._blocks[binding] = new Float32Array(this._rootBlock, _bufferViewInfo.offset, _size / Float32Array.BYTES_PER_ELEMENT);

      this._descriptorSet.bindBuffer(binding, bufferView);
    }

    var directHandleMap = this._propertyHandleMap = handleMap;
    var indirectHandleMap = {};

    for (var name in this._properties) {
      var prop = this._properties[name];

      if (!prop.handleInfo) {
        continue;
      }

      indirectHandleMap[name] = this.getHandle.apply(this, prop.handleInfo);
    }

    Object.assign(directHandleMap, indirectHandleMap);
  };

  _proto._syncBatchingScheme = function _syncBatchingScheme() {
    if (this._defines.USE_INSTANCING) {
      if (this._device.hasFeature(exports.Feature.INSTANCED_ARRAYS)) {
        this._setBatchingScheme(exports.BatchingSchemes.INSTANCING);
      } else {
        this._defines.USE_INSTANCING = false;

        this._setBatchingScheme(exports.BatchingSchemes.NONE);
      }
    } else if (this._defines.USE_BATCHING) {
      this._setBatchingScheme(exports.BatchingSchemes.VB_MERGING);
    } else {
      this._setBatchingScheme(exports.BatchingSchemes.NONE);
    }
  };

  _proto._setBatchingScheme = function _setBatchingScheme(val) {
    this._batchingScheme = val;
  };

  _proto._setDynamicState = function _setDynamicState(val) {
    this._dynamicStates = val;
  };

  _proto._setHash = function _setHash(val) {
    this._hash = val;
  };

  _proto._setPipelineLayout = function _setPipelineLayout(pipelineLayout) {
    this._pipelineLayout = pipelineLayout;
  };

  _proto._initPassFromTarget = function _initPassFromTarget(target, dss, bs, hashFactor) {
    this._initNative();

    this._setPriority(target.priority);

    this._setStage(target.stage);

    this._setPhase(target.phase);

    this._setBatchingScheme(target.batchingScheme);

    this._setPrimitive(target.primitive);

    this._setDynamicState(target.dynamicStates);

    this._setState(bs, dss, target.rasterizerState, target.descriptorSet);

    this._passIndex = target.passIndex;
    this._propertyIndex = target.propertyIndex;
    this._programName = target.program;
    this._defines = target.defines;
    this._shaderInfo = target._shaderInfo;
    this._properties = target._properties;
    this._blocks = target._blocks;
    this._dynamics = target._dynamics;
    this._shader = target._shader;

    this._setPipelineLayout(programLib.getTemplateInfo(this._programName).pipelineLayout);

    this._setHash(target._hash ^ hashFactor);
  };

  _createClass(Pass, [{
    key: "root",
    get: function get() {
      return this._root;
    }
  }, {
    key: "device",
    get: function get() {
      return this._device;
    }
  }, {
    key: "shaderInfo",
    get: function get() {
      return this._shaderInfo;
    }
  }, {
    key: "localSetLayout",
    get: function get() {
      return programLib.getDescriptorSetLayout(this._device, this._programName, true);
    }
  }, {
    key: "program",
    get: function get() {
      return this._programName;
    }
  }, {
    key: "properties",
    get: function get() {
      return this._properties;
    }
  }, {
    key: "defines",
    get: function get() {
      return this._defines;
    }
  }, {
    key: "passIndex",
    get: function get() {
      return this._passIndex;
    }
  }, {
    key: "propertyIndex",
    get: function get() {
      return this._propertyIndex;
    }
  }, {
    key: "dynamics",
    get: function get() {
      return this._dynamics;
    }
  }, {
    key: "blocks",
    get: function get() {
      return this._blocks;
    }
  }, {
    key: "rootBufferDirty",
    get: function get() {
      return this._rootBufferDirty;
    }
  }, {
    key: "priority",
    get: function get() {
      return this._priority;
    }
  }, {
    key: "primitive",
    get: function get() {
      return this._primitive;
    }
  }, {
    key: "stage",
    get: function get() {
      return this._stage;
    }
  }, {
    key: "phase",
    get: function get() {
      return this._phase;
    }
  }, {
    key: "rasterizerState",
    get: function get() {
      return this._rs;
    }
  }, {
    key: "depthStencilState",
    get: function get() {
      return this._dss;
    }
  }, {
    key: "blendState",
    get: function get() {
      return this._bs;
    }
  }, {
    key: "dynamicStates",
    get: function get() {
      return this._dynamicStates;
    }
  }, {
    key: "batchingScheme",
    get: function get() {
      return this._batchingScheme;
    }
  }, {
    key: "descriptorSet",
    get: function get() {
      return this._descriptorSet;
    }
  }, {
    key: "hash",
    get: function get() {
      return this._hash;
    }
  }, {
    key: "pipelineLayout",
    get: function get() {
      return this._pipelineLayout;
    }
  }]);

  return Pass;
}();
Pass.PropertyType = exports.PropertyType;
Pass.getPropertyTypeFromHandle = getPropertyTypeFromHandle;
Pass.getTypeFromHandle = getTypeFromHandle;
Pass.getBindingFromHandle = getBindingFromHandle;
Pass.getOffsetFromHandle = getOffsetFromHandle;

function serializeBlendState(bs) {
  var res = ",bs," + bs.isA2C;

  for (var _iterator = _createForOfIteratorHelperLoose(bs.targets), _step; !(_step = _iterator()).done;) {
    var t = _step.value;
    res += ",bt," + t.blend + "," + t.blendEq + "," + t.blendAlphaEq + "," + t.blendColorMask;
    res += "," + t.blendSrc + "," + t.blendDst + "," + t.blendSrcAlpha + "," + t.blendDstAlpha;
  }

  return res;
}

function serializeRasterizerState(rs) {
  return ",rs," + rs.cullMode + "," + rs.depthBias + "," + rs.isFrontFaceCCW;
}

function serializeDepthStencilState(dss) {
  var res = ",dss," + dss.depthTest + "," + dss.depthWrite + "," + dss.depthFunc;
  res += "," + dss.stencilTestFront + "," + dss.stencilFuncFront + "," + dss.stencilRefFront + "," + dss.stencilReadMaskFront;
  res += "," + dss.stencilFailOpFront + "," + dss.stencilZFailOpFront + "," + dss.stencilPassOpFront + "," + dss.stencilWriteMaskFront;
  res += "," + dss.stencilTestBack + "," + dss.stencilFuncBack + "," + dss.stencilRefBack + "," + dss.stencilReadMaskBack;
  res += "," + dss.stencilFailOpBack + "," + dss.stencilZFailOpBack + "," + dss.stencilPassOpBack + "," + dss.stencilWriteMaskBack;
  return res;
}

var NodeSpace;

(function (NodeSpace) {
  NodeSpace[NodeSpace["LOCAL"] = 0] = "LOCAL";
  NodeSpace[NodeSpace["WORLD"] = 1] = "WORLD";
})(NodeSpace || (NodeSpace = {}));

(function (TransformBit) {
  TransformBit[TransformBit["NONE"] = 0] = "NONE";
  TransformBit[TransformBit["POSITION"] = 1] = "POSITION";
  TransformBit[TransformBit["ROTATION"] = 2] = "ROTATION";
  TransformBit[TransformBit["SCALE"] = 4] = "SCALE";
  TransformBit[TransformBit["RS"] = TransformBit.ROTATION | TransformBit.SCALE] = "RS";
  TransformBit[TransformBit["TRS"] = TransformBit.POSITION | TransformBit.ROTATION | TransformBit.SCALE] = "TRS";
  TransformBit[TransformBit["TRS_MASK"] = ~TransformBit.TRS] = "TRS_MASK";
})(exports.TransformBit || (exports.TransformBit = {}));

legacyCC.internal.TransformBit = exports.TransformBit;

var _dec$g, _class$g, _class2$d, _descriptor$b, _descriptor2$7, _descriptor3$5, _descriptor4$4, _class3$7, _temp$d;
var EffectAsset = (_dec$g = ccclass('cc.EffectAsset'), _dec$g(_class$g = (_class2$d = (_temp$d = _class3$7 = function (_Asset) {
  _inheritsLoose(EffectAsset, _Asset);

  function EffectAsset() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _Asset.call.apply(_Asset, [this].concat(args)) || this;

    _initializerDefineProperty(_this, "techniques", _descriptor$b, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "shaders", _descriptor2$7, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "combinations", _descriptor3$5, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "hideInEditor", _descriptor4$4, _assertThisInitialized(_this));

    return _this;
  }

  EffectAsset.register = function register(asset) {
    EffectAsset._effects[asset.name] = asset;
  };

  EffectAsset.remove = function remove(asset) {
    if (typeof asset !== 'string') {
      if (EffectAsset._effects[asset.name] && EffectAsset._effects[asset.name].equals(asset)) {
        delete EffectAsset._effects[asset.name];
      }
    } else {
      if (EffectAsset._effects[asset]) {
        delete EffectAsset._effects[asset];
        return;
      }

      for (var n in EffectAsset._effects) {
        if (EffectAsset._effects[n]._uuid === asset) {
          delete EffectAsset._effects[n];
          return;
        }
      }
    }
  };

  EffectAsset.get = function get(name) {
    if (EffectAsset._effects[name]) {
      return EffectAsset._effects[name];
    }

    for (var n in EffectAsset._effects) {
      if (EffectAsset._effects[n]._uuid === name) {
        return EffectAsset._effects[n];
      }
    }

    return null;
  };

  EffectAsset.getAll = function getAll() {
    return EffectAsset._effects;
  };

  var _proto = EffectAsset.prototype;

  _proto.onLoaded = function onLoaded() {
    programLib.register(this);
    EffectAsset.register(this);

    {
      legacyCC.game.once(legacyCC.Game.EVENT_ENGINE_INITED, this._precompile, this);
    }
  };

  _proto._precompile = function _precompile() {
    var _this2 = this;

    var root = legacyCC.director.root;

    var _loop = function _loop(i) {
      var shader = _this2.shaders[i];
      var combination = _this2.combinations[i];

      if (!combination) {
        return "continue";
      }

      var defines = Object.keys(combination).reduce(function (out, name) {
        return out.reduce(function (acc, cur) {
          var choices = combination[name];

          for (var _i = 0; _i < choices.length; ++_i) {
            var _defines = _extends({}, cur);

            _defines[name] = choices[_i];
            acc.push(_defines);
          }

          return acc;
        }, []);
      }, [{}]);
      defines.forEach(function (defines) {
        return programLib.getGFXShader(root.device, shader.name, defines, root.pipeline);
      });
    };

    for (var i = 0; i < this.shaders.length; i++) {
      var _ret = _loop(i);

      if (_ret === "continue") continue;
    }
  };

  _proto.destroy = function destroy() {
    EffectAsset.remove(this);
    return _Asset.prototype.destroy.call(this);
  };

  _proto.initDefault = function initDefault(uuid) {
    _Asset.prototype.initDefault.call(this, uuid);

    var effect = EffectAsset.get('unlit');
    this.name = 'unlit';
    this.shaders = effect.shaders;
    this.combinations = effect.combinations;
    this.techniques = effect.techniques;
  };

  _proto.validate = function validate() {
    return this.techniques.length > 0 && this.shaders.length > 0;
  };

  return EffectAsset;
}(Asset), _class3$7._effects = {}, _temp$d), (_descriptor$b = _applyDecoratedDescriptor(_class2$d.prototype, "techniques", [serializable, editable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return [];
  }
}), _descriptor2$7 = _applyDecoratedDescriptor(_class2$d.prototype, "shaders", [serializable, editable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return [];
  }
}), _descriptor3$5 = _applyDecoratedDescriptor(_class2$d.prototype, "combinations", [serializable, editable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return [];
  }
}), _descriptor4$4 = _applyDecoratedDescriptor(_class2$d.prototype, "hideInEditor", [serializable, editorOnly], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return false;
  }
})), _class2$d)) || _class$g);
legacyCC.EffectAsset = EffectAsset;

var _dec$h, _dec2$6, _class$h, _class2$e, _descriptor$c, _descriptor2$8, _descriptor3$6, _descriptor4$5, _descriptor5$2, _temp$e;
var Material = (_dec$h = ccclass('cc.Material'), _dec2$6 = type(EffectAsset), _dec$h(_class$h = (_class2$e = (_temp$e = function (_Asset) {
  _inheritsLoose(Material, _Asset);

  Material.getHash = function getHash(material) {
    var hash = 0;

    for (var _iterator = _createForOfIteratorHelperLoose(material.passes), _step; !(_step = _iterator()).done;) {
      var pass = _step.value;
      hash ^= pass.hash;
    }

    return hash;
  };

  function Material() {
    var _this;

    _this = _Asset.call(this) || this;

    _initializerDefineProperty(_this, "_effectAsset", _descriptor$c, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_techIdx", _descriptor2$8, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_defines", _descriptor3$6, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_states", _descriptor4$5, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_props", _descriptor5$2, _assertThisInitialized(_this));

    _this._passes = [];
    _this._hash = 0;
    return _this;
  }

  var _proto = Material.prototype;

  _proto.initialize = function initialize(info) {
    if (this._passes.length) {
      warnID(12005);
      return;
    }

    if (!this._defines) {
      this._defines = [];
    }

    if (!this._states) {
      this._states = [];
    }

    if (!this._props) {
      this._props = [];
    }

    if (info.technique !== undefined) {
      this._techIdx = info.technique;
    }

    if (info.effectAsset) {
      this._effectAsset = info.effectAsset;
    } else if (info.effectName) {
      this._effectAsset = EffectAsset.get(info.effectName);
    }

    if (info.defines) {
      this._prepareInfo(info.defines, this._defines);
    }

    if (info.states) {
      this._prepareInfo(info.states, this._states);
    }

    this._update();
  };

  _proto.reset = function reset(info) {
    this.initialize(info);
  };

  _proto.destroy = function destroy() {
    this._doDestroy();

    return _Asset.prototype.destroy.call(this);
  };

  _proto.recompileShaders = function recompileShaders(overrides, passIdx) {
    console.warn("Shaders in material asset '" + this.name + "' cannot be modified at runtime, please instantiate the material first.");
  };

  _proto.overridePipelineStates = function overridePipelineStates(overrides, passIdx) {
    console.warn("Pipeline states in material asset '" + this.name + "' cannot be modified at runtime, please instantiate the material first.");
  };

  _proto.onLoaded = function onLoaded() {
    this._update();
  };

  _proto.resetUniforms = function resetUniforms(clearPasses) {
    if (clearPasses === void 0) {
      clearPasses = true;
    }

    this._props.length = this._passes.length;

    for (var i = 0; i < this._props.length; i++) {
      this._props[i] = {};
    }

    if (!clearPasses) {
      return;
    }

    for (var _iterator2 = _createForOfIteratorHelperLoose(this._passes), _step2; !(_step2 = _iterator2()).done;) {
      var pass = _step2.value;
      pass.resetUBOs();
      pass.resetTextures();
    }
  };

  _proto.setProperty = function setProperty(name, val, passIdx) {
    var success = false;

    if (passIdx === undefined) {
      var passes = this._passes;
      var len = passes.length;

      for (var i = 0; i < len; i++) {
        var pass = passes[i];

        if (this._uploadProperty(pass, name, val)) {
          this._props[pass.propertyIndex][name] = val;
          success = true;
        }
      }
    } else {
      if (passIdx >= this._passes.length) {
        console.warn("illegal pass index: " + passIdx + ".");
        return;
      }

      var _pass = this._passes[passIdx];

      if (this._uploadProperty(_pass, name, val)) {
        this._props[_pass.propertyIndex][name] = val;
        success = true;
      }
    }

    if (!success) {
      console.warn("illegal property name: " + name + ".");
    }
  };

  _proto.getProperty = function getProperty(name, passIdx) {
    if (passIdx === undefined) {
      var propsArray = this._props;
      var len = propsArray.length;

      for (var i = 0; i < len; i++) {
        var props = propsArray[i];

        if (name in props) {
          return props[name];
        }
      }
    } else {
      if (passIdx >= this._props.length) {
        console.warn("illegal pass index: " + passIdx + ".");
        return null;
      }

      var _props = this._props[this._passes[passIdx].propertyIndex];

      if (name in _props) {
        return _props[name];
      }
    }

    return null;
  };

  _proto.copy = function copy(mat) {
    this._techIdx = mat._techIdx;
    this._props.length = mat._props.length;

    for (var i = 0; i < mat._props.length; i++) {
      this._props[i] = _extends({}, mat._props[i]);
    }

    this._defines.length = mat._defines.length;

    for (var _i = 0; _i < mat._defines.length; _i++) {
      this._defines[_i] = _extends({}, mat._defines[_i]);
    }

    this._states.length = mat._states.length;

    for (var _i2 = 0; _i2 < mat._states.length; _i2++) {
      this._states[_i2] = _extends({}, mat._states[_i2]);
    }

    this._effectAsset = mat._effectAsset;

    this._update();
  };

  _proto._prepareInfo = function _prepareInfo(patch, cur) {
    var patchArray = patch;

    if (!Array.isArray(patchArray)) {
      var len = this._effectAsset ? this._effectAsset.techniques[this._techIdx].passes.length : 1;
      patchArray = Array(len).fill(patchArray);
    }

    for (var i = 0; i < patchArray.length; ++i) {
      Object.assign(cur[i] || (cur[i] = {}), patchArray[i]);
    }
  };

  _proto._createPasses = function _createPasses() {
    var tech = this._effectAsset.techniques[this._techIdx || 0];

    if (!tech) {
      return [];
    }

    var passNum = tech.passes.length;
    var passes = [];

    for (var k = 0; k < passNum; ++k) {
      var passInfo = tech.passes[k];
      var propIdx = passInfo.passIndex = k;
      var defines = passInfo.defines = this._defines[propIdx] || (this._defines[propIdx] = {});
      var states = passInfo.stateOverrides = this._states[propIdx] || (this._states[propIdx] = {});

      if (passInfo.propertyIndex !== undefined) {
        Object.assign(defines, this._defines[passInfo.propertyIndex]);
        Object.assign(states, this._states[passInfo.propertyIndex]);
      }

      if (passInfo.embeddedMacros !== undefined) {
        Object.assign(defines, passInfo.embeddedMacros);
      }

      if (passInfo["switch"] && !defines[passInfo["switch"]]) {
        continue;
      }

      var pass = new Pass(legacyCC.director.root);
      pass.initialize(passInfo);
      passes.push(pass);
    }

    return passes;
  };

  _proto._update = function _update(keepProps) {
    var _this2 = this;

    if (keepProps === void 0) {
      keepProps = true;
    }

    if (this._effectAsset) {
      this._passes = this._createPasses();
      var totalPasses = this._effectAsset.techniques[this._techIdx].passes.length;
      this._props.length = totalPasses;

      if (keepProps) {
        this._passes.forEach(function (pass, i) {
          var props = _this2._props[i];

          if (!props) {
            props = _this2._props[i] = {};
          }

          if (pass.propertyIndex !== undefined) {
            Object.assign(props, _this2._props[pass.propertyIndex]);
          }

          for (var p in props) {
            _this2._uploadProperty(pass, p, props[p]);
          }
        });
      } else {
        for (var i = 0; i < this._props.length; i++) {
          this._props[i] = {};
        }
      }
    }

    this._hash = Material.getHash(this);
  };

  _proto._uploadProperty = function _uploadProperty(pass, name, val) {
    var handle = pass.getHandle(name);

    if (!handle) {
      return false;
    }

    var propertyType = Pass.getPropertyTypeFromHandle(handle);

    if (propertyType === exports.PropertyType.BUFFER) {
      if (Array.isArray(val)) {
        pass.setUniformArray(handle, val);
      } else if (val !== null) {
        pass.setUniform(handle, val);
      } else {
        pass.resetUniform(name);
      }
    } else if (propertyType === exports.PropertyType.TEXTURE) {
      if (Array.isArray(val)) {
        for (var i = 0; i < val.length; i++) {
          this._bindTexture(pass, handle, val[i], i);
        }
      } else if (val) {
        this._bindTexture(pass, handle, val);
      } else {
        pass.resetTexture(name);
      }
    }

    return true;
  };

  _proto._bindTexture = function _bindTexture(pass, handle, val, index) {
    var binding = Pass.getBindingFromHandle(handle);

    if (val instanceof Texture) {
      pass.bindTexture(binding, val, index);
    } else if (val instanceof TextureBase) {
      var texture = val.getGFXTexture();

      if (!texture || !texture.width || !texture.height) {
        return;
      }

      pass.bindTexture(binding, texture, index);
      pass.bindSampler(binding, val.getGFXSampler(), index);
    }
  };

  _proto._doDestroy = function _doDestroy() {
    if (this._passes && this._passes.length) {
      for (var _iterator3 = _createForOfIteratorHelperLoose(this._passes), _step3; !(_step3 = _iterator3()).done;) {
        var pass = _step3.value;
        pass.destroy();
      }
    }

    this._passes.length = 0;
  };

  _proto.initDefault = function initDefault(uuid) {
    _Asset.prototype.initDefault.call(this, uuid);

    this.initialize({
      effectName: 'unlit',
      defines: {
        USE_COLOR: true
      }
    });
    this.setProperty('mainColor', new Color('#ff00ff'));
  };

  _proto.validate = function validate() {
    return !!this._effectAsset && !this._effectAsset.isDefault && this.passes.length > 0;
  };

  _createClass(Material, [{
    key: "effectAsset",
    get: function get() {
      return this._effectAsset;
    }
  }, {
    key: "effectName",
    get: function get() {
      return this._effectAsset ? this._effectAsset.name : '';
    }
  }, {
    key: "technique",
    get: function get() {
      return this._techIdx;
    }
  }, {
    key: "passes",
    get: function get() {
      return this._passes;
    }
  }, {
    key: "hash",
    get: function get() {
      return this._hash;
    }
  }, {
    key: "parent",
    get: function get() {
      return null;
    }
  }, {
    key: "owner",
    get: function get() {
      return null;
    }
  }]);

  return Material;
}(Asset), _temp$e), (_descriptor$c = _applyDecoratedDescriptor(_class2$e.prototype, "_effectAsset", [_dec2$6], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return null;
  }
}), _descriptor2$8 = _applyDecoratedDescriptor(_class2$e.prototype, "_techIdx", [serializable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return 0;
  }
}), _descriptor3$6 = _applyDecoratedDescriptor(_class2$e.prototype, "_defines", [serializable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return [];
  }
}), _descriptor4$5 = _applyDecoratedDescriptor(_class2$e.prototype, "_states", [serializable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return [];
  }
}), _descriptor5$2 = _applyDecoratedDescriptor(_class2$e.prototype, "_props", [serializable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return [];
  }
})), _class2$e)) || _class$h);
legacyCC.Material = Material;

var ShadowSize = Enum({
  Low_256x256: 256,
  Medium_512x512: 512,
  High_1024x1024: 1024,
  Ultra_2048x2048: 2048
});
var ShadowType = Enum({
  Planar: 0,
  ShadowMap: 1
});
var PCFType = Enum({
  HARD: 0,
  SOFT: 1,
  SOFT_2X: 2
});
var SHADOW_TYPE_NONE = ShadowType.ShadowMap + 1;
var Shadows = function () {
  _createClass(Shadows, [{
    key: "enabled",
    get: function get() {
      return this._enabled;
    },
    set: function set(val) {
      this._setEnable(val);

      this.activate();
    }
  }, {
    key: "normal",
    get: function get() {
      return this._normal;
    },
    set: function set(val) {
      Vec3.copy(this._normal, val);
    }
  }, {
    key: "distance",
    get: function get() {
      return this._distance;
    },
    set: function set(val) {
      this._distance = val;
    }
  }, {
    key: "shadowColor",
    get: function get() {
      return this._shadowColor;
    },
    set: function set(color) {
      this._shadowColor = color;
    }
  }, {
    key: "type",
    get: function get() {
      return this._type;
    },
    set: function set(val) {
      this._setType(val);

      this.activate();
    }
  }, {
    key: "near",
    get: function get() {
      return this._near;
    },
    set: function set(val) {
      this._near = val;
    }
  }, {
    key: "far",
    get: function get() {
      return this._far;
    },
    set: function set(val) {
      this._far = val;
    }
  }, {
    key: "orthoSize",
    get: function get() {
      return this._orthoSize;
    },
    set: function set(val) {
      this._orthoSize = val;
    }
  }, {
    key: "size",
    get: function get() {
      return this._size;
    },
    set: function set(val) {
      this._size.set(val);
    }
  }, {
    key: "pcf",
    get: function get() {
      return this._pcf;
    },
    set: function set(val) {
      this._pcf = val;
    }
  }, {
    key: "shadowMapDirty",
    get: function get() {
      return this._shadowMapDirty;
    },
    set: function set(val) {
      this._shadowMapDirty = val;
    }
  }, {
    key: "bias",
    get: function get() {
      return this._bias;
    },
    set: function set(val) {
      this._bias = val;
    }
  }, {
    key: "normalBias",
    get: function get() {
      return this._normalBias;
    },
    set: function set(val) {
      this._normalBias = val;
    }
  }, {
    key: "saturation",
    get: function get() {
      return this._saturation;
    },
    set: function set(val) {
      this._saturation = val;
    }
  }, {
    key: "autoAdapt",
    get: function get() {
      return this._autoAdapt;
    },
    set: function set(val) {
      this._autoAdapt = val;
    }
  }, {
    key: "matLight",
    get: function get() {
      return this._matLight;
    }
  }, {
    key: "material",
    get: function get() {
      return this._material;
    }
  }, {
    key: "instancingMaterial",
    get: function get() {
      return this._instancingMaterial;
    }
  }, {
    key: "native",
    get: function get() {
      return this._nativeObj;
    }
  }]);

  function Shadows() {
    this.sphere = new Sphere(0.0, 0.0, 0.0, 0.01);
    this.maxReceived = 4;
    this._normal = new Vec3(0, 1, 0);
    this._shadowColor = new Color(0, 0, 0, 76);
    this._matLight = new Mat4();
    this._material = null;
    this._instancingMaterial = null;
    this._size = new Vec2(512, 512);
    this._enabled = false;
    this._distance = 0;
    this._type = SHADOW_TYPE_NONE;
    this._near = 0;
    this._far = 0;
    this._orthoSize = 1;
    this._pcf = 0;
    this._shadowMapDirty = false;
    this._bias = 0;
    this._normalBias = 0;
    this._autoAdapt = true;
    this._saturation = 0.75;
  }

  var _proto = Shadows.prototype;

  _proto.getPlanarShader = function getPlanarShader(patches) {
    if (!this._material) {
      this._material = new Material();

      this._material.initialize({
        effectName: 'planar-shadow'
      });
    }

    return this._material.passes[0].getShaderVariant(patches);
  };

  _proto.getPlanarInstanceShader = function getPlanarInstanceShader(patches) {
    if (!this._instancingMaterial) {
      this._instancingMaterial = new Material();

      this._instancingMaterial.initialize({
        effectName: 'planar-shadow',
        defines: {
          USE_INSTANCING: true
        }
      });
    }

    return this._instancingMaterial.passes[0].getShaderVariant(patches);
  };

  _proto._setEnable = function _setEnable(val) {
    this._enabled = val;
  };

  _proto._setType = function _setType(val) {
    this._type = this.enabled ? val : SHADOW_TYPE_NONE;
  };

  _proto.initialize = function initialize(shadowsInfo) {
    this.near = shadowsInfo.near;
    this.far = shadowsInfo.far;
    this.orthoSize = shadowsInfo.orthoSize;
    this.size = shadowsInfo.size;
    this.pcf = shadowsInfo.pcf;
    this.normal = shadowsInfo.normal;
    this.distance = shadowsInfo.distance;
    this.shadowColor = shadowsInfo.shadowColor;
    this.bias = shadowsInfo.bias;
    this.normalBias = shadowsInfo.normalBias;
    this.maxReceived = shadowsInfo.maxReceived;
    this.autoAdapt = shadowsInfo.autoAdapt;

    this._setEnable(shadowsInfo.enabled);

    this._setType(shadowsInfo.type);

    this.saturation = shadowsInfo.saturation;
  };

  _proto.activate = function activate() {
    if (this.enabled) {
      if (this.type === ShadowType.ShadowMap) {
        this._updatePipeline();
      } else {
        this._updatePlanarInfo();
      }
    } else {
      var root = legacyCC.director.root;
      var pipeline = root.pipeline;
      pipeline.macros.CC_RECEIVE_SHADOW = 0;
      root.onGlobalPipelineStateChanged();
    }
  };

  _proto._updatePlanarInfo = function _updatePlanarInfo() {
    if (!this._material) {
      this._material = new Material();

      this._material.initialize({
        effectName: 'planar-shadow'
      });
    }

    if (!this._instancingMaterial) {
      this._instancingMaterial = new Material();

      this._instancingMaterial.initialize({
        effectName: 'planar-shadow',
        defines: {
          USE_INSTANCING: true
        }
      });
    }

    var root = legacyCC.director.root;
    var pipeline = root.pipeline;
    pipeline.macros.CC_RECEIVE_SHADOW = 0;
    root.onGlobalPipelineStateChanged();
  };

  _proto._updatePipeline = function _updatePipeline() {
    var root = legacyCC.director.root;
    var pipeline = root.pipeline;
    pipeline.macros.CC_RECEIVE_SHADOW = 1;
    root.onGlobalPipelineStateChanged();
  };

  _proto._destroy = function _destroy() {
  };

  _proto.destroy = function destroy() {
    this._destroy();

    if (this._material) {
      this._material.destroy();
    }

    if (this._instancingMaterial) {
      this._instancingMaterial.destroy();
    }

    this.sphere.destroy();
  };

  return Shadows;
}();
Shadows.MAX_FAR = 2000.0;
Shadows.COEFFICIENT_OF_EXPANSION = 2.0 * Math.sqrt(3.0);
legacyCC.Shadows = Shadows;

var _dec$i, _dec2$7, _dec3$2, _dec4$1, _dec5, _class$i, _class2$f, _descriptor$d, _descriptor2$9, _temp$f;

var _colorAttachment = new ColorAttachment();

_colorAttachment.endAccesses = [exports.AccessType.FRAGMENT_SHADER_READ_TEXTURE];

var _depthStencilAttachment = new DepthStencilAttachment();

var passInfo = new RenderPassInfo([_colorAttachment], _depthStencilAttachment);
var _windowInfo = {
  width: 1,
  height: 1,
  renderPassInfo: passInfo
};
var RenderTexture = (_dec$i = ccclass('cc.RenderTexture'), _dec2$7 = rangeMin(), _dec3$2 = rangeMax(), _dec4$1 = rangeMin(), _dec5 = rangeMax(), _dec$i(_class$i = (_class2$f = (_temp$f = function (_TextureBase) {
  _inheritsLoose(RenderTexture, _TextureBase);

  function RenderTexture() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _TextureBase.call.apply(_TextureBase, [this].concat(args)) || this;

    _initializerDefineProperty(_this, "_width", _descriptor$d, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_height", _descriptor2$9, _assertThisInitialized(_this));

    _this._window = null;
    return _this;
  }

  var _proto = RenderTexture.prototype;

  _proto.initialize = function initialize(info) {
    this._name = info.name || '';
    this._width = info.width;
    this._height = info.height;

    this._initWindow(info);
  };

  _proto.reset = function reset(info) {
    this.initialize(info);
  };

  _proto.destroy = function destroy() {
    if (this._window) {
      var root = legacyCC.director.root;
      root === null || root === void 0 ? void 0 : root.destroyWindow(this._window);
      this._window = null;
    }

    return _TextureBase.prototype.destroy.call(this);
  };

  _proto.resize = function resize(width, height) {
    this._width = width;
    this._height = height;

    if (this._window) {
      this._window.resize(width, height);
    }

    this.emit('resize', this._window);
  };

  _proto.getGFXTexture = function getGFXTexture() {
    return this._window && this._window.framebuffer.colorTextures[0];
  };

  _proto.getGFXSampler = function getGFXSampler() {
    var root = legacyCC.director.root;
    return samplerLib.getSampler(root.device, defaultSamplerHash);
  };

  _proto.getSamplerHash = function getSamplerHash() {
    return defaultSamplerHash;
  };

  _proto.onLoaded = function onLoaded() {
    this._initWindow();
  };

  _proto._initWindow = function _initWindow(info) {
    var root = legacyCC.director.root;
    _windowInfo.title = this._name;
    _windowInfo.width = this._width;
    _windowInfo.height = this._height;
    _windowInfo.renderPassInfo = info && info.passInfo ? info.passInfo : passInfo;

    if (this._window) {
      this._window.destroy();

      this._window.initialize(root.device, _windowInfo);
    } else {
      this._window = root.createWindow(_windowInfo);
    }
  };

  _proto.initDefault = function initDefault(uuid) {
    _TextureBase.prototype.initDefault.call(this, uuid);

    this._width = this._height = 1;

    this._initWindow();
  };

  _proto.validate = function validate() {
    return this.width >= 1 && this.width <= 2048 && this.height >= 1 && this.height <= 2048;
  };

  _createClass(RenderTexture, [{
    key: "width",
    get: function get() {
      return this._width;
    }
  }, {
    key: "height",
    get: function get() {
      return this._height;
    }
  }, {
    key: "window",
    get: function get() {
      return this._window;
    }
  }, {
    key: "_serialize",
    get: function get() {
      return null;
    }
  }, {
    key: "_deserialize",
    get: function get() {
      return null;
    }
  }]);

  return RenderTexture;
}(TextureBase), _temp$f), (_descriptor$d = _applyDecoratedDescriptor(_class2$f.prototype, "_width", [serializable, _dec2$7, _dec3$2], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return 1;
  }
}), _descriptor2$9 = _applyDecoratedDescriptor(_class2$f.prototype, "_height", [serializable, _dec4$1, _dec5], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return 1;
  }
})), _class2$f)) || _class$i);
legacyCC.RenderTexture = RenderTexture;

var FogType = Enum({
  LINEAR: 0,
  EXP: 1,
  EXP_SQUARED: 2,
  LAYERED: 3
});
var FOG_TYPE_NONE = FogType.LAYERED + 1;
var Fog = function () {
  _createClass(Fog, [{
    key: "enabled",
    set: function set(val) {
      this._setEnable(val);

      if (!val) this._type = FOG_TYPE_NONE;
      val ? this.activate() : this._updatePipeline();
    },
    get: function get() {
      return this._enabled;
    }
  }, {
    key: "fogColor",
    set: function set(val) {
      this._fogColor.set(val);

      Color.toArray(this._colorArray, this._fogColor);
    },
    get: function get() {
      return this._fogColor;
    }
  }, {
    key: "type",
    get: function get() {
      return this._type;
    },
    set: function set(val) {
      this._setType(val);

      if (this.enabled) this._updatePipeline();
    }
  }, {
    key: "fogDensity",
    get: function get() {
      return this._fogDensity;
    },
    set: function set(val) {
      this._fogDensity = val;
    }
  }, {
    key: "fogStart",
    get: function get() {
      return this._fogStart;
    },
    set: function set(val) {
      this._fogStart = val;
    }
  }, {
    key: "fogEnd",
    get: function get() {
      return this._fogEnd;
    },
    set: function set(val) {
      this._fogEnd = val;
    }
  }, {
    key: "fogAtten",
    get: function get() {
      return this._fogAtten;
    },
    set: function set(val) {
      this._fogAtten = val;
    }
  }, {
    key: "fogTop",
    get: function get() {
      return this._fogTop;
    },
    set: function set(val) {
      this._fogTop = val;
    }
  }, {
    key: "fogRange",
    get: function get() {
      return this._fogRange;
    },
    set: function set(val) {
      this._fogRange = val;
    }
  }, {
    key: "colorArray",
    get: function get() {
      return this._colorArray;
    }
  }, {
    key: "native",
    get: function get() {
      return this._nativeObj;
    }
  }]);

  function Fog() {
    this._fogColor = new Color('#C8C8C8');
    this._colorArray = new Float32Array([0.2, 0.2, 0.2, 1.0]);
    this._enabled = false;
    this._type = 0;
    this._fogDensity = 0.3;
    this._fogStart = 0.5;
    this._fogEnd = 300;
    this._fogAtten = 5;
    this._fogTop = 1.5;
    this._fogRange = 1.2;
  }

  var _proto = Fog.prototype;

  _proto._setType = function _setType(val) {
    this._type = this.enabled ? val : FOG_TYPE_NONE;
  };

  _proto._setEnable = function _setEnable(val) {
    this._enabled = val;
  };

  _proto.initialize = function initialize(fogInfo) {
    this.fogColor = fogInfo.fogColor;

    this._setEnable(fogInfo.enabled);

    this._setType(fogInfo.type);

    this.fogDensity = fogInfo.fogDensity;
    this.fogStart = fogInfo.fogStart;
    this.fogEnd = fogInfo.fogEnd;
    this.fogAtten = fogInfo.fogAtten;
    this.fogTop = fogInfo.fogTop;
    this.fogRange = fogInfo.fogRange;
  };

  _proto.activate = function activate() {
    this._updatePipeline();
  };

  _proto._updatePipeline = function _updatePipeline() {
    var root = legacyCC.director.root;
    var value = this.enabled ? this.type : FOG_TYPE_NONE;
    var pipeline = root.pipeline;

    if (pipeline.macros.CC_USE_FOG === value) {
      return;
    }

    pipeline.macros.CC_USE_FOG = value;
    root.onGlobalPipelineStateChanged();
  };

  _proto._destroy = function _destroy() {
  };

  _proto.destroy = function destroy() {
    this._destroy();
  };

  return Fog;
}();
legacyCC.Fog = Fog;

function deepFlatten(strList, array) {
  for (var _iterator = _createForOfIteratorHelperLoose(array), _step; !(_step = _iterator()).done;) {
    var item = _step.value;

    if (Array.isArray(item)) {
      deepFlatten(strList, item);
    } else {
        strList.push(item);
      }
  }
}

function flattenCodeArray(array) {
  var separator =  '';
  var strList = [];
  deepFlatten(strList, array);
  return strList.join(separator);
}

var Destroyed$2 = CCObject.Flags.Destroyed;
var PersistentMask$2 = CCObject.Flags.PersistentMask;
var DEFAULT = DELIMETER + "default";
var IDENTIFIER_RE$1 = CCClass.IDENTIFIER_RE;
var VAR = 'var ';
var LOCAL_OBJ = 'o';
var LOCAL_TEMP_OBJ = 't';
var LOCAL_ARRAY = 'a';
var LINE_INDEX_OF_NEW_OBJ = 0;
var DEFAULT_MODULE_CACHE = {
  'cc.ClickEvent': false,
  'cc.PrefabInfo': false
};
var escapeForJS$1 = CCClass.escapeForJS;

var Declaration = function () {
  function Declaration(varName, expression) {
    this.varName = void 0;
    this.expression = void 0;
    this.varName = varName;
    this.expression = expression;
  }

  var _proto = Declaration.prototype;

  _proto.toString = function toString() {
    return VAR + this.varName + "=" + this.expression + ";";
  };

  return Declaration;
}();

function mergeDeclaration(statement, expression) {
  if (expression instanceof Declaration) {
    return new Declaration(expression.varName, statement + expression.expression);
  } else {
    return statement + expression;
  }
}

function writeAssignment(codeArray, statement, expression) {
  if (Array.isArray(expression)) {
    expression[0] = mergeDeclaration(statement, expression[0]);
    codeArray.push(expression);
  } else {
    codeArray.push(mergeDeclaration(statement, expression) + ";");
  }
}

var Assignments = function () {
  function Assignments(targetExpression) {
    this._exps = void 0;
    this._targetExp = void 0;
    this._exps = [];
    this._targetExp = targetExpression;
  }

  var _proto2 = Assignments.prototype;

  _proto2.append = function append(key, expression) {
    this._exps.push([key, expression]);
  };

  _proto2.writeCode = function writeCode(codeArray) {
    var targetVar;

    if (this._exps.length > 1) {
      codeArray.push(LOCAL_TEMP_OBJ + "=" + this._targetExp + ";");
      targetVar = LOCAL_TEMP_OBJ;
    } else if (this._exps.length === 1) {
      targetVar = this._targetExp;
    } else {
      return;
    }

    for (var i = 0; i < this._exps.length; i++) {
      var pair = this._exps[i];
      writeAssignment(codeArray, targetVar + getPropAccessor(pair[0]) + "=", pair[1]);
    }
  };

  return Assignments;
}();

Assignments.pool = void 0;
Assignments.pool = new Pool$1(function (obj) {
  obj._exps.length = 0;
  obj._targetExp = null;
}, 1);

Assignments.pool.get = function (targetExpression) {
  var cache = this._get() || new Assignments();
  cache._targetExp = targetExpression;
  return cache;
};

function getPropAccessor(key) {
  return IDENTIFIER_RE$1.test(key) ? "." + key : "[" + escapeForJS$1(key) + "]";
}

var Parser = function () {
  function Parser(obj, parent) {
    this.parent = void 0;
    this.objsToClear_iN$t = void 0;
    this.codeArray = void 0;
    this.objs = void 0;
    this.funcs = void 0;
    this.funcModuleCache = void 0;
    this.globalVariables = void 0;
    this.globalVariableId = void 0;
    this.localVariableId = void 0;
    this.result = void 0;
    this.parent = parent;
    this.objsToClear_iN$t = [];
    this.codeArray = [];
    this.objs = [];
    this.funcs = [];
    this.funcModuleCache = createMap();
    mixin(this.funcModuleCache, DEFAULT_MODULE_CACHE);
    this.globalVariables = [];
    this.globalVariableId = 0;
    this.localVariableId = 0;
    this.codeArray.push(VAR + LOCAL_OBJ + "," + LOCAL_TEMP_OBJ + ";", 'if(R){', LOCAL_OBJ + "=R;", '}else{', LOCAL_OBJ + "=R=new " + this.getFuncModule(obj.constructor, true) + "();", '}');
    obj._iN$t = {
      globalVar: 'R'
    };
    this.objsToClear_iN$t.push(obj);
    this.enumerateObject(this.codeArray, obj);
    var globalVariablesDeclaration;

    if (this.globalVariables.length > 0) {
      globalVariablesDeclaration = VAR + this.globalVariables.join(',') + ";";
    }

    var code = flattenCodeArray(['return (function(R){', globalVariablesDeclaration || [], this.codeArray, 'return o;', '})']);
    this.result = Function('O', 'F', code)(this.objs, this.funcs);

    for (var i = 0, len = this.objsToClear_iN$t.length; i < len; ++i) {
      this.objsToClear_iN$t[i]._iN$t = null;
    }

    this.objsToClear_iN$t.length = 0;
  }

  var _proto3 = Parser.prototype;

  _proto3.getFuncModule = function getFuncModule(func, usedInNew) {
    var clsName = getClassName(func);

    if (clsName) {
      var cache = this.funcModuleCache[clsName];

      if (cache) {
        return cache;
      } else if (cache === undefined) {
        var clsNameIsModule = clsName.indexOf('.') !== -1;

        if (clsNameIsModule) {
          try {
            clsNameIsModule = func === Function("return " + clsName)();

            if (clsNameIsModule) {
              this.funcModuleCache[clsName] = clsName;
              return clsName;
            }
          } catch (e) {}
        }
      }
    }

    var index = this.funcs.indexOf(func);

    if (index < 0) {
      index = this.funcs.length;
      this.funcs.push(func);
    }

    var res = "F[" + index + "]";

    if (usedInNew) {
      res = "(" + res + ")";
    }

    this.funcModuleCache[clsName] = res;
    return res;
  };

  _proto3.getObjRef = function getObjRef(obj) {
    var index = this.objs.indexOf(obj);

    if (index < 0) {
      index = this.objs.length;
      this.objs.push(obj);
    }

    return "O[" + index + "]";
  };

  _proto3.setValueType = function setValueType(codeArray, defaultValue, srcValue, targetExpression) {
    var assignments = Assignments.pool.get(targetExpression);
    var fastDefinedProps = defaultValue.constructor.__props__;

    if (!fastDefinedProps) {
      fastDefinedProps = Object.keys(defaultValue);
    }

    for (var i = 0; i < fastDefinedProps.length; i++) {
      var propName = fastDefinedProps[i];
      var prop = srcValue[propName];

      if (defaultValue[propName] === prop) {
        continue;
      }

      var expression = this.enumerateField(srcValue, propName, prop);
      assignments.append(propName, expression);
    }

    assignments.writeCode(codeArray);
    Assignments.pool.put(assignments);
  };

  _proto3.enumerateCCClass = function enumerateCCClass(codeArray, obj, klass) {
    var props = klass.__values__;
    var attrs = getClassAttrs(klass);

    for (var p = 0; p < props.length; p++) {
      var key = props[p];
      var val = obj[key];
      var defaultValue = attrs[key + DEFAULT];

      if (equalsToDefault(defaultValue, val)) {
        continue;
      }

      if (typeof val === 'object' && val instanceof legacyCC.ValueType) {
        defaultValue = CCClass.getDefault(defaultValue);

        if (defaultValue && defaultValue.constructor === val.constructor) {
          var targetExpression = LOCAL_OBJ + getPropAccessor(key);
          this.setValueType(codeArray, defaultValue, val, targetExpression);
          continue;
        }
      }

      this.setObjProp(codeArray, obj, key, val);
    }
  };

  _proto3.instantiateArray = function instantiateArray(value) {
    if (value.length === 0) {
      return '[]';
    }

    var arrayVar = LOCAL_ARRAY + ++this.localVariableId;
    var declaration = new Declaration(arrayVar, "new Array(" + value.length + ")");
    var codeArray = [declaration];
    value._iN$t = {
      globalVar: '',
      source: codeArray
    };
    this.objsToClear_iN$t.push(value);

    for (var i = 0; i < value.length; ++i) {
      var statement = arrayVar + "[" + i + "]=";
      var expression = this.enumerateField(value, i, value[i]);
      writeAssignment(codeArray, statement, expression);
    }

    return codeArray;
  };

  _proto3.instantiateTypedArray = function instantiateTypedArray(value) {
    var type = value.constructor.name;

    if (value.length === 0) {
      return "new " + type;
    }

    var arrayVar = LOCAL_ARRAY + ++this.localVariableId;
    var declaration = new Declaration(arrayVar, "new " + type + "(" + value.length + ")");
    var codeArray = [declaration];
    value._iN$t = {
      globalVar: '',
      source: codeArray
    };
    this.objsToClear_iN$t.push(value);

    for (var i = 0; i < value.length; ++i) {
      if (value[i] !== 0) {
        var statement = arrayVar + "[" + i + "]=";
        writeAssignment(codeArray, statement, value[i]);
      }
    }

    return codeArray;
  };

  _proto3.enumerateField = function enumerateField(obj, key, value) {
    if (typeof value === 'object' && value) {
      var _iN$t = value._iN$t;

      if (_iN$t) {
        var globalVar = _iN$t.globalVar;

        if (!globalVar) {
          globalVar = _iN$t.globalVar = "v" + ++this.globalVariableId;
          this.globalVariables.push(globalVar);
          var line = _iN$t.source[LINE_INDEX_OF_NEW_OBJ];
          _iN$t.source[LINE_INDEX_OF_NEW_OBJ] = mergeDeclaration(globalVar + "=", line);
        }

        return globalVar;
      } else if (ArrayBuffer.isView(value)) {
        return this.instantiateTypedArray(value);
      } else if (Array.isArray(value)) {
        return this.instantiateArray(value);
      } else {
        return this.instantiateObj(value);
      }
    } else if (typeof value === 'function') {
      return this.getFuncModule(value);
    } else if (typeof value === 'string') {
      return escapeForJS$1(value);
    } else {
      if (key === '_objFlags' && obj instanceof CCObject) {
        value &= PersistentMask$2;
      }

      return value;
    }
  };

  _proto3.setObjProp = function setObjProp(codeArray, obj, key, value) {
    var statement = LOCAL_OBJ + getPropAccessor(key) + "=";
    var expression = this.enumerateField(obj, key, value);
    writeAssignment(codeArray, statement, expression);
  };

  _proto3.enumerateObject = function enumerateObject(codeArray, obj) {
    var klass = obj.constructor;

    if (legacyCC.Class._isCCClass(klass)) {
      this.enumerateCCClass(codeArray, obj, klass);
    } else {
      for (var key in obj) {
        if (!obj.hasOwnProperty(key) || key.charCodeAt(0) === 95 && key.charCodeAt(1) === 95 && key !== '__type__') {
          continue;
        }

        var value = obj[key];

        if (typeof value === 'object' && value && value === obj._iN$t) {
          continue;
        }

        this.setObjProp(codeArray, obj, key, value);
      }
    }
  };

  _proto3.instantiateObj = function instantiateObj(obj) {
    if (obj instanceof legacyCC.ValueType) {
      return CCClass.getNewValueTypeCode(obj);
    }

    if (obj instanceof legacyCC.Asset) {
      return this.getObjRef(obj);
    }

    if (obj._objFlags & Destroyed$2) {
      return null;
    }

    var createCode;
    var ctor = obj.constructor;

    if (legacyCC.Class._isCCClass(ctor)) {
      if (this.parent) {
        if (this.parent instanceof legacyCC.Component) {
          if (obj instanceof legacyCC._BaseNode || obj instanceof legacyCC.Component) {
            return this.getObjRef(obj);
          }
        } else if (this.parent instanceof legacyCC._BaseNode) {
          if (obj instanceof legacyCC._BaseNode) {
            if (!obj.isChildOf(this.parent)) {
              return this.getObjRef(obj);
            }
          } else if (obj instanceof legacyCC.Component) {
            if (!obj.node.isChildOf(this.parent)) {
              return this.getObjRef(obj);
            }
          }
        }
      }

      createCode = new Declaration(LOCAL_OBJ, "new " + this.getFuncModule(ctor, true) + "()");
    } else if (ctor === Object) {
      createCode = new Declaration(LOCAL_OBJ, '{}');
    } else if (!ctor) {
      createCode = new Declaration(LOCAL_OBJ, 'Object.create(null)');
    } else {
      return this.getObjRef(obj);
    }

    var codeArray = [createCode];
    obj._iN$t = {
      globalVar: '',
      source: codeArray
    };
    this.objsToClear_iN$t.push(obj);
    this.enumerateObject(codeArray, obj);
    return ['(function(){', codeArray, 'return o;})();'];
  };

  return Parser;
}();

function equalsToDefault(def, value) {
  if (typeof def === 'function') {
    try {
      def = def();
    } catch (e) {
      return false;
    }
  }

  if (def === value) {
    return true;
  }

  if (def && value && typeof def === 'object' && typeof value === 'object' && def.constructor === value.constructor) {
    if (def instanceof legacyCC.ValueType) {
      if (def.equals(value)) {
        return true;
      }
    } else if (Array.isArray(def)) {
      return def.length === 0 && value.length === 0;
    } else if (def.constructor === Object) {
      return isEmptyObject(def) && isEmptyObject(value);
    }
  }

  return false;
}
function compile(node) {
  var root = node instanceof legacyCC._BaseNode && node;
  var parser = new Parser(node, root);
  return parser.result;
}

var NodeUIProperties = function () {
  _createClass(NodeUIProperties, [{
    key: "uiTransformComp",
    get: function get() {
      if (!this._uiTransformComp) {
        this._uiTransformComp = this._node.getComponent('cc.UITransform');
      }

      return this._uiTransformComp;
    },
    set: function set(value) {
      this._uiTransformComp = value;
    }
  }, {
    key: "uiComp",
    get: function get() {
      return this._uiComp;
    },
    set: function set(comp) {
      if (this._uiComp && comp) {
        warnID(12002);
        return;
      }

      this._uiComp = comp;
    }
  }]);

  function NodeUIProperties(node) {
    this._uiComp = null;
    this.opacity = 1;
    this.localOpacity = 1;
    this._uiTransformComp = null;
    this._node = void 0;
    this.uiTransformDirty = true;
    this._node = node;
  }

  return NodeUIProperties;
}();

(function (SystemEventType) {
  SystemEventType["TOUCH_START"] = "touch-start";
  SystemEventType["TOUCH_MOVE"] = "touch-move";
  SystemEventType["TOUCH_END"] = "touch-end";
  SystemEventType["TOUCH_CANCEL"] = "touch-cancel";
  SystemEventType["MOUSE_DOWN"] = "mouse-down";
  SystemEventType["MOUSE_MOVE"] = "mouse-move";
  SystemEventType["MOUSE_UP"] = "mouse-up";
  SystemEventType["MOUSE_WHEEL"] = "mouse-wheel";
  SystemEventType["MOUSE_ENTER"] = "mouse-enter";
  SystemEventType["MOUSE_LEAVE"] = "mouse-leave";
  SystemEventType["KEY_DOWN"] = "keydown";
  SystemEventType["KEY_UP"] = "keyup";
  SystemEventType["DEVICEMOTION"] = "devicemotion";
  SystemEventType["TRANSFORM_CHANGED"] = "transform-changed";
  SystemEventType["SCENE_CHANGED_FOR_PERSISTS"] = "scene-changed-for-persists";
  SystemEventType["SIZE_CHANGED"] = "size-changed";
  SystemEventType["ANCHOR_CHANGED"] = "anchor-changed";
  SystemEventType["COLOR_CHANGED"] = "color-changed";
  SystemEventType["CHILD_ADDED"] = "child-added";
  SystemEventType["CHILD_REMOVED"] = "child-removed";
  SystemEventType["PARENT_CHANGED"] = "parent-changed";
  SystemEventType["NODE_DESTROYED"] = "node-destroyed";
  SystemEventType["LAYER_CHANGED"] = "layer-changed";
  SystemEventType["SIBLING_ORDER_CHANGED"] = "sibling-order-changed";
})(exports.SystemEventType || (exports.SystemEventType = {}));

ccenum(exports.SystemEventType);
legacyCC.SystemEventType = exports.SystemEventType;

var EventListener = function () {
  EventListener.create = function create(argObj) {
    assertID(argObj && argObj.event, 1900);
    var listenerType = argObj.event;
    delete argObj.event;
    var listener = null;

    if (listenerType === legacyCC.EventListener.TOUCH_ONE_BY_ONE) {
      listener = new TouchOneByOneEventListener();
    } else if (listenerType === legacyCC.EventListener.TOUCH_ALL_AT_ONCE) {
      listener = new TouchAllAtOnceEventListener();
    } else if (listenerType === legacyCC.EventListener.MOUSE) {
      listener = new MouseEventListener();
    } else if (listenerType === legacyCC.EventListener.KEYBOARD) {
      listener = new KeyboardEventListener();
    } else if (listenerType === legacyCC.EventListener.ACCELERATION) {
      listener = new AccelerationEventListener(argObj.callback);
      delete argObj.callback;
    }

    if (listener) {
      for (var _i = 0, _Object$keys = Object.keys(argObj); _i < _Object$keys.length; _i++) {
        var key = _Object$keys[_i];
        listener[key] = argObj[key];
      }
    }

    return listener;
  };

  _createClass(EventListener, [{
    key: "onEvent",
    get: function get() {
      return this._onEvent;
    }
  }]);

  function EventListener(type, listenerID, callback) {
    this._cameraPriority = 0;
    this.owner = null;
    this.mask = null;
    this._previousIn = false;
    this._target = null;
    this._onEvent = void 0;
    this._type = void 0;
    this._listenerID = void 0;
    this._registered = false;
    this._fixedPriority = 0;
    this._node = null;
    this._paused = true;
    this._isEnabled = true;
    this._onEvent = callback;
    this._type = type || 0;
    this._listenerID = listenerID || '';
  }

  var _proto = EventListener.prototype;

  _proto._setPaused = function _setPaused(paused) {
    this._paused = paused;
  };

  _proto._isPaused = function _isPaused() {
    return this._paused;
  };

  _proto._setRegistered = function _setRegistered(registered) {
    this._registered = registered;
  };

  _proto._isRegistered = function _isRegistered() {
    return this._registered;
  };

  _proto._getType = function _getType() {
    return this._type;
  };

  _proto._getListenerID = function _getListenerID() {
    return this._listenerID;
  };

  _proto._setFixedPriority = function _setFixedPriority(fixedPriority) {
    this._fixedPriority = fixedPriority;
  };

  _proto._getFixedPriority = function _getFixedPriority() {
    return this._fixedPriority;
  };

  _proto._setSceneGraphPriority = function _setSceneGraphPriority(node) {
    this._target = node;
    this._node = node;
  };

  _proto._getSceneGraphPriority = function _getSceneGraphPriority() {
    return this._node;
  };

  _proto.checkAvailable = function checkAvailable() {
    return this._onEvent !== null;
  };

  _proto.clone = function clone() {
    return null;
  };

  _proto.setEnabled = function setEnabled(enabled) {
    this._isEnabled = enabled;
  };

  _proto.isEnabled = function isEnabled() {
    return this._isEnabled;
  };

  return EventListener;
}();
EventListener.UNKNOWN = 0;
EventListener.TOUCH_ONE_BY_ONE = 1;
EventListener.TOUCH_ALL_AT_ONCE = 2;
EventListener.KEYBOARD = 3;
EventListener.MOUSE = 4;
EventListener.ACCELERATION = 6;
EventListener.CUSTOM = 8;
EventListener.ListenerID = {
  MOUSE: '__cc_mouse',
  TOUCH_ONE_BY_ONE: '__cc_touch_one_by_one',
  TOUCH_ALL_AT_ONCE: '__cc_touch_all_at_once',
  KEYBOARD: '__cc_keyboard',
  ACCELERATION: '__cc_acceleration'
};
var ListenerID = EventListener.ListenerID;
var MouseEventListener = function (_EventListener) {
  _inheritsLoose(MouseEventListener, _EventListener);

  function MouseEventListener() {
    var _this;

    _this = _EventListener.call(this, EventListener.MOUSE, ListenerID.MOUSE, null) || this;
    _this.onMouseDown = null;
    _this.onMouseUp = null;
    _this.onMouseMove = null;
    _this.onMouseScroll = null;

    _this._onEvent = function (event) {
      return _this._callback(event);
    };

    return _this;
  }

  var _proto2 = MouseEventListener.prototype;

  _proto2._callback = function _callback(event) {
    switch (event.type) {
      case exports.SystemEventType.MOUSE_DOWN:
        if (this.onMouseDown) {
          this.onMouseDown(event);
        }

        break;

      case exports.SystemEventType.MOUSE_UP:
        if (this.onMouseUp) {
          this.onMouseUp(event);
        }

        break;

      case exports.SystemEventType.MOUSE_MOVE:
        if (this.onMouseMove) {
          this.onMouseMove(event);
        }

        break;

      case exports.SystemEventType.MOUSE_WHEEL:
        if (this.onMouseScroll) {
          this.onMouseScroll(event);
        }

        break;
    }
  };

  _proto2.clone = function clone() {
    var eventListener = new MouseEventListener();
    eventListener.onMouseDown = this.onMouseDown;
    eventListener.onMouseUp = this.onMouseUp;
    eventListener.onMouseMove = this.onMouseMove;
    eventListener.onMouseScroll = this.onMouseScroll;
    return eventListener;
  };

  _proto2.checkAvailable = function checkAvailable() {
    return true;
  };

  return MouseEventListener;
}(EventListener);
var TouchOneByOneEventListener = function (_EventListener2) {
  _inheritsLoose(TouchOneByOneEventListener, _EventListener2);

  function TouchOneByOneEventListener() {
    var _this2;

    _this2 = _EventListener2.call(this, EventListener.TOUCH_ONE_BY_ONE, ListenerID.TOUCH_ONE_BY_ONE, null) || this;
    _this2.swallowTouches = false;
    _this2.onTouchBegan = null;
    _this2.onTouchMoved = null;
    _this2.onTouchEnded = null;
    _this2.onTouchCancelled = null;
    _this2._claimedTouches = [];
    return _this2;
  }

  var _proto3 = TouchOneByOneEventListener.prototype;

  _proto3.setSwallowTouches = function setSwallowTouches(needSwallow) {
    this.swallowTouches = needSwallow;
  };

  _proto3.isSwallowTouches = function isSwallowTouches() {
    return this.swallowTouches;
  };

  _proto3.clone = function clone() {
    var eventListener = new TouchOneByOneEventListener();
    eventListener.onTouchBegan = this.onTouchBegan;
    eventListener.onTouchMoved = this.onTouchMoved;
    eventListener.onTouchEnded = this.onTouchEnded;
    eventListener.onTouchCancelled = this.onTouchCancelled;
    eventListener.swallowTouches = this.swallowTouches;
    return eventListener;
  };

  _proto3.checkAvailable = function checkAvailable() {
    if (!this.onTouchBegan) {
      logID(1801);
      return false;
    }

    return true;
  };

  return TouchOneByOneEventListener;
}(EventListener);
var TouchAllAtOnceEventListener = function (_EventListener3) {
  _inheritsLoose(TouchAllAtOnceEventListener, _EventListener3);

  function TouchAllAtOnceEventListener() {
    var _this3;

    _this3 = _EventListener3.call(this, EventListener.TOUCH_ALL_AT_ONCE, ListenerID.TOUCH_ALL_AT_ONCE, null) || this;
    _this3.onTouchesBegan = null;
    _this3.onTouchesMoved = null;
    _this3.onTouchesEnded = null;
    _this3.onTouchesCancelled = null;
    return _this3;
  }

  var _proto4 = TouchAllAtOnceEventListener.prototype;

  _proto4.clone = function clone() {
    var eventListener = new TouchAllAtOnceEventListener();
    eventListener.onTouchesBegan = this.onTouchesBegan;
    eventListener.onTouchesMoved = this.onTouchesMoved;
    eventListener.onTouchesEnded = this.onTouchesEnded;
    eventListener.onTouchesCancelled = this.onTouchesCancelled;
    return eventListener;
  };

  _proto4.checkAvailable = function checkAvailable() {
    if (this.onTouchesBegan === null && this.onTouchesMoved === null && this.onTouchesEnded === null && this.onTouchesCancelled === null) {
      logID(1802);
      return false;
    }

    return true;
  };

  return TouchAllAtOnceEventListener;
}(EventListener);
var AccelerationEventListener = function (_EventListener4) {
  _inheritsLoose(AccelerationEventListener, _EventListener4);

  function AccelerationEventListener(callback) {
    var _this4;

    _this4 = _EventListener4.call(this, EventListener.ACCELERATION, ListenerID.ACCELERATION, null) || this;
    _this4._onAccelerationEvent = null;

    _this4._onEvent = function (event) {
      return _this4._callback(event);
    };

    _this4._onAccelerationEvent = callback;
    return _this4;
  }

  var _proto5 = AccelerationEventListener.prototype;

  _proto5._callback = function _callback(event) {
    if (this._onAccelerationEvent) {
      this._onAccelerationEvent(event.acc, event);
    }
  };

  _proto5.checkAvailable = function checkAvailable() {
    assertID(this._onAccelerationEvent, 1803);
    return true;
  };

  _proto5.clone = function clone() {
    return new AccelerationEventListener(this._onAccelerationEvent);
  };

  return AccelerationEventListener;
}(EventListener);
var KeyboardEventListener = function (_EventListener5) {
  _inheritsLoose(KeyboardEventListener, _EventListener5);

  function KeyboardEventListener() {
    var _this5;

    _this5 = _EventListener5.call(this, EventListener.KEYBOARD, ListenerID.KEYBOARD, null) || this;
    _this5.onKeyDown = undefined;
    _this5.onKeyPressed = undefined;
    _this5.onKeyReleased = undefined;

    _this5._onEvent = function (event) {
      return _this5._callback(event);
    };

    return _this5;
  }

  var _proto6 = KeyboardEventListener.prototype;

  _proto6._callback = function _callback(event) {
    var _this$onKeyPressed, _this$onKeyReleased;

    switch (event.type) {
      case exports.SystemEventType.KEY_DOWN:
        (_this$onKeyPressed = this.onKeyPressed) === null || _this$onKeyPressed === void 0 ? void 0 : _this$onKeyPressed.call(this, event.keyCode, event);
        break;

      case exports.SystemEventType.KEY_UP:
        (_this$onKeyReleased = this.onKeyReleased) === null || _this$onKeyReleased === void 0 ? void 0 : _this$onKeyReleased.call(this, event.keyCode, event);
        break;
    }
  };

  _proto6.clone = function clone() {
    var eventListener = new KeyboardEventListener();
    eventListener.onKeyDown = this.onKeyDown;
    eventListener.onKeyPressed = this.onKeyPressed;
    eventListener.onKeyReleased = this.onKeyReleased;
    return eventListener;
  };

  _proto6.checkAvailable = function checkAvailable() {
    if (this.onKeyDown === null && this.onKeyPressed === null && this.onKeyReleased === null) {
      logID(1800);
      return false;
    }

    return true;
  };

  return KeyboardEventListener;
}(EventListener);
legacyCC.EventListener = EventListener;

var ListenerID$1 = EventListener.ListenerID;

function checkUINode(node) {
  if (node && node.getComponent('cc.UITransform')) {
    return true;
  }

  return false;
}

var touchEvents = [exports.SystemEventType.TOUCH_START, exports.SystemEventType.TOUCH_MOVE, exports.SystemEventType.TOUCH_END, exports.SystemEventType.TOUCH_CANCEL];
var mouseEvents = [exports.SystemEventType.MOUSE_DOWN, exports.SystemEventType.MOUSE_MOVE, exports.SystemEventType.MOUSE_UP, exports.SystemEventType.MOUSE_WHEEL];
var keyboardEvents = [exports.SystemEventType.KEY_DOWN, exports.SystemEventType.KEY_UP];

var _EventListenerVector = function () {
  function _EventListenerVector() {
    this.gt0Index = 0;
    this._fixedListeners = [];
    this._sceneGraphListeners = [];
  }

  var _proto = _EventListenerVector.prototype;

  _proto.size = function size() {
    return this._fixedListeners.length + this._sceneGraphListeners.length;
  };

  _proto.empty = function empty() {
    return this._fixedListeners.length === 0 && this._sceneGraphListeners.length === 0;
  };

  _proto.push = function push(listener) {
    if (listener._getFixedPriority() === 0) {
      this._sceneGraphListeners.push(listener);
    } else {
      this._fixedListeners.push(listener);
    }
  };

  _proto.clearSceneGraphListeners = function clearSceneGraphListeners() {
    this._sceneGraphListeners.length = 0;
  };

  _proto.clearFixedListeners = function clearFixedListeners() {
    this._fixedListeners.length = 0;
  };

  _proto.clear = function clear() {
    this._sceneGraphListeners.length = 0;
    this._fixedListeners.length = 0;
  };

  _proto.getFixedPriorityListeners = function getFixedPriorityListeners() {
    return this._fixedListeners;
  };

  _proto.getSceneGraphPriorityListeners = function getSceneGraphPriorityListeners() {
    return this._sceneGraphListeners;
  };

  return _EventListenerVector;
}();

function __getListenerID(event) {
  var type = event.type;

  if (type === exports.SystemEventType.DEVICEMOTION) {
    return ListenerID$1.ACCELERATION;
  }

  if (keyboardEvents.includes(type)) {
    return ListenerID$1.KEYBOARD;
  }

  if (mouseEvents.includes(type)) {
    return ListenerID$1.MOUSE;
  }

  if (touchEvents.includes(type)) {
    logID(2000);
  }

  return '';
}

var DIRTY_NONE = 0;
var DIRTY_FIXED_PRIORITY = 1 << 0;
var DIRTY_SCENE_GRAPH_PRIORITY = 1 << 1;

var EventManager = function () {
  function EventManager() {
    this._listenersMap = {};
    this._priorityDirtyFlagMap = {};
    this._nodeListenersMap = {};
    this._toAddedListeners = [];
    this._toRemovedListeners = [];
    this._dirtyListeners = {};
    this._inDispatch = 0;
    this._isEnabled = false;
    this._internalCustomListenerIDs = [];
    this._currentTouch = null;
    this._currentTouchListener = null;
  }

  var _proto2 = EventManager.prototype;

  _proto2.pauseTarget = function pauseTarget(node, recursive) {
    if (recursive === void 0) {
      recursive = false;
    }

    if (!(node instanceof legacyCC._BaseNode)) {
      warnID(3506);
      return;
    }

    var listeners = this._nodeListenersMap[node.uuid];

    if (listeners) {
      for (var i = 0, len = listeners.length; i < len; i++) {
        var _listener = listeners[i];

        _listener._setPaused(true);

        if (_listener instanceof TouchOneByOneEventListener && _listener._claimedTouches.includes(this._currentTouch)) {
          this._clearCurTouch();
        }
      }
    }

    if (recursive === true) {
      var locChildren = node.children;

      if (locChildren) {
        for (var _i = 0; _i < locChildren.length; ++_i) {
          var locChild = locChildren[_i];
          this.pauseTarget(locChild, true);
        }
      }
    }
  };

  _proto2.resumeTarget = function resumeTarget(node, recursive) {
    if (recursive === void 0) {
      recursive = false;
    }

    if (!(node instanceof legacyCC._BaseNode)) {
      warnID(3506);
      return;
    }

    var listeners = this._nodeListenersMap[node.uuid];

    if (listeners) {
      for (var i = 0; i < listeners.length; ++i) {
        var _listener2 = listeners[i];

        _listener2._setPaused(false);
      }
    }

    this._setDirtyForNode(node);

    if (recursive === true && node.children.length > 0) {
      var locChildren = node.children;

      if (locChildren) {
        for (var _i2 = 0; _i2 < locChildren.length; ++_i2) {
          var locChild = locChildren[_i2];
          this.resumeTarget(locChild, true);
        }
      }
    }
  };

  _proto2.frameUpdateListeners = function frameUpdateListeners() {
    var locListenersMap = this._listenersMap;
    var locPriorityDirtyFlagMap = this._priorityDirtyFlagMap;

    for (var selKey in locListenersMap) {
      if (locListenersMap[selKey].empty()) {
        delete locPriorityDirtyFlagMap[selKey];
        delete locListenersMap[selKey];
      }
    }

    var locToAddedListeners = this._toAddedListeners;

    if (locToAddedListeners.length !== 0) {
      for (var i = 0, len = locToAddedListeners.length; i < len; i++) {
        this._forceAddEventListener(locToAddedListeners[i]);
      }

      locToAddedListeners.length = 0;
    }

    if (this._toRemovedListeners.length !== 0) {
      this._cleanToRemovedListeners();
    }
  };

  _proto2.hasEventListener = function hasEventListener(listenerID) {
    return !!this._getListeners(listenerID);
  };

  _proto2.addListener = function addListener(listener, nodeOrPriority) {
    assertID(listener && nodeOrPriority, 3503);

    if (!(legacyCC.js.isNumber(nodeOrPriority) || nodeOrPriority instanceof legacyCC._BaseNode)) {
      warnID(3506);
      return null;
    }

    if (!(listener instanceof legacyCC.EventListener)) {
      assertID(!legacyCC.js.isNumber(nodeOrPriority), 3504);
      listener = legacyCC.EventListener.create(listener);
    } else if (listener._isRegistered()) {
      logID(3505);
      return null;
    }

    if (!listener.checkAvailable()) {
      return null;
    }

    if (legacyCC.js.isNumber(nodeOrPriority)) {
      if (nodeOrPriority === 0) {
        logID(3500);
        return null;
      }

      listener._setSceneGraphPriority(null);

      listener._setFixedPriority(nodeOrPriority);

      listener._setRegistered(true);

      listener._setPaused(false);

      this._addListener(listener);
    } else {
      if (!checkUINode(nodeOrPriority)) {
        logID(3512);
        return null;
      }

      listener._setSceneGraphPriority(nodeOrPriority);

      listener._setFixedPriority(0);

      listener._setRegistered(true);

      this._addListener(listener);
    }

    return listener;
  };

  _proto2.addCustomListener = function addCustomListener(eventName, callback) {
    var listener = EventListener.create({
      event: legacyCC.EventListener.CUSTOM,
      eventName: eventName,
      callback: callback
    });
    this.addListener(listener, 1);
    return listener;
  };

  _proto2.removeListener = function removeListener(listener) {
    if (listener == null) {
      return;
    }

    var isFound = false;
    var locListener = this._listenersMap;

    if (listener === this._currentTouchListener) {
      this._currentTouchListener = this._currentTouch = null;
    }

    for (var selKey in locListener) {
      var listeners = locListener[selKey];
      var fixedPriorityListeners = listeners.getFixedPriorityListeners();
      var sceneGraphPriorityListeners = listeners.getSceneGraphPriorityListeners();
      isFound = this._removeListenerInVector(sceneGraphPriorityListeners, listener);

      if (isFound) {
        this._setDirty(listener._getListenerID(), DIRTY_SCENE_GRAPH_PRIORITY);
      } else {
        isFound = this._removeListenerInVector(fixedPriorityListeners, listener);

        if (isFound) {
          this._setDirty(listener._getListenerID(), DIRTY_FIXED_PRIORITY);
        }
      }

      if (listeners.empty()) {
        delete this._priorityDirtyFlagMap[listener._getListenerID()];
        delete locListener[selKey];
      }

      if (isFound) {
        break;
      }
    }

    if (!isFound) {
      var locToAddedListeners = this._toAddedListeners;

      for (var i = locToAddedListeners.length - 1; i >= 0; i--) {
        var selListener = locToAddedListeners[i];

        if (selListener === listener) {
          legacyCC.js.array.removeAt(locToAddedListeners, i);

          selListener._setRegistered(false);

          break;
        }
      }
    }
  };

  _proto2.removeListeners = function removeListeners(listenerType, recursive) {
    if (recursive === void 0) {
      recursive = false;
    }

    if (!(legacyCC.js.isNumber(listenerType) || listenerType instanceof legacyCC._BaseNode)) {
      warnID(3506);
      return;
    }

    if (listenerType._id !== undefined) {
      var listeners = this._nodeListenersMap[listenerType._id];

      if (listeners) {
        var listenersCopy = legacyCC.js.array.copy(listeners);

        for (var i = 0; i < listenersCopy.length; ++i) {
          var listenerCopy = listenersCopy[i];
          this.removeListener(listenerCopy);
        }

        delete this._nodeListenersMap[listenerType._id];
      }

      var locToAddedListeners = this._toAddedListeners;

      for (var _i3 = 0; _i3 < locToAddedListeners.length;) {
        var _listener3 = locToAddedListeners[_i3];

        if (_listener3._getSceneGraphPriority() === listenerType) {
          _listener3._setSceneGraphPriority(null);

          _listener3._setRegistered(false);

          locToAddedListeners.splice(_i3, 1);
        } else {
          ++_i3;
        }
      }

      if (recursive === true) {
        var locChildren = listenerType.getChildren();

        for (var _i4 = 0; _i4 < locChildren.length; ++_i4) {
          var locChild = locChildren[_i4];
          this.removeListeners(locChild, true);
        }
      }
    } else if (listenerType === legacyCC.EventListener.TOUCH_ONE_BY_ONE) {
      this._removeListenersForListenerID(ListenerID$1.TOUCH_ONE_BY_ONE);
    } else if (listenerType === legacyCC.EventListener.TOUCH_ALL_AT_ONCE) {
      this._removeListenersForListenerID(ListenerID$1.TOUCH_ALL_AT_ONCE);
    } else if (listenerType === legacyCC.EventListener.MOUSE) {
      this._removeListenersForListenerID(ListenerID$1.MOUSE);
    } else if (listenerType === legacyCC.EventListener.ACCELERATION) {
      this._removeListenersForListenerID(ListenerID$1.ACCELERATION);
    } else if (listenerType === legacyCC.EventListener.KEYBOARD) {
      this._removeListenersForListenerID(ListenerID$1.KEYBOARD);
    } else {
      logID(3501);
    }
  };

  _proto2.removeCustomListeners = function removeCustomListeners(customEventName) {
    this._removeListenersForListenerID(customEventName);
  };

  _proto2.removeAllListeners = function removeAllListeners() {
    var locListeners = this._listenersMap;
    var locInternalCustomEventIDs = this._internalCustomListenerIDs;

    for (var selKey in locListeners) {
      if (locInternalCustomEventIDs.indexOf(selKey) === -1) {
        this._removeListenersForListenerID(selKey);
      }
    }
  };

  _proto2.setPriority = function setPriority(listener, fixedPriority) {
    if (listener == null) {
      return;
    }

    var locListeners = this._listenersMap;

    for (var selKey in locListeners) {
      var selListeners = locListeners[selKey];
      var fixedPriorityListeners = selListeners.getFixedPriorityListeners();

      if (fixedPriorityListeners) {
        var found = fixedPriorityListeners.indexOf(listener);

        if (found !== -1) {
          if (listener._getSceneGraphPriority() != null) {
            logID(3502);
          }

          if (listener._getFixedPriority() !== fixedPriority) {
            listener._setFixedPriority(fixedPriority);

            this._setDirty(listener._getListenerID(), DIRTY_FIXED_PRIORITY);
          }

          return;
        }
      }
    }
  };

  _proto2.setEnabled = function setEnabled(enabled) {
    this._isEnabled = enabled;
  };

  _proto2.isEnabled = function isEnabled() {
    return this._isEnabled;
  };

  _proto2.dispatchEvent = function dispatchEvent(event) {
    if (!this._isEnabled) {
      return;
    }

    this._updateDirtyFlagForSceneGraph();

    this._inDispatch++;

    if (!event || !event.getType) {
      errorID(3511);
      return;
    }

    if (touchEvents.includes(event.getType())) {
      this._dispatchTouchEvent(event);

      this._inDispatch--;
      return;
    }

    var listenerID = __getListenerID(event);

    this._sortEventListeners(listenerID);

    var selListeners = this._listenersMap[listenerID];

    if (selListeners != null) {
      this._dispatchEventToListeners(selListeners, this._onListenerCallback, event);

      this._onUpdateListeners(selListeners);
    }

    this._inDispatch--;
  };

  _proto2._onListenerCallback = function _onListenerCallback(listener, event) {
    event.currentTarget = listener._target;
    var onEvent = listener.onEvent;

    if (onEvent) {
      onEvent(event);
    }

    return event.isStopped();
  };

  _proto2.dispatchCustomEvent = function dispatchCustomEvent(eventName, optionalUserData) {
    var ev = new legacyCC.Event.EventCustom(eventName);
    ev.setUserData(optionalUserData);
    this.dispatchEvent(ev);
  };

  _proto2._setDirtyForNode = function _setDirtyForNode(node) {
    var selListeners = this._nodeListenersMap[node._id];

    if (selListeners !== undefined) {
      for (var j = 0, len = selListeners.length; j < len; j++) {
        var selListener = selListeners[j];

        var listenerID = selListener._getListenerID();

        if (!this._dirtyListeners[listenerID]) {
          this._dirtyListeners[listenerID] = true;
        }
      }
    }

    if (node.children.length > 0) {
      var _children = node.children;

      for (var i = 0, _len = _children ? _children.length : 0; i < _len; i++) {
        this._setDirtyForNode(_children[i]);
      }
    }
  };

  _proto2._addListener = function _addListener(listener) {
    if (this._inDispatch === 0) {
      this._forceAddEventListener(listener);
    } else {
      this._toAddedListeners.push(listener);
    }
  };

  _proto2._forceAddEventListener = function _forceAddEventListener(listener) {
    var listenerID = listener._getListenerID();

    var listeners = this._listenersMap[listenerID];

    if (!listeners) {
      listeners = new _EventListenerVector();
      this._listenersMap[listenerID] = listeners;
    }

    listeners.push(listener);

    if (listener._getFixedPriority() === 0) {
      this._setDirty(listenerID, DIRTY_SCENE_GRAPH_PRIORITY);

      var node = listener._getSceneGraphPriority();

      if (node === null) {
        logID(3507);
      }

      this._associateNodeAndEventListener(node, listener);

      if (node.activeInHierarchy) {
        this.resumeTarget(node);
      }
    } else {
      this._setDirty(listenerID, DIRTY_FIXED_PRIORITY);
    }
  };

  _proto2._getListeners = function _getListeners(listenerID) {
    return this._listenersMap[listenerID];
  };

  _proto2._updateDirtyFlagForSceneGraph = function _updateDirtyFlagForSceneGraph() {
    var locDirtyListeners = this._dirtyListeners;

    for (var selKey in locDirtyListeners) {
      this._setDirty(selKey, DIRTY_SCENE_GRAPH_PRIORITY);

      locDirtyListeners[selKey] = false;
    }
  };

  _proto2._removeAllListenersInVector = function _removeAllListenersInVector(listenerVector) {
    if (!listenerVector) {
      return;
    }

    var selListener;

    for (var i = listenerVector.length - 1; i >= 0; i--) {
      selListener = listenerVector[i];

      selListener._setRegistered(false);

      if (selListener._getSceneGraphPriority() != null) {
        this._dissociateNodeAndEventListener(selListener._getSceneGraphPriority(), selListener);

        selListener._setSceneGraphPriority(null);
      }

      if (this._inDispatch === 0) {
        legacyCC.js.array.removeAt(listenerVector, i);
      }
    }
  };

  _proto2._removeListenersForListenerID = function _removeListenersForListenerID(listenerID) {
    var listeners = this._listenersMap[listenerID];

    if (listeners) {
      var fixedPriorityListeners = listeners.getFixedPriorityListeners();
      var sceneGraphPriorityListeners = listeners.getSceneGraphPriorityListeners();

      this._removeAllListenersInVector(sceneGraphPriorityListeners);

      this._removeAllListenersInVector(fixedPriorityListeners);

      delete this._priorityDirtyFlagMap[listenerID];

      if (!this._inDispatch) {
        listeners.clear();
        delete this._listenersMap[listenerID];
      }
    }

    var locToAddedListeners = this._toAddedListeners;

    for (var i = locToAddedListeners.length - 1; i >= 0; i--) {
      var _listener4 = locToAddedListeners[i];

      if (_listener4 && _listener4._getListenerID() === listenerID) {
        legacyCC.js.array.removeAt(locToAddedListeners, i);
      }
    }
  };

  _proto2._sortEventListeners = function _sortEventListeners(listenerID) {
    var dirtyFlag = DIRTY_NONE;
    var locFlagMap = this._priorityDirtyFlagMap;

    if (locFlagMap[listenerID]) {
      dirtyFlag = locFlagMap[listenerID];
    }

    if (dirtyFlag !== DIRTY_NONE) {
      locFlagMap[listenerID] = DIRTY_NONE;

      if (dirtyFlag & DIRTY_FIXED_PRIORITY) {
        this._sortListenersOfFixedPriority(listenerID);
      }

      if (dirtyFlag & DIRTY_SCENE_GRAPH_PRIORITY) {
        var rootEntity = legacyCC.director.getScene();

        if (rootEntity) {
          this._sortListenersOfSceneGraphPriority(listenerID);
        }
      }
    }
  };

  _proto2._sortListenersOfSceneGraphPriority = function _sortListenersOfSceneGraphPriority(listenerID) {
    var listeners = this._getListeners(listenerID);

    if (!listeners) {
      return;
    }

    var sceneGraphListener = listeners.getSceneGraphPriorityListeners();

    if (!sceneGraphListener || sceneGraphListener.length === 0) {
      return;
    }

    var eventListeners = listeners.getSceneGraphPriorityListeners();
    eventListeners.forEach(function (listener) {
      var node = listener._getSceneGraphPriority();

      var trans = node._uiProps.uiTransformComp;
      listener._cameraPriority = trans.cameraPriority;
    });
    eventListeners.sort(this._sortEventListenersOfSceneGraphPriorityDes);
  };

  _proto2._sortEventListenersOfSceneGraphPriorityDes = function _sortEventListenersOfSceneGraphPriorityDes(l1, l2) {
    var node1 = l1._getSceneGraphPriority();

    var node2 = l2._getSceneGraphPriority();

    if (!l2 || !node2 || !node2._activeInHierarchy || !node2._uiProps.uiTransformComp) {
      return -1;
    } else if (!l1 || !node1 || !node1._activeInHierarchy || !node1._uiProps.uiTransformComp) {
      return 1;
    }

    var p1 = node1;
    var p2 = node2;
    var ex = false;

    if (l1._cameraPriority !== l2._cameraPriority) {
      return l2._cameraPriority - l1._cameraPriority;
    }

    while (p1.parent._id !== p2.parent._id) {
      p1 = p1.parent.parent === null ? (ex = true) && node2 : p1.parent;
      p2 = p2.parent.parent === null ? (ex = true) && node1 : p2.parent;
    }

    if (p1._id === p2._id) {
      if (p1._id === node2._id) {
        return -1;
      }

      if (p1._id === node1._id) {
        return 1;
      }
    }

    var priority1 = p1.getSiblingIndex();
    var priority2 = p2.getSiblingIndex();
    return ex ? priority1 - priority2 : priority2 - priority1;
  };

  _proto2._sortListenersOfFixedPriority = function _sortListenersOfFixedPriority(listenerID) {
    var listeners = this._listenersMap[listenerID];

    if (!listeners) {
      return;
    }

    var fixedListeners = listeners.getFixedPriorityListeners();

    if (!fixedListeners || fixedListeners.length === 0) {
      return;
    }

    fixedListeners.sort(this._sortListenersOfFixedPriorityAsc);
    var index = 0;

    for (var len = fixedListeners.length; index < len;) {
      if (fixedListeners[index]._getFixedPriority() >= 0) {
        break;
      }

      ++index;
    }

    listeners.gt0Index = index;
  };

  _proto2._sortListenersOfFixedPriorityAsc = function _sortListenersOfFixedPriorityAsc(l1, l2) {
    return l1._getFixedPriority() - l2._getFixedPriority();
  };

  _proto2._onUpdateListeners = function _onUpdateListeners(listeners) {
    var fixedPriorityListeners = listeners.getFixedPriorityListeners();
    var sceneGraphPriorityListeners = listeners.getSceneGraphPriorityListeners();
    var toRemovedListeners = this._toRemovedListeners;

    if (sceneGraphPriorityListeners) {
      for (var i = sceneGraphPriorityListeners.length - 1; i >= 0; i--) {
        var selListener = sceneGraphPriorityListeners[i];

        if (!selListener._isRegistered()) {
          legacyCC.js.array.removeAt(sceneGraphPriorityListeners, i);
          var idx = toRemovedListeners.indexOf(selListener);

          if (idx !== -1) {
            toRemovedListeners.splice(idx, 1);
          }
        }
      }
    }

    if (fixedPriorityListeners) {
      for (var _i5 = fixedPriorityListeners.length - 1; _i5 >= 0; _i5--) {
        var _selListener = fixedPriorityListeners[_i5];

        if (!_selListener._isRegistered()) {
          legacyCC.js.array.removeAt(fixedPriorityListeners, _i5);

          var _idx = toRemovedListeners.indexOf(_selListener);

          if (_idx !== -1) {
            toRemovedListeners.splice(_idx, 1);
          }
        }
      }
    }

    if (sceneGraphPriorityListeners && sceneGraphPriorityListeners.length === 0) {
      listeners.clearSceneGraphListeners();
    }

    if (fixedPriorityListeners && fixedPriorityListeners.length === 0) {
      listeners.clearFixedListeners();
    }
  };

  _proto2._updateTouchListeners = function _updateTouchListeners(event) {
    var locInDispatch = this._inDispatch;
    assertID(locInDispatch > 0, 3508);

    if (locInDispatch > 1) {
      return;
    }

    var listeners;
    listeners = this._listenersMap[ListenerID$1.TOUCH_ONE_BY_ONE];

    if (listeners) {
      this._onUpdateListeners(listeners);
    }

    listeners = this._listenersMap[ListenerID$1.TOUCH_ALL_AT_ONCE];

    if (listeners) {
      this._onUpdateListeners(listeners);
    }

    assertID(locInDispatch === 1, 3509);
    var locToAddedListeners = this._toAddedListeners;

    if (locToAddedListeners.length !== 0) {
      for (var i = 0, len = locToAddedListeners.length; i < len; i++) {
        this._forceAddEventListener(locToAddedListeners[i]);
      }

      this._toAddedListeners.length = 0;
    }

    if (this._toRemovedListeners.length !== 0) {
      this._cleanToRemovedListeners();
    }
  };

  _proto2._cleanToRemovedListeners = function _cleanToRemovedListeners() {
    var toRemovedListeners = this._toRemovedListeners;

    for (var i = 0; i < toRemovedListeners.length; ++i) {
      var selListener = toRemovedListeners[i];

      var listeners = this._listenersMap[selListener._getListenerID()];

      if (!listeners) {
        continue;
      }

      var fixedPriorityListeners = listeners.getFixedPriorityListeners();
      var sceneGraphPriorityListeners = listeners.getSceneGraphPriorityListeners();

      if (sceneGraphPriorityListeners) {
        var idx = sceneGraphPriorityListeners.indexOf(selListener);

        if (idx !== -1) {
          sceneGraphPriorityListeners.splice(idx, 1);
        }
      }

      if (fixedPriorityListeners) {
        var _idx2 = fixedPriorityListeners.indexOf(selListener);

        if (_idx2 !== -1) {
          fixedPriorityListeners.splice(_idx2, 1);
        }
      }
    }

    toRemovedListeners.length = 0;
  };

  _proto2._onTouchEventCallback = function _onTouchEventCallback(listener, argsObj) {
    if (!listener._isRegistered()) {
      return false;
    }

    var event = argsObj.event;
    var selTouch = event.touch;
    event.currentTarget = listener._getSceneGraphPriority();
    var isClaimed = false;
    var removedIdx = -1;
    var eventType = event.type;

    if (eventType === exports.SystemEventType.TOUCH_START) {
      if (!macro.ENABLE_MULTI_TOUCH && eventManager._currentTouch) {
        var node = eventManager._currentTouchListener._node;

        if (!node || node.activeInHierarchy) {
          return false;
        }
      }

      if (listener.onTouchBegan) {
        isClaimed = listener.onTouchBegan(selTouch, event);

        if (isClaimed && listener._isRegistered() && !listener._isPaused()) {
          listener._claimedTouches.push(selTouch);

          if (macro.ENABLE_MULTI_TOUCH || !eventManager._currentTouch) {
            eventManager._currentTouch = selTouch;
          }

          eventManager._currentTouchListener = listener;
        }
      }
    } else if (listener._claimedTouches.length > 0) {
      removedIdx = listener._claimedTouches.indexOf(selTouch);

      if (removedIdx !== -1) {
        isClaimed = true;

        if (!macro.ENABLE_MULTI_TOUCH && eventManager._currentTouch && eventManager._currentTouch !== selTouch) {
          return false;
        }

        if (eventType === exports.SystemEventType.TOUCH_MOVE && listener.onTouchMoved) {
          listener.onTouchMoved(selTouch, event);
        } else if (eventType === exports.SystemEventType.TOUCH_END) {
          if (listener.onTouchEnded) {
            listener.onTouchEnded(selTouch, event);
          }

          if (listener._isRegistered()) {
            listener._claimedTouches.splice(removedIdx, 1);
          }

          if (macro.ENABLE_MULTI_TOUCH || eventManager._currentTouch === selTouch) {
            eventManager._currentTouch = null;
          }

          eventManager._currentTouchListener = null;
        } else if (eventType === exports.SystemEventType.TOUCH_CANCEL) {
          if (listener.onTouchCancelled) {
            listener.onTouchCancelled(selTouch, event);
          }

          if (listener._isRegistered()) {
            listener._claimedTouches.splice(removedIdx, 1);
          }

          if (macro.ENABLE_MULTI_TOUCH || eventManager._currentTouch === selTouch) {
            eventManager._currentTouch = null;
          }

          eventManager._currentTouchListener = null;
        }
      }
    }

    if (event.isStopped()) {
      eventManager._updateTouchListeners(event);

      return true;
    }

    if (isClaimed && listener._isRegistered() && listener.swallowTouches) {
      if (argsObj.needsMutableSet) {
        argsObj.touches.splice(selTouch, 1);
      }

      return true;
    }

    return false;
  };

  _proto2._dispatchTouchEvent = function _dispatchTouchEvent(event) {
    this._sortEventListeners(ListenerID$1.TOUCH_ONE_BY_ONE);

    this._sortEventListeners(ListenerID$1.TOUCH_ALL_AT_ONCE);

    var oneByOneListeners = this._getListeners(ListenerID$1.TOUCH_ONE_BY_ONE);

    var allAtOnceListeners = this._getListeners(ListenerID$1.TOUCH_ALL_AT_ONCE);

    if (oneByOneListeners === null && allAtOnceListeners === null) {
      return;
    }

    var originalTouches = event.getTouches();
    var mutableTouches = legacyCC.js.array.copy(originalTouches);
    var oneByOneArgsObj = {
      event: event,
      needsMutableSet: oneByOneListeners && allAtOnceListeners,
      touches: mutableTouches,
      selTouch: null
    };

    if (oneByOneListeners) {
      for (var i = 0; i < originalTouches.length; ++i) {
        var originalTouch = originalTouches[i];
        event.touch = originalTouch;
        event.propagationStopped = event.propagationImmediateStopped = false;

        this._dispatchEventToListeners(oneByOneListeners, this._onTouchEventCallback, oneByOneArgsObj);
      }
    }

    if (allAtOnceListeners && mutableTouches.length > 0) {
      this._dispatchEventToListeners(allAtOnceListeners, this._onTouchesEventCallback, {
        event: event,
        touches: mutableTouches
      });

      if (event.isStopped()) {
        return;
      }
    }

    this._updateTouchListeners(event);
  };

  _proto2._onTouchesEventCallback = function _onTouchesEventCallback(listener, callbackParams) {
    if (!listener._isRegistered()) {
      return false;
    }

    var event = callbackParams.event;
    var touches = callbackParams.touches;
    var eventType = event.type;
    event.currentTarget = listener._getSceneGraphPriority();

    if (eventType === exports.SystemEventType.TOUCH_START && listener.onTouchesBegan) {
      listener.onTouchesBegan(touches, event);
    } else if (eventType === exports.SystemEventType.TOUCH_MOVE && listener.onTouchesMoved) {
      listener.onTouchesMoved(touches, event);
    } else if (eventType === exports.SystemEventType.TOUCH_END && listener.onTouchesEnded) {
      listener.onTouchesEnded(touches, event);
    } else if (eventType === exports.SystemEventType.TOUCH_CANCEL && listener.onTouchesCancelled) {
      listener.onTouchesCancelled(touches, event);
    }

    if (event.isStopped()) {
      eventManager._updateTouchListeners(event);

      return true;
    }

    return false;
  };

  _proto2._associateNodeAndEventListener = function _associateNodeAndEventListener(node, listener) {
    var listeners = this._nodeListenersMap[node.uuid];

    if (!listeners) {
      listeners = [];
      this._nodeListenersMap[node.uuid] = listeners;
    }

    listeners.push(listener);
  };

  _proto2._dissociateNodeAndEventListener = function _dissociateNodeAndEventListener(node, listener) {
    var listeners = this._nodeListenersMap[node.uuid];

    if (listeners) {
      legacyCC.js.array.remove(listeners, listener);

      if (listeners.length === 0) {
        delete this._nodeListenersMap[node.uuid];
      }
    }
  };

  _proto2._dispatchEventToListeners = function _dispatchEventToListeners(listeners, onEvent, eventOrArgs) {
    var shouldStopPropagation = false;
    var fixedPriorityListeners = listeners.getFixedPriorityListeners();
    var sceneGraphPriorityListeners = listeners.getSceneGraphPriorityListeners();
    var i = 0;

    if (fixedPriorityListeners) {
      if (fixedPriorityListeners.length !== 0) {
        for (; i < listeners.gt0Index; ++i) {
          var selListener = fixedPriorityListeners[i];

          if (selListener.isEnabled() && !selListener._isPaused() && selListener._isRegistered() && onEvent(selListener, eventOrArgs)) {
            shouldStopPropagation = true;
            break;
          }
        }
      }
    }

    if (sceneGraphPriorityListeners && !shouldStopPropagation) {
      for (var _i6 = 0; _i6 < sceneGraphPriorityListeners.length; ++_i6) {
        var _selListener2 = sceneGraphPriorityListeners[_i6];

        if (_selListener2.isEnabled() && !_selListener2._isPaused() && _selListener2._isRegistered() && onEvent(_selListener2, eventOrArgs)) {
          shouldStopPropagation = true;
          break;
        }
      }
    }

    if (fixedPriorityListeners && !shouldStopPropagation) {
      for (; i < fixedPriorityListeners.length; ++i) {
        var _selListener3 = fixedPriorityListeners[i];

        if (_selListener3.isEnabled() && !_selListener3._isPaused() && _selListener3._isRegistered() && onEvent(_selListener3, eventOrArgs)) {
          shouldStopPropagation = true;
          break;
        }
      }
    }
  };

  _proto2._setDirty = function _setDirty(listenerID, flag) {
    var locDirtyFlagMap = this._priorityDirtyFlagMap;

    if (locDirtyFlagMap[listenerID] == null) {
      locDirtyFlagMap[listenerID] = flag;
    } else {
      locDirtyFlagMap[listenerID] |= flag;
    }
  };

  _proto2._sortNumberAsc = function _sortNumberAsc(a, b) {
    return a - b;
  };

  _proto2._clearCurTouch = function _clearCurTouch() {
    this._currentTouchListener = null;
    this._currentTouch = null;
  };

  _proto2._removeListenerInCallback = function _removeListenerInCallback(listeners, callback) {
    if (listeners == null) {
      return false;
    }

    for (var i = listeners.length - 1; i >= 0; i--) {
      var selListener = listeners[i];

      if (selListener._onCustomEvent === callback || selListener.onEvent === callback) {
        selListener._setRegistered(false);

        if (selListener._getSceneGraphPriority() != null) {
          this._dissociateNodeAndEventListener(selListener._getSceneGraphPriority(), selListener);

          selListener._setSceneGraphPriority(null);
        }

        if (this._inDispatch === 0) {
          legacyCC.js.array.removeAt(listeners, i);
        } else {
          this._toRemovedListeners.push(selListener);
        }

        return true;
      }
    }

    return false;
  };

  _proto2._removeListenerInVector = function _removeListenerInVector(listeners, listener) {
    if (listeners == null) {
      return false;
    }

    for (var i = listeners.length - 1; i >= 0; i--) {
      var selListener = listeners[i];

      if (selListener === listener) {
        selListener._setRegistered(false);

        if (selListener._getSceneGraphPriority() != null) {
          this._dissociateNodeAndEventListener(selListener._getSceneGraphPriority(), selListener);

          selListener._setSceneGraphPriority(null);
        }

        if (this._inDispatch === 0) {
          legacyCC.js.array.removeAt(listeners, i);
        } else {
          this._toRemovedListeners.push(selListener);
        }

        return true;
      }
    }

    return false;
  };

  return EventManager;
}();

var eventManager = new EventManager();

var Destroying$1 = CCObject.Flags.Destroying;

(function (NodeEventType) {
  NodeEventType["TOUCH_START"] = "touch-start";
  NodeEventType["TOUCH_MOVE"] = "touch-move";
  NodeEventType["TOUCH_END"] = "touch-end";
  NodeEventType["TOUCH_CANCEL"] = "touch-cancel";
  NodeEventType["MOUSE_DOWN"] = "mouse-down";
  NodeEventType["MOUSE_MOVE"] = "mouse-move";
  NodeEventType["MOUSE_UP"] = "mouse-up";
  NodeEventType["MOUSE_WHEEL"] = "mouse-wheel";
  NodeEventType["MOUSE_ENTER"] = "mouse-enter";
  NodeEventType["MOUSE_LEAVE"] = "mouse-leave";
  NodeEventType["KEY_DOWN"] = "keydown";
  NodeEventType["KEY_UP"] = "keyup";
  NodeEventType["DEVICEMOTION"] = "devicemotion";
  NodeEventType["TRANSFORM_CHANGED"] = "transform-changed";
  NodeEventType["SCENE_CHANGED_FOR_PERSISTS"] = "scene-changed-for-persists";
  NodeEventType["SIZE_CHANGED"] = "size-changed";
  NodeEventType["ANCHOR_CHANGED"] = "anchor-changed";
  NodeEventType["COLOR_CHANGED"] = "color-changed";
  NodeEventType["CHILD_ADDED"] = "child-added";
  NodeEventType["CHILD_REMOVED"] = "child-removed";
  NodeEventType["PARENT_CHANGED"] = "parent-changed";
  NodeEventType["NODE_DESTROYED"] = "node-destroyed";
  NodeEventType["LAYER_CHANGED"] = "layer-changed";
  NodeEventType["SIBLING_ORDER_CHANGED"] = "sibling-order-changed";
})(exports.NodeEventType || (exports.NodeEventType = {}));

var _dec$j, _class$j, _class2$g, _descriptor$e, _descriptor2$a, _descriptor3$7, _descriptor4$6, _descriptor5$3, _class3$8, _temp$g;
var Destroying$2 = CCObject.Flags.Destroying;
var DontDestroy$1 = CCObject.Flags.DontDestroy;
var Deactivating$1 = CCObject.Flags.Deactivating;
var TRANSFORM_ON = 1 << 0;
var idGenerator$2 = new IDGenerator('Node');

function getConstructor(typeOrClassName) {
  if (!typeOrClassName) {
    errorID(3804);
    return null;
  }

  if (typeof typeOrClassName === 'string') {
    return getClassByName(typeOrClassName);
  }

  return typeOrClassName;
}

var BaseNode = (_dec$j = ccclass('cc.BaseNode'), _dec$j(_class$j = (_class2$g = (_temp$g = _class3$8 = function (_CCObject) {
  _inheritsLoose(BaseNode, _CCObject);

  BaseNode._setScene = function _setScene(node) {
    node._updateScene();
  };

  BaseNode._findComponent = function _findComponent(node, constructor) {
    var cls = constructor;
    var comps = node._components;

    if (cls._sealed) {
      for (var i = 0; i < comps.length; ++i) {
        var comp = comps[i];

        if (comp.constructor === constructor) {
          return comp;
        }
      }
    } else {
      for (var _i = 0; _i < comps.length; ++_i) {
        var _comp = comps[_i];

        if (_comp instanceof constructor) {
          return _comp;
        }
      }
    }

    return null;
  };

  BaseNode._findComponents = function _findComponents(node, constructor, components) {
    var cls = constructor;
    var comps = node._components;

    if (cls._sealed) {
      for (var i = 0; i < comps.length; ++i) {
        var comp = comps[i];

        if (comp.constructor === constructor) {
          components.push(comp);
        }
      }
    } else {
      for (var _i2 = 0; _i2 < comps.length; ++_i2) {
        var _comp2 = comps[_i2];

        if (_comp2 instanceof constructor) {
          components.push(_comp2);
        }
      }
    }
  };

  BaseNode._findChildComponent = function _findChildComponent(children, constructor) {
    for (var i = 0; i < children.length; ++i) {
      var node = children[i];

      var comp = BaseNode._findComponent(node, constructor);

      if (comp) {
        return comp;
      }

      if (node._children.length > 0) {
        comp = BaseNode._findChildComponent(node._children, constructor);

        if (comp) {
          return comp;
        }
      }
    }

    return null;
  };

  BaseNode._findChildComponents = function _findChildComponents(children, constructor, components) {
    for (var i = 0; i < children.length; ++i) {
      var node = children[i];

      BaseNode._findComponents(node, constructor, components);

      if (node._children.length > 0) {
        BaseNode._findChildComponents(node._children, constructor, components);
      }
    }
  };

  var _proto = BaseNode.prototype;

  _proto._updateScene = function _updateScene() {
    if (this._parent == null) {
      error('Node %s(%s) has not attached to a scene.', this.name, this.uuid);
    } else {
      this._scene = this._parent._scene;
    }
  };

  _createClass(BaseNode, [{
    key: "components",
    get: function get() {
      return this._components;
    }
  }, {
    key: "_persistNode",
    get: function get() {
      return (this._objFlags & DontDestroy$1) > 0;
    },
    set: function set(value) {
      if (value) {
        this._objFlags |= DontDestroy$1;
      } else {
        this._objFlags &= ~DontDestroy$1;
      }
    }
  }, {
    key: "name",
    get: function get() {
      return this._name;
    },
    set: function set(value) {

      this._name = value;
    }
  }, {
    key: "uuid",
    get: function get() {
      return this._id;
    }
  }, {
    key: "children",
    get: function get() {
      return this._children;
    }
  }, {
    key: "active",
    get: function get() {
      return this._active;
    },
    set: function set(isActive) {
      if (this._active !== isActive) {
        this._active = isActive;
        var parent = this._parent;

        if (parent) {
          var couldActiveInScene = parent._activeInHierarchy;

          if (couldActiveInScene) {
            legacyCC.director._nodeActivator.activateNode(this, isActive);
          }
        }
      }
    }
  }, {
    key: "activeInHierarchy",
    get: function get() {
      return this._activeInHierarchy;
    }
  }, {
    key: "parent",
    get: function get() {
      return this._parent;
    },
    set: function set(value) {
      this.setParent(value);
    }
  }, {
    key: "scene",
    get: function get() {
      return this._scene;
    }
  }, {
    key: "eventProcessor",
    get: function get() {
      return this._eventProcessor;
    }
  }]);

  function BaseNode(name) {
    var _this;

    _this = _CCObject.call(this, name) || this;

    _initializerDefineProperty(_this, "_parent", _descriptor$e, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_children", _descriptor2$a, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_active", _descriptor3$7, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_components", _descriptor4$6, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_prefab", _descriptor5$3, _assertThisInitialized(_this));

    _this._scene = null;
    _this._activeInHierarchy = false;
    _this._id = idGenerator$2.getNewId();
    _this._name = void 0;
    _this._eventProcessor = new legacyCC.NodeEventProcessor(_assertThisInitialized(_this));
    _this._eventMask = 0;
    _this._siblingIndex = 0;
    _this._originalSceneId = '';
    _this._registerIfAttached =  undefined ;
    _this._name = name !== undefined ? name : 'New Node';
    return _this;
  }

  _proto.attr = function attr(attrs) {
    mixin(this, attrs);
  };

  _proto.getParent = function getParent() {
    return this._parent;
  };

  _proto.setParent = function setParent(value, keepWorldTransform) {
    if (keepWorldTransform === void 0) {
      keepWorldTransform = false;
    }

    if (this._parent === value) {
      return;
    }

    var oldParent = this._parent;
    var newParent = value;

    this._parent = newParent;
    this._siblingIndex = 0;

    this._onSetParent(oldParent, keepWorldTransform);

    if (this.emit) {
      this.emit(exports.NodeEventType.PARENT_CHANGED, oldParent);
    }

    if (oldParent) {
      if (!(oldParent._objFlags & Destroying$2)) {
        var removeAt = oldParent._children.indexOf(this);

        oldParent._children.splice(removeAt, 1);

        oldParent._updateSiblingIndex();

        if (oldParent.emit) {
          oldParent.emit(exports.NodeEventType.CHILD_REMOVED, this);
        }
      }
    }

    if (newParent) {

      newParent._children.push(this);

      this._siblingIndex = newParent._children.length - 1;

      if (newParent.emit) {
        newParent.emit(exports.NodeEventType.CHILD_ADDED, this);
      }
    }

    this._onHierarchyChanged(oldParent);
  };

  _proto.getChildByUuid = function getChildByUuid(uuid) {
    if (!uuid) {
      log('Invalid uuid');
      return null;
    }

    var locChildren = this._children;

    for (var i = 0, len = locChildren.length; i < len; i++) {
      if (locChildren[i]._id === uuid) {
        return locChildren[i];
      }
    }

    return null;
  };

  _proto.getChildByName = function getChildByName(name) {
    if (!name) {
      log('Invalid name');
      return null;
    }

    var locChildren = this._children;

    for (var i = 0, len = locChildren.length; i < len; i++) {
      if (locChildren[i]._name === name) {
        return locChildren[i];
      }
    }

    return null;
  };

  _proto.getChildByPath = function getChildByPath(path) {
    var segments = path.split('/');
    var lastNode = this;

    var _loop = function _loop(i) {
      var segment = segments[i];

      if (segment.length === 0) {
        return "continue";
      }

      var next = lastNode.children.find(function (childNode) {
        return childNode.name === segment;
      });

      if (!next) {
        return {
          v: null
        };
      }

      lastNode = next;
    };

    for (var i = 0; i < segments.length; ++i) {
      var _ret = _loop(i);

      switch (_ret) {
        case "continue":
          continue;

        default:
          if (typeof _ret === "object") return _ret.v;
      }
    }

    return lastNode;
  };

  _proto.addChild = function addChild(child) {
    child.setParent(this);
  };

  _proto.insertChild = function insertChild(child, siblingIndex) {
    child.parent = this;
    child.setSiblingIndex(siblingIndex);
  };

  _proto.getSiblingIndex = function getSiblingIndex() {
    return this._siblingIndex;
  };

  _proto.setSiblingIndex = function setSiblingIndex(index) {
    if (!this._parent) {
      return;
    }

    if (this._parent._objFlags & Deactivating$1) {
      errorID(3821);
      return;
    }

    var siblings = this._parent._children;
    index = index !== -1 ? index : siblings.length - 1;
    var oldIndex = siblings.indexOf(this);

    if (index !== oldIndex) {
      siblings.splice(oldIndex, 1);

      if (index < siblings.length) {
        siblings.splice(index, 0, this);
      } else {
        siblings.push(this);
      }

      this._parent._updateSiblingIndex();

      if (this._onSiblingIndexChanged) {
        this._onSiblingIndexChanged(index);
      }
    }
  };

  _proto.walk = function walk(preFunc, postFunc) {
    var index = 1;
    var children = null;
    var curr = null;
    var i = 0;
    var stack = BaseNode._stacks[BaseNode._stackId];

    if (!stack) {
      stack = [];

      BaseNode._stacks.push(stack);
    }

    BaseNode._stackId++;
    stack.length = 0;
    stack[0] = this;
    var parent = null;
    var afterChildren = false;

    while (index) {
      index--;
      curr = stack[index];

      if (!curr) {
        continue;
      }

      if (!afterChildren && preFunc) {
        preFunc(curr);
      } else if (afterChildren && postFunc) {
        postFunc(curr);
      }

      stack[index] = null;

      if (afterChildren) {
        if (parent === this._parent) break;
        afterChildren = false;
      } else {
        if (curr._children.length > 0) {
          parent = curr;
          children = curr._children;
          i = 0;
          stack[index] = children[i];
          index++;
        } else {
          stack[index] = curr;
          index++;
          afterChildren = true;
        }

        continue;
      }

      if (children) {
        i++;

        if (children[i]) {
          stack[index] = children[i];
          index++;
        } else if (parent) {
          stack[index] = parent;
          index++;
          afterChildren = true;

          if (parent._parent) {
            children = parent._parent._children;
            i = children.indexOf(parent);
            parent = parent._parent;
          } else {
            parent = null;
            children = null;
          }

          if (i < 0) {
            break;
          }
        }
      }
    }

    stack.length = 0;
    BaseNode._stackId--;
  };

  _proto.removeFromParent = function removeFromParent() {
    if (this._parent) {
      this._parent.removeChild(this);
    }
  };

  _proto.removeChild = function removeChild(child) {
    if (this._children.indexOf(child) > -1) {
      child.parent = null;
    }
  };

  _proto.removeAllChildren = function removeAllChildren() {
    var children = this._children;

    for (var i = children.length - 1; i >= 0; i--) {
      var node = children[i];

      if (node) {
        node.parent = null;
      }
    }

    this._children.length = 0;
  };

  _proto.isChildOf = function isChildOf(parent) {
    var child = this;

    do {
      if (child === parent) {
        return true;
      }

      child = child._parent;
    } while (child);

    return false;
  };

  _proto.getComponent = function getComponent(typeOrClassName) {
    var constructor = getConstructor(typeOrClassName);

    if (constructor) {
      return BaseNode._findComponent(this, constructor);
    }

    return null;
  };

  _proto.getComponents = function getComponents(typeOrClassName) {
    var constructor = getConstructor(typeOrClassName);
    var components = [];

    if (constructor) {
      BaseNode._findComponents(this, constructor, components);
    }

    return components;
  };

  _proto.getComponentInChildren = function getComponentInChildren(typeOrClassName) {
    var constructor = getConstructor(typeOrClassName);

    if (constructor) {
      return BaseNode._findChildComponent(this._children, constructor);
    }

    return null;
  };

  _proto.getComponentsInChildren = function getComponentsInChildren(typeOrClassName) {
    var constructor = getConstructor(typeOrClassName);
    var components = [];

    if (constructor) {
      BaseNode._findComponents(this, constructor, components);

      BaseNode._findChildComponents(this._children, constructor, components);
    }

    return components;
  };

  _proto.addComponent = function addComponent(typeOrClassName) {

    var constructor;

    if (typeof typeOrClassName === 'string') {
      constructor = getClassByName(typeOrClassName);

      if (!constructor) {
        if (legacyCC._RF.peek()) {
          errorID(3808, typeOrClassName);
        }

        throw TypeError(getError(3807, typeOrClassName));
      }
    } else {
      if (!typeOrClassName) {
        throw TypeError(getError(3804));
      }

      constructor = typeOrClassName;
    }

    if (typeof constructor !== 'function') {
      throw TypeError(getError(3809));
    }

    if (!isChildClassOf(constructor, legacyCC.Component)) {
      throw TypeError(getError(3810));
    }

    var ReqComp = constructor._requireComponent;

    if (ReqComp && !this.getComponent(ReqComp)) {
      this.addComponent(ReqComp);
    }

    var component = new constructor();
    component.node = this;

    this._components.push(component);

    if (this._activeInHierarchy) {
      legacyCC.director._nodeActivator.activateComp(component);
    }

    return component;
  };

  _proto.removeComponent = function removeComponent(component) {
    if (!component) {
      errorID(3813);
      return;
    }

    var componentInstance = null;

    if (component instanceof Component) {
      componentInstance = component;
    } else {
      componentInstance = this.getComponent(component);
    }

    if (componentInstance) {
      componentInstance.destroy();
    }
  };

  _proto.on = function on(type, callback, target, useCapture) {
    if (useCapture === void 0) {
      useCapture = false;
    }

    switch (type) {
      case exports.NodeEventType.TRANSFORM_CHANGED:
        this._eventMask |= TRANSFORM_ON;
        break;
    }

    this._eventProcessor.on(type, callback, target, useCapture);
  };

  _proto.off = function off(type, callback, target, useCapture) {
    if (useCapture === void 0) {
      useCapture = false;
    }

    this._eventProcessor.off(type, callback, target, useCapture);

    var hasListeners = this._eventProcessor.hasEventListener(type);

    if (!hasListeners) {
      switch (type) {
        case exports.NodeEventType.TRANSFORM_CHANGED:
          this._eventMask &= ~TRANSFORM_ON;
          break;
      }
    }
  };

  _proto.once = function once(type, callback, target, useCapture) {
    this._eventProcessor.once(type, callback, target, useCapture);
  };

  _proto.emit = function emit(type, arg0, arg1, arg2, arg3, arg4) {
    this._eventProcessor.emit(type, arg0, arg1, arg2, arg3, arg4);
  };

  _proto.dispatchEvent = function dispatchEvent(event) {
    this._eventProcessor.dispatchEvent(event);
  };

  _proto.hasEventListener = function hasEventListener(type, callback, target) {
    return this._eventProcessor.hasEventListener(type, callback, target);
  };

  _proto.targetOff = function targetOff(target) {
    this._eventProcessor.targetOff(target);

    if (this._eventMask & TRANSFORM_ON && !this._eventProcessor.hasEventListener(exports.NodeEventType.TRANSFORM_CHANGED)) {
      this._eventMask &= ~TRANSFORM_ON;
    }
  };

  _proto.destroy = function destroy() {
    if (_CCObject.prototype.destroy.call(this)) {
      this.active = false;
      return true;
    }

    return false;
  };

  _proto.destroyAllChildren = function destroyAllChildren() {
    var children = this._children;

    for (var i = 0; i < children.length; ++i) {
      children[i].destroy();
    }
  };

  _proto._removeComponent = function _removeComponent(component) {
    if (!component) {
      errorID(3814);
      return;
    }

    if (!(this._objFlags & Destroying$2)) {
      var i = this._components.indexOf(component);

      if (i !== -1) {
        this._components.splice(i, 1);
      } else if (component.node !== this) {
        errorID(3815);
      }
    }
  };

  _proto._updateSiblingIndex = function _updateSiblingIndex() {
    for (var i = 0; i < this._children.length; ++i) {
      this._children[i]._siblingIndex = i;
    }

    this.emit(exports.NodeEventType.SIBLING_ORDER_CHANGED);
  };

  _proto._onSetParent = function _onSetParent(oldParent, keepWorldTransform) {

    if (this._parent) {
      if ((oldParent == null || oldParent._scene !== this._parent._scene) && this._parent._scene != null) {
        this.walk(BaseNode._setScene);
      }
    }
  };

  _proto._onPostActivated = function _onPostActivated(active) {};

  _proto._onBatchCreated = function _onBatchCreated(dontSyncChildPrefab) {
    if (this._parent) {
      this._siblingIndex = this._parent.children.indexOf(this);
    }
  };

  _proto._onPreDestroy = function _onPreDestroy() {
    this._onPreDestroyBase();
  };

  _proto._onHierarchyChanged = function _onHierarchyChanged(oldParent) {
    return this._onHierarchyChangedBase(oldParent);
  };

  _proto._instantiate = function _instantiate(cloned, isSyncedNode) {
    if (!cloned) {
      cloned = legacyCC.instantiate._clone(this, this);
    }

    var newPrefabInfo = cloned._prefab;

    cloned._parent = null;

    cloned._onBatchCreated(isSyncedNode);

    return cloned;
  };

  _proto._onHierarchyChangedBase = function _onHierarchyChangedBase(oldParent) {
    var newParent = this._parent;

    if (this._persistNode && !(newParent instanceof legacyCC.Scene)) {
      legacyCC.game.removePersistRootNode(this);
    }

    var shouldActiveNow = this._active && !!(newParent && newParent._activeInHierarchy);

    if (this._activeInHierarchy !== shouldActiveNow) {
      legacyCC.director._nodeActivator.activateNode(this, shouldActiveNow);
    }
  };

  _proto._onPreDestroyBase = function _onPreDestroyBase() {
    this._objFlags |= Destroying$2;
    var parent = this._parent;
    var destroyByParent = !!parent && (parent._objFlags & Destroying$2) !== 0;

    if (!destroyByParent && EDITOR) {
      this._registerIfAttached(false);
    }

    if (this._persistNode) {
      legacyCC.game.removePersistRootNode(this);
    }

    if (!destroyByParent) {
      if (parent) {
        this.emit(exports.NodeEventType.PARENT_CHANGED, this);

        var childIndex = parent._children.indexOf(this);

        parent._children.splice(childIndex, 1);

        this._siblingIndex = 0;

        parent._updateSiblingIndex();

        if (parent.emit) {
          parent.emit(exports.NodeEventType.CHILD_REMOVED, this);
        }
      }
    }

    this.emit(exports.NodeEventType.NODE_DESTROYED, this);

    this._eventProcessor.destroy();

    var children = this._children;

    for (var i = 0; i < children.length; ++i) {
      children[i]._destroyImmediate();
    }

    var comps = this._components;

    for (var _i5 = 0; _i5 < comps.length; ++_i5) {
      comps[_i5]._destroyImmediate();
    }

    return destroyByParent;
  };

  return BaseNode;
}(CCObject), _class3$8.idGenerator = idGenerator$2, _class3$8._stacks = [[]], _class3$8._stackId = 0, _temp$g), (_applyDecoratedDescriptor(_class2$g.prototype, "_persistNode", [property], Object.getOwnPropertyDescriptor(_class2$g.prototype, "_persistNode"), _class2$g.prototype), _applyDecoratedDescriptor(_class2$g.prototype, "name", [editable], Object.getOwnPropertyDescriptor(_class2$g.prototype, "name"), _class2$g.prototype), _applyDecoratedDescriptor(_class2$g.prototype, "children", [editable], Object.getOwnPropertyDescriptor(_class2$g.prototype, "children"), _class2$g.prototype), _applyDecoratedDescriptor(_class2$g.prototype, "active", [editable], Object.getOwnPropertyDescriptor(_class2$g.prototype, "active"), _class2$g.prototype), _applyDecoratedDescriptor(_class2$g.prototype, "activeInHierarchy", [editable], Object.getOwnPropertyDescriptor(_class2$g.prototype, "activeInHierarchy"), _class2$g.prototype), _applyDecoratedDescriptor(_class2$g.prototype, "parent", [editable], Object.getOwnPropertyDescriptor(_class2$g.prototype, "parent"), _class2$g.prototype), _descriptor$e = _applyDecoratedDescriptor(_class2$g.prototype, "_parent", [serializable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return null;
  }
}), _descriptor2$a = _applyDecoratedDescriptor(_class2$g.prototype, "_children", [serializable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return [];
  }
}), _descriptor3$7 = _applyDecoratedDescriptor(_class2$g.prototype, "_active", [serializable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return true;
  }
}), _descriptor4$6 = _applyDecoratedDescriptor(_class2$g.prototype, "_components", [serializable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return [];
  }
}), _descriptor5$3 = _applyDecoratedDescriptor(_class2$g.prototype, "_prefab", [serializable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return null;
  }
})), _class2$g)) || _class$j);
legacyCC._BaseNode = BaseNode;

function createNodeWithPrefab(node) {
  var prefabInfo = node._prefab;

  if (!prefabInfo) {
    return;
  }

  var prefabInstance = prefabInfo.instance;

  if (!prefabInstance) {
    return;
  }

  if (!prefabInfo.asset) {
    {
      errorID(3701, node.name);
    }

    prefabInfo.instance = undefined;
    return;
  }

  var _objFlags = node._objFlags;
  var _parent = node._parent;
  var _id = node._id;
  var _prefab = node._prefab;
  var editorExtras = node[editorExtrasTag];
  legacyCC.game._isCloning = true;

  {
    prefabInfo.asset._doInstantiate(node);
  }

  legacyCC.game._isCloning = false;
  node._objFlags = _objFlags;
  node._parent = _parent;
  node._id = _id;

  if (node._prefab) {
    node._prefab.instance = _prefab === null || _prefab === void 0 ? void 0 : _prefab.instance;
  }
}
function generateTargetMap(node, targetMap, isRoot) {
  var _node$_prefab;

  if (!targetMap) {
    return;
  }

  var curTargetMap = targetMap;
  var prefabInstance = (_node$_prefab = node._prefab) === null || _node$_prefab === void 0 ? void 0 : _node$_prefab.instance;

  if (!isRoot && prefabInstance) {
    targetMap[prefabInstance.fileId] = {};
    curTargetMap = targetMap[prefabInstance.fileId];
  }

  var prefabInfo = node._prefab;

  if (prefabInfo) {
    curTargetMap[prefabInfo.fileId] = node;
  }

  var components = node.components;

  for (var i = 0; i < components.length; i++) {
    var comp = components[i];

    if (comp.__prefab) {
      curTargetMap[comp.__prefab.fileId] = comp;
    }
  }

  for (var _i = 0; _i < node.children.length; _i++) {
    var childNode = node.children[_i];
    generateTargetMap(childNode, curTargetMap, false);
  }
}
function getTarget(localID, targetMap) {
  if (!localID) {
    return null;
  }

  var target = null;
  var targetIter = targetMap;

  for (var i = 0; i < localID.length; i++) {
    if (!targetIter) {
      return null;
    }

    targetIter = targetIter[localID[i]];
  }

  target = targetIter;
  return target;
}
function applyMountedChildren(node, mountedChildren, targetMap) {
  if (!mountedChildren) {
    return;
  }

  for (var i = 0; i < mountedChildren.length; i++) {
    var childInfo = mountedChildren[i];

    if (childInfo && childInfo.targetInfo) {
      var target = getTarget(childInfo.targetInfo.localID, targetMap);

      if (!target) {
        continue;
      }

      var curTargetMap = targetMap;
      var localID = childInfo.targetInfo.localID;

      if (localID.length > 0) {
        for (var _i2 = 0; _i2 < localID.length - 1; _i2++) {
          curTargetMap = curTargetMap[localID[_i2]];
        }
      }

      if (childInfo.nodes) {
        for (var _i3 = 0; _i3 < childInfo.nodes.length; _i3++) {
          var childNode = childInfo.nodes[_i3];

          if (!childNode) {
            continue;
          }

          target._children.push(childNode);

          childNode._parent = target;

          generateTargetMap(childNode, curTargetMap, false);
          childNode._siblingIndex = target._children.length - 1;

          childNode._onBatchCreated(false);
        }
      }
    }
  }
}
function applyMountedComponents(node, mountedComponents, targetMap) {
  if (!mountedComponents) {
    return;
  }

  for (var i = 0; i < mountedComponents.length; i++) {
    var componentsInfo = mountedComponents[i];

    if (componentsInfo && componentsInfo.targetInfo) {
      var target = getTarget(componentsInfo.targetInfo.localID, targetMap);

      if (!target) {
        continue;
      }

      if (componentsInfo.components) {
        for (var _i4 = 0; _i4 < componentsInfo.components.length; _i4++) {
          var comp = componentsInfo.components[_i4];

          if (!comp) {
            continue;
          }

          comp.node = target;

          target._components.push(comp);
        }
      }
    }
  }
}
function applyRemovedComponents(node, removedComponents, targetMap) {
  if (!removedComponents) {
    return;
  }

  for (var i = 0; i < removedComponents.length; i++) {
    var targetInfo = removedComponents[i];

    if (targetInfo) {
      var target = getTarget(targetInfo.localID, targetMap);

      if (!target || !target.node) {
        continue;
      }

      var index = target.node.components.indexOf(target);

      if (index >= 0) {
        target.node._components.splice(index, 1);
      }
    }
  }
}
function applyPropertyOverrides(node, propertyOverrides, targetMap) {
  if (propertyOverrides.length <= 0) {
    return;
  }

  var target = null;

  for (var i = 0; i < propertyOverrides.length; i++) {
    var propOverride = propertyOverrides[i];

    if (propOverride && propOverride.targetInfo) {
      var targetInfo = propOverride.targetInfo;
      target = getTarget(targetInfo.localID, targetMap);

      if (!target) {
        continue;
      }

      var targetPropOwner = target;
      var propertyPath = propOverride.propertyPath.slice();

      if (propertyPath.length > 0) {
        var targetPropName = propertyPath.pop();

        if (!targetPropName) {
          continue;
        }

        for (var _i5 = 0; _i5 < propertyPath.length; _i5++) {
          var propName = propertyPath[_i5];
          targetPropOwner = targetPropOwner[propName];

          if (!targetPropOwner) {
            break;
          }
        }

        if (!targetPropOwner) {
          continue;
        }

        if (Array.isArray(targetPropOwner)) {
          if (targetPropName === 'length') {
            targetPropOwner[targetPropName] = propOverride.value;
          } else {
            var index = Number.parseInt(targetPropName);

            if (Number.isInteger(index) && index < targetPropOwner.length) {
              targetPropOwner[targetPropName] = propOverride.value;
            }
          }
        } else {
          targetPropOwner[targetPropName] = propOverride.value;
        }
      }
    }
  }
}
function applyTargetOverrides(node) {
  var _node$_prefab2;

  var targetOverrides = (_node$_prefab2 = node._prefab) === null || _node$_prefab2 === void 0 ? void 0 : _node$_prefab2.targetOverrides;

  if (targetOverrides) {
    for (var i = 0; i < targetOverrides.length; i++) {
      var _targetOverride$targe, _targetOverride$targe2;

      var targetOverride = targetOverrides[i];
      var source = targetOverride.source;
      var sourceInfo = targetOverride.sourceInfo;

      if (sourceInfo) {
        var _targetOverride$sourc, _targetOverride$sourc2;

        var sourceInstance = (_targetOverride$sourc = targetOverride.source) === null || _targetOverride$sourc === void 0 ? void 0 : (_targetOverride$sourc2 = _targetOverride$sourc._prefab) === null || _targetOverride$sourc2 === void 0 ? void 0 : _targetOverride$sourc2.instance;

        if (sourceInstance && sourceInstance.targetMap) {
          source = getTarget(sourceInfo.localID, sourceInstance.targetMap);
        }
      }

      if (!source) {
        continue;
      }

      var target = null;
      var targetInfo = targetOverride.targetInfo;

      if (!targetInfo) {
        continue;
      }

      var targetInstance = (_targetOverride$targe = targetOverride.target) === null || _targetOverride$targe === void 0 ? void 0 : (_targetOverride$targe2 = _targetOverride$targe._prefab) === null || _targetOverride$targe2 === void 0 ? void 0 : _targetOverride$targe2.instance;

      if (!targetInstance || !targetInstance.targetMap) {
        continue;
      }

      target = getTarget(targetInfo.localID, targetInstance.targetMap);

      if (!target) {
        continue;
      }

      var propertyPath = targetOverride.propertyPath.slice();
      var targetPropOwner = source;

      if (propertyPath.length > 0) {
        var targetPropName = propertyPath.pop();

        if (!targetPropName) {
          return;
        }

        for (var _i6 = 0; _i6 < propertyPath.length; _i6++) {
          var propName = propertyPath[_i6];
          targetPropOwner = targetPropOwner[propName];

          if (!targetPropOwner) {
            break;
          }
        }

        if (!targetPropOwner) {
          continue;
        }

        targetPropOwner[targetPropName] = target;
      }
    }
  }
}

var _dec$k, _dec2$8, _class$k, _class2$h, _descriptor$f, _descriptor2$b, _descriptor3$8, _descriptor4$7, _descriptor5$4, _class3$9, _temp$h;
var v3_a = new Vec3();
var q_a = new Quat();
var q_b = new Quat();
var qt_1$1 = new Quat();
var m3_1$2 = new Mat3();
var m3_scaling = new Mat3();
var m4_1 = new Mat4();
var dirtyNodes = [];
var nativeDirtyNodes = [];

var BookOfChange = function () {
  function BookOfChange() {
    this._chunks = [];
    this._freelists = [];

    this._createChunk();
  }

  var _proto = BookOfChange.prototype;

  _proto.alloc = function alloc() {
    var chunkCount = this._freelists.length;

    for (var i = 0; i < chunkCount; ++i) {
      if (!this._freelists[i].length) continue;
      return this._createView(i);
    }

    this._createChunk();

    return this._createView(chunkCount);
  };

  _proto.free = function free(view, idx) {
    var chunkCount = this._freelists.length;

    for (var i = 0; i < chunkCount; ++i) {
      if (this._chunks[i] !== view) continue;

      this._freelists[i].push(idx);

      return;
    }
  };

  _proto.clear = function clear() {
    var chunkCount = this._chunks.length;

    for (var i = 0; i < chunkCount; ++i) {
      this._chunks[i].fill(0);
    }
  };

  _proto._createChunk = function _createChunk() {
    this._chunks.push(new Uint32Array(BookOfChange.CAPACITY_PER_CHUNK));

    var freelist = [];

    for (var i = 0; i < BookOfChange.CAPACITY_PER_CHUNK; ++i) {
      freelist.push(i);
    }

    this._freelists.push(freelist);
  };

  _proto._createView = function _createView(chunkIdx) {
    var chunk = this._chunks[chunkIdx];

    var offset = this._freelists[chunkIdx].pop();

    return [chunk, offset];
  };

  return BookOfChange;
}();

BookOfChange.CAPACITY_PER_CHUNK = 256;
var bookOfChange = new BookOfChange();
var reserveContentsForAllSyncablePrefabTag = Symbol('ReserveContentsForAllSyncablePrefab');
var Node$1 = (_dec$k = ccclass('cc.Node'), _dec2$8 = type(Vec3), _dec$k(_class$k = (_class2$h = (_temp$h = _class3$9 = function (_BaseNode) {
  _inheritsLoose(Node, _BaseNode);

  var _proto2 = Node.prototype;

  _proto2._init = function _init() {
    var _bookOfChange$alloc = bookOfChange.alloc(),
        chunk = _bookOfChange$alloc[0],
        offset = _bookOfChange$alloc[1];

    this._hasChangedFlagsChunk = chunk;
    this._hasChangedFlagsOffset = offset;

    {
      this._pos = new Vec3();
      this._rot = new Quat();
      this._scale = new Vec3(1, 1, 1);
      this._mat = new Mat4();
    }
  };

  _createClass(Node, [{
    key: "_dirtyFlags",
    get: function get() {
      return this._dirtyFlagsPri;
    },
    set: function set(flags) {
      this._dirtyFlagsPri = flags;
    }
  }]);

  function Node(name) {
    var _this;

    _this = _BaseNode.call(this, name) || this;
    _this._uiProps = new NodeUIProperties(_assertThisInitialized(_this));
    _this._static = false;

    _initializerDefineProperty(_this, "_lpos", _descriptor$f, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_lrot", _descriptor2$b, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_lscale", _descriptor3$8, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_layer", _descriptor4$7, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_euler", _descriptor5$4, _assertThisInitialized(_this));

    _this._dirtyFlagsPri = exports.TransformBit.NONE;
    _this._eulerDirty = false;
    _this._nodeHandle = NULL_HANDLE;

    _this._init();

    return _this;
  }

  Node.isNode = function isNode(obj) {
    return obj instanceof Node && (obj.constructor === Node || !(obj instanceof legacyCC.Scene));
  };

  _proto2._onPreDestroy = function _onPreDestroy() {
    var result = this._onPreDestroyBase();

    bookOfChange.free(this._hasChangedFlagsChunk, this._hasChangedFlagsOffset);
    return result;
  };

  _proto2[serializeTag] = function (serializationOutput, context) {

    {
      serializationOutput.writeThis();
      return;
    }
  };

  _proto2.setParent = function setParent(value, keepWorldTransform) {
    if (keepWorldTransform === void 0) {
      keepWorldTransform = false;
    }

    if (keepWorldTransform) {
      this.updateWorldTransform();
    }

    _BaseNode.prototype.setParent.call(this, value, keepWorldTransform);
  };

  _proto2._onSetParent = function _onSetParent(oldParent, keepWorldTransform) {
    _BaseNode.prototype._onSetParent.call(this, oldParent, keepWorldTransform);

    if (keepWorldTransform) {
      var parent = this._parent;

      if (parent) {
        parent.updateWorldTransform();
        Mat4.multiply(m4_1, Mat4.invert(m4_1, parent._mat), this._mat);
        Mat4.toRTS(m4_1, this._lrot, this._lpos, this._lscale);
      } else {
        Vec3.copy(this._lpos, this._pos);
        Quat.copy(this._lrot, this._rot);
        Vec3.copy(this._lscale, this._scale);
      }

      this._eulerDirty = true;
    }

    this.invalidateChildren(exports.TransformBit.TRS);
  };

  _proto2._onHierarchyChanged = function _onHierarchyChanged(oldParent) {
    this.eventProcessor.reattach();

    _BaseNode.prototype._onHierarchyChangedBase.call(this, oldParent);
  };

  _proto2._onBatchCreated = function _onBatchCreated(dontSyncChildPrefab) {
    var _this$_prefab2;

    var prefabInstance = (_this$_prefab2 = this._prefab) === null || _this$_prefab2 === void 0 ? void 0 : _this$_prefab2.instance;

    if (!dontSyncChildPrefab && prefabInstance) {
      createNodeWithPrefab(this);
    }

    this.hasChangedFlags = exports.TransformBit.TRS;
    this._dirtyFlags |= exports.TransformBit.TRS;
    this._uiProps.uiTransformDirty = true;
    var len = this._children.length;

    for (var i = 0; i < len; ++i) {
      this._children[i]._siblingIndex = i;

      this._children[i]._onBatchCreated(dontSyncChildPrefab);
    }

    if (!dontSyncChildPrefab && prefabInstance) {
      var targetMap = {};
      prefabInstance.targetMap = targetMap;
      generateTargetMap(this, targetMap, true);
      applyMountedChildren(this, prefabInstance.mountedChildren, targetMap);
      applyRemovedComponents(this, prefabInstance.removedComponents, targetMap);
      applyMountedComponents(this, prefabInstance.mountedComponents, targetMap);
      applyPropertyOverrides(this, prefabInstance.propertyOverrides, targetMap);
    }

    applyTargetOverrides(this);
  };

  _proto2._onBeforeSerialize = function _onBeforeSerialize() {
    this.eulerAngles;
  };

  _proto2._onPostActivated = function _onPostActivated(active) {
    if (active) {
      eventManager.resumeTarget(this);
      this.invalidateChildren(exports.TransformBit.TRS);
    } else {
      eventManager.pauseTarget(this);
    }
  };

  _proto2.translate = function translate(trans, ns) {
    var space = ns || NodeSpace.LOCAL;

    if (space === NodeSpace.LOCAL) {
      Vec3.transformQuat(v3_a, trans, this._lrot);
      this._lpos.x += v3_a.x;
      this._lpos.y += v3_a.y;
      this._lpos.z += v3_a.z;
    } else if (space === NodeSpace.WORLD) {
      if (this._parent) {
        Quat.invert(q_a, this._parent.worldRotation);
        Vec3.transformQuat(v3_a, trans, q_a);
        var _scale = this.worldScale;
        this._lpos.x += v3_a.x / _scale.x;
        this._lpos.y += v3_a.y / _scale.y;
        this._lpos.z += v3_a.z / _scale.z;
      } else {
        this._lpos.x += trans.x;
        this._lpos.y += trans.y;
        this._lpos.z += trans.z;
      }
    }

    this.invalidateChildren(exports.TransformBit.POSITION);

    if (this._eventMask & TRANSFORM_ON) {
      this.emit(exports.NodeEventType.TRANSFORM_CHANGED, exports.TransformBit.POSITION);
    }
  };

  _proto2.rotate = function rotate(rot, ns) {
    var space = ns || NodeSpace.LOCAL;
    Quat.normalize(q_a, rot);

    if (space === NodeSpace.LOCAL) {
      Quat.multiply(this._lrot, this._lrot, q_a);
    } else if (space === NodeSpace.WORLD) {
      var worldRot = this.worldRotation;
      Quat.multiply(q_b, q_a, worldRot);
      Quat.invert(q_a, worldRot);
      Quat.multiply(q_b, q_a, q_b);
      Quat.multiply(this._lrot, this._lrot, q_b);
    }

    this._eulerDirty = true;
    this.invalidateChildren(exports.TransformBit.ROTATION);

    if (this._eventMask & TRANSFORM_ON) {
      this.emit(exports.NodeEventType.TRANSFORM_CHANGED, exports.TransformBit.ROTATION);
    }
  };

  _proto2.lookAt = function lookAt(pos, up) {
    this.getWorldPosition(v3_a);
    Vec3.subtract(v3_a, v3_a, pos);
    Vec3.normalize(v3_a, v3_a);
    Quat.fromViewUp(q_a, v3_a, up);
    this.setWorldRotation(q_a);
  };

  _proto2._setDirtyNode = function _setDirtyNode(idx, currNode) {
    dirtyNodes[idx] = currNode;
  };

  _proto2.invalidateChildren = function invalidateChildren(dirtyBit) {
    var childDirtyBit = dirtyBit | exports.TransformBit.POSITION;

    this._setDirtyNode(0, this);

    var i = 0;

    while (i >= 0) {
      var cur = dirtyNodes[i--];
      var hasChangedFlags = cur.hasChangedFlags;

      if (cur.isValid && (cur._dirtyFlags & hasChangedFlags & dirtyBit) !== dirtyBit) {
        cur._dirtyFlags |= dirtyBit;
        cur._uiProps.uiTransformDirty = true;
        cur.hasChangedFlags = hasChangedFlags | dirtyBit;
        var children = cur._children;
        var len = children.length;

        for (var j = 0; j < len; ++j) {
          this._setDirtyNode(++i, children[j]);
        }
      }

      dirtyBit = childDirtyBit;
    }
  };

  _proto2.updateWorldTransform = function updateWorldTransform() {
    if (!this._dirtyFlags) {
      return;
    }

    var cur = this;
    var i = 0;

    while (cur && cur._dirtyFlags) {
      this._setDirtyNode(i++, cur);

      cur = cur._parent;
    }

    var child;
    var dirtyBits = 0;

    while (i) {
      child = dirtyNodes[--i];
      dirtyBits |= child._dirtyFlags;

      if (cur) {
        if (dirtyBits & exports.TransformBit.POSITION) {
          Vec3.transformMat4(child._pos, child._lpos, cur._mat);
          child._mat.m12 = child._pos.x;
          child._mat.m13 = child._pos.y;
          child._mat.m14 = child._pos.z;
        }

        if (dirtyBits & exports.TransformBit.RS) {
          Mat4.fromRTS(child._mat, child._lrot, child._lpos, child._lscale);
          Mat4.multiply(child._mat, cur._mat, child._mat);

          if (dirtyBits & exports.TransformBit.ROTATION) {
            Quat.multiply(child._rot, cur._rot, child._lrot);
          }

          Mat3.fromQuat(m3_1$2, Quat.conjugate(qt_1$1, child._rot));
          Mat3.multiplyMat4(m3_1$2, m3_1$2, child._mat);
          child._scale.x = m3_1$2.m00;
          child._scale.y = m3_1$2.m04;
          child._scale.z = m3_1$2.m08;
        }
      } else {
        if (dirtyBits & exports.TransformBit.POSITION) {
          Vec3.copy(child._pos, child._lpos);
          child._mat.m12 = child._pos.x;
          child._mat.m13 = child._pos.y;
          child._mat.m14 = child._pos.z;
        }

        if (dirtyBits & exports.TransformBit.RS) {
          if (dirtyBits & exports.TransformBit.ROTATION) {
            Quat.copy(child._rot, child._lrot);
          }

          if (dirtyBits & exports.TransformBit.SCALE) {
            Vec3.copy(child._scale, child._lscale);
            Mat4.fromRTS(child._mat, child._rot, child._pos, child._scale);
          }
        }
      }

      child._dirtyFlags = exports.TransformBit.NONE;
      cur = child;
    }
  };

  _proto2.setPosition = function setPosition(val, y, z) {
    if (y === undefined && z === undefined) {
      Vec3.copy(this._lpos, val);
    } else if (z === undefined) {
      Vec3.set(this._lpos, val, y, this._lpos.z);
    } else {
      Vec3.set(this._lpos, val, y, z);
    }

    this.invalidateChildren(exports.TransformBit.POSITION);

    if (this._eventMask & TRANSFORM_ON) {
      this.emit(exports.NodeEventType.TRANSFORM_CHANGED, exports.TransformBit.POSITION);
    }
  };

  _proto2.getPosition = function getPosition(out) {
    if (out) {
      return Vec3.set(out, this._lpos.x, this._lpos.y, this._lpos.z);
    }

    return Vec3.copy(new Vec3(), this._lpos);
  };

  _proto2.setRotation = function setRotation(val, y, z, w) {
    if (y === undefined || z === undefined || w === undefined) {
      Quat.copy(this._lrot, val);
    } else {
      Quat.set(this._lrot, val, y, z, w);
    }

    this._eulerDirty = true;
    this.invalidateChildren(exports.TransformBit.ROTATION);

    if (this._eventMask & TRANSFORM_ON) {
      this.emit(exports.NodeEventType.TRANSFORM_CHANGED, exports.TransformBit.ROTATION);
    }
  };

  _proto2.setRotationFromEuler = function setRotationFromEuler(val, y, zOpt) {
    var z = zOpt === undefined ? this._euler.z : zOpt;

    if (y === undefined) {
      Vec3.copy(this._euler, val);
      Quat.fromEuler(this._lrot, val.x, val.y, val.z);
    } else {
      Vec3.set(this._euler, val, y, z);
      Quat.fromEuler(this._lrot, val, y, z);
    }

    this._eulerDirty = false;
    this.invalidateChildren(exports.TransformBit.ROTATION);

    if (this._eventMask & TRANSFORM_ON) {
      this.emit(exports.NodeEventType.TRANSFORM_CHANGED, exports.TransformBit.ROTATION);
    }
  };

  _proto2.getRotation = function getRotation(out) {
    if (out) {
      return Quat.set(out, this._lrot.x, this._lrot.y, this._lrot.z, this._lrot.w);
    }

    return Quat.copy(new Quat(), this._lrot);
  };

  _proto2.setScale = function setScale(val, y, z) {
    if (y === undefined && z === undefined) {
      Vec3.copy(this._lscale, val);
    } else if (z === undefined) {
      Vec3.set(this._lscale, val, y, this._lscale.z);
    } else {
      Vec3.set(this._lscale, val, y, z);
    }

    this.invalidateChildren(exports.TransformBit.SCALE);

    if (this._eventMask & TRANSFORM_ON) {
      this.emit(exports.NodeEventType.TRANSFORM_CHANGED, exports.TransformBit.SCALE);
    }
  };

  _proto2.getScale = function getScale(out) {
    if (out) {
      return Vec3.set(out, this._lscale.x, this._lscale.y, this._lscale.z);
    }

    return Vec3.copy(new Vec3(), this._lscale);
  };

  _proto2.inverseTransformPoint = function inverseTransformPoint(out, p) {
    Vec3.copy(out, p);
    var cur = this;
    var i = 0;

    while (cur._parent) {
      this._setDirtyNode(i++, cur);

      cur = cur._parent;
    }

    while (i >= 0) {
      Vec3.transformInverseRTS(out, out, cur._lrot, cur._lpos, cur._lscale);
      cur = dirtyNodes[--i];
    }

    return out;
  };

  _proto2.setWorldPosition = function setWorldPosition(val, y, z) {
    if (y === undefined || z === undefined) {
      Vec3.copy(this._pos, val);
    } else {
      Vec3.set(this._pos, val, y, z);
    }

    var parent = this._parent;
    var local = this._lpos;

    if (parent) {
      parent.updateWorldTransform();
      Vec3.transformMat4(local, this._pos, Mat4.invert(m4_1, parent._mat));
    } else {
      Vec3.copy(local, this._pos);
    }

    this.invalidateChildren(exports.TransformBit.POSITION);

    if (this._eventMask & TRANSFORM_ON) {
      this.emit(exports.NodeEventType.TRANSFORM_CHANGED, exports.TransformBit.POSITION);
    }
  };

  _proto2.getWorldPosition = function getWorldPosition(out) {
    this.updateWorldTransform();

    if (out) {
      return Vec3.copy(out, this._pos);
    }

    return Vec3.copy(new Vec3(), this._pos);
  };

  _proto2.setWorldRotation = function setWorldRotation(val, y, z, w) {
    if (y === undefined || z === undefined || w === undefined) {
      Quat.copy(this._rot, val);
    } else {
      Quat.set(this._rot, val, y, z, w);
    }

    if (this._parent) {
      this._parent.updateWorldTransform();

      Quat.multiply(this._lrot, Quat.conjugate(this._lrot, this._parent._rot), this._rot);
    } else {
      Quat.copy(this._lrot, this._rot);
    }

    this._eulerDirty = true;
    this.invalidateChildren(exports.TransformBit.ROTATION);

    if (this._eventMask & TRANSFORM_ON) {
      this.emit(exports.NodeEventType.TRANSFORM_CHANGED, exports.TransformBit.ROTATION);
    }
  };

  _proto2.setWorldRotationFromEuler = function setWorldRotationFromEuler(x, y, z) {
    Quat.fromEuler(this._rot, x, y, z);

    if (this._parent) {
      this._parent.updateWorldTransform();

      Quat.multiply(this._lrot, Quat.conjugate(this._lrot, this._parent._rot), this._rot);
    } else {
      Quat.copy(this._lrot, this._rot);
    }

    this._eulerDirty = true;
    this.invalidateChildren(exports.TransformBit.ROTATION);

    if (this._eventMask & TRANSFORM_ON) {
      this.emit(exports.NodeEventType.TRANSFORM_CHANGED, exports.TransformBit.ROTATION);
    }
  };

  _proto2.getWorldRotation = function getWorldRotation(out) {
    this.updateWorldTransform();

    if (out) {
      return Quat.copy(out, this._rot);
    }

    return Quat.copy(new Quat(), this._rot);
  };

  _proto2.setWorldScale = function setWorldScale(val, y, z) {
    if (y === undefined || z === undefined) {
      Vec3.copy(this._scale, val);
    } else {
      Vec3.set(this._scale, val, y, z);
    }

    var parent = this._parent;

    if (parent) {
      parent.updateWorldTransform();
      Mat3.fromQuat(m3_1$2, Quat.conjugate(qt_1$1, parent._rot));
      Mat3.multiplyMat4(m3_1$2, m3_1$2, parent._mat);
      m3_scaling.m00 = this._scale.x;
      m3_scaling.m04 = this._scale.y;
      m3_scaling.m08 = this._scale.z;
      Mat3.multiply(m3_1$2, m3_scaling, Mat3.invert(m3_1$2, m3_1$2));
      this._lscale.x = Vec3.set(v3_a, m3_1$2.m00, m3_1$2.m01, m3_1$2.m02).length();
      this._lscale.y = Vec3.set(v3_a, m3_1$2.m03, m3_1$2.m04, m3_1$2.m05).length();
      this._lscale.z = Vec3.set(v3_a, m3_1$2.m06, m3_1$2.m07, m3_1$2.m08).length();
    } else {
      Vec3.copy(this._lscale, this._scale);
    }

    this.invalidateChildren(exports.TransformBit.SCALE);

    if (this._eventMask & TRANSFORM_ON) {
      this.emit(exports.NodeEventType.TRANSFORM_CHANGED, exports.TransformBit.SCALE);
    }
  };

  _proto2.getWorldScale = function getWorldScale(out) {
    this.updateWorldTransform();

    if (out) {
      return Vec3.copy(out, this._scale);
    }

    return Vec3.copy(new Vec3(), this._scale);
  };

  _proto2.getWorldMatrix = function getWorldMatrix(out) {
    this.updateWorldTransform();
    var target = out || new Mat4();
    return Mat4.copy(target, this._mat);
  };

  _proto2.getWorldRS = function getWorldRS(out) {
    this.updateWorldTransform();
    var target = out || new Mat4();
    Mat4.copy(target, this._mat);
    target.m12 = 0;
    target.m13 = 0;
    target.m14 = 0;
    return target;
  };

  _proto2.getWorldRT = function getWorldRT(out) {
    this.updateWorldTransform();
    var target = out || new Mat4();
    return Mat4.fromRT(target, this._rot, this._pos);
  };

  _proto2.setRTS = function setRTS(rot, pos, scale) {
    var dirtyBit = 0;

    if (rot) {
      dirtyBit |= exports.TransformBit.ROTATION;

      if (rot.w !== undefined) {
        Quat.copy(this._lrot, rot);
        this._eulerDirty = true;
      } else {
        Vec3.copy(this._euler, rot);
        Quat.fromEuler(this._lrot, rot.x, rot.y, rot.z);
        this._eulerDirty = false;
      }
    }

    if (pos) {
      Vec3.copy(this._lpos, pos);
      dirtyBit |= exports.TransformBit.POSITION;
    }

    if (scale) {
      Vec3.copy(this._lscale, scale);
      dirtyBit |= exports.TransformBit.SCALE;
    }

    if (dirtyBit) {
      this.invalidateChildren(dirtyBit);

      if (this._eventMask & TRANSFORM_ON) {
        this.emit(exports.NodeEventType.TRANSFORM_CHANGED, dirtyBit);
      }
    }
  };

  _proto2.pauseSystemEvents = function pauseSystemEvents(recursive) {
    eventManager.pauseTarget(this, recursive);
  };

  _proto2.resumeSystemEvents = function resumeSystemEvents(recursive) {
    eventManager.resumeTarget(this, recursive);
  };

  Node.resetHasChangedFlags = function resetHasChangedFlags() {
    bookOfChange.clear();
  };

  Node.clearNodeArray = function clearNodeArray() {
    if (Node.ClearFrame < Node.ClearRound && !EDITOR) {
      Node.ClearFrame++;
    } else {
      Node.ClearFrame = 0;
      dirtyNodes.length = 0;
      nativeDirtyNodes.length = 0;
    }
  };

  _createClass(Node, [{
    key: "native",
    get: function get() {
      return this._nativeObj;
    }
  }, {
    key: "position",
    get: function get() {
      return this._lpos;
    },
    set: function set(val) {
      this.setPosition(val);
    }
  }, {
    key: "worldPosition",
    get: function get() {
      this.updateWorldTransform();
      return this._pos;
    },
    set: function set(val) {
      this.setWorldPosition(val);
    }
  }, {
    key: "rotation",
    get: function get() {
      return this._lrot;
    },
    set: function set(val) {
      this.setRotation(val);
    }
  }, {
    key: "eulerAngles",
    set: function set(val) {
      this.setRotationFromEuler(val.x, val.y, val.z);
    },
    get: function get() {
      if (this._eulerDirty) {
        Quat.toEuler(this._euler, this._lrot);
        this._eulerDirty = false;
      }

      return this._euler;
    }
  }, {
    key: "angle",
    get: function get() {
      return this._euler.z;
    },
    set: function set(val) {
      Vec3.set(this._euler, 0, 0, val);
      Quat.fromAngleZ(this._lrot, val);
      this._eulerDirty = false;
      this.invalidateChildren(exports.TransformBit.ROTATION);

      if (this._eventMask & TRANSFORM_ON) {
        this.emit(exports.NodeEventType.TRANSFORM_CHANGED, exports.TransformBit.ROTATION);
      }
    }
  }, {
    key: "worldRotation",
    get: function get() {
      this.updateWorldTransform();
      return this._rot;
    },
    set: function set(val) {
      this.setWorldRotation(val);
    }
  }, {
    key: "scale",
    get: function get() {
      return this._lscale;
    },
    set: function set(val) {
      this.setScale(val);
    }
  }, {
    key: "worldScale",
    get: function get() {
      this.updateWorldTransform();
      return this._scale;
    },
    set: function set(val) {
      this.setWorldScale(val);
    }
  }, {
    key: "matrix",
    set: function set(val) {
      Mat4.toRTS(val, this._lrot, this._lpos, this._lscale);
      this.invalidateChildren(exports.TransformBit.TRS);
      this._eulerDirty = true;

      if (this._eventMask & TRANSFORM_ON) {
        this.emit(exports.NodeEventType.TRANSFORM_CHANGED, exports.TransformBit.TRS);
      }
    }
  }, {
    key: "worldMatrix",
    get: function get() {
      this.updateWorldTransform();
      return this._mat;
    }
  }, {
    key: "forward",
    get: function get() {
      return Vec3.transformQuat(new Vec3(), Vec3.FORWARD, this.worldRotation);
    },
    set: function set(dir) {
      var len = dir.length();
      Vec3.multiplyScalar(v3_a, dir, -1 / len);
      Quat.fromViewUp(q_a, v3_a);
      this.setWorldRotation(q_a);
    }
  }, {
    key: "up",
    get: function get() {
      return Vec3.transformQuat(new Vec3(), Vec3.UP, this.worldRotation);
    }
  }, {
    key: "right",
    get: function get() {
      return Vec3.transformQuat(new Vec3(), Vec3.RIGHT, this.worldRotation);
    }
  }, {
    key: "layer",
    set: function set(l) {
      this._layer = l;

      this.emit(exports.NodeEventType.LAYER_CHANGED, this._layer);
    },
    get: function get() {
      return this._layer;
    }
  }, {
    key: "hasChangedFlags",
    get: function get() {
      return this._hasChangedFlagsChunk[this._hasChangedFlagsOffset];
    },
    set: function set(val) {
      this._hasChangedFlagsChunk[this._hasChangedFlagsOffset] = val;
    }
  }]);

  return Node;
}(BaseNode), _class3$9.EventType = exports.NodeEventType, _class3$9.NodeSpace = NodeSpace, _class3$9.TransformDirtyBit = exports.TransformBit, _class3$9.TransformBit = exports.TransformBit, _class3$9.reserveContentsForAllSyncablePrefabTag = reserveContentsForAllSyncablePrefabTag, _class3$9.ClearFrame = 0, _class3$9.ClearRound = 1000, _temp$h), (_descriptor$f = _applyDecoratedDescriptor(_class2$h.prototype, "_lpos", [serializable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return new Vec3();
  }
}), _descriptor2$b = _applyDecoratedDescriptor(_class2$h.prototype, "_lrot", [serializable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return new Quat();
  }
}), _descriptor3$8 = _applyDecoratedDescriptor(_class2$h.prototype, "_lscale", [serializable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return new Vec3(1, 1, 1);
  }
}), _descriptor4$7 = _applyDecoratedDescriptor(_class2$h.prototype, "_layer", [serializable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return Layers.Enum.DEFAULT;
  }
}), _descriptor5$4 = _applyDecoratedDescriptor(_class2$h.prototype, "_euler", [serializable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return new Vec3();
  }
}), _applyDecoratedDescriptor(_class2$h.prototype, "eulerAngles", [_dec2$8], Object.getOwnPropertyDescriptor(_class2$h.prototype, "eulerAngles"), _class2$h.prototype), _applyDecoratedDescriptor(_class2$h.prototype, "angle", [editable], Object.getOwnPropertyDescriptor(_class2$h.prototype, "angle"), _class2$h.prototype), _applyDecoratedDescriptor(_class2$h.prototype, "layer", [editable], Object.getOwnPropertyDescriptor(_class2$h.prototype, "layer"), _class2$h.prototype)), _class2$h)) || _class$k);
legacyCC.Node = Node$1;

var _dec$l, _class$l, _class2$i, _descriptor$g, _temp$i, _dec2$9, _dec3$3, _dec4$2, _dec5$1, _dec6, _class4$2, _class5$2, _descriptor2$c, _descriptor3$9, _descriptor4$8, _descriptor5$5, _descriptor6$2, _temp2, _dec7, _class7, _class8, _descriptor7$2, _temp3$2, _dec8, _dec9, _class10, _class11, _descriptor8$2, _descriptor9$1, _descriptor10$1, _temp4, _dec10, _dec11, _dec12, _class13, _class14, _descriptor11, _descriptor12, _temp5, _dec13, _dec14, _dec15, _class16, _class17, _descriptor13, _descriptor14, _temp6, _dec16, _dec17, _dec18, _dec19, _dec20, _dec21, _class19, _class20, _descriptor15, _descriptor16, _descriptor17, _descriptor18, _descriptor19, _descriptor20, _temp7, _dec22, _dec23, _dec24, _dec25, _class22, _class23, _descriptor21, _descriptor22, _descriptor23, _descriptor24, _descriptor25, _temp8;

var TargetInfo = (_dec$l = ccclass('cc.TargetInfo'), _dec$l(_class$l = (_class2$i = (_temp$i = function TargetInfo() {
  _initializerDefineProperty(this, "localID", _descriptor$g, this);
}, _temp$i), (_descriptor$g = _applyDecoratedDescriptor(_class2$i.prototype, "localID", [serializable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return [];
  }
})), _class2$i)) || _class$l);
var TargetOverrideInfo = (_dec2$9 = ccclass('cc.TargetOverrideInfo'), _dec3$3 = type(CCObject), _dec4$2 = type(TargetInfo), _dec5$1 = type(Node$1), _dec6 = type(TargetInfo), _dec2$9(_class4$2 = (_class5$2 = (_temp2 = function TargetOverrideInfo() {
  _initializerDefineProperty(this, "source", _descriptor2$c, this);

  _initializerDefineProperty(this, "sourceInfo", _descriptor3$9, this);

  _initializerDefineProperty(this, "propertyPath", _descriptor4$8, this);

  _initializerDefineProperty(this, "target", _descriptor5$5, this);

  _initializerDefineProperty(this, "targetInfo", _descriptor6$2, this);
}, _temp2), (_descriptor2$c = _applyDecoratedDescriptor(_class5$2.prototype, "source", [serializable, _dec3$3], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return null;
  }
}), _descriptor3$9 = _applyDecoratedDescriptor(_class5$2.prototype, "sourceInfo", [serializable, _dec4$2], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return null;
  }
}), _descriptor4$8 = _applyDecoratedDescriptor(_class5$2.prototype, "propertyPath", [serializable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return [];
  }
}), _descriptor5$5 = _applyDecoratedDescriptor(_class5$2.prototype, "target", [serializable, _dec5$1], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return null;
  }
}), _descriptor6$2 = _applyDecoratedDescriptor(_class5$2.prototype, "targetInfo", [serializable, _dec6], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return null;
  }
})), _class5$2)) || _class4$2);
var CompPrefabInfo = (_dec7 = ccclass('cc.CompPrefabInfo'), _dec7(_class7 = (_class8 = (_temp3$2 = function CompPrefabInfo() {
  _initializerDefineProperty(this, "fileId", _descriptor7$2, this);
}, _temp3$2), (_descriptor7$2 = _applyDecoratedDescriptor(_class8.prototype, "fileId", [serializable, editable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return '';
  }
})), _class8)) || _class7);
var PropertyOverrideInfo = (_dec8 = ccclass('CCPropertyOverrideInfo'), _dec9 = type(TargetInfo), _dec8(_class10 = (_class11 = (_temp4 = function () {
  function PropertyOverrideInfo() {
    _initializerDefineProperty(this, "targetInfo", _descriptor8$2, this);

    _initializerDefineProperty(this, "propertyPath", _descriptor9$1, this);

    _initializerDefineProperty(this, "value", _descriptor10$1, this);
  }

  var _proto = PropertyOverrideInfo.prototype;

  _proto.isTarget = function isTarget(localID, propPath) {
  };

  return PropertyOverrideInfo;
}(), _temp4), (_descriptor8$2 = _applyDecoratedDescriptor(_class11.prototype, "targetInfo", [serializable, _dec9], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return null;
  }
}), _descriptor9$1 = _applyDecoratedDescriptor(_class11.prototype, "propertyPath", [serializable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return [];
  }
}), _descriptor10$1 = _applyDecoratedDescriptor(_class11.prototype, "value", [serializable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
})), _class11)) || _class10);
var MountedChildrenInfo = (_dec10 = ccclass('cc.MountedChildrenInfo'), _dec11 = type(TargetInfo), _dec12 = type([Node$1]), _dec10(_class13 = (_class14 = (_temp5 = function () {
  function MountedChildrenInfo() {
    _initializerDefineProperty(this, "targetInfo", _descriptor11, this);

    _initializerDefineProperty(this, "nodes", _descriptor12, this);
  }

  var _proto2 = MountedChildrenInfo.prototype;

  _proto2.isTarget = function isTarget(localID) {
  };

  return MountedChildrenInfo;
}(), _temp5), (_descriptor11 = _applyDecoratedDescriptor(_class14.prototype, "targetInfo", [serializable, _dec11], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return null;
  }
}), _descriptor12 = _applyDecoratedDescriptor(_class14.prototype, "nodes", [serializable, _dec12], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return [];
  }
})), _class14)) || _class13);
var MountedComponentsInfo = (_dec13 = ccclass('cc.MountedComponentsInfo'), _dec14 = type(TargetInfo), _dec15 = type([Component]), _dec13(_class16 = (_class17 = (_temp6 = function () {
  function MountedComponentsInfo() {
    _initializerDefineProperty(this, "targetInfo", _descriptor13, this);

    _initializerDefineProperty(this, "components", _descriptor14, this);
  }

  var _proto3 = MountedComponentsInfo.prototype;

  _proto3.isTarget = function isTarget(localID) {
  };

  return MountedComponentsInfo;
}(), _temp6), (_descriptor13 = _applyDecoratedDescriptor(_class17.prototype, "targetInfo", [serializable, _dec14], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return null;
  }
}), _descriptor14 = _applyDecoratedDescriptor(_class17.prototype, "components", [serializable, _dec15], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return [];
  }
})), _class17)) || _class16);
var PrefabInstance = (_dec16 = ccclass('cc.PrefabInstance'), _dec17 = type(Node$1), _dec18 = type([MountedChildrenInfo]), _dec19 = type([MountedComponentsInfo]), _dec20 = type([PropertyOverrideInfo]), _dec21 = type([TargetInfo]), _dec16(_class19 = (_class20 = (_temp7 = function () {
  function PrefabInstance() {
    _initializerDefineProperty(this, "fileId", _descriptor15, this);

    _initializerDefineProperty(this, "prefabRootNode", _descriptor16, this);

    _initializerDefineProperty(this, "mountedChildren", _descriptor17, this);

    _initializerDefineProperty(this, "mountedComponents", _descriptor18, this);

    _initializerDefineProperty(this, "propertyOverrides", _descriptor19, this);

    _initializerDefineProperty(this, "removedComponents", _descriptor20, this);

    this.targetMap = {};
  }

  var _proto4 = PrefabInstance.prototype;

  _proto4.findPropertyOverride = function findPropertyOverride(localID, propPath) {
  };

  _proto4.removePropertyOverride = function removePropertyOverride(localID, propPath) {
  };

  return PrefabInstance;
}(), _temp7), (_descriptor15 = _applyDecoratedDescriptor(_class20.prototype, "fileId", [serializable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return '';
  }
}), _descriptor16 = _applyDecoratedDescriptor(_class20.prototype, "prefabRootNode", [serializable, _dec17], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor17 = _applyDecoratedDescriptor(_class20.prototype, "mountedChildren", [serializable, _dec18], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return [];
  }
}), _descriptor18 = _applyDecoratedDescriptor(_class20.prototype, "mountedComponents", [serializable, _dec19], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return [];
  }
}), _descriptor19 = _applyDecoratedDescriptor(_class20.prototype, "propertyOverrides", [serializable, _dec20], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return [];
  }
}), _descriptor20 = _applyDecoratedDescriptor(_class20.prototype, "removedComponents", [serializable, _dec21], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return [];
  }
})), _class20)) || _class19);
var PrefabInfo = (_dec22 = ccclass('cc.PrefabInfo'), _dec23 = type(Node$1), _dec24 = type(PrefabInstance), _dec25 = type([TargetOverrideInfo]), _dec22(_class22 = (_class23 = (_temp8 = function PrefabInfo() {
  _initializerDefineProperty(this, "root", _descriptor21, this);

  _initializerDefineProperty(this, "asset", _descriptor22, this);

  _initializerDefineProperty(this, "fileId", _descriptor23, this);

  _initializerDefineProperty(this, "instance", _descriptor24, this);

  _initializerDefineProperty(this, "targetOverrides", _descriptor25, this);
}, _temp8), (_descriptor21 = _applyDecoratedDescriptor(_class23.prototype, "root", [serializable, _dec23], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor22 = _applyDecoratedDescriptor(_class23.prototype, "asset", [serializable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor23 = _applyDecoratedDescriptor(_class23.prototype, "fileId", [serializable, editable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return '';
  }
}), _descriptor24 = _applyDecoratedDescriptor(_class23.prototype, "instance", [serializable, _dec24], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor25 = _applyDecoratedDescriptor(_class23.prototype, "targetOverrides", [serializable, _dec25], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
})), _class23)) || _class22);
legacyCC._PrefabInfo = PrefabInfo;

var utils = /*#__PURE__*/Object.freeze({
    __proto__: null,
    TargetInfo: TargetInfo,
    TargetOverrideInfo: TargetOverrideInfo,
    CompPrefabInfo: CompPrefabInfo,
    PropertyOverrideInfo: PropertyOverrideInfo,
    MountedChildrenInfo: MountedChildrenInfo,
    MountedComponentsInfo: MountedComponentsInfo,
    PrefabInstance: PrefabInstance,
    PrefabInfo: PrefabInfo,
    createNodeWithPrefab: createNodeWithPrefab,
    generateTargetMap: generateTargetMap,
    getTarget: getTarget,
    applyMountedChildren: applyMountedChildren,
    applyMountedComponents: applyMountedComponents,
    applyRemovedComponents: applyRemovedComponents,
    applyPropertyOverrides: applyPropertyOverrides,
    applyTargetOverrides: applyTargetOverrides
});

var _dec$m, _class$m, _class2$j, _descriptor$h, _descriptor2$d, _class3$a, _temp$j;
var OptimizationPolicy = Enum({
  AUTO: 0,
  SINGLE_INSTANCE: 1,
  MULTI_INSTANCE: 2
});
var Prefab = (_dec$m = ccclass('cc.Prefab'), _dec$m(_class$m = (_class2$j = (_temp$j = _class3$a = function (_Asset) {
  _inheritsLoose(Prefab, _Asset);

  function Prefab() {
    var _this;

    _this = _Asset.call(this) || this;

    _initializerDefineProperty(_this, "data", _descriptor$h, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "optimizationPolicy", _descriptor2$d, _assertThisInitialized(_this));

    _this._createFunction = void 0;
    _this._instantiatedTimes = void 0;
    _this._createFunction = null;
    _this._instantiatedTimes = 0;
    return _this;
  }

  var _proto = Prefab.prototype;

  _proto.createNode = function createNode(cb) {
    var node = legacyCC.instantiate(this);
    node.name = this.name;
    cb(null, node);
  };

  _proto.compileCreateFunction = function compileCreateFunction() {
    this._createFunction = compile(this.data);
  };

  _proto._doInstantiate = function _doInstantiate(rootToRedirect) {
    if (!this.data._prefab) {
      warnID(3700);
    }

    if (!this._createFunction) {
      this.compileCreateFunction();
    }

    return this._createFunction(rootToRedirect);
  };

  _proto._instantiate = function _instantiate() {
    var node;
    var useJit = false;

    {
      if (this.optimizationPolicy === OptimizationPolicy.SINGLE_INSTANCE) {
        useJit = false;
      } else if (this.optimizationPolicy === OptimizationPolicy.MULTI_INSTANCE) {
        useJit = true;
      } else {
        useJit = this._instantiatedTimes + 1 >= Prefab.OptimizationPolicyThreshold;
      }
    }

    if (useJit) {
      node = this._doInstantiate();

      this.data._instantiate(node);
    } else {
      node = this.data._instantiate();
    }

    ++this._instantiatedTimes;
    return node;
  };

  _proto.initDefault = function initDefault(uuid) {
    _Asset.prototype.initDefault.call(this, uuid);

    this.data = new Node$1();
    this.data.name = '(Missing Node)';
    var prefabInfo = new legacyCC._PrefabInfo();
    prefabInfo.asset = this;
    prefabInfo.root = this.data;
    this.data._prefab = prefabInfo;
  };

  _proto.validate = function validate() {
    return !!this.data;
  };

  return Prefab;
}(Asset), _class3$a.OptimizationPolicy = OptimizationPolicy, _class3$a.OptimizationPolicyThreshold = 3, _temp$j), (_descriptor$h = _applyDecoratedDescriptor(_class2$j.prototype, "data", [serializable, editable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return null;
  }
}), _descriptor2$d = _applyDecoratedDescriptor(_class2$j.prototype, "optimizationPolicy", [serializable, editable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return OptimizationPolicy.AUTO;
  }
})), _class2$j)) || _class$m);
js.value(Prefab, '_utils', utils);
legacyCC.Prefab = Prefab;

{
  obsolete(legacyCC, 'cc._Prefab', 'Prefab');
}

var _dec$n, _dec2$a, _dec3$4, _class$n, _class2$k, _descriptor$i, _temp$k;
var PrefabLink = (_dec$n = ccclass('cc.PrefabLink'), _dec2$a = type(Prefab), _dec3$4 = visible(), _dec$n(_class$n = (_class2$k = (_temp$k = function (_Component) {
  _inheritsLoose(PrefabLink, _Component);

  function PrefabLink() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _Component.call.apply(_Component, [this].concat(args)) || this;

    _initializerDefineProperty(_this, "prefab", _descriptor$i, _assertThisInitialized(_this));

    return _this;
  }

  return PrefabLink;
}(Component), _temp$k), (_descriptor$i = _applyDecoratedDescriptor(_class2$k.prototype, "prefab", [_dec2$a, serializable, _dec3$4], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return null;
  }
})), _class2$k)) || _class$n);

var _vec3 = new Vec3();

function WorldNode3DToLocalNodeUI(mainCamera, wpos, uiNode, out) {
  if (!out) {
    out = new Vec3();
  }

  mainCamera.convertToUINode(wpos, uiNode, out);
  var pos = uiNode.position;
  out.add(pos);
  return out;
}
function WorldNode3DToWorldNodeUI(mainCamera, wpos, out) {
  if (!out) {
    out = new Vec3();
  }

  mainCamera.worldToScreen(wpos, out);
  out.x /= legacyCC.view.getScaleX();
  out.y /= legacyCC.view.getScaleY();
  return out;
}
var convertUtils = {
  WorldNode3DToLocalNodeUI: WorldNode3DToLocalNodeUI,
  WorldNode3DToWorldNodeUI: WorldNode3DToWorldNodeUI
};
legacyCC.pipelineUtils = convertUtils;
exports.replaceProperty(legacyCC.pipelineUtils, 'cc.pipelineUtils', [{
  name: 'WorldNode3DToLocalNodeUI',
  newName: 'convertToUINode',
  targetName: 'cc.Camera.prototype',
  customFunction: function customFunction() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var camera = args[0];
    var out = args[3] || _vec3;
    camera.convertToUINode(args[1], args[2], out);
    out.add(args[2].position);
    return args[3] || out.clone();
  }
}]);

exports.removeProperty(TextureBase.prototype, 'TextureBase.prototype', [{
  name: 'hasPremultipliedAlpha'
}, {
  name: 'setPremultiplyAlpha'
}, {
  name: 'setFlipY'
}]);
exports.replaceProperty(RenderTexture.prototype, 'RenderTexture.prototype', [{
  name: 'getGFXWindow',
  customFunction: function customFunction() {
    return this._window;
  }
}]);

var _dec$o, _class$o, _class2$l, _temp$l;
var BufferAsset = (_dec$o = ccclass('cc.BufferAsset'), _dec$o(_class$o = (_class2$l = (_temp$l = function (_Asset) {
  _inheritsLoose(BufferAsset, _Asset);

  function BufferAsset() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _Asset.call.apply(_Asset, [this].concat(args)) || this;
    _this._buffer = null;
    return _this;
  }

  var _proto = BufferAsset.prototype;

  _proto.buffer = function buffer() {
    return this._buffer;
  };

  _proto.validate = function validate() {
    return !!this.buffer;
  };

  _createClass(BufferAsset, [{
    key: "_nativeAsset",
    get: function get() {
      return this._buffer;
    },
    set: function set(bin) {
      if (bin instanceof ArrayBuffer) {
        this._buffer = bin;
      } else {
        this._buffer = bin.buffer;
      }
    }
  }]);

  return BufferAsset;
}(Asset), _temp$l), (_applyDecoratedDescriptor(_class2$l.prototype, "_nativeAsset", [override], Object.getOwnPropertyDescriptor(_class2$l.prototype, "_nativeAsset"), _class2$l.prototype)), _class2$l)) || _class$o);
legacyCC.BufferAsset = BufferAsset;

var _typeMap2;

var _typeMap = (_typeMap2 = {}, _typeMap2[exports.FormatType.UNORM] = 'Uint', _typeMap2[exports.FormatType.SNORM] = 'Int', _typeMap2[exports.FormatType.UINT] = 'Uint', _typeMap2[exports.FormatType.INT] = 'Int', _typeMap2[exports.FormatType.UFLOAT] = 'Float', _typeMap2[exports.FormatType.FLOAT] = 'Float', _typeMap2["default"] = 'Uint', _typeMap2);

function _getDataViewType(info) {
  var type = _typeMap[info.type] || _typeMap["default"];
  var bytes = info.size / info.count * 8;
  return "" + type + bytes;
}

function writeBuffer(target, data, format, offset, stride) {
  if (format === void 0) {
    format = exports.Format.R32F;
  }

  if (offset === void 0) {
    offset = 0;
  }

  if (stride === void 0) {
    stride = 0;
  }

  var info = FormatInfos[format];

  if (!stride) {
    stride = info.size;
  }

  var writer = "set" + _getDataViewType(info);

  var componentBytesLength = info.size / info.count;
  var nSeg = Math.floor(data.length / info.count);
  var isLittleEndian = sys.isLittleEndian;

  for (var iSeg = 0; iSeg < nSeg; ++iSeg) {
    var x = offset + stride * iSeg;

    for (var iComponent = 0; iComponent < info.count; ++iComponent) {
      var y = x + componentBytesLength * iComponent;
      target[writer](y, data[info.count * iSeg + iComponent], isLittleEndian);
    }
  }
}
function readBuffer(target, format, offset, length, stride, out) {
  if (format === void 0) {
    format = exports.Format.R32F;
  }

  if (offset === void 0) {
    offset = 0;
  }

  if (length === void 0) {
    length = target.byteLength - offset;
  }

  if (stride === void 0) {
    stride = 0;
  }

  if (out === void 0) {
    out = [];
  }

  var info = FormatInfos[format];

  if (!stride) {
    stride = info.size;
  }

  var reader = "get" + _getDataViewType(info);

  var componentBytesLength = info.size / info.count;
  var nSeg = Math.floor(length / stride);
  var isLittleEndian = sys.isLittleEndian;

  for (var iSeg = 0; iSeg < nSeg; ++iSeg) {
    var x = offset + stride * iSeg;

    for (var iComponent = 0; iComponent < info.count; ++iComponent) {
      var y = x + componentBytesLength * iComponent;
      out[info.count * iSeg + iComponent] = target[reader](y, isLittleEndian);
    }
  }

  return out;
}
function mapBuffer(target, callback, format, offset, length, stride, out) {
  if (format === void 0) {
    format = exports.Format.R32F;
  }

  if (offset === void 0) {
    offset = 0;
  }

  if (length === void 0) {
    length = target.byteLength - offset;
  }

  if (stride === void 0) {
    stride = 0;
  }

  if (!out) {
    out = new DataView(target.buffer.slice(target.byteOffset, target.byteOffset + target.byteLength));
  }

  var info = FormatInfos[format];

  if (!stride) {
    stride = info.size;
  }

  var writer = "set" + _getDataViewType(info);

  var reader = "get" + _getDataViewType(info);

  var componentBytesLength = info.size / info.count;
  var nSeg = Math.floor(length / stride);
  var isLittleEndian = sys.isLittleEndian;

  for (var iSeg = 0; iSeg < nSeg; ++iSeg) {
    var x = offset + stride * iSeg;

    for (var iComponent = 0; iComponent < info.count; ++iComponent) {
      var y = x + componentBytesLength * iComponent;

      var _cur = target[reader](y, isLittleEndian);

      out[writer](y, callback(_cur, iComponent, target), isLittleEndian);
    }
  }

  return out;
}

var RenderingSubMesh = function () {
  var _proto = RenderingSubMesh.prototype;

  _proto._init = function _init() {};

  function RenderingSubMesh(vertexBuffers, attributes, primitiveMode, indexBuffer, indirectBuffer) {
    if (indexBuffer === void 0) {
      indexBuffer = null;
    }

    if (indirectBuffer === void 0) {
      indirectBuffer = null;
    }

    this.mesh = void 0;
    this.subMeshIdx = void 0;
    this._flatBuffers = [];
    this._jointMappedBuffers = void 0;
    this._jointMappedBufferIndices = void 0;
    this._vertexIdChannel = void 0;
    this._geometricInfo = void 0;
    this._vertexBuffers = void 0;
    this._attributes = void 0;
    this._indexBuffer = null;
    this._indirectBuffer = null;
    this._primitiveMode = void 0;
    this._iaInfo = void 0;
    this._attributes = attributes;
    this._vertexBuffers = vertexBuffers;
    this._indexBuffer = indexBuffer;
    this._indirectBuffer = indirectBuffer;
    this._primitiveMode = primitiveMode;
    this._iaInfo = new InputAssemblerInfo(attributes, vertexBuffers, indexBuffer, indirectBuffer);

    this._init();
  }

  _proto.genFlatBuffers = function genFlatBuffers() {
    if (this._flatBuffers.length || !this.mesh || this.subMeshIdx === undefined) {
      return;
    }

    var mesh = this.mesh;
    var idxCount = 0;
    var prim = mesh.struct.primitives[this.subMeshIdx];

    if (prim.indexView) {
      idxCount = prim.indexView.count;
    }

    for (var i = 0; i < prim.vertexBundelIndices.length; i++) {
      var bundleIdx = prim.vertexBundelIndices[i];
      var vertexBundle = mesh.struct.vertexBundles[bundleIdx];
      var vbCount = prim.indexView ? prim.indexView.count : vertexBundle.view.count;
      var vbStride = vertexBundle.view.stride;
      var vbSize = vbStride * vbCount;
      var view = new Uint8Array(mesh.data.buffer, vertexBundle.view.offset, vertexBundle.view.length);
      var sharedView = new Uint8Array(prim.indexView ? vbSize : vertexBundle.view.length);

      if (!prim.indexView) {
        sharedView.set(mesh.data.subarray(vertexBundle.view.offset, vertexBundle.view.offset + vertexBundle.view.length));

        this._flatBuffers.push({
          stride: vbStride,
          count: vbCount,
          buffer: sharedView
        });

        continue;
      }

      var ibView = mesh.readIndices(this.subMeshIdx);

      for (var n = 0; n < idxCount; ++n) {
        var idx = ibView[n];
        var offset = n * vbStride;
        var srcOffset = idx * vbStride;

        for (var m = 0; m < vbStride; ++m) {
          sharedView[offset + m] = view[srcOffset + m];
        }
      }

      this._flatBuffers.push({
        stride: vbStride,
        count: vbCount,
        buffer: sharedView
      });
    }
  };

  _proto.destroy = function destroy() {
    for (var i = 0; i < this.vertexBuffers.length; i++) {
      this.vertexBuffers[i].destroy();
    }

    this.vertexBuffers.length = 0;

    if (this._indexBuffer) {
      this._indexBuffer.destroy();

      this._indexBuffer = null;
    }

    if (this._jointMappedBuffers && this._jointMappedBufferIndices) {
      for (var _i = 0; _i < this._jointMappedBufferIndices.length; _i++) {
        this._jointMappedBuffers[this._jointMappedBufferIndices[_i]].destroy();
      }

      this._jointMappedBuffers = undefined;
      this._jointMappedBufferIndices = undefined;
    }

    if (this._indirectBuffer) {
      this._indirectBuffer.destroy();

      this._indirectBuffer = null;
    }
  };

  _proto.enableVertexIdChannel = function enableVertexIdChannel(device) {
    if (this._vertexIdChannel) {
      return;
    }

    var streamIndex = this.vertexBuffers.length;
    var attributeIndex = this.attributes.length;

    var vertexIdBuffer = this._allocVertexIdBuffer(device);

    this._vertexBuffers.push(vertexIdBuffer);

    this._attributes.push(new Attribute('a_vertexId', exports.Format.R32F, false, streamIndex));

    this._iaInfo.attributes = this._attributes;
    this._iaInfo.vertexBuffers = this._vertexBuffers;
    this._vertexIdChannel = {
      stream: streamIndex,
      index: attributeIndex
    };
  };

  _proto._allocVertexIdBuffer = function _allocVertexIdBuffer(device) {
    var vertexCount = this.vertexBuffers.length === 0 || this.vertexBuffers[0].stride === 0 ? 0 : this.vertexBuffers[0].size / this.vertexBuffers[0].stride;
    var vertexIds = new Float32Array(vertexCount);

    for (var iVertex = 0; iVertex < vertexCount; ++iVertex) {
      vertexIds[iVertex] = iVertex + 0.5;
    }

    var vertexIdBuffer = device.createBuffer(new BufferInfo(exports.BufferUsageBit.VERTEX | exports.BufferUsageBit.TRANSFER_DST, exports.MemoryUsageBit.DEVICE, vertexIds.byteLength, vertexIds.BYTES_PER_ELEMENT));
    vertexIdBuffer.update(vertexIds);
    return vertexIdBuffer;
  };

  _createClass(RenderingSubMesh, [{
    key: "attributes",
    get: function get() {
      return this._attributes;
    }
  }, {
    key: "vertexBuffers",
    get: function get() {
      return this._vertexBuffers;
    }
  }, {
    key: "indexBuffer",
    get: function get() {
      return this._indexBuffer;
    }
  }, {
    key: "indirectBuffer",
    get: function get() {
      return this._indirectBuffer;
    }
  }, {
    key: "primitiveMode",
    get: function get() {
      return this._primitiveMode;
    }
  }, {
    key: "geometricInfo",
    get: function get() {
      if (this._geometricInfo) {
        return this._geometricInfo;
      }

      if (this.mesh === undefined) {
        return {
          positions: new Float32Array(),
          indices: new Uint8Array(),
          boundingBox: {
            min: Vec3.ZERO,
            max: Vec3.ZERO
          }
        };
      }

      if (this.subMeshIdx === undefined) {
        return {
          positions: new Float32Array(),
          indices: new Uint8Array(),
          boundingBox: {
            min: Vec3.ZERO,
            max: Vec3.ZERO
          }
        };
      }

      var mesh = this.mesh;
      var index = this.subMeshIdx;
      var positions = mesh.readAttribute(index, exports.AttributeName.ATTR_POSITION);
      var indices = mesh.readIndices(index);
      var max = new Vec3();
      var min = new Vec3();
      var pAttri = this.attributes.find(function (element) {
        return element.name === exports.AttributeName.ATTR_POSITION;
      });

      if (pAttri) {
        var conut = FormatInfos[pAttri.format].count;

        if (conut === 2) {
          max.set(positions[0], positions[1], 0);
          min.set(positions[0], positions[1], 0);
        } else {
          max.set(positions[0], positions[1], positions[2]);
          min.set(positions[0], positions[1], positions[2]);
        }

        for (var i = 0; i < positions.length; i += conut) {
          if (conut === 2) {
            max.x = positions[i] > max.x ? positions[i] : max.x;
            max.y = positions[i + 1] > max.y ? positions[i + 1] : max.y;
            min.x = positions[i] < min.x ? positions[i] : min.x;
            min.y = positions[i + 1] < min.y ? positions[i + 1] : min.y;
          } else {
            max.x = positions[i] > max.x ? positions[i] : max.x;
            max.y = positions[i + 1] > max.y ? positions[i + 1] : max.y;
            max.z = positions[i + 2] > max.z ? positions[i + 2] : max.z;
            min.x = positions[i] < min.x ? positions[i] : min.x;
            min.y = positions[i + 1] < min.y ? positions[i + 1] : min.y;
            min.z = positions[i + 2] < min.z ? positions[i + 2] : min.z;
          }
        }
      }

      this._geometricInfo = {
        positions: positions,
        indices: indices,
        boundingBox: {
          max: max,
          min: min
        }
      };
      return this._geometricInfo;
    }
  }, {
    key: "flatBuffers",
    get: function get() {
      return this._flatBuffers;
    }
  }, {
    key: "jointMappedBuffers",
    get: function get() {
      var _this = this;

      if (this._jointMappedBuffers) {
        return this._jointMappedBuffers;
      }

      var buffers = this._jointMappedBuffers = [];
      var indices = this._jointMappedBufferIndices = [];

      if (!this.mesh || this.subMeshIdx === undefined) {
        return this._jointMappedBuffers = this.vertexBuffers;
      }

      var struct = this.mesh.struct;
      var prim = struct.primitives[this.subMeshIdx];

      if (!struct.jointMaps || prim.jointMapIndex === undefined || !struct.jointMaps[prim.jointMapIndex]) {
        return this._jointMappedBuffers = this.vertexBuffers;
      }

      var jointFormat;
      var jointOffset;
      var device = legacyCC.director.root.device;

      for (var i = 0; i < prim.vertexBundelIndices.length; i++) {
        var bundle = struct.vertexBundles[prim.vertexBundelIndices[i]];
        jointOffset = 0;
        jointFormat = exports.Format.UNKNOWN;

        for (var j = 0; j < bundle.attributes.length; j++) {
          var attr = bundle.attributes[j];

          if (attr.name === exports.AttributeName.ATTR_JOINTS) {
            jointFormat = attr.format;
            break;
          }

          jointOffset += FormatInfos[attr.format].size;
        }

        if (jointFormat) {
          (function () {
            var data = new Uint8Array(_this.mesh.data.buffer, bundle.view.offset, bundle.view.length);
            var dataView = new DataView(data.slice().buffer);
            var idxMap = struct.jointMaps[prim.jointMapIndex];
            mapBuffer(dataView, function (cur) {
              return idxMap.indexOf(cur);
            }, jointFormat, jointOffset, bundle.view.length, bundle.view.stride, dataView);
            var buffer = device.createBuffer(new BufferInfo(exports.BufferUsageBit.VERTEX | exports.BufferUsageBit.TRANSFER_DST, exports.MemoryUsageBit.DEVICE, bundle.view.length, bundle.view.stride));
            buffer.update(dataView.buffer);
            buffers.push(buffer);
            indices.push(i);
          })();
        } else {
          buffers.push(this.vertexBuffers[prim.vertexBundelIndices[i]]);
        }
      }

      if (this._vertexIdChannel) {
        buffers.push(this._allocVertexIdBuffer(device));
      }

      return buffers;
    }
  }, {
    key: "iaInfo",
    get: function get() {
      return this._iaInfo;
    }
  }]);

  return RenderingSubMesh;
}();

var _cachedArray = new Array(16);

var _currentHovered = null;
var pos = new Vec2();
var _touchEvents = [exports.NodeEventType.TOUCH_START, exports.NodeEventType.TOUCH_MOVE, exports.NodeEventType.TOUCH_END, exports.NodeEventType.TOUCH_CANCEL];
var _mouseEvents = [exports.NodeEventType.MOUSE_DOWN, exports.NodeEventType.MOUSE_ENTER, exports.NodeEventType.MOUSE_MOVE, exports.NodeEventType.MOUSE_LEAVE, exports.NodeEventType.MOUSE_UP, exports.NodeEventType.MOUSE_WHEEL];

function _touchStartHandler(touch, event) {
  var node = this.owner;

  if (!node || !node._uiProps.uiTransformComp) {
    return false;
  }

  touch.getUILocation(pos);

  if (node._uiProps.uiTransformComp.isHit(pos, this)) {
    event.type = exports.NodeEventType.TOUCH_START;
    event.touch = touch;
    event.bubbles = true;
    node.dispatchEvent(event);
    return true;
  }

  return false;
}

function _touchMoveHandler(touch, event) {
  var node = this.owner;

  if (!node || !node._uiProps.uiTransformComp) {
    return false;
  }

  event.type = exports.NodeEventType.TOUCH_MOVE;
  event.touch = touch;
  event.bubbles = true;
  node.dispatchEvent(event);
  return true;
}

function _touchEndHandler(touch, event) {
  var node = this.owner;

  if (!node || !node._uiProps.uiTransformComp) {
    return;
  }

  touch.getUILocation(pos);

  if (node._uiProps.uiTransformComp.isHit(pos, this)) {
    event.type = exports.NodeEventType.TOUCH_END;
  } else {
    event.type = exports.NodeEventType.TOUCH_CANCEL;
  }

  event.touch = touch;
  event.bubbles = true;
  node.dispatchEvent(event);
}

function _touchCancelHandler(touch, event) {
  var node = this.owner;

  if (!node || !node._uiProps.uiTransformComp) {
    return;
  }

  event.type = exports.NodeEventType.TOUCH_CANCEL;
  event.touch = touch;
  event.bubbles = true;
  node.dispatchEvent(event);
}

function _mouseDownHandler(event) {
  var node = this.owner;

  if (!node || !node._uiProps.uiTransformComp) {
    return;
  }

  pos = event.getUILocation();

  if (node._uiProps.uiTransformComp.isHit(pos, this)) {
    event.type = exports.NodeEventType.MOUSE_DOWN;
    event.bubbles = true;
    node.dispatchEvent(event);
  }
}

function _mouseMoveHandler(event) {
  var node = this.owner;

  if (!node || !node._uiProps.uiTransformComp) {
    return;
  }

  pos = event.getUILocation();

  var hit = node._uiProps.uiTransformComp.isHit(pos, this);

  if (hit) {
    if (!this._previousIn) {
      if (_currentHovered && _currentHovered.eventProcessor.mouseListener) {
        event.type = exports.NodeEventType.MOUSE_LEAVE;

        _currentHovered.dispatchEvent(event);

        if (_currentHovered.eventProcessor.mouseListener) {
          _currentHovered.eventProcessor.mouseListener._previousIn = false;
        }
      }

      _currentHovered = node;
      event.type = exports.NodeEventType.MOUSE_ENTER;
      node.dispatchEvent(event);
      this._previousIn = true;
    }

    event.type = exports.NodeEventType.MOUSE_MOVE;
    event.bubbles = true;
    node.dispatchEvent(event);
  } else if (this._previousIn) {
    event.type = exports.NodeEventType.MOUSE_LEAVE;
    node.dispatchEvent(event);
    this._previousIn = false;
    _currentHovered = null;
  } else {
    return;
  }

  event.propagationStopped = true;
}

function _mouseUpHandler(event) {
  var node = this.owner;

  if (!node || !node._uiProps.uiTransformComp) {
    return;
  }

  pos = event.getUILocation();

  if (node._uiProps.uiTransformComp.isHit(pos, this)) {
    event.type = exports.NodeEventType.MOUSE_UP;
    event.bubbles = true;
    node.dispatchEvent(event);
    event.propagationStopped = true;
  }
}

function _mouseWheelHandler(event) {
  var node = this.owner;

  if (!node || !node._uiProps.uiTransformComp) {
    return;
  }

  pos = event.getUILocation();

  if (node._uiProps.uiTransformComp.isHit(pos, this)) {
    event.type = exports.NodeEventType.MOUSE_WHEEL;
    event.bubbles = true;
    node.dispatchEvent(event);
    event.propagationStopped = true;
  }
}

function _doDispatchEvent(owner, event) {
  var target;
  var i = 0;
  event.target = owner;
  _cachedArray.length = 0;
  owner.eventProcessor.getCapturingTargets(event.type, _cachedArray);
  event.eventPhase = 1;

  for (i = _cachedArray.length - 1; i >= 0; --i) {
    target = _cachedArray[i];

    if (target.eventProcessor.capturingTargets) {
      event.currentTarget = target;
      target.eventProcessor.capturingTargets.emit(event.type, event, _cachedArray);

      if (event.propagationStopped) {
        _cachedArray.length = 0;
        return;
      }
    }
  }

  _cachedArray.length = 0;
  event.eventPhase = 2;
  event.currentTarget = owner;

  if (owner.eventProcessor.capturingTargets) {
    owner.eventProcessor.capturingTargets.emit(event.type, event);
  }

  if (!event.propagationImmediateStopped && owner.eventProcessor.bubblingTargets) {
    owner.eventProcessor.bubblingTargets.emit(event.type, event);
  }

  if (!event.propagationStopped && event.bubbles) {
    owner.eventProcessor.getBubblingTargets(event.type, _cachedArray);
    event.eventPhase = 3;

    for (i = 0; i < _cachedArray.length; ++i) {
      target = _cachedArray[i];

      if (target.eventProcessor.bubblingTargets) {
        event.currentTarget = target;
        target.eventProcessor.bubblingTargets.emit(event.type, event);

        if (event.propagationStopped) {
          _cachedArray.length = 0;
          return;
        }
      }
    }
  }

  _cachedArray.length = 0;
}

function _searchComponentsInParent(node, ctor) {
  if (ctor) {
    var index = 0;
    var list = [];

    for (var curr = node; curr && Node$1.isNode(curr); curr = curr.parent, ++index) {
      var comp = curr.getComponent(ctor);

      if (comp) {
        var next = {
          index: index,
          comp: comp
        };

        if (list) {
          list.push(next);
        } else {
          list = [next];
        }
      }
    }

    return list.length > 0 ? list : null;
  }

  return null;
}

function _checkListeners(node, events) {
  if (!node._persistNode) {
    if (node.eventProcessor.bubblingTargets) {
      for (var i = 0; i < events.length; ++i) {
        if (node.eventProcessor.bubblingTargets.hasEventListener(events[i])) {
          return true;
        }
      }
    }

    if (node.eventProcessor.capturingTargets) {
      for (var _i = 0; _i < events.length; ++_i) {
        if (node.eventProcessor.capturingTargets.hasEventListener(events[_i])) {
          return true;
        }
      }
    }

    return false;
  }

  return true;
}

var NodeEventProcessor = function () {
  _createClass(NodeEventProcessor, [{
    key: "node",
    get: function get() {
      return this._node;
    }
  }]);

  function NodeEventProcessor(node) {
    this.bubblingTargets = null;
    this.capturingTargets = null;
    this.touchListener = null;
    this.mouseListener = null;
    this._node = void 0;
    this._node = node;
  }

  var _proto = NodeEventProcessor.prototype;

  _proto.reattach = function reattach() {
    var currMask;
    this.node.walk(function (node) {
      if (!currMask) {
        currMask = _searchComponentsInParent(node, NodeEventProcessor._comp);
      }

      if (node.eventProcessor.touchListener) {
        node.eventProcessor.touchListener.mask = currMask;
      }

      if (node.eventProcessor.mouseListener) {
        node.eventProcessor.mouseListener.mask = currMask;
      }
    });
  };

  _proto.destroy = function destroy() {
    if (_currentHovered === this._node) {
      _currentHovered = null;
    }

    if (this.touchListener || this.mouseListener) {
      eventManager.removeListeners(this._node);

      if (this.touchListener) {
        this.touchListener.owner = null;
        this.touchListener.mask = null;
        this.touchListener = null;
      }

      if (this.mouseListener) {
        this.mouseListener.owner = null;
        this.mouseListener.mask = null;
        this.mouseListener = null;
      }
    }

    if (this.capturingTargets) this.capturingTargets.clear();
    if (this.bubblingTargets) this.bubblingTargets.clear();
  };

  _proto.on = function on(type, callback, target, useCapture) {
    var forDispatch = this._checknSetupSysEvent(type);

    if (forDispatch) {
      return this._onDispatch(type, callback, target, useCapture);
    } else {
      if (!this.bubblingTargets) {
        this.bubblingTargets = new CallbacksInvoker();
      }

      return this.bubblingTargets.on(type, callback, target);
    }
  };

  _proto.once = function once(type, callback, target, useCapture) {
    var _this = this;

    var forDispatch = this._checknSetupSysEvent(type);

    var listeners;

    if (forDispatch && useCapture) {
      listeners = this.capturingTargets = this.capturingTargets || new CallbacksInvoker();
    } else {
      listeners = this.bubblingTargets = this.bubblingTargets || new CallbacksInvoker();
    }

    listeners.on(type, callback, target, true);
    listeners.on(type, function () {
      _this.off(type, callback, target);
    }, undefined, true);
  };

  _proto.off = function off(type, callback, target, useCapture) {
    var touchEvent = _touchEvents.indexOf(type) !== -1;
    var mouseEvent = !touchEvent && _mouseEvents.indexOf(type) !== -1;

    if (touchEvent || mouseEvent) {
      this._offDispatch(type, callback, target, useCapture);

      if (touchEvent) {
        if (this.touchListener && !_checkListeners(this._node, _touchEvents)) {
          eventManager.removeListener(this.touchListener);
          this.touchListener = null;
        }
      } else if (mouseEvent) {
        if (this.mouseListener && !_checkListeners(this._node, _mouseEvents)) {
          eventManager.removeListener(this.mouseListener);
          this.mouseListener = null;
        }
      }
    } else if (this.bubblingTargets) {
      this.bubblingTargets.off(type, callback, target);
    }
  };

  _proto.emit = function emit(type, arg0, arg1, arg2, arg3, arg4) {
    if (this.bubblingTargets) {
      this.bubblingTargets.emit(type, arg0, arg1, arg2, arg3, arg4);
    }
  };

  _proto.dispatchEvent = function dispatchEvent(event) {
    _doDispatchEvent(this._node, event);

    _cachedArray.length = 0;
  };

  _proto.hasEventListener = function hasEventListener(type, callback, target) {
    var has = false;

    if (this.bubblingTargets) {
      has = this.bubblingTargets.hasEventListener(type, callback, target);
    }

    if (!has && this.capturingTargets) {
      has = this.capturingTargets.hasEventListener(type, callback, target);
    }

    return has;
  };

  _proto.targetOff = function targetOff(target) {
    if (this.capturingTargets) {
      this.capturingTargets.removeAll(target);
    }

    if (this.bubblingTargets) {
      this.bubblingTargets.removeAll(target);
    }

    if (this.touchListener && !_checkListeners(this.node, _touchEvents)) {
      eventManager.removeListener(this.touchListener);
      this.touchListener = null;
    }

    if (this.mouseListener && !_checkListeners(this.node, _mouseEvents)) {
      eventManager.removeListener(this.mouseListener);
      this.mouseListener = null;
    }
  };

  _proto.getCapturingTargets = function getCapturingTargets(type, targets) {
    var parent = this._node.parent;

    while (parent) {
      if (parent.eventProcessor.capturingTargets && parent.eventProcessor.capturingTargets.hasEventListener(type)) {
        targets.push(parent);
      }

      parent = parent.parent;
    }
  };

  _proto.getBubblingTargets = function getBubblingTargets(type, targets) {
    var parent = this._node.parent;

    while (parent) {
      if (parent.eventProcessor.bubblingTargets && parent.eventProcessor.bubblingTargets.hasEventListener(type)) {
        targets.push(parent);
      }

      parent = parent.parent;
    }
  };

  _proto._checknSetupSysEvent = function _checknSetupSysEvent(type) {
    var _this2 = this;

    var newAdded = false;
    var forDispatch = false;

    if (_touchEvents.indexOf(type) !== -1) {
      if (!this.touchListener) {
        this.touchListener = legacyCC.EventListener.create({
          event: legacyCC.EventListener.TOUCH_ONE_BY_ONE,
          swallowTouches: true,
          owner: this._node,
          mask: _searchComponentsInParent(this._node, NodeEventProcessor._comp),
          onTouchBegan: _touchStartHandler,
          onTouchMoved: _touchMoveHandler,
          onTouchEnded: _touchEndHandler,
          onTouchCancelled: _touchCancelHandler
        });
        eventManager.addListener(this.touchListener, this._node);
        newAdded = true;
      }

      forDispatch = true;
    } else if (_mouseEvents.indexOf(type) !== -1) {
      if (!this.mouseListener) {
        this.mouseListener = legacyCC.EventListener.create({
          event: legacyCC.EventListener.MOUSE,
          _previousIn: false,
          owner: this._node,
          mask: _searchComponentsInParent(this._node, NodeEventProcessor._comp),
          onMouseDown: _mouseDownHandler,
          onMouseMove: _mouseMoveHandler,
          onMouseUp: _mouseUpHandler,
          onMouseScroll: _mouseWheelHandler
        });
        eventManager.addListener(this.mouseListener, this._node);
        newAdded = true;
      }

      forDispatch = true;
    }

    if (newAdded && !this._node.activeInHierarchy) {
      legacyCC.director.getScheduler().schedule(function () {
        if (!_this2._node.activeInHierarchy) {
          eventManager.pauseTarget(_this2._node);
        }
      }, this._node, 0, 0, 0, false);
    }

    return forDispatch;
  };

  _proto._onDispatch = function _onDispatch(type, callback, target, useCapture) {
    if (typeof target === 'boolean') {
      useCapture = target;
      target = undefined;
    } else {
      useCapture = !!useCapture;
    }

    if (!callback) {
      errorID(6800);
      return undefined;
    }

    var listeners = null;

    if (useCapture) {
      listeners = this.capturingTargets = this.capturingTargets || new CallbacksInvoker();
    } else {
      listeners = this.bubblingTargets = this.bubblingTargets || new CallbacksInvoker();
    }

    if (!listeners.hasEventListener(type, callback, target)) {
      listeners.on(type, callback, target);
    }

    return callback;
  };

  _proto._offDispatch = function _offDispatch(type, callback, target, useCapture) {
    if (typeof target === 'boolean') {
      useCapture = target;
      target = undefined;
    } else {
      useCapture = !!useCapture;
    }

    if (!callback) {
      if (this.capturingTargets) {
        this.capturingTargets.removeAll(type);
      }

      if (this.bubblingTargets) {
        this.bubblingTargets.removeAll(type);
      }
    } else {
      var listeners = useCapture ? this.capturingTargets : this.bubblingTargets;

      if (listeners) {
        listeners.off(type, callback, target);
      }
    }
  };

  return NodeEventProcessor;
}();
NodeEventProcessor._comp = null;
legacyCC.NodeEventProcessor = NodeEventProcessor;

var _dec$p, _dec2$b, _class$p, _class2$m, _descriptor$j, _descriptor2$e, _descriptor3$a, _temp$m, _dec3$5, _dec4$3, _dec5$2, _class4$3, _class5$3, _descriptor4$9, _descriptor5$6, _descriptor6$3, _descriptor7$3, _temp2$1, _dec6$1, _dec7$1, _dec8$1, _dec9$1, _dec10$1, _dec11$1, _dec12$1, _dec13$1, _dec14$1, _dec15$1, _dec16$1, _dec17$1, _dec18$1, _dec19$1, _dec20$1, _dec21$1, _dec22$1, _dec23$1, _dec24$1, _dec25$1, _dec26, _dec27, _dec28, _dec29, _dec30, _dec31, _dec32, _dec33, _class7$1, _class8$1, _descriptor8$3, _descriptor9$2, _descriptor10$2, _descriptor11$1, _descriptor12$1, _descriptor13$1, _descriptor14$1, _descriptor15$1, _descriptor16$1, _class9, _temp3$3, _dec34, _dec35, _dec36, _dec37, _dec38, _dec39, _dec40, _dec41, _dec42, _dec43, _dec44, _dec45, _dec46, _dec47, _dec48, _dec49, _dec50, _dec51, _dec52, _dec53, _dec54, _dec55, _dec56, _dec57, _dec58, _dec59, _dec60, _class10$1, _class11$1, _descriptor17$1, _descriptor18$1, _descriptor19$1, _descriptor20$1, _descriptor21$1, _descriptor22$1, _descriptor23$1, _descriptor24$1, _descriptor25$1, _descriptor26, _descriptor27, _descriptor28, _descriptor29, _descriptor30, _descriptor31, _temp4$1, _dec61, _dec62, _class13$1, _class14$1, _descriptor32, _descriptor33, _descriptor34, _descriptor35, _temp5$1;

var _up = new Vec3(0, 1, 0);

var _v3 = new Vec3();

var _qt = new Quat();

var AmbientInfo = (_dec$p = ccclass('cc.AmbientInfo'), _dec2$b = type(CCFloat), _dec$p(_class$p = (_class2$m = (_temp$m = function () {
  function AmbientInfo() {
    _initializerDefineProperty(this, "_skyColor", _descriptor$j, this);

    _initializerDefineProperty(this, "_skyIllum", _descriptor2$e, this);

    _initializerDefineProperty(this, "_groundAlbedo", _descriptor3$a, this);

    this._resource = null;
  }

  var _proto = AmbientInfo.prototype;

  _proto.activate = function activate(resource) {
    this._resource = resource;

    this._resource.initialize(this);
  };

  _createClass(AmbientInfo, [{
    key: "skyColor",
    set: function set(val) {
      this._skyColor.set(val);

      if (this._resource) {
        this._resource.skyColor = this._skyColor;
      }
    },
    get: function get() {
      return this._skyColor;
    }
  }, {
    key: "skyIllum",
    set: function set(val) {
      this._skyIllum = val;

      if (this._resource) {
        this._resource.skyIllum = this.skyIllum;
      }
    },
    get: function get() {
      return this._skyIllum;
    }
  }, {
    key: "groundAlbedo",
    set: function set(val) {
      this._groundAlbedo.set(val);

      if (this._resource) {
        this._resource.groundAlbedo = this._groundAlbedo;
      }
    },
    get: function get() {
      return this._groundAlbedo;
    }
  }]);

  return AmbientInfo;
}(), _temp$m), (_descriptor$j = _applyDecoratedDescriptor(_class2$m.prototype, "_skyColor", [serializable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return new Color(51, 128, 204, 1.0);
  }
}), _descriptor2$e = _applyDecoratedDescriptor(_class2$m.prototype, "_skyIllum", [serializable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return Ambient.SKY_ILLUM;
  }
}), _descriptor3$a = _applyDecoratedDescriptor(_class2$m.prototype, "_groundAlbedo", [serializable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return new Color(51, 51, 51, 255);
  }
}), _applyDecoratedDescriptor(_class2$m.prototype, "skyColor", [editable], Object.getOwnPropertyDescriptor(_class2$m.prototype, "skyColor"), _class2$m.prototype), _applyDecoratedDescriptor(_class2$m.prototype, "skyIllum", [editable, _dec2$b], Object.getOwnPropertyDescriptor(_class2$m.prototype, "skyIllum"), _class2$m.prototype), _applyDecoratedDescriptor(_class2$m.prototype, "groundAlbedo", [editable], Object.getOwnPropertyDescriptor(_class2$m.prototype, "groundAlbedo"), _class2$m.prototype)), _class2$m)) || _class$p);
legacyCC.AmbientInfo = AmbientInfo;
var SkyboxInfo = (_dec3$5 = ccclass('cc.SkyboxInfo'), _dec4$3 = type(TextureCube), _dec5$2 = type(TextureCube), _dec3$5(_class4$3 = (_class5$3 = (_temp2$1 = function () {
  function SkyboxInfo() {
    _initializerDefineProperty(this, "_envmap", _descriptor4$9, this);

    _initializerDefineProperty(this, "_isRGBE", _descriptor5$6, this);

    _initializerDefineProperty(this, "_enabled", _descriptor6$3, this);

    _initializerDefineProperty(this, "_useIBL", _descriptor7$3, this);

    this._resource = null;
  }

  var _proto2 = SkyboxInfo.prototype;

  _proto2.activate = function activate(resource) {
    this._resource = resource;

    this._resource.initialize(this);

    this._resource.activate();
  };

  _createClass(SkyboxInfo, [{
    key: "enabled",
    set: function set(val) {
      if (this._enabled === val) return;
      this._enabled = val;

      if (this._resource) {
        this._resource.enabled = this._enabled;
      }
    },
    get: function get() {
      return this._enabled;
    }
  }, {
    key: "useIBL",
    set: function set(val) {
      this._useIBL = val;

      if (this._resource) {
        this._resource.useIBL = this._useIBL;
      }
    },
    get: function get() {
      return this._useIBL;
    }
  }, {
    key: "envmap",
    set: function set(val) {
      this._envmap = val;

      if (this._resource) {
        this._resource.envmap = this._envmap;
      }
    },
    get: function get() {
      return this._envmap;
    }
  }, {
    key: "isRGBE",
    set: function set(val) {
      this._isRGBE = val;

      if (this._resource) {
        this._resource.isRGBE = this._isRGBE;
      }
    },
    get: function get() {
      return this._isRGBE;
    }
  }]);

  return SkyboxInfo;
}(), _temp2$1), (_descriptor4$9 = _applyDecoratedDescriptor(_class5$3.prototype, "_envmap", [_dec4$3], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return null;
  }
}), _descriptor5$6 = _applyDecoratedDescriptor(_class5$3.prototype, "_isRGBE", [serializable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return false;
  }
}), _descriptor6$3 = _applyDecoratedDescriptor(_class5$3.prototype, "_enabled", [serializable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return false;
  }
}), _descriptor7$3 = _applyDecoratedDescriptor(_class5$3.prototype, "_useIBL", [serializable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return false;
  }
}), _applyDecoratedDescriptor(_class5$3.prototype, "enabled", [editable], Object.getOwnPropertyDescriptor(_class5$3.prototype, "enabled"), _class5$3.prototype), _applyDecoratedDescriptor(_class5$3.prototype, "useIBL", [editable], Object.getOwnPropertyDescriptor(_class5$3.prototype, "useIBL"), _class5$3.prototype), _applyDecoratedDescriptor(_class5$3.prototype, "envmap", [editable, _dec5$2], Object.getOwnPropertyDescriptor(_class5$3.prototype, "envmap"), _class5$3.prototype), _applyDecoratedDescriptor(_class5$3.prototype, "isRGBE", [editable], Object.getOwnPropertyDescriptor(_class5$3.prototype, "isRGBE"), _class5$3.prototype)), _class5$3)) || _class4$3);
legacyCC.SkyboxInfo = SkyboxInfo;
var FogInfo = (_dec6$1 = ccclass('cc.FogInfo'), _dec7$1 = type(FogType), _dec8$1 = visible(), _dec9$1 = type(CCFloat), _dec10$1 = range(), _dec11$1 = rangeStep(), _dec12$1 = displayOrder(), _dec13$1 = visible(), _dec14$1 = type(CCFloat), _dec15$1 = rangeStep(), _dec16$1 = displayOrder(), _dec17$1 = visible(), _dec18$1 = type(CCFloat), _dec19$1 = rangeStep(), _dec20$1 = displayOrder(), _dec21$1 = visible(), _dec22$1 = type(CCFloat), _dec23$1 = rangeMin(), _dec24$1 = rangeStep(), _dec25$1 = displayOrder(), _dec26 = visible(), _dec27 = type(CCFloat), _dec28 = rangeStep(), _dec29 = displayOrder(), _dec30 = visible(), _dec31 = type(CCFloat), _dec32 = rangeStep(), _dec33 = displayOrder(), _dec6$1(_class7$1 = (_class8$1 = (_temp3$3 = _class9 = function () {
  function FogInfo() {
    _initializerDefineProperty(this, "_type", _descriptor8$3, this);

    _initializerDefineProperty(this, "_fogColor", _descriptor9$2, this);

    _initializerDefineProperty(this, "_enabled", _descriptor10$2, this);

    _initializerDefineProperty(this, "_fogDensity", _descriptor11$1, this);

    _initializerDefineProperty(this, "_fogStart", _descriptor12$1, this);

    _initializerDefineProperty(this, "_fogEnd", _descriptor13$1, this);

    _initializerDefineProperty(this, "_fogAtten", _descriptor14$1, this);

    _initializerDefineProperty(this, "_fogTop", _descriptor15$1, this);

    _initializerDefineProperty(this, "_fogRange", _descriptor16$1, this);

    this._resource = null;
  }

  var _proto3 = FogInfo.prototype;

  _proto3.activate = function activate(resource) {
    this._resource = resource;

    this._resource.initialize(this);

    this._resource.activate();
  };

  _createClass(FogInfo, [{
    key: "enabled",
    set: function set(val) {
      if (this._enabled === val) return;
      this._enabled = val;

      if (this._resource) {
        this._resource.enabled = val;

        if (val) {
          this._resource.type = this._type;
        }
      }
    },
    get: function get() {
      return this._enabled;
    }
  }, {
    key: "fogColor",
    set: function set(val) {
      this._fogColor.set(val);

      if (this._resource) {
        this._resource.fogColor = this._fogColor;
      }
    },
    get: function get() {
      return this._fogColor;
    }
  }, {
    key: "type",
    get: function get() {
      return this._type;
    },
    set: function set(val) {
      this._type = val;

      if (this._resource) {
        this._resource.type = val;
      }
    }
  }, {
    key: "fogDensity",
    get: function get() {
      return this._fogDensity;
    },
    set: function set(val) {
      this._fogDensity = val;

      if (this._resource) {
        this._resource.fogDensity = val;
      }
    }
  }, {
    key: "fogStart",
    get: function get() {
      return this._fogStart;
    },
    set: function set(val) {
      this._fogStart = val;

      if (this._resource) {
        this._resource.fogStart = val;
      }
    }
  }, {
    key: "fogEnd",
    get: function get() {
      return this._fogEnd;
    },
    set: function set(val) {
      this._fogEnd = val;

      if (this._resource) {
        this._resource.fogEnd = val;
      }
    }
  }, {
    key: "fogAtten",
    get: function get() {
      return this._fogAtten;
    },
    set: function set(val) {
      this._fogAtten = val;

      if (this._resource) {
        this._resource.fogAtten = val;
      }
    }
  }, {
    key: "fogTop",
    get: function get() {
      return this._fogTop;
    },
    set: function set(val) {
      this._fogTop = val;

      if (this._resource) {
        this._resource.fogTop = val;
      }
    }
  }, {
    key: "fogRange",
    get: function get() {
      return this._fogRange;
    },
    set: function set(val) {
      this._fogRange = val;

      if (this._resource) {
        this._resource.fogRange = val;
      }
    }
  }]);

  return FogInfo;
}(), _class9.FogType = FogType, _temp3$3), (_descriptor8$3 = _applyDecoratedDescriptor(_class8$1.prototype, "_type", [serializable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return FogType.LINEAR;
  }
}), _descriptor9$2 = _applyDecoratedDescriptor(_class8$1.prototype, "_fogColor", [serializable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return new Color('#C8C8C8');
  }
}), _descriptor10$2 = _applyDecoratedDescriptor(_class8$1.prototype, "_enabled", [serializable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return false;
  }
}), _descriptor11$1 = _applyDecoratedDescriptor(_class8$1.prototype, "_fogDensity", [serializable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return 0.3;
  }
}), _descriptor12$1 = _applyDecoratedDescriptor(_class8$1.prototype, "_fogStart", [serializable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return 0.5;
  }
}), _descriptor13$1 = _applyDecoratedDescriptor(_class8$1.prototype, "_fogEnd", [serializable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return 300;
  }
}), _descriptor14$1 = _applyDecoratedDescriptor(_class8$1.prototype, "_fogAtten", [serializable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return 5;
  }
}), _descriptor15$1 = _applyDecoratedDescriptor(_class8$1.prototype, "_fogTop", [serializable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return 1.5;
  }
}), _descriptor16$1 = _applyDecoratedDescriptor(_class8$1.prototype, "_fogRange", [serializable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return 1.2;
  }
}), _applyDecoratedDescriptor(_class8$1.prototype, "enabled", [editable], Object.getOwnPropertyDescriptor(_class8$1.prototype, "enabled"), _class8$1.prototype), _applyDecoratedDescriptor(_class8$1.prototype, "fogColor", [editable], Object.getOwnPropertyDescriptor(_class8$1.prototype, "fogColor"), _class8$1.prototype), _applyDecoratedDescriptor(_class8$1.prototype, "type", [editable, _dec7$1], Object.getOwnPropertyDescriptor(_class8$1.prototype, "type"), _class8$1.prototype), _applyDecoratedDescriptor(_class8$1.prototype, "fogDensity", [_dec8$1, _dec9$1, _dec10$1, _dec11$1, slide, _dec12$1], Object.getOwnPropertyDescriptor(_class8$1.prototype, "fogDensity"), _class8$1.prototype), _applyDecoratedDescriptor(_class8$1.prototype, "fogStart", [_dec13$1, _dec14$1, _dec15$1, _dec16$1], Object.getOwnPropertyDescriptor(_class8$1.prototype, "fogStart"), _class8$1.prototype), _applyDecoratedDescriptor(_class8$1.prototype, "fogEnd", [_dec17$1, _dec18$1, _dec19$1, _dec20$1], Object.getOwnPropertyDescriptor(_class8$1.prototype, "fogEnd"), _class8$1.prototype), _applyDecoratedDescriptor(_class8$1.prototype, "fogAtten", [_dec21$1, _dec22$1, _dec23$1, _dec24$1, _dec25$1], Object.getOwnPropertyDescriptor(_class8$1.prototype, "fogAtten"), _class8$1.prototype), _applyDecoratedDescriptor(_class8$1.prototype, "fogTop", [_dec26, _dec27, _dec28, _dec29], Object.getOwnPropertyDescriptor(_class8$1.prototype, "fogTop"), _class8$1.prototype), _applyDecoratedDescriptor(_class8$1.prototype, "fogRange", [_dec30, _dec31, _dec32, _dec33], Object.getOwnPropertyDescriptor(_class8$1.prototype, "fogRange"), _class8$1.prototype)), _class8$1)) || _class7$1);
var ShadowsInfo = (_dec34 = ccclass('cc.ShadowsInfo'), _dec35 = type(ShadowType), _dec36 = visible(), _dec37 = visible(), _dec38 = type(CCFloat), _dec39 = visible(), _dec40 = range(), _dec41 = type(CCFloat), _dec42 = visible(), _dec43 = type(PCFType), _dec44 = visible(), _dec45 = type(CCInteger), _dec46 = visible(), _dec47 = type(CCFloat), _dec48 = visible(), _dec49 = type(CCFloat), _dec50 = visible(), _dec51 = type(ShadowSize), _dec52 = visible(), _dec53 = type(CCBoolean), _dec54 = visible(), _dec55 = type(CCFloat), _dec56 = visible(), _dec57 = type(CCFloat), _dec58 = visible(), _dec59 = type(CCFloat), _dec60 = visible(), _dec34(_class10$1 = (_class11$1 = (_temp4$1 = function () {
  function ShadowsInfo() {
    _initializerDefineProperty(this, "_type", _descriptor17$1, this);

    _initializerDefineProperty(this, "_enabled", _descriptor18$1, this);

    _initializerDefineProperty(this, "_normal", _descriptor19$1, this);

    _initializerDefineProperty(this, "_distance", _descriptor20$1, this);

    _initializerDefineProperty(this, "_shadowColor", _descriptor21$1, this);

    _initializerDefineProperty(this, "_autoAdapt", _descriptor22$1, this);

    _initializerDefineProperty(this, "_pcf", _descriptor23$1, this);

    _initializerDefineProperty(this, "_bias", _descriptor24$1, this);

    _initializerDefineProperty(this, "_normalBias", _descriptor25$1, this);

    _initializerDefineProperty(this, "_near", _descriptor26, this);

    _initializerDefineProperty(this, "_far", _descriptor27, this);

    _initializerDefineProperty(this, "_orthoSize", _descriptor28, this);

    _initializerDefineProperty(this, "_maxReceived", _descriptor29, this);

    _initializerDefineProperty(this, "_size", _descriptor30, this);

    _initializerDefineProperty(this, "_saturation", _descriptor31, this);

    this._resource = null;
  }

  var _proto4 = ShadowsInfo.prototype;

  _proto4.setPlaneFromNode = function setPlaneFromNode(node) {
    node.getWorldRotation(_qt);
    this.normal = Vec3.transformQuat(_v3, _up, _qt);
    node.getWorldPosition(_v3);
    this.distance = Vec3.dot(this._normal, _v3);
  };

  _proto4.activate = function activate(resource) {
    this._resource = resource;

    this._resource.initialize(this);

    this._resource.activate();
  };

  _createClass(ShadowsInfo, [{
    key: "enabled",
    set: function set(val) {
      if (this._enabled === val) return;
      this._enabled = val;

      if (this._resource) {
        this._resource.enabled = val;

        if (val) {
          this._resource.type = this._type;
        }
      }
    },
    get: function get() {
      return this._enabled;
    }
  }, {
    key: "type",
    set: function set(val) {
      this._type = val;

      if (this._resource) {
        this._resource.type = val;
      }
    },
    get: function get() {
      return this._type;
    }
  }, {
    key: "shadowColor",
    set: function set(val) {
      this._shadowColor.set(val);

      if (this._resource) {
        this._resource.shadowColor = val;
      }
    },
    get: function get() {
      return this._shadowColor;
    }
  }, {
    key: "normal",
    set: function set(val) {
      Vec3.copy(this._normal, val);

      if (this._resource) {
        this._resource.normal = val;
      }
    },
    get: function get() {
      return this._normal;
    }
  }, {
    key: "distance",
    set: function set(val) {
      this._distance = val;

      if (this._resource) {
        this._resource.distance = val;
      }
    },
    get: function get() {
      return this._distance;
    }
  }, {
    key: "saturation",
    set: function set(val) {
      if (val > 1.0) {
        this._saturation = val / val;

        if (this._resource) {
          this._resource.saturation = val / val;
        }
      } else {
        this._saturation = val;

        if (this._resource) {
          this._resource.saturation = val;
        }
      }
    },
    get: function get() {
      return this._saturation;
    }
  }, {
    key: "pcf",
    set: function set(val) {
      this._pcf = val;

      if (this._resource) {
        this._resource.pcf = val;
      }
    },
    get: function get() {
      return this._pcf;
    }
  }, {
    key: "maxReceived",
    set: function set(val) {
      this._maxReceived = val;

      if (this._resource) {
        this._resource.maxReceived = val;
      }
    },
    get: function get() {
      return this._maxReceived;
    }
  }, {
    key: "bias",
    set: function set(val) {
      this._bias = val;

      if (this._resource) {
        this._resource.bias = val;
      }
    },
    get: function get() {
      return this._bias;
    }
  }, {
    key: "normalBias",
    set: function set(val) {
      this._normalBias = val;

      if (this._resource) {
        this._resource.normalBias = val;
      }
    },
    get: function get() {
      return this._normalBias;
    }
  }, {
    key: "shadowMapSize",
    set: function set(value) {
      this._size.set(value, value);

      if (this._resource) {
        this._resource.size.set(value, value);

        this._resource.shadowMapDirty = true;
      }
    },
    get: function get() {
      return this._size.x;
    }
  }, {
    key: "size",
    get: function get() {
      return this._size;
    }
  }, {
    key: "autoAdapt",
    set: function set(val) {
      this._autoAdapt = val;

      if (this._resource) {
        this._resource.autoAdapt = val;
      }
    },
    get: function get() {
      return this._autoAdapt;
    }
  }, {
    key: "near",
    set: function set(val) {
      this._near = val;

      if (this._resource) {
        this._resource.near = val;
      }
    },
    get: function get() {
      return this._near;
    }
  }, {
    key: "far",
    set: function set(val) {
      this._far = val;

      if (this._resource) {
        this._resource.far = val;
      }
    },
    get: function get() {
      return this._far;
    }
  }, {
    key: "orthoSize",
    set: function set(val) {
      this._orthoSize = val;

      if (this._resource) {
        this._resource.orthoSize = val;
      }
    },
    get: function get() {
      return this._orthoSize;
    }
  }]);

  return ShadowsInfo;
}(), _temp4$1), (_descriptor17$1 = _applyDecoratedDescriptor(_class11$1.prototype, "_type", [serializable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return ShadowType.Planar;
  }
}), _descriptor18$1 = _applyDecoratedDescriptor(_class11$1.prototype, "_enabled", [serializable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return false;
  }
}), _descriptor19$1 = _applyDecoratedDescriptor(_class11$1.prototype, "_normal", [serializable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return new Vec3(0, 1, 0);
  }
}), _descriptor20$1 = _applyDecoratedDescriptor(_class11$1.prototype, "_distance", [serializable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return 0;
  }
}), _descriptor21$1 = _applyDecoratedDescriptor(_class11$1.prototype, "_shadowColor", [serializable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return new Color(0, 0, 0, 76);
  }
}), _descriptor22$1 = _applyDecoratedDescriptor(_class11$1.prototype, "_autoAdapt", [serializable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return true;
  }
}), _descriptor23$1 = _applyDecoratedDescriptor(_class11$1.prototype, "_pcf", [serializable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return PCFType.HARD;
  }
}), _descriptor24$1 = _applyDecoratedDescriptor(_class11$1.prototype, "_bias", [serializable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return 0.00001;
  }
}), _descriptor25$1 = _applyDecoratedDescriptor(_class11$1.prototype, "_normalBias", [serializable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return 0.0;
  }
}), _descriptor26 = _applyDecoratedDescriptor(_class11$1.prototype, "_near", [serializable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return 1;
  }
}), _descriptor27 = _applyDecoratedDescriptor(_class11$1.prototype, "_far", [serializable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return 30;
  }
}), _descriptor28 = _applyDecoratedDescriptor(_class11$1.prototype, "_orthoSize", [serializable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return 5;
  }
}), _descriptor29 = _applyDecoratedDescriptor(_class11$1.prototype, "_maxReceived", [serializable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return 4;
  }
}), _descriptor30 = _applyDecoratedDescriptor(_class11$1.prototype, "_size", [serializable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return new Vec2(512, 512);
  }
}), _descriptor31 = _applyDecoratedDescriptor(_class11$1.prototype, "_saturation", [serializable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return 0.75;
  }
}), _applyDecoratedDescriptor(_class11$1.prototype, "enabled", [editable], Object.getOwnPropertyDescriptor(_class11$1.prototype, "enabled"), _class11$1.prototype), _applyDecoratedDescriptor(_class11$1.prototype, "type", [editable, _dec35], Object.getOwnPropertyDescriptor(_class11$1.prototype, "type"), _class11$1.prototype), _applyDecoratedDescriptor(_class11$1.prototype, "shadowColor", [_dec36], Object.getOwnPropertyDescriptor(_class11$1.prototype, "shadowColor"), _class11$1.prototype), _applyDecoratedDescriptor(_class11$1.prototype, "normal", [_dec37], Object.getOwnPropertyDescriptor(_class11$1.prototype, "normal"), _class11$1.prototype), _applyDecoratedDescriptor(_class11$1.prototype, "distance", [_dec38, _dec39], Object.getOwnPropertyDescriptor(_class11$1.prototype, "distance"), _class11$1.prototype), _applyDecoratedDescriptor(_class11$1.prototype, "saturation", [editable, _dec40, slide, _dec41, _dec42], Object.getOwnPropertyDescriptor(_class11$1.prototype, "saturation"), _class11$1.prototype), _applyDecoratedDescriptor(_class11$1.prototype, "pcf", [_dec43, _dec44], Object.getOwnPropertyDescriptor(_class11$1.prototype, "pcf"), _class11$1.prototype), _applyDecoratedDescriptor(_class11$1.prototype, "maxReceived", [_dec45, _dec46], Object.getOwnPropertyDescriptor(_class11$1.prototype, "maxReceived"), _class11$1.prototype), _applyDecoratedDescriptor(_class11$1.prototype, "bias", [_dec47, _dec48], Object.getOwnPropertyDescriptor(_class11$1.prototype, "bias"), _class11$1.prototype), _applyDecoratedDescriptor(_class11$1.prototype, "normalBias", [_dec49, _dec50], Object.getOwnPropertyDescriptor(_class11$1.prototype, "normalBias"), _class11$1.prototype), _applyDecoratedDescriptor(_class11$1.prototype, "shadowMapSize", [_dec51, _dec52], Object.getOwnPropertyDescriptor(_class11$1.prototype, "shadowMapSize"), _class11$1.prototype), _applyDecoratedDescriptor(_class11$1.prototype, "autoAdapt", [_dec53, _dec54], Object.getOwnPropertyDescriptor(_class11$1.prototype, "autoAdapt"), _class11$1.prototype), _applyDecoratedDescriptor(_class11$1.prototype, "near", [_dec55, _dec56], Object.getOwnPropertyDescriptor(_class11$1.prototype, "near"), _class11$1.prototype), _applyDecoratedDescriptor(_class11$1.prototype, "far", [_dec57, _dec58], Object.getOwnPropertyDescriptor(_class11$1.prototype, "far"), _class11$1.prototype), _applyDecoratedDescriptor(_class11$1.prototype, "orthoSize", [_dec59, _dec60], Object.getOwnPropertyDescriptor(_class11$1.prototype, "orthoSize"), _class11$1.prototype)), _class11$1)) || _class10$1);
legacyCC.ShadowsInfo = ShadowsInfo;
var SceneGlobals = (_dec61 = ccclass('cc.SceneGlobals'), _dec62 = type(SkyboxInfo), _dec61(_class13$1 = (_class14$1 = (_temp5$1 = function () {
  function SceneGlobals() {
    _initializerDefineProperty(this, "ambient", _descriptor32, this);

    _initializerDefineProperty(this, "shadows", _descriptor33, this);

    _initializerDefineProperty(this, "_skybox", _descriptor34, this);

    _initializerDefineProperty(this, "fog", _descriptor35, this);
  }

  var _proto5 = SceneGlobals.prototype;

  _proto5.activate = function activate() {
    var sceneData = legacyCC.director.root.pipeline.pipelineSceneData;
    this.ambient.activate(sceneData.ambient);
    this.skybox.activate(sceneData.skybox);
    this.shadows.activate(sceneData.shadows);
    this.fog.activate(sceneData.fog);
  };

  _createClass(SceneGlobals, [{
    key: "skybox",
    get: function get() {
      return this._skybox;
    },
    set: function set(value) {
      this._skybox = value;
    }
  }]);

  return SceneGlobals;
}(), _temp5$1), (_descriptor32 = _applyDecoratedDescriptor(_class14$1.prototype, "ambient", [serializable, editable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return new AmbientInfo();
  }
}), _descriptor33 = _applyDecoratedDescriptor(_class14$1.prototype, "shadows", [serializable, editable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return new ShadowsInfo();
  }
}), _descriptor34 = _applyDecoratedDescriptor(_class14$1.prototype, "_skybox", [serializable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return new SkyboxInfo();
  }
}), _descriptor35 = _applyDecoratedDescriptor(_class14$1.prototype, "fog", [editable, serializable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return new FogInfo();
  }
}), _applyDecoratedDescriptor(_class14$1.prototype, "skybox", [editable, _dec62], Object.getOwnPropertyDescriptor(_class14$1.prototype, "skybox"), _class14$1.prototype)), _class14$1)) || _class13$1);
legacyCC.SceneGlobals = SceneGlobals;

var _dec$q, _class$q;
exports.replaceProperty(BaseNode.prototype, 'BaseNode', [{
  name: 'childrenCount',
  newName: 'children.length',
  customGetter: function customGetter() {
    return this.children.length;
  }
}]);
exports.replaceProperty(Node$1.prototype, 'Node', [{
  name: 'width',
  targetName: 'node.getComponent(UITransform)',
  customGetter: function customGetter() {
    return this._uiProps.uiTransformComp.width;
  },
  customSetter: function customSetter(value) {
    this._uiProps.uiTransformComp.width = value;
  }
}, {
  name: 'height',
  targetName: 'node.getComponent(UITransform)',
  customGetter: function customGetter() {
    return this._uiProps.uiTransformComp.height;
  },
  customSetter: function customSetter(value) {
    this._uiProps.uiTransformComp.height = value;
  }
}, {
  name: 'anchorX',
  targetName: 'node.getComponent(UITransform)',
  customGetter: function customGetter() {
    return this._uiProps.uiTransformComp.anchorX;
  },
  customSetter: function customSetter(value) {
    this._uiProps.uiTransformComp.anchorX = value;
  }
}, {
  name: 'anchorY',
  targetName: 'node.getComponent(UITransform)',
  customGetter: function customGetter() {
    return this._uiProps.uiTransformComp.anchorY;
  },
  customSetter: function customSetter(value) {
    this._uiProps.uiTransformComp.anchorY = value;
  }
}, {
  name: 'getAnchorPoint',
  targetName: 'node.getComponent(UITransform)',
  customFunction: function customFunction(out) {
    if (!out) {
      out = new Vec2();
    }

    out.set(this._uiProps.uiTransformComp.anchorPoint);
    return out;
  }
}, {
  name: 'setAnchorPoint',
  targetName: 'node.getComponent(UITransform)',
  customFunction: function customFunction(point, y) {
    this._uiProps.uiTransformComp.setAnchorPoint(point, y);
  }
}, {
  name: 'getContentSize',
  targetName: 'node.getComponent(UITransform)',
  customFunction: function customFunction(out) {
    if (!out) {
      out = new Size();
    }

    out.set(this._uiProps.uiTransformComp.contentSize);
    return out;
  }
}, {
  name: 'setContentSize',
  targetName: 'node.getComponent(UITransform)',
  customFunction: function customFunction(size, height) {
    if (typeof size === 'number') {
      this._uiProps.uiTransformComp.setContentSize(size, height);
    } else {
      this._uiProps.uiTransformComp.setContentSize(size);
    }
  }
}]);
exports.removeProperty(SceneGlobals.prototype, 'SceneGlobals.prototype', [{
  name: 'aspect'
}, {
  name: 'selfShadow'
}, {
  name: 'linear'
}, {
  name: 'packing'
}]);
exports.removeProperty(Node$1.prototype, 'Node.prototype', [{
  name: 'addLayer'
}, {
  name: 'removeLayer'
}]);
exports.removeProperty(Layers, 'Layers', [{
  name: 'All'
}, {
  name: 'RaycastMask'
}, {
  name: 'check'
}]);
exports.replaceProperty(Layers, 'Layers', [{
  name: 'Default',
  newName: 'DEFAULT',
  target: Layers.Enum,
  targetName: 'Layers.Enum'
}, {
  name: 'Always',
  newName: 'ALWAYS',
  target: Layers.Enum,
  targetName: 'Layers.Enum'
}, {
  name: 'IgnoreRaycast',
  newName: 'IGNORE_RAYCAST',
  target: Layers.Enum,
  targetName: 'Layers.Enum'
}, {
  name: 'Gizmos',
  newName: 'GIZMOS',
  target: Layers.Enum,
  targetName: 'Layers.Enum'
}, {
  name: 'Editor',
  newName: 'EDITOR',
  target: Layers.Enum,
  targetName: 'Layers.Enum'
}, {
  name: 'UI',
  newName: 'UI_3D',
  target: Layers.Enum,
  targetName: 'Layers.Enum'
}, {
  name: 'UI2D',
  newName: 'UI_2D',
  target: Layers.Enum,
  targetName: 'Layers.Enum'
}, {
  name: 'SceneGizmo',
  newName: 'SCENE_GIZMO',
  target: Layers.Enum,
  targetName: 'Layers.Enum'
}, {
  name: 'makeInclusiveMask',
  newName: 'makeMaskInclude',
  target: Layers,
  targetName: 'Layers'
}, {
  name: 'makeExclusiveMask',
  newName: 'makeMaskExclude',
  target: Layers,
  targetName: 'Layers'
}]);
exports.removeProperty(Layers.Enum, 'Layers.Enum', [{
  name: 'ALWAYS'
}]);
exports.removeProperty(Layers.BitMask, 'Layers.BitMask', [{
  name: 'ALWAYS'
}]);
var HideInHierarchy$1 = CCObject.Flags.HideInHierarchy;
var DontSave$1 = CCObject.Flags.DontSave;
var PrivateNode = (_dec$q = ccclass('cc.PrivateNode'), _dec$q(_class$q = function (_Node) {
  _inheritsLoose(PrivateNode, _Node);

  function PrivateNode(name) {
    var _this;

    _this = _Node.call(this, name) || this;
    warnID(12003, _this.name);
    _this.hideFlags |= DontSave$1 | HideInHierarchy$1;
    return _this;
  }

  return PrivateNode;
}(Node$1)) || _class$q);

legacyCC.PrivateNode = PrivateNode;

var _dec$r, _class$r, _class2$n, _descriptor$k, _descriptor2$f, _temp$n;
var Scene = (_dec$r = ccclass('cc.Scene'), _dec$r(_class$r = (_class2$n = (_temp$n = function (_BaseNode) {
  _inheritsLoose(Scene, _BaseNode);

  var _proto = Scene.prototype;

  _proto._updateScene = function _updateScene() {
    this._scene = this;
  };

  _proto._init = function _init() {
  };

  _createClass(Scene, [{
    key: "renderScene",
    get: function get() {
      return this._renderScene;
    }
  }, {
    key: "globals",
    get: function get() {
      return this._globals;
    }
  }, {
    key: "native",
    get: function get() {
      return this._nativeObj;
    }
  }]);

  function Scene(name) {
    var _this;

    _this = _BaseNode.call(this, name) || this;

    _initializerDefineProperty(_this, "autoReleaseAssets", _descriptor$k, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_globals", _descriptor2$f, _assertThisInitialized(_this));

    _this._renderScene = null;
    _this.dependAssets = null;
    _this._inited = void 0;
    _this._prefabSyncedInLiveReload = false;
    _this._pos = Vec3.ZERO;
    _this._rot = Quat.IDENTITY;
    _this._scale = Vec3.ONE;
    _this._mat = Mat4.IDENTITY;
    _this._dirtyFlags = 0;
    _this._activeInHierarchy = false;

    if (legacyCC.director && legacyCC.director.root) {
      _this._renderScene = legacyCC.director.root.createScene({});
    }

    _this._inited = legacyCC.game ? !legacyCC.game._isCloning : true;

    _this._init();

    return _this;
  }

  _proto.destroy = function destroy() {
    var success = CCObject.prototype.destroy.call(this);

    if (success) {
      var children = this._children;

      for (var i = 0; i < children.length; ++i) {
        children[i].active = false;
      }
    }

    if (this._renderScene) legacyCC.director.root.destroyScene(this._renderScene);
    this._active = false;
    this._activeInHierarchy = false;
    return success;
  };

  _proto.addComponent = function addComponent() {
    throw new Error(getError(3822));
  };

  _proto._onHierarchyChanged = function _onHierarchyChanged() {};

  _proto._onBatchCreated = function _onBatchCreated(dontSyncChildPrefab) {
    _BaseNode.prototype._onBatchCreated.call(this, dontSyncChildPrefab);

    var len = this._children.length;

    for (var i = 0; i < len; ++i) {
      this.children[i]._siblingIndex = i;

      this._children[i]._onBatchCreated(dontSyncChildPrefab);
    }

    applyTargetOverrides(this);
  };

  _proto.getPosition = function getPosition(out) {
    return Vec3.copy(out || new Vec3(), Vec3.ZERO);
  };

  _proto.getRotation = function getRotation(out) {
    return Quat.copy(out || new Quat(), Quat.IDENTITY);
  };

  _proto.getScale = function getScale(out) {
    return Vec3.copy(out || new Vec3(), Vec3.ONE);
  };

  _proto.getWorldPosition = function getWorldPosition(out) {
    return Vec3.copy(out || new Vec3(), Vec3.ZERO);
  };

  _proto.getWorldRotation = function getWorldRotation(out) {
    return Quat.copy(out || new Quat(), Quat.IDENTITY);
  };

  _proto.getWorldScale = function getWorldScale(out) {
    return Vec3.copy(out || new Vec3(), Vec3.ONE);
  };

  _proto.getWorldMatrix = function getWorldMatrix(out) {
    return Mat4.copy(out || new Mat4(), Mat4.IDENTITY);
  };

  _proto.getWorldRS = function getWorldRS(out) {
    return Mat4.copy(out || new Mat4(), Mat4.IDENTITY);
  };

  _proto.getWorldRT = function getWorldRT(out) {
    return Mat4.copy(out || new Mat4(), Mat4.IDENTITY);
  };

  _proto.updateWorldTransform = function updateWorldTransform() {};

  _proto._instantiate = function _instantiate() {};

  _proto._load = function _load() {
    if (!this._inited) {

      this._onBatchCreated(EDITOR );

      this._inited = true;
    }

    this.walk(BaseNode._setScene);
  };

  _proto._activate = function _activate(active) {
    active = active !== false;

    legacyCC.director._nodeActivator.activateNode(this, active);

    this._globals.activate();
  };

  _createClass(Scene, [{
    key: "position",
    get: function get() {
      return Vec3.ZERO;
    }
  }, {
    key: "worldPosition",
    get: function get() {
      return Vec3.ZERO;
    }
  }, {
    key: "rotation",
    get: function get() {
      return Quat.IDENTITY;
    }
  }, {
    key: "worldRotation",
    get: function get() {
      return Quat.IDENTITY;
    }
  }, {
    key: "scale",
    get: function get() {
      return Vec3.ONE;
    }
  }, {
    key: "worldScale",
    get: function get() {
      return Vec3.ONE;
    }
  }, {
    key: "eulerAngles",
    get: function get() {
      return Vec3.ZERO;
    }
  }, {
    key: "worldMatrix",
    get: function get() {
      return Mat4.IDENTITY;
    }
  }]);

  return Scene;
}(BaseNode), _temp$n), (_applyDecoratedDescriptor(_class2$n.prototype, "globals", [editable], Object.getOwnPropertyDescriptor(_class2$n.prototype, "globals"), _class2$n.prototype), _descriptor$k = _applyDecoratedDescriptor(_class2$n.prototype, "autoReleaseAssets", [serializable, editable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return false;
  }
}), _descriptor2$f = _applyDecoratedDescriptor(_class2$n.prototype, "_globals", [serializable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return new SceneGlobals();
  }
})), _class2$n)) || _class$r);
legacyCC.Scene = Scene;

function find(path, referenceNode) {
  if (!referenceNode) {
    var scene = legacyCC.director.getScene();

    if (!scene) {

      return null;
    }

    referenceNode = scene;
  }

  return referenceNode.getChildByPath(path);
}
legacyCC.find = find;

var fastRemoveAt$2 = array.fastRemoveAt;
var IsStartCalled$1 = CCObject.Flags.IsStartCalled;
var IsOnEnableCalled$1 = CCObject.Flags.IsOnEnableCalled;
var IsEditorOnEnableCalled$1 = CCObject.Flags.IsEditorOnEnableCalled;

function sortedIndex(array, comp) {
  var order = comp.constructor._executionOrder;
  var id = comp._id;
  var l = 0;

  for (var h = array.length - 1, m = h >>> 1; l <= h; m = l + h >>> 1) {
    var test = array[m];
    var testOrder = test.constructor._executionOrder;

    if (testOrder > order) {
      h = m - 1;
    } else if (testOrder < order) {
      l = m + 1;
    } else {
      var testId = test._id;

      if (testId > id) {
        h = m - 1;
      } else if (testId < id) {
        l = m + 1;
      } else {
        return m;
      }
    }
  }

  return ~l;
}

function stableRemoveInactive(iterator, flagToClear) {
  var array = iterator.array;
  var next = iterator.i + 1;

  while (next < array.length) {
    var comp = array[next];

    if (comp.node._activeInHierarchy) {
      ++next;
    } else {
      iterator.removeAt(next);

      if (flagToClear) {
        comp._objFlags &= ~flagToClear;
      }
    }
  }
}

var LifeCycleInvoker = function LifeCycleInvoker(invokeFunc) {
  this._zero = void 0;
  this._neg = void 0;
  this._pos = void 0;
  this._invoke = void 0;
  var Iterator = MutableForwardIterator;
  this._zero = new Iterator([]);
  this._neg = new Iterator([]);
  this._pos = new Iterator([]);

  this._invoke = invokeFunc;
};
LifeCycleInvoker.stableRemoveInactive = stableRemoveInactive;

function compareOrder(a, b) {
  return a.constructor._executionOrder - b.constructor._executionOrder;
}

var OneOffInvoker = function (_LifeCycleInvoker) {
  _inheritsLoose(OneOffInvoker, _LifeCycleInvoker);

  function OneOffInvoker() {
    return _LifeCycleInvoker.apply(this, arguments) || this;
  }

  var _proto = OneOffInvoker.prototype;

  _proto.add = function add(comp) {
    var order = comp.constructor._executionOrder;
    (order === 0 ? this._zero : order < 0 ? this._neg : this._pos).array.push(comp);
  };

  _proto.remove = function remove(comp) {
    var order = comp.constructor._executionOrder;
    (order === 0 ? this._zero : order < 0 ? this._neg : this._pos).fastRemove(comp);
  };

  _proto.cancelInactive = function cancelInactive(flagToClear) {
    stableRemoveInactive(this._zero, flagToClear);
    stableRemoveInactive(this._neg, flagToClear);
    stableRemoveInactive(this._pos, flagToClear);
  };

  _proto.invoke = function invoke() {
    var compsNeg = this._neg;

    if (compsNeg.array.length > 0) {
      compsNeg.array.sort(compareOrder);

      this._invoke(compsNeg);

      compsNeg.array.length = 0;
    }

    this._invoke(this._zero);

    this._zero.array.length = 0;
    var compsPos = this._pos;

    if (compsPos.array.length > 0) {
      compsPos.array.sort(compareOrder);

      this._invoke(compsPos);

      compsPos.array.length = 0;
    }
  };

  return OneOffInvoker;
}(LifeCycleInvoker);

var ReusableInvoker = function (_LifeCycleInvoker2) {
  _inheritsLoose(ReusableInvoker, _LifeCycleInvoker2);

  function ReusableInvoker() {
    return _LifeCycleInvoker2.apply(this, arguments) || this;
  }

  var _proto2 = ReusableInvoker.prototype;

  _proto2.add = function add(comp) {
    var order = comp.constructor._executionOrder;

    if (order === 0) {
      this._zero.array.push(comp);
    } else {
      var _array = order < 0 ? this._neg.array : this._pos.array;

      var i = sortedIndex(_array, comp);

      if (i < 0) {
        _array.splice(~i, 0, comp);
      }
    }
  };

  _proto2.remove = function remove(comp) {
    var order = comp.constructor._executionOrder;

    if (order === 0) {
      this._zero.fastRemove(comp);
    } else {
      var iterator = order < 0 ? this._neg : this._pos;
      var i = sortedIndex(iterator.array, comp);

      if (i >= 0) {
        iterator.removeAt(i);
      }
    }
  };

  _proto2.invoke = function invoke(dt) {
    if (this._neg.array.length > 0) {
      this._invoke(this._neg, dt);
    }

    this._invoke(this._zero, dt);

    if (this._pos.array.length > 0) {
      this._invoke(this._pos, dt);
    }
  };

  return ReusableInvoker;
}(LifeCycleInvoker);

function createInvokeImplJit(code, useDt, ensureFlag) {
  var body = "" + ('var a=it.array;' + 'for(it.i=0;it.i<a.length;++it.i){' + 'var c=a[it.i];') + code + "}";
  var fastPath = useDt ? Function('it', 'dt', body) : Function('it', body);
  var singleInvoke = Function('c', 'dt', code);
  return createInvokeImpl(singleInvoke, fastPath, ensureFlag);
}
function createInvokeImpl(singleInvoke, fastPath, ensureFlag) {
  return function (iterator, dt) {
    try {
      fastPath(iterator, dt);
    } catch (e) {
      legacyCC._throw(e);

      var _array2 = iterator.array;

      if (ensureFlag) {
        _array2[iterator.i]._objFlags |= ensureFlag;
      }

      ++iterator.i;

      for (; iterator.i < _array2.length; ++iterator.i) {
        try {
          singleInvoke(_array2[iterator.i], dt);
        } catch (e) {
          legacyCC._throw(e);

          if (ensureFlag) {
            _array2[iterator.i]._objFlags |= ensureFlag;
          }
        }
      }
    }
  };
}
var invokeStart =  createInvokeImplJit("c.start();c._objFlags|=" + IsStartCalled$1, false, IsStartCalled$1) ;
var invokeUpdate =  createInvokeImplJit('c.update(dt)', true) ;
var invokeLateUpdate =  createInvokeImplJit('c.lateUpdate(dt)', true) ;
var invokeOnEnable =  function (iterator) {
  var compScheduler = legacyCC.director._compScheduler;
  var array = iterator.array;

  for (iterator.i = 0; iterator.i < array.length; ++iterator.i) {
    var comp = array[iterator.i];

    if (comp._enabled) {
      comp.onEnable();
      var deactivatedDuringOnEnable = !comp.node._activeInHierarchy;

      if (!deactivatedDuringOnEnable) {
        compScheduler._onEnabled(comp);
      }
    }
  }
};
var ComponentScheduler = function () {
  function ComponentScheduler() {
    this.startInvoker = void 0;
    this.updateInvoker = void 0;
    this.lateUpdateInvoker = void 0;
    this._deferredComps = [];
    this._updating = void 0;
    this.unscheduleAll();
  }

  var _proto3 = ComponentScheduler.prototype;

  _proto3.unscheduleAll = function unscheduleAll() {
    this.startInvoker = new OneOffInvoker(invokeStart);
    this.updateInvoker = new ReusableInvoker(invokeUpdate);
    this.lateUpdateInvoker = new ReusableInvoker(invokeLateUpdate);
    this._updating = false;
  };

  _proto3._onEnabled = function _onEnabled(comp) {
    legacyCC.director.getScheduler().resumeTarget(comp);
    comp._objFlags |= IsOnEnableCalled$1;

    if (this._updating) {
      this._deferredComps.push(comp);
    } else {
      this._scheduleImmediate(comp);
    }
  };

  _proto3._onDisabled = function _onDisabled(comp) {
    legacyCC.director.getScheduler().pauseTarget(comp);
    comp._objFlags &= ~IsOnEnableCalled$1;

    var index = this._deferredComps.indexOf(comp);

    if (index >= 0) {
      fastRemoveAt$2(this._deferredComps, index);
      return;
    }

    if (comp.start && !(comp._objFlags & IsStartCalled$1)) {
      this.startInvoker.remove(comp);
    }

    if (comp.update) {
      this.updateInvoker.remove(comp);
    }

    if (comp.lateUpdate) {
      this.lateUpdateInvoker.remove(comp);
    }
  };

  _proto3.enableComp = function enableComp(comp, invoker) {
    if (!(comp._objFlags & IsOnEnableCalled$1)) {
      if (comp.onEnable) {
        if (invoker) {
          invoker.add(comp);
          return;
        } else {
          comp.onEnable();
          var deactivatedDuringOnEnable = !comp.node._activeInHierarchy;

          if (deactivatedDuringOnEnable) {
            return;
          }
        }
      }

      this._onEnabled(comp);
    }
  };

  _proto3.disableComp = function disableComp(comp) {
    if (comp._objFlags & IsOnEnableCalled$1) {
      if (comp.onDisable) {
        comp.onDisable();
      }

      this._onDisabled(comp);
    }
  };

  _proto3.startPhase = function startPhase() {
    this._updating = true;
    this.startInvoker.invoke();

    this._startForNewComps();
  };

  _proto3.updatePhase = function updatePhase(dt) {
    this.updateInvoker.invoke(dt);
  };

  _proto3.lateUpdatePhase = function lateUpdatePhase(dt) {
    this.lateUpdateInvoker.invoke(dt);
    this._updating = false;

    this._startForNewComps();
  };

  _proto3._startForNewComps = function _startForNewComps() {
    if (this._deferredComps.length > 0) {
      this._deferredSchedule();

      this.startInvoker.invoke();
    }
  };

  _proto3._scheduleImmediate = function _scheduleImmediate(comp) {
    if (typeof comp.start === 'function' && !(comp._objFlags & IsStartCalled$1)) {
      this.startInvoker.add(comp);
    }

    if (typeof comp.update === 'function') {
      this.updateInvoker.add(comp);
    }

    if (typeof comp.lateUpdate === 'function') {
      this.lateUpdateInvoker.add(comp);
    }
  };

  _proto3._deferredSchedule = function _deferredSchedule() {
    var comps = this._deferredComps;

    for (var i = 0, len = comps.length; i < len; i++) {
      this._scheduleImmediate(comps[i]);
    }

    comps.length = 0;
  };

  return ComponentScheduler;
}();

var MAX_POOL_SIZE = 4;
var IsPreloadStarted$1 = CCObject.Flags.IsPreloadStarted;
var IsOnLoadStarted$1 = CCObject.Flags.IsOnLoadStarted;
var IsOnLoadCalled$2 = CCObject.Flags.IsOnLoadCalled;
var Deactivating$2 = CCObject.Flags.Deactivating;

var UnsortedInvoker = function (_LifeCycleInvoker) {
  _inheritsLoose(UnsortedInvoker, _LifeCycleInvoker);

  function UnsortedInvoker() {
    return _LifeCycleInvoker.apply(this, arguments) || this;
  }

  var _proto = UnsortedInvoker.prototype;

  _proto.add = function add(comp) {
    this._zero.array.push(comp);
  };

  _proto.remove = function remove(comp) {
    this._zero.fastRemove(comp);
  };

  _proto.cancelInactive = function cancelInactive(flagToClear) {
    LifeCycleInvoker.stableRemoveInactive(this._zero, flagToClear);
  };

  _proto.invoke = function invoke() {
    this._invoke(this._zero);

    this._zero.array.length = 0;
  };

  return UnsortedInvoker;
}(LifeCycleInvoker);

var invokePreload =  createInvokeImplJit('c.__preload();') ;
var invokeOnLoad =  createInvokeImplJit("c.onLoad();c._objFlags|=" + IsOnLoadCalled$2, false, IsOnLoadCalled$2) ;
var activateTasksPool = new Pool$1(MAX_POOL_SIZE);

activateTasksPool.get = function getActivateTask() {
  var task = this._get() || {
    preload: new UnsortedInvoker(invokePreload),
    onLoad: new OneOffInvoker(invokeOnLoad),
    onEnable: new OneOffInvoker(invokeOnEnable)
  };
  task.preload._zero.i = -1;
  var invoker = task.onLoad;
  invoker._zero.i = -1;
  invoker._neg.i = -1;
  invoker._pos.i = -1;
  invoker = task.onEnable;
  invoker._zero.i = -1;
  invoker._neg.i = -1;
  invoker._pos.i = -1;
  return task;
};

function _componentCorrupted(node, comp, index) {

  if (comp) {
    node._removeComponent(comp);
  } else {
    array.removeAt(node._components, index);
  }
}

var NodeActivator = function () {
  function NodeActivator() {
    this.resetComp = void 0;
    this._activatingStack = void 0;
    this.reset();
  }

  var _proto2 = NodeActivator.prototype;

  _proto2.reset = function reset() {
    this._activatingStack = [];
  };

  _proto2.activateNode = function activateNode(node, active) {
    if (active) {
      var task = activateTasksPool.get();

      this._activatingStack.push(task);

      this._activateNodeRecursively(node, task.preload, task.onLoad, task.onEnable);

      task.preload.invoke();
      task.onLoad.invoke();
      task.onEnable.invoke();

      this._activatingStack.pop();

      activateTasksPool.put(task);
    } else {
      this._deactivateNodeRecursively(node);

      var stack = this._activatingStack;

      for (var _iterator = _createForOfIteratorHelperLoose(stack), _step; !(_step = _iterator()).done;) {
        var lastTask = _step.value;
        lastTask.preload.cancelInactive(IsPreloadStarted$1);
        lastTask.onLoad.cancelInactive(IsOnLoadStarted$1);
        lastTask.onEnable.cancelInactive();
      }
    }

    node.emit('active-in-hierarchy-changed', node);
  };

  _proto2.activateComp = function activateComp(comp, preloadInvoker, onLoadInvoker, onEnableInvoker) {
    if (!isValid(comp, true)) {
      return;
    }

    if (!(comp._objFlags & IsPreloadStarted$1)) {
      comp._objFlags |= IsPreloadStarted$1;

      if (comp.__preload) {
        if (preloadInvoker) {
          preloadInvoker.add(comp);
        } else {
          comp.__preload();
        }
      }
    }

    if (!(comp._objFlags & IsOnLoadStarted$1)) {
      comp._objFlags |= IsOnLoadStarted$1;

      if (comp.onLoad) {
        if (onLoadInvoker) {
          onLoadInvoker.add(comp);
        } else {
          comp.onLoad();
          comp._objFlags |= IsOnLoadCalled$2;
        }
      } else {
        comp._objFlags |= IsOnLoadCalled$2;
      }
    }

    if (comp._enabled) {
      var deactivatedOnLoading = !comp.node._activeInHierarchy;

      if (deactivatedOnLoading) {
        return;
      }

      legacyCC.director._compScheduler.enableComp(comp, onEnableInvoker);
    }
  };

  _proto2.destroyComp = function destroyComp(comp) {
    legacyCC.director._compScheduler.disableComp(comp);

    if (comp.onDestroy && comp._objFlags & IsOnLoadCalled$2) {
      comp.onDestroy();
    }
  };

  _proto2._activateNodeRecursively = function _activateNodeRecursively(node, preloadInvoker, onLoadInvoker, onEnableInvoker) {
    if (node._objFlags & Deactivating$2) {
      errorID(3816, node.name);
      return;
    }

    node._activeInHierarchy = true;
    var originCount = node._components.length;

    for (var i = 0; i < originCount; ++i) {
      var component = node._components[i];

      if (component instanceof legacyCC.Component) {
        this.activateComp(component, preloadInvoker, onLoadInvoker, onEnableInvoker);
      } else {
        _componentCorrupted(node, component, i);

        --i;
        --originCount;
      }
    }

    node._childArrivalOrder = node._children.length;

    for (var _i = 0, len = node._children.length; _i < len; ++_i) {
      var child = node._children[_i];

      if (child._active) {
        this._activateNodeRecursively(child, preloadInvoker, onLoadInvoker, onEnableInvoker);
      }
    }

    node._onPostActivated(true);
  };

  _proto2._deactivateNodeRecursively = function _deactivateNodeRecursively(node) {

    node._objFlags |= Deactivating$2;
    node._activeInHierarchy = false;
    var originCount = node._components.length;

    for (var c = 0; c < originCount; ++c) {
      var component = node._components[c];

      if (component._enabled) {
        legacyCC.director._compScheduler.disableComp(component);

        if (node._activeInHierarchy) {
          node._objFlags &= ~Deactivating$2;
          return;
        }
      }
    }

    for (var i = 0, len = node._children.length; i < len; ++i) {
      var child = node._children[i];

      if (child._activeInHierarchy) {
        this._deactivateNodeRecursively(child);

        if (node._activeInHierarchy) {
          node._objFlags &= ~Deactivating$2;
          return;
        }
      }
    }

    node._onPostActivated(false);

    node._objFlags &= ~Deactivating$2;
  };

  return NodeActivator;
}();

var _dec$s, _class$s, _class2$o, _descriptor$l, _temp$o;
var SceneAsset = (_dec$s = ccclass('cc.SceneAsset'), _dec$s(_class$s = (_class2$o = (_temp$o = function (_Asset) {
  _inheritsLoose(SceneAsset, _Asset);

  function SceneAsset() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _Asset.call.apply(_Asset, [this].concat(args)) || this;

    _initializerDefineProperty(_this, "scene", _descriptor$l, _assertThisInitialized(_this));

    return _this;
  }

  var _proto = SceneAsset.prototype;

  _proto.initDefault = function initDefault(uuid) {
    _Asset.prototype.initDefault.call(this, uuid);

    this.scene = new Scene('New Scene');
  };

  _proto.validate = function validate() {
    return !!this.scene;
  };

  return SceneAsset;
}(Asset), _temp$o), (_descriptor$l = _applyDecoratedDescriptor(_class2$o.prototype, "scene", [editable, serializable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return null;
  }
})), _class2$o)) || _class$s);
legacyCC.SceneAsset = SceneAsset;

var _dec$t, _class$t, _class2$p, _descriptor$m, _temp$p;
var TextAsset = (_dec$t = ccclass('cc.TextAsset'), _dec$t(_class$t = (_class2$p = (_temp$p = function (_Asset) {
  _inheritsLoose(TextAsset, _Asset);

  function TextAsset() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _Asset.call.apply(_Asset, [this].concat(args)) || this;

    _initializerDefineProperty(_this, "text", _descriptor$m, _assertThisInitialized(_this));

    return _this;
  }

  var _proto = TextAsset.prototype;

  _proto.toString = function toString() {
    return this.text;
  };

  return TextAsset;
}(Asset), _temp$p), (_descriptor$m = _applyDecoratedDescriptor(_class2$p.prototype, "text", [serializable, editable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return '';
  }
})), _class2$p)) || _class$t);
legacyCC.TextAsset = TextAsset;

var _dec$u, _class$u, _class2$q, _descriptor$n, _temp$q;
var JsonAsset = (_dec$u = ccclass('cc.JsonAsset'), _dec$u(_class$u = (_class2$q = (_temp$q = function (_Asset) {
  _inheritsLoose(JsonAsset, _Asset);

  function JsonAsset() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _Asset.call.apply(_Asset, [this].concat(args)) || this;

    _initializerDefineProperty(_this, "json", _descriptor$n, _assertThisInitialized(_this));

    return _this;
  }

  return JsonAsset;
}(Asset), _temp$q), (_descriptor$n = _applyDecoratedDescriptor(_class2$q.prototype, "json", [serializable, editable], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return null;
  }
})), _class2$q)) || _class$u);
legacyCC.JsonAsset = JsonAsset;

exports.AABB = AABB;
exports.AABBPool = AABBPool;
exports.AffineTransform = AffineTransform;
exports.Ambient = Ambient;
exports.AnimationCurve = AnimationCurve;
exports.Asset = Asset;
exports.Attribute = Attribute;
exports.BaseNode = BaseNode;
exports.BindingMappingInfo = BindingMappingInfo;
exports.BitMask = BitMask;
exports.BlendState = BlendState;
exports.BlendTarget = BlendTarget;
exports.Buffer = Buffer;
exports.BufferAsset = BufferAsset;
exports.BufferInfo = BufferInfo;
exports.BufferTextureCopy = BufferTextureCopy;
exports.BufferViewInfo = BufferViewInfo;
exports.CAMERA_DEFAULT_MASK = CAMERA_DEFAULT_MASK;
exports.CCBoolean = CCBoolean;
exports.CCClass = CCClass;
exports.CCFloat = CCFloat;
exports.CCInteger = CCInteger;
exports.CCON = CCON;
exports.CCObject = CCObject;
exports.CCString = CCString;
exports.Cache = Cache;
exports.CachedArray = CachedArray;
exports.Capsule = Capsule;
exports.Color = Color$1;
exports.Color$1 = Color;
exports.ColorAttachment = ColorAttachment;
exports.CommandBuffer = CommandBuffer;
exports.CommandBufferInfo = CommandBufferInfo;
exports.CompactValueTypeArray = CompactValueTypeArray;
exports.Component = Component;
exports.ComponentScheduler = ComponentScheduler;
exports.DESCRIPTOR_BUFFER_TYPE = DESCRIPTOR_BUFFER_TYPE;
exports.DESCRIPTOR_DYNAMIC_TYPE = DESCRIPTOR_DYNAMIC_TYPE;
exports.DESCRIPTOR_SAMPLER_TYPE = DESCRIPTOR_SAMPLER_TYPE;
exports.DRAW_INFO_SIZE = DRAW_INFO_SIZE;
exports.DepthStencilAttachment = DepthStencilAttachment;
exports.DepthStencilState = DepthStencilState;
exports.DescriptorSet = DescriptorSet;
exports.DescriptorSetInfo = DescriptorSetInfo;
exports.DescriptorSetLayout = DescriptorSetLayout;
exports.DescriptorSetLayoutBinding = DescriptorSetLayoutBinding;
exports.DescriptorSetLayoutInfo = DescriptorSetLayoutInfo;
exports.Details = Details;
exports.Device = Device;
exports.DeviceCaps = DeviceCaps;
exports.DeviceInfo = DeviceInfo;
exports.DispatchInfo = DispatchInfo;
exports.DrawInfo = DrawInfo;
exports.DynamicStates = DynamicStates;
exports.DynamicStencilStates = DynamicStencilStates;
exports.EDITOR = EDITOR;
exports.EPSILON = EPSILON;
exports.EffectAsset = EffectAsset;
exports.Enum = Enum;
exports.Event = Event;
exports.EventListener = EventListener;
exports.EventTarget = EventTarget;
exports.Eventify = Eventify;
exports.Extent = Extent;
exports.Fog = Fog;
exports.FormatInfo = FormatInfo;
exports.FormatInfos = FormatInfos;
exports.FormatSize = FormatSize;
exports.FormatSurfaceSize = FormatSurfaceSize;
exports.Framebuffer = Framebuffer;
exports.FramebufferInfo = FramebufferInfo;
exports.Frustum = Frustum;
exports.GetTypeSize = GetTypeSize;
exports.GlobalBarrier = GlobalBarrier;
exports.GlobalBarrierInfo = GlobalBarrierInfo;
exports.IDGenerator = IDGenerator;
exports.INST_JOINT_ANIM_INFO = INST_JOINT_ANIM_INFO;
exports.INST_MAT_WORLD = INST_MAT_WORLD;
exports.INT_MAX = INT_MAX;
exports.ImageAsset = ImageAsset;
exports.IndirectBuffer = IndirectBuffer;
exports.InputAssembler = InputAssembler;
exports.InputAssemblerInfo = InputAssemblerInfo;
exports.InputState = InputState;
exports.IsPowerOf2 = IsPowerOf2;
exports.JSB = JSB;
exports.JavaScript = JavaScript;
exports.JsonAsset = JsonAsset;
exports.Keyframe = Keyframe;
exports.Layers = Layers;
exports.Line = Line;
exports.MATH_FLOAT_ARRAY = MATH_FLOAT_ARRAY;
exports.MINIGAME = MINIGAME;
exports.Mat3 = Mat3;
exports.Mat4 = Mat4;
exports.Material = Material;
exports.MathBase = MathBase;
exports.MemoryStatus = MemoryStatus;
exports.MissingScript = MissingScript;
exports.MutableForwardIterator = MutableForwardIterator;
exports.NULL_HANDLE = NULL_HANDLE;
exports.Node = Node$1;
exports.NodeActivator = NodeActivator;
exports.NodeEventProcessor = NodeEventProcessor;
exports.NodePool = NodePool;
exports.OBB = OBB;
exports.Obj = Obj;
exports.ObjectCurve = ObjectCurve;
exports.Offset = Offset;
exports.PCFType = PCFType;
exports.PIPELINE_FLOW_FORWARD = PIPELINE_FLOW_FORWARD;
exports.PIPELINE_FLOW_MAIN = PIPELINE_FLOW_MAIN;
exports.PIPELINE_FLOW_SHADOW = PIPELINE_FLOW_SHADOW;
exports.PREVIEW = PREVIEW;
exports.Pass = Pass;
exports.PassPool = PassPool;
exports.Pipeline = Pipeline;
exports.PipelineLayout = PipelineLayout;
exports.PipelineLayoutInfo = PipelineLayoutInfo;
exports.PipelineState = PipelineState;
exports.PipelineStateInfo = PipelineStateInfo;
exports.Plane = Plane;
exports.Pool = Pool;
exports.Pool$1 = Pool$1;
exports.Prefab = Prefab;
exports.PrefabLink = PrefabLink;
exports.PrivateNode = PrivateNode;
exports.Quat = Quat;
exports.QuatCurve = QuatCurve;
exports.Queue = Queue;
exports.QueueInfo = QueueInfo;
exports.RUNTIME_BASED = RUNTIME_BASED;
exports.RasterizerState = RasterizerState;
exports.Ray = Ray;
exports.RealCurve = RealCurve;
exports.Rect = Rect$1;
exports.Rect$1 = Rect;
exports.RecyclePool = RecyclePool;
exports.RenderPass = RenderPass;
exports.RenderPassInfo = RenderPassInfo;
exports.RenderTexture = RenderTexture;
exports.RenderingSubMesh = RenderingSubMesh;
exports.Sampler = Sampler;
exports.SamplerInfo = SamplerInfo;
exports.Scene = Scene;
exports.SceneAsset = SceneAsset;
exports.Script = Script;
exports.Shader = Shader;
exports.ShaderInfo = ShaderInfo;
exports.ShaderStage = ShaderStage;
exports.ShadowSize = ShadowSize;
exports.ShadowType = ShadowType;
exports.Shadows = Shadows;
exports.Size = Size$1;
exports.Size$1 = Size;
exports.Sphere = Sphere;
exports.SubpassDependency = SubpassDependency;
exports.SubpassInfo = SubpassInfo;
exports.TEST = TEST;
exports.Task = Task;
exports.TextAsset = TextAsset;
exports.Texture = Texture;
exports.Texture2D = Texture2D;
exports.TextureBarrier = TextureBarrier;
exports.TextureBarrierInfo = TextureBarrierInfo;
exports.TextureBase = TextureBase;
exports.TextureBlit = TextureBlit;
exports.TextureCopy = TextureCopy;
exports.TextureCube = TextureCube;
exports.TextureInfo = TextureInfo;
exports.TextureSubresLayers = TextureSubresLayers;
exports.TextureSubresRange = TextureSubresRange;
exports.TextureViewInfo = TextureViewInfo;
exports.Triangle = Triangle;
exports.TypeScript = TypeScript;
exports.UBOCamera = UBOCamera;
exports.UBODeferredLight = UBODeferredLight;
exports.UBOForwardLight = UBOForwardLight;
exports.UBOGlobal = UBOGlobal;
exports.UBOLocal = UBOLocal;
exports.UBOLocalBatched = UBOLocalBatched;
exports.UBOMorph = UBOMorph;
exports.UBOShadow = UBOShadow;
exports.UBOSkinning = UBOSkinning;
exports.UBOSkinningAnimation = UBOSkinningAnimation;
exports.UBOSkinningTexture = UBOSkinningTexture;
exports.UNIFORM_ENVIRONMENT_BINDING = UNIFORM_ENVIRONMENT_BINDING;
exports.UNIFORM_GBUFFER_ALBEDOMAP_BINDING = UNIFORM_GBUFFER_ALBEDOMAP_BINDING;
exports.UNIFORM_GBUFFER_EMISSIVEMAP_BINDING = UNIFORM_GBUFFER_EMISSIVEMAP_BINDING;
exports.UNIFORM_GBUFFER_NORMALMAP_BINDING = UNIFORM_GBUFFER_NORMALMAP_BINDING;
exports.UNIFORM_GBUFFER_POSITIONMAP_BINDING = UNIFORM_GBUFFER_POSITIONMAP_BINDING;
exports.UNIFORM_JOINT_TEXTURE_BINDING = UNIFORM_JOINT_TEXTURE_BINDING;
exports.UNIFORM_LIGHTING_RESULTMAP_BINDING = UNIFORM_LIGHTING_RESULTMAP_BINDING;
exports.UNIFORM_LIGHTMAP_TEXTURE_BINDING = UNIFORM_LIGHTMAP_TEXTURE_BINDING;
exports.UNIFORM_NORMAL_MORPH_TEXTURE_BINDING = UNIFORM_NORMAL_MORPH_TEXTURE_BINDING;
exports.UNIFORM_POSITION_MORPH_TEXTURE_BINDING = UNIFORM_POSITION_MORPH_TEXTURE_BINDING;
exports.UNIFORM_REFLECTION_STORAGE_BINDING = UNIFORM_REFLECTION_STORAGE_BINDING;
exports.UNIFORM_REFLECTION_TEXTURE_BINDING = UNIFORM_REFLECTION_TEXTURE_BINDING;
exports.UNIFORM_SHADOWMAP_BINDING = UNIFORM_SHADOWMAP_BINDING;
exports.UNIFORM_SPOT_LIGHTING_MAP_TEXTURE_BINDING = UNIFORM_SPOT_LIGHTING_MAP_TEXTURE_BINDING;
exports.UNIFORM_TANGENT_MORPH_TEXTURE_BINDING = UNIFORM_TANGENT_MORPH_TEXTURE_BINDING;
exports.Uniform = Uniform;
exports.UniformBlock = UniformBlock;
exports.UniformInputAttachment = UniformInputAttachment;
exports.UniformSampler = UniformSampler;
exports.UniformSamplerTexture = UniformSamplerTexture;
exports.UniformStorageBuffer = UniformStorageBuffer;
exports.UniformStorageImage = UniformStorageImage;
exports.UniformTexture = UniformTexture;
exports.ValueType = ValueType;
exports.Vec2 = Vec2;
exports.Vec3 = Vec3;
exports.Vec4 = Vec4;
exports.Viewport = Viewport;
exports.WECHAT = WECHAT;
exports.WorldNode3DToLocalNodeUI = WorldNode3DToLocalNodeUI;
exports.WorldNode3DToWorldNodeUI = WorldNode3DToWorldNodeUI;
exports.WrappedInfo = WrappedInfo;
exports._applyDecoratedDescriptor = _applyDecoratedDescriptor;
exports._assertThisInitialized = _assertThisInitialized;
exports._construct = _construct;
exports._createClass = _createClass;
exports._createForOfIteratorHelperLoose = _createForOfIteratorHelperLoose;
exports._decorator = _decorator;
exports._extends = _extends;
exports._float = _float;
exports._getClassId = _getClassId;
exports._inheritsLoose = _inheritsLoose;
exports._initializerDefineProperty = _initializerDefineProperty;
exports._normalize = _normalize;
exports._resetDebugSetting = _resetDebugSetting;
exports._throw = _throw;
exports.aabb = aabb;
exports.absMax = absMax;
exports.absMaxComponent = absMaxComponent;
exports.addon = addon;
exports.approx = approx;
exports.array = array;
exports.assert = assert;
exports.assertID = assertID;
exports.assertIsNonNullable = assertIsNonNullable;
exports.assertIsTrue = assertIsTrue;
exports.assets = assets;
exports.basename = basename;
exports.binarySearchEpsilon = binarySearchEpsilon;
exports.bindingMappingInfo = bindingMappingInfo;
exports.bits = bits;
exports.builtinResMgr = builtinResMgr;
exports.bundles = bundles;
exports.callInNextTick = callInNextTick;
exports.capsule = capsule;
exports.ccclass = ccclass;
exports.ccenum = ccenum;
exports.changeBasename = changeBasename;
exports.changeExtname = changeExtname;
exports.clamp = clamp;
exports.clamp01 = clamp01;
exports.clampf = clampf;
exports.color = color;
exports.constructLegacyCurveAndConvert = constructLegacyCurveAndConvert;
exports.contains = contains;
exports.contains$1 = contains$1;
exports.convertUtils = convertUtils;
exports.createMap = createMap;
exports.cubicOut = cubicOut;
exports.customizeType = customizeType;
exports.debug = debug$1;
exports.debug$1 = debug;
exports.decodeCCONBinary = decodeCCONBinary;
exports.decodeUuid = decodeUuid;
exports.defaultSamplerHash = defaultSamplerHash;
exports.define = define$1;
exports.degreesToRadians = degreesToRadians;
exports.dependMap = dependMap;
exports.dependUtil = dependUtil;
exports.deserialize = deserialize;
exports.deserializeAsset = deserializeAsset;
exports.deserializeTag = deserializeTag;
exports.dirname = dirname;
exports.disallowAnimation = disallowAnimation;
exports.disallowMultiple = disallowMultiple;
exports.displayName = displayName;
exports.displayOrder = displayOrder;
exports.distance = distance;
exports.easing = easing;
exports.editable = editable;
exports.editorExtrasTag = editorExtrasTag;
exports.editorOnly = editorOnly;
exports.effects = effects;
exports.engineVersion = engineVersion;
exports.enumerableProps = enumerableProps;
exports.enums = enums;
exports.equals = equals;
exports.error = error;
exports.errorID = errorID;
exports.eventManager = eventManager;
exports.executeInEditMode = executeInEditMode;
exports.executionOrder = executionOrder;
exports.extname = extname;
exports.fastRemoveAt = fastRemoveAt;
exports.fetchPipeline = fetchPipeline;
exports.files = files;
exports.find = find;
exports.formerlySerializedAs = formerlySerializedAs;
exports.frustum = frustum;
exports.garbageCollectionManager = garbageCollectionManager;
exports.genHandle = genHandle;
exports.genSamplerHash = genSamplerHash;
exports.getBindingFromHandle = getBindingFromHandle;
exports.getDefaultFromType = getDefaultFromType;
exports.getDeviceShaderVersion = getDeviceShaderVersion;
exports.getError = getError;
exports.getOffsetFromHandle = getOffsetFromHandle;
exports.getPhaseID = getPhaseID;
exports.getPropertyTypeFromHandle = getPropertyTypeFromHandle;
exports.getSeperator = getSeperator;
exports.getSetIndexFromHandle = getSetIndexFromHandle;
exports.getTypeFromHandle = getTypeFromHandle;
exports.getTypedArrayConstructor = getTypedArrayConstructor;
exports.getUuidFromURL = getUuidFromURL;
exports.globalDescriptorSetLayout = globalDescriptorSetLayout;
exports.help = help;
exports.helper = helper;
exports.instantiate = instantiate;
exports.intersect = intersect;
exports.inverseLerp = inverseLerp;
exports.isDisplayStats = isDisplayStats;
exports.isLerpable = isLerpable;
exports.isScene = isScene;
exports.isValid = isValid;
exports.join = join;
exports.js = js$1;
exports.js$1 = js;
exports.legacyCC = legacyCC;
exports.lerp = lerp;
exports.line = line;
exports.localDescriptorSetLayout = localDescriptorSetLayout;
exports.log = log;
exports.log2 = log2;
exports.logID = logID;
exports.macro = macro;
exports.mainFileName = mainFileName;
exports.mapBuffer = mapBuffer;
exports.mat4 = mat4;
exports.menu = menu;
exports.misc = misc;
exports.mixin = mixin;
exports.multiline = multiline;
exports.murmurhash2_32_gc = murmurhash2_32_gc;
exports.nativeDependMap = nativeDependMap;
exports.nextPow2 = nextPow2$1;
exports.nextPow2$1 = nextPow2;
exports.normalize = normalize;
exports.obb = obb;
exports.onLoadedInvokedMap = onLoadedInvokedMap;
exports.override = override;
exports.overrideMacros = overrideMacros;
exports.packCustomObjData = packCustomObjData;
exports.parseCCONJson = parseCCONJson;
exports.parsed = parsed;
exports.path = path;
exports.pingPong = pingPong;
exports.pipeline = pipeline;
exports.plane = plane;
exports.playOnFocus = playOnFocus;
exports.preTransforms = preTransforms;
exports.presets = presets;
exports.programLib = programLib;
exports.property = property;
exports.pseudoRandom = pseudoRandom;
exports.pseudoRandomRange = pseudoRandomRange;
exports.pseudoRandomRangeInt = pseudoRandomRangeInt;
exports.quat = quat;
exports.radian = radian;
exports.radiansToDegrees = radiansToDegrees;
exports.random = random;
exports.randomRange = randomRange;
exports.randomRangeInt = randomRangeInt;
exports.range = range;
exports.rangeMax = rangeMax;
exports.rangeMin = rangeMin;
exports.ray = ray;
exports.readBuffer = readBuffer;
exports.readOnly = readOnly;
exports.rect = rect;
exports.references = references;
exports.remove = remove;
exports.repeat = repeat;
exports.requireComponent = requireComponent;
exports.samplerLib = samplerLib;
exports.screenAdapter = screenAdapter;
exports.serializable = serializable;
exports.serializeTag = serializeTag;
exports.setClassAlias = setClassAlias;
exports.setDefaultLogTimes = setDefaultLogTimes;
exports.setDisplayStats = setDisplayStats;
exports.sign = sign;
exports.size = size;
exports.slide = slide;
exports.sphere = sphere;
exports.string = string;
exports.stripSep = stripSep;
exports.supportsHalfFloatTexture = supportsHalfFloatTexture;
exports.sys = sys;
exports.systemInfo = systemInfo;
exports.toDegree = toDegree;
exports.toRadian = toRadian;
exports.tooltip = tooltip;
exports.transform = transform;
exports.transformPipeline = transformPipeline;
exports.triangle = triangle;
exports.type = type;
exports.type2reader = type2reader;
exports.type2writer = type2writer;
exports.uniquelyReferenced = uniquelyReferenced;
exports.unit = unit;
exports.unpackJSONs = unpackJSONs;
exports.v2 = v2;
exports.v3 = v3;
exports.v4 = v4;
exports.visible = visible;
exports.warn = warn;
exports.warnID = warnID;
exports.writeBuffer = writeBuffer;
